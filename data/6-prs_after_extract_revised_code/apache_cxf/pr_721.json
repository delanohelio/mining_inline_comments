{"pr_number": 721, "pr_title": "[cxf-8340] add precompiled class for Graalvm native support", "pr_createdAt": "2020-11-06T13:55:51Z", "pr_url": "https://github.com/apache/cxf/pull/721", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2OTg0NA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r520969844", "bodyText": "I think we have to clearly distinguish the case when factory class exists and does not (createFactory). Could you please extract the logic of detecting the presence of factory class into dedicated method and modify addClass method to try to find the factory class first and fallback to createFactory if needed?\nWe should also ensure that the factory class is suitable and could be used accordingly.", "author": "reta", "createdAt": "2020-11-11T00:53:08Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java", "diffHunk": "@@ -559,44 +559,47 @@ private static Object createTypeReference(QName n, Class<?> cls) {\n     private Object createFactory(Class<?> cls, Constructor<?> contructor) {\n         String newClassName = cls.getName() + \"Factory\";\n         ASMHelper helper = new ASMHelper();\n-        ClassWriter cw = helper.createClassWriter();\n-        MethodVisitor mv;\n-\n-        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER,\n-                 ASMHelper.periodToSlashes(newClassName), null, \"java/lang/Object\", null);\n-\n-        cw.visitSource(cls.getSimpleName() + \"Factory\" + \".java\", null);\n+        Class<?> factoryClass = helper.findClass(newClassName, cls);", "originalCommit": "4780b1cd1d888cd4b527aa8d1c7e214f165275f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5072cc99b31bdf8b01cc3eccee5c85184597995c", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java\nindex dcb1f6c17a..9c8d6fa53d 100644\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java\n+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/JAXBContextInitializer.java\n\n@@ -554,52 +557,63 @@ class JAXBContextInitializer extends ServiceModelVisitor {\n         }\n         return null;\n     }\n-\n     @SuppressWarnings(\"unused\")\n-    private Object createFactory(Class<?> cls, Constructor<?> contructor) {\n+    private Object getFactory(Class<?> cls) {\n         String newClassName = cls.getName() + \"Factory\";\n         ASMHelper helper = new ASMHelper();\n         Class<?> factoryClass = helper.findClass(newClassName, cls);\n         if (factoryClass == null) {\n-            ClassWriter cw = helper.createClassWriter();\n-            MethodVisitor mv;\n-\n-            cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER,\n-                     ASMHelper.periodToSlashes(newClassName), null, \"java/lang/Object\", null);\n-\n-            cw.visitSource(cls.getSimpleName() + \"Factory\" + \".java\", null);\n-\n-            mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\n-            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-\n-            mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"create\" + cls.getSimpleName(),\n-                                \"()L\" + ASMHelper.periodToSlashes(cls.getName()) + \";\", null, null);\n-            mv.visitCode();\n-            String name = cls.getName().replace(\".\", \"/\");\n-            mv.visitTypeInsn(Opcodes.NEW, name);\n-            mv.visitInsn(Opcodes.DUP);\n-            StringBuilder paraString = new StringBuilder(32).append(\"(\");\n-\n-            for (Class<?> paraClass : contructor.getParameterTypes()) {\n-                mv.visitInsn(Opcodes.ACONST_NULL);\n-                paraString.append(\"Ljava/lang/Object;\");\n-            }\n-            paraString.append(\")V\");\n+            return null;\n+        }\n+        try {\n+            return factoryClass.newInstance();\n+        } catch (Exception e) {\n+           //ignore\n+        }\n+        return null;\n+    }\n+    @SuppressWarnings(\"unused\")\n+    private Object createFactory(Class<?> cls, Constructor<?> contructor) {\n+        String newClassName = cls.getName() + \"Factory\";\n+        ASMHelper helper = new ASMHelper();\n+        ClassWriter cw = helper.createClassWriter();\n+        MethodVisitor mv;\n \n-            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, name, \"<init>\", paraString.toString(), false);\n+        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER,\n+                 ASMHelper.periodToSlashes(newClassName), null, \"java/lang/Object\", null);\n \n-            mv.visitInsn(Opcodes.ARETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n+        cw.visitSource(cls.getSimpleName() + \"Factory\" + \".java\", null);\n \n-            cw.visitEnd();\n-            factoryClass = helper.loadClass(newClassName, cls, cw.toByteArray());\n+        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+        mv.visitCode();\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n+        mv.visitInsn(Opcodes.RETURN);\n+        mv.visitMaxs(1, 1);\n+        mv.visitEnd();\n+\n+        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"create\" + cls.getSimpleName(),\n+                            \"()L\" + ASMHelper.periodToSlashes(cls.getName()) + \";\", null, null);\n+        mv.visitCode();\n+        String name = cls.getName().replace(\".\", \"/\");\n+        mv.visitTypeInsn(Opcodes.NEW, name);\n+        mv.visitInsn(Opcodes.DUP);\n+        StringBuilder paraString = new StringBuilder(32).append(\"(\");\n+\n+        for (Class<?> paraClass : contructor.getParameterTypes()) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+            paraString.append(\"Ljava/lang/Object;\");\n         }\n+        paraString.append(\")V\");\n+\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, name, \"<init>\", paraString.toString(), false);\n+\n+        mv.visitInsn(Opcodes.ARETURN);\n+        mv.visitMaxs(1, 1);\n+        mv.visitEnd();\n+\n+        cw.visitEnd();\n+        Class<?> factoryClass = helper.loadClass(newClassName, cls, cw.toByteArray());\n         try {\n             return factoryClass.newInstance();\n         } catch (Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r520970218", "bodyText": "How these methods are supposed to be used?", "author": "reta", "createdAt": "2020-11-11T00:53:37Z", "path": "core/src/main/java/org/apache/cxf/common/util/ASMHelper.java", "diffHunk": "@@ -342,7 +342,10 @@ public ClassWriter createClassWriter() {\n         TypeHelperClassLoader loader = getTypeHelperClassLoader(l);\n         return loader.lookupDefinedClass(className);\n     }\n-\n+    public static void addExternalClass(String className, ClassLoader l, Class<?> cls) {", "originalCommit": "4780b1cd1d888cd4b527aa8d1c7e214f165275f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2OTUwOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521169509", "bodyText": "inside quarkiverse-cxf inside a a servlet\nhttps://github.com/quarkiverse/quarkiverse-cxf/blob/master/runtime/src/main/java/io/quarkiverse/cxf/CXFQuarkusServlet.java#L50\nor\nhttps://github.com/quarkiverse/quarkiverse-cxf/blob/master/runtime/src/main/java/io/quarkiverse/cxf/CxfClientProducer.java#L19\nI can add\nASMHelper.addExternalClass('io.quarkiverse.test.FruitFactory', Class.forName('io.quarkiverse.test.FruitFactory'));\nhere it is just for factory but I will provide the full list of generated class wrapperHelper (for request and response), packageInfo, customException with faultInfo field, NamespacePrefixMapper", "author": "dufoli", "createdAt": "2020-11-11T07:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIwOTA2MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521209060", "bodyText": "augmentor will produce class during build time and send class generated through recorder to runtime.", "author": "dufoli", "createdAt": "2020-11-11T08:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMjE3MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521212171", "bodyText": "Is it possible to not make it quarkus specific? Here is my proposal:\n\nMake ASMHelper a SPI set as cxf bus extension - to support versions in a pluggable way and not hardcode 10 versions of asm + reflection\nProvide current default impls\nHave a a) generate proxy at build time mojo AND b) a load first proxy (before generating it) strategy (note that it makes asm useless and must not trigger asm classloading to work).\n\n3 is close to https://github.com/apache/openwebbeans/blob/1f83552e74c7966fc1009a3a7417900e7ce42b32/webbeans-impl/src/main/java/org/apache/webbeans/service/ClassLoaderProxyService.java#L85 for runtime and https://github.com/apache/openwebbeans/blob/1f83552e74c7966fc1009a3a7417900e7ce42b32/webbeans-impl/src/main/java/org/apache/webbeans/service/ClassLoaderProxyService.java#L62 for build time (and dump the proxies as .class).\nThis way the code is not quarkus specific and benefits all applications in JVM and native mode.", "author": "rmannibucau", "createdAt": "2020-11-11T09:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NzgwMA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521267800", "bodyText": "I do not get the point that this is quarkus specific\n\n\nindeed it is not quarkus specific but graal specific because can be used by spring boot too. Or any system which can provide class directly to avoid class generation. Anyway, It was the other proposition in the jira. But I found that less intrusive. The issue if I do so, I will have to do it for more class (wrapper helper, exception,...) which are generated. That s why I choose this solution.\n\n\nIf I understand correctly, I create a class factory proxy static which provide creator which return Class and if not in Map<String, Class<?>> . and each time, AsmHelper is used, I add this ProxyClassFactory in between. And in my code I just call ProxyClassFactory.getProxies().put(...);\n\n\nSorry, I do not know what you mean by \"SPI set as cxf bus extension\" ?\nDo you mean, adding interface and implementation in bus-extensions.txt and adding interface for ASMHelper and inherit ASMHelper an implemtnation for each asm version in getASMClass ?\nIt seems a big refactoring and not related to the proxy need for quarkus ?\nI agree that static class is not a good solution for ASMHelper and it is better to have factory pattern but I need a little help on that to have more explanation to respect the cxf pattern (bus-extensions.txt and factory). Do you have any document / guide ?", "author": "dufoli", "createdAt": "2020-11-11T10:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMxMDQ5NA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521310494", "bodyText": "@dufoli:\n\nit is quarkus specific until you have the generator in cxf codebase (which is not the case in the pr) so it is quarkus specific ;). In other words, current PR is a quarkus extension point because it is feature incomplete for all other env and there is no real reason for that - don't get me wrong, I understand you got stucked and solve your issue but I think to integrate mainstream code it should go a bit further otherwise there is no benefit to get it in cxf land.\nyou actually don't need this map, you just do a classloader.loadClass (take care it is not the tccl but cxf classloader, can be in bus extensions). Only small thing to take care is to not do it at runtime but only deploy time but it should already be the case (or with a lazy init pattern but only once). In quarkus land you just generate the class at build time and put it in runtime classes (as other proxies).\nthe spi point is to avoid to have to handle ow2.asm, xbean.asm7, xbean.asm8, xbean.asm9 etc.\nto not make it global it must be in cxf bus extensions IMHO (as ClassUnwrapper for example). Each time a class is generated, it has a bus not far so it should be easy to read from there.\n\nhope it makes sense", "author": "rmannibucau", "createdAt": "2020-11-11T12:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ1MjgwNQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521452805", "bodyText": "@rmannibucau  thanks for response ! ;-)\n\nhmm, I think, I got your point. indeed, you mean that I need to use cxf parsing system to get serviceInfo and generate all classes without loading servlet or client stuff. The issue is that quarkus use yandex to parse classes and gizmo lib to generate code during build time. I am not sure, I can reuse the cxf system to parse wsdl, and annoted classe and generate serviceInfo in order to generate all classes. Is it doable ? Because I need to inject particular classWriter for that.\nIs it your point ? I have think to a such system at the beginning but it was a nightmare to understand how to use cxf for that. Because it is not a usual case.\nSo you mean that I inject my own classLoader which contain my classes in order that classLoader see the class I have generated ?\nI do not get you point fully but I will try to code what I understand and I will let you review the code and give feedback.", "author": "dufoli", "createdAt": "2020-11-11T15:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ1ODEwOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521458109", "bodyText": "@dufoli\n\njandex or not does not change much things, at the end you must register the generated class in graal so a loadClass will cover both cases, only the generation phase will be different but CXF must get one impl for this feature to make sense in CXF itself IMHO - and it shouldnt be that hard to do a mojo generating proxies.\nyou don't need any custom classloader since classes are generated and dumped (physically or not) at build time in the target/classes of your project so you have them at runtime and just need to read them at run time.", "author": "rmannibucau", "createdAt": "2020-11-11T15:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzNDAxOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521634019", "bodyText": "TODO:\nFor point 1)\n\nI create ASMHelper as interface with public\nrename ASMHelper class to ASMHelperImpl and make it inherite of interface.\ncreate subclass of ASMHelperImpl  for each version of ASM ? (not sure of this part )\ncreate class Proxy implements ASMHelper which do nothing but just load class from classLoader. For this part it is not clear because className is send through a visite on ClassWriter. So it mean I need a NoOpClassWriter wich just store className ?\nadd in bus-extenstions.txt a line:\norg.apache.cxf.common.util.ASMHelper$TypeHelperClassLoader:org.apache.cxf.common.util.ASMHelper$:true", "author": "dufoli", "createdAt": "2020-11-11T20:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzNTM2MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521635360", "bodyText": "just to know if I am on right direction... @rmannibucau can you just check what I provide.\nBut I need to understand some things which seems odd to me.", "author": "dufoli", "createdAt": "2020-11-11T21:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzODU3NQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521638575", "bodyText": "Hmm,\nThink it mixes two things, sorry if I was not clear about this point.\nUntil now we were generating proxies with asm, that was it.\nNow we will be able to load proxies without using asm at all so we must split loading and generation IMO and only trigger generation if not existing so it means 2 independent services: GeneratedClassLoader maybe and ClassGenerator (backend by ASM).\nSplitting it avoids to have the generation API in build time generation case.\nIt also means CXF does not need the proxy code anymore since asmX integration can now belong to another module (we can create a cxf-asm-compat module for migration purposes maybe and only keep ow2 integration code in cxf-core and register it only if asm is available and ClassGenerator not registered in the bus already).\nAbout the registration: I wouldn't register it by default but use something like: if (not bus has ClassGenerator) tryLoadOw2AsmClassGenerator().\nHope it makes sense.\nIn all case I think it goes in the very right direction, thanks a lot for the effort!", "author": "rmannibucau", "createdAt": "2020-11-11T21:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDU5MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521654591", "bodyText": "indeed best is just to provide me pseudoCode of usage you expect. Because, you are talking about SPI for ASMHelper and ClassLoader so I am bit lost? I think we need a factory for both (because I hate static class)", "author": "dufoli", "createdAt": "2020-11-11T21:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2NzczNg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521667736", "bodyText": "Idea is to split the way to get the class - findClass (Generated Class Loader or finder, name was not very great since ambiguous with ClassLoader) - and the way to generate a class (all asm impls).\nAll static calls must become deprecated imho.", "author": "rmannibucau", "createdAt": "2020-11-11T22:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY4NTg0NQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521685845", "bodyText": "Ok So, I am on good way, but long move. Because so much here use static...", "author": "dufoli", "createdAt": "2020-11-11T22:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY5NDQzMQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521694431", "bodyText": "I have move asmHelper to instance now. I will continue tomorrow...", "author": "dufoli", "createdAt": "2020-11-11T23:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY5NDQ2NA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r521694464", "bodyText": "thanks for help ;-)", "author": "dufoli", "createdAt": "2020-11-11T23:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyMDkyOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522020928", "bodyText": "@rmannibucau I have implement all for (it do not build because not migrate for other and I have issue of syntax validation.)\n\ndo you know how maven can fix syntax validation automatically ? be cause process-sources report error but do not fix them. (import sort, ...)\nif you are ok with this solution, I will continue with other classes.\nBTW, Huge patch 1200 LOC and it is not finished ;-)", "author": "dufoli", "createdAt": "2020-11-12T11:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyMTQ2Nw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522021467", "bodyText": "is there any live chat like zulip, because we are both french and it can be easier to exchange about solution directly?", "author": "dufoli", "createdAt": "2020-11-12T11:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyNzg2OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522027869", "bodyText": "@dufoli we have slack (the-asf), can need to request an invite (don't fully recall the details) but it should be quite straight forward to connect.\nFor syntax validation I'm generally doing it manually (don't think maven-checkstyle-plugin can autoformat sources).\nAbout the rest I'd say ASMHelperImpl can maybe be N classes and drop the abstraction, wdyt? Also the generation is not only about namespace mapper think we have some other proxies no?\nbut overall, it looks good.", "author": "rmannibucau", "createdAt": "2020-11-12T11:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NTY4Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522045682", "bodyText": "and I need to know how I can inject to bus.GetExtension(org.apache.cxf.common.spi.ClassLoaderService.class) the\norg.apache.cxf.common.spi.ClassLoaderProxyService$LoadFirst instead of\norg.apache.cxf.common.spi.ClassLoaderProxyService$GenerateJustInTime\nand after how I inject my class...\nthrough bus-extensions.txt , if create bus-extensions.txt in my quarkus augmentor with\norg.apache.cxf.common.spi.ClassLoaderProxyService:org.apache.cxf.common.spi.ClassLoaderProxyService$GenerateJustInTime: true\nis it ok ?\nor I have to use code to declare a change of extension ?\nsecond question is how to use cxf to parse code and wsdl to generate class . I was thinking to use my own ASMHelper with a quarkus class writer .", "author": "dufoli", "createdAt": "2020-11-12T11:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NjEzMw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522056133", "bodyText": "@dufoli: i tend to do programmatically or configuration (spring) when configuring cxf deployment. I didn't dig into your quarkus integration but if you create yourself your bus you can do it quite trivially, if you don't, you fallback on a default factory and the txt file is needed (i would recommend you to not rely on it since it will be easier to interact with cxf without but it works).\nTo generate you should trigger a cxf deployment (potentially on a local storage) and let the spy service capture the proxies, then you dump them in the graal classes singleton I think - here again, having the bus means you have the service instance so it is quite trivial to run the cxf deployment and read the captured instances ;).", "author": "rmannibucau", "createdAt": "2020-11-12T12:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI1ODIwNw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522258207", "bodyText": "@rmannibucau I have added basic codes for it but it is complicated for something.\nClassCreator class generate the JAXButils createNamespaceWrapper and it work but it work because we are in same module (core) but other classcreator are in dependencies... so if we switch to new system class creation need to be moved to core which seems a bad idea to me.", "author": "dufoli", "createdAt": "2020-11-12T16:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2NjAyOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522266029", "bodyText": "@dufoli not sure i'm following, the goal is to hide ASM abstraction and replace it by a functional API so it shouldn't be an issue. Also for something jaxb specific you can use another SPI in the bus, sounds fine for me. They can be implemented in the same module (ex: cxf-asm, cxf-xbean-asm9 and so on) and instantiated at need only. wdyt?", "author": "rmannibucau", "createdAt": "2020-11-12T17:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4NDQzOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522284439", "bodyText": "ok got it. So it mean that each class writer  (ASMHelper) will need a dedicated service provider with classloader on one side and class generator on other side. I get it. I was just expectif a single service provider to avoid to recode each time the balancing system everywhere. I prefer to have a single solution for all ASMHelper Class generator. I will think to it .", "author": "dufoli", "createdAt": "2020-11-12T17:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NDI1MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522294251", "bodyText": "The classloader part can be shared, we don't have to split the code which is the same.\nThe proxy generation will likely be forked until we keep the kind of facade we have (but it has some pitfalls and is not tested).\nNow if you prefer a single asm module for now it works too as a first step - your PR is not exactly on that point, it just implies a refactoring which enables that point ;). Once we have extensions in the bus we can refactor more easily in a second step too. The only key point is to split bytecode generation and loading in extensions.\nOpen point: will corba module be dropped (I see it uses asmhelper but if it is deleted soon no need to handle it and then asm becomes an xml thing it seems which can makes things easier).", "author": "rmannibucau", "createdAt": "2020-11-12T17:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ1MDAzNQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522450035", "bodyText": "I have produce all ASMHelper spi. Need to fix format and test tomorrow.", "author": "dufoli", "createdAt": "2020-11-12T21:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMDk5NQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522710995", "bodyText": "+1, small note: when you read an extension, maybe check it is null and if so throw an exception saying \"missing extension X, you can add module m1 or m2\" to ensure user is aware of what happens.", "author": "rmannibucau", "createdAt": "2020-11-13T07:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxODU0Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522718543", "bodyText": "basic null ref check... ;-)\nMy current issue, is that I miss one class JAXBExtensionHelper and it is full static... and no bus available to getExtension...\nI am looking for solution.", "author": "dufoli", "createdAt": "2020-11-13T07:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMDg5NA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522720894", "bodyText": "AFAIK it is only used in \"register\" or \"loader\" classes which have the bus ;)", "author": "rmannibucau", "createdAt": "2020-11-13T07:21:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4NDk0OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r522784948", "bodyText": "Yes I remove static...", "author": "dufoli", "createdAt": "2020-11-13T08:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM5NzE5MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r523397190", "bodyText": "I have issue with test class. I use the mock system to create bus and return the good ASMHelper.\n        Bus bus = control.createMock(Bus.class);\n        EasyMock.expect(bus.getExtension(ASMHelper.class)).andReturn(new ASMHelperImpl()).anyTimes();\n        ExtensionClassCreator extr = new ExtensionClassGenerator(bus);\n        EasyMock.expect(bus.getExtension(ExtensionClassCreator.class)).andStubReturn(extr);\n\nbut I get error:\njava.lang.IllegalStateException:\nmissing behavior definition for the preceding method call:\nBus.getExtension(interface org.apache.cxf.common.util.ASMHelper)\nUsage is: expect(a.foo()).andXXX()\nat org.apache.cxf.wsdl.JAXBExtensionHelperTest.testAddTestExtension(JAXBExtensionHelperTest.java:88)", "author": "dufoli", "createdAt": "2020-11-14T09:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM5NzIyMA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r523397220", "bodyText": "I have try with AndStubReturn but change nothing...", "author": "dufoli", "createdAt": "2020-11-14T09:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM5Nzg4NA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r523397884", "bodyText": "Before digging, did you try not mocking it at all? Looks very doable using the bus impl directly (also mock tests have very few value at the end so I wouldnt invest much in them if possible).", "author": "rmannibucau", "createdAt": "2020-11-14T09:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwMzI2Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r523403263", "bodyText": "it work without mock but now, I am on a real issue because asm version generated is not the good one ... Strange", "author": "dufoli", "createdAt": "2020-11-14T10:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MDIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "f9a8be7241c621988b2ed48754bf9f32a17dc09f", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java b/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java\nindex 4cd5cf8c92..37e895a91c 100644\n--- a/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java\n+++ b/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java\n\n@@ -36,438 +36,82 @@ import org.apache.cxf.common.util.ReflectionInvokationHandler.Optional;\n import org.apache.cxf.common.util.ReflectionInvokationHandler.UnwrapParam;\n import org.apache.cxf.common.util.ReflectionInvokationHandler.WrapReturn;\n \n-public class ASMHelper {\n-    protected static final Map<Class<?>, String> PRIMITIVE_MAP = new HashMap<>();\n-    protected static final Map<Class<?>, String> NONPRIMITIVE_MAP = new HashMap<>();\n-    protected static final Map<Class<?>, Integer> PRIMITIVE_ZERO_MAP = new HashMap<>();\n-\n-    protected static final Map<ClassLoader, WeakReference<TypeHelperClassLoader>> LOADER_MAP\n-        = new WeakIdentityHashMap<>();\n-    protected static final Map<Class<?>, WeakReference<TypeHelperClassLoader>> CLASS_MAP\n-        = new WeakIdentityHashMap<>();\n-\n-    protected static boolean badASM;\n-    private static Class<?> cwClass;\n-\n-    static {\n-        PRIMITIVE_MAP.put(Byte.TYPE, \"B\");\n-        PRIMITIVE_MAP.put(Boolean.TYPE, \"Z\");\n-        PRIMITIVE_MAP.put(Long.TYPE, \"J\");\n-        PRIMITIVE_MAP.put(Integer.TYPE, \"I\");\n-        PRIMITIVE_MAP.put(Short.TYPE, \"S\");\n-        PRIMITIVE_MAP.put(Character.TYPE, \"C\");\n-        PRIMITIVE_MAP.put(Float.TYPE, \"F\");\n-        PRIMITIVE_MAP.put(Double.TYPE, \"D\");\n-\n-        NONPRIMITIVE_MAP.put(Byte.TYPE, Byte.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-        NONPRIMITIVE_MAP.put(Boolean.TYPE, Boolean.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-        NONPRIMITIVE_MAP.put(Long.TYPE, Long.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-        NONPRIMITIVE_MAP.put(Integer.TYPE, Integer.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-        NONPRIMITIVE_MAP.put(Short.TYPE, Short.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-        NONPRIMITIVE_MAP.put(Character.TYPE, Character.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-        NONPRIMITIVE_MAP.put(Float.TYPE, Float.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-        NONPRIMITIVE_MAP.put(Double.TYPE, Double.class.getName().replaceAll(\"\\\\.\", \"/\"));\n-    }\n-\n-    private static void tryClass(String s) {\n-        if (cwClass == null) {\n-            try {\n-                Class<?> c2 = ClassLoaderUtils.loadClass(s, ASMHelper.class);\n-\n-                //old versions don't have this, but we need it\n-                Class<?> cls = ClassLoaderUtils.loadClass(c2.getPackage().getName() + \".MethodVisitor\", c2);\n-                cls.getMethod(\"visitFrame\", Integer.TYPE, Integer.TYPE,\n-                              Object[].class,  Integer.TYPE, Object[].class);\n-                cwClass = c2;\n-            } catch (Throwable t) {\n-                //ignore\n-            }\n-        }\n-    }\n-    private static Class<?> getASMClassWriterClass() {\n-        //force this to make sure the proper OSGi import is generated\n-        return org.objectweb.asm.ClassWriter.class;\n-    }\n-\n-    private static synchronized Class<?> getASMClass() throws ClassNotFoundException {\n-        if (cwClass == null) {\n-            //try the \"real\" asm first, then the others\n-            tryClass(\"org.objectweb.asm.ClassWriter\");\n-            tryClass(\"org.apache.xbean.asm9.ClassWriter\");\n-            tryClass(\"org.apache.xbean.asm8.ClassWriter\");\n-            tryClass(\"org.apache.xbean.asm7.ClassWriter\");\n-            tryClass(\"org.apache.xbean.asm5.ClassWriter\");\n-            tryClass(\"org.apache.xbean.asm6.ClassWriter\");\n-            tryClass(\"org.apache.xbean.asm4.ClassWriter\");\n-            tryClass(\"org.apache.xbean.asm.ClassWriter\");\n-            tryClass(\"org.springframework.asm.ClassWriter\");\n-            if (cwClass == null) {\n-                cwClass = getASMClassWriterClass();\n-            }\n-        }\n-        return cwClass;\n-    }\n-\n-    public static class Opcodes {\n+public interface ASMHelper {\n+    String periodToSlashes(String s);\n+    String getClassCode(Class<?> cl);\n+    String getClassCode(java.lang.reflect.Type type);\n+    ClassWriter createClassWriter();\n+    Class<?> loadClass(String className, Class<?> clz, byte[] bytes);\n+    Class<?> loadClass(String className, ClassLoader l, byte[] bytes);\n+    Class<?> findClass(String className, Class<?> clz);\n+    Class<?> findClass(String className, ClassLoader l);\n+    ASMType getType(final String type);\n+    Label createLabel();\n+    public OpcodesProxy getOpCodes();\n+    Class<?> getASMClass() throws ClassNotFoundException;\n+\n+    class OpcodesProxy {\n         //CHECKSTYLE:OFF\n         //Will use reflection to set these based on the package name and such\n         //so we don't want them \"final\" or the compiler will optimize them out\n         //to just \"0\" which we really don't want\n-        public static int ARETURN = 0;\n-        public static int ALOAD = 0;\n-        public static int IFNULL = 0;\n-        public static int CHECKCAST = 0;\n-        public static int INVOKEINTERFACE = 0;\n-        public static int GETFIELD = 0;\n-        public static int GETSTATIC = 0;\n-        public static int ASTORE = 0;\n-        public static int PUTFIELD = 0;\n-        public static int PUTSTATIC = 0;\n-        public static int RETURN = 0;\n-        public static int F_APPEND = 0;\n-        public static int F_SAME = 0;\n-        public static int F_SAME1 = 0;\n-        public static int INVOKESPECIAL = 0;\n-        public static int ACC_PUBLIC = 0;\n-        public static int ACC_FINAL = 0;\n-        public static int ACC_SUPER = 0;\n-        public static int ACC_PRIVATE = 0;\n-        public static int ACC_STATIC = 0;\n-        public static int V1_5 = 0;\n-        public static int V1_6 = 0;\n-        public static int V1_7 = 0;\n-        public static int ACC_ABSTRACT = 0;\n-        public static int ACC_INTERFACE = 0;\n-        public static int ACC_SYNTHETIC = 0;\n-        public static int ILOAD = 0;\n-        public static int ISTORE = 0;\n-        public static int AALOAD = 0;\n-        public static int ARRAYLENGTH = 0;\n-        public static int IRETURN = 0;\n-        public static int NEW = 0;\n-        public static int ANEWARRAY = 0;\n-        public static int DUP = 0;\n-        public static int ATHROW = 0;\n-        public static int INVOKEVIRTUAL = 0;\n-        public static int GOTO = 0;\n-        public static int POP = 0;\n-        public static int ACONST_NULL = 0;\n-        public static int IFNONNULL = 0;\n-        public static int SIPUSH = 0;\n-        public static int INVOKESTATIC = 0;\n-        public static int ICONST_0;\n-        public static int ICONST_1;\n-        public static int LCONST_0;\n-        public static int FCONST_0;\n-        public static int DCONST_0;\n-        public static int IF_ICMPLT = 0;\n-        public static java.lang.Integer INTEGER;\n-\n-        //CHECKSTYLE:ON\n-        static {\n-            try {\n-                Class<?> cls = getASMClass();\n-                cls = ClassLoaderUtils.loadClass(cls.getPackage().getName() + \".Opcodes\", cls);\n-                for (Field f1 : Opcodes.class.getDeclaredFields()) {\n-                    Field f = cls.getDeclaredField(f1.getName());\n-                    ReflectionUtil.setAccessible(f1).set(null, ReflectionUtil.setAccessible(f).get(null));\n-                }\n-            } catch (Throwable e) {\n-                //ignore\n-            }\n-\n-            PRIMITIVE_ZERO_MAP.put(Byte.TYPE, Opcodes.ICONST_0);\n-            PRIMITIVE_ZERO_MAP.put(Boolean.TYPE, Opcodes.ICONST_0);\n-            PRIMITIVE_ZERO_MAP.put(Long.TYPE, Opcodes.LCONST_0);\n-            PRIMITIVE_ZERO_MAP.put(Integer.TYPE, Opcodes.ICONST_0);\n-            PRIMITIVE_ZERO_MAP.put(Short.TYPE, Opcodes.ICONST_0);\n-            PRIMITIVE_ZERO_MAP.put(Character.TYPE, Opcodes.ICONST_0);\n-            PRIMITIVE_ZERO_MAP.put(Float.TYPE, Opcodes.FCONST_0);\n-            PRIMITIVE_ZERO_MAP.put(Double.TYPE, Opcodes.DCONST_0);\n-        }\n-    }\n-\n-    protected static String getMethodSignature(Method m) {\n-        StringBuilder buf = new StringBuilder(\"(\");\n-        for (Class<?> cl : m.getParameterTypes()) {\n-            buf.append(getClassCode(cl));\n-        }\n-        buf.append(')');\n-        buf.append(getClassCode(m.getReturnType()));\n-\n-        return buf.toString();\n-    }\n-\n-    public static String periodToSlashes(String s) {\n-        char[] ch = s.toCharArray();\n-        for (int x = 0; x < ch.length; x++) {\n-            if (ch[x] == '.') {\n-                ch[x] = '/';\n-            }\n-        }\n-        return new String(ch);\n-    }\n-\n-\n-    public static String getClassCode(Class<?> cl) {\n-        if (cl == Void.TYPE) {\n-            return \"V\";\n-        }\n-        if (cl.isPrimitive()) {\n-            return PRIMITIVE_MAP.get(cl);\n-        }\n-        if (cl.isArray()) {\n-            return \"[\" + getClassCode(cl.getComponentType());\n-        }\n-        return \"L\" + periodToSlashes(cl.getName()) + \";\";\n-    }\n-    public static String getClassCode(java.lang.reflect.Type type) {\n-        if (type instanceof Class) {\n-            return getClassCode((Class<?>)type);\n-        } else if (type instanceof GenericArrayType) {\n-            GenericArrayType at = (GenericArrayType)type;\n-            return \"[\" + getClassCode(at.getGenericComponentType());\n-        } else if (type instanceof TypeVariable) {\n-            TypeVariable<?> tv = (TypeVariable<?>)type;\n-            java.lang.reflect.Type[] bounds = tv.getBounds();\n-            if (bounds != null && bounds.length == 1) {\n-                return getClassCode(bounds[0]);\n-            }\n-            throw new IllegalArgumentException(\"Unable to determine type for: \" + tv);\n-        } else if (type instanceof ParameterizedType) {\n-            ParameterizedType pt = (ParameterizedType)type;\n-            StringBuilder a = new StringBuilder(getClassCode(pt.getRawType()));\n-            if (!pt.getRawType().equals(Enum.class)) {\n-                a.setLength(a.length() - 1);\n-                a.append('<');\n-\n-                for (java.lang.reflect.Type t : pt.getActualTypeArguments()) {\n-                    a.append(getClassCode(t));\n-                }\n-                a.append(\">;\");\n-            }\n-            return a.toString();\n-        } else if (type instanceof WildcardType) {\n-            WildcardType wt = (WildcardType)type;\n-            StringBuilder a = new StringBuilder();\n-            java.lang.reflect.Type[] lowBounds = wt.getLowerBounds();\n-            java.lang.reflect.Type[] upBounds = wt.getUpperBounds();\n-            for (java.lang.reflect.Type t : upBounds) {\n-                a.append('+');\n-                a.append(getClassCode(t));\n-            }\n-            for (java.lang.reflect.Type t : lowBounds) {\n-                a.append('-');\n-                a.append(getClassCode(t));\n-            }\n-            return a.toString();\n-        }\n-        return null;\n-    }\n-\n-\n-    public ClassWriter createClassWriter() {\n-        Object newCw = null;\n-        if (!badASM) {\n-            if (cwClass == null) {\n-                try {\n-                    cwClass = getASMClass();\n-                } catch (Throwable error) {\n-                    badASM = true;\n-                    throw new RuntimeException(\"No ASM ClassWriterFound\", error);\n-                }\n-            }\n-            try {\n-                // ASM 1.5.x/2.x\n-                Constructor<?> cons\n-                    = cwClass.getConstructor(new Class<?>[] {Boolean.TYPE});\n-\n-                try {\n-                    // got constructor, now check if it's 1.x which is very\n-                    // different from 2.x and 3.x\n-                    cwClass.getMethod(\"newConstInt\", new Class<?>[] {Integer.TYPE});\n-                    // newConstInt was removed in 2.x, if we get this far, we're\n-                    // using 1.5.x,\n-                    // set to null so we don't attempt to use it.\n-                    badASM = true;\n-                } catch (Throwable t) {\n-                    newCw = cons.newInstance(new Object[] {Boolean.TRUE});\n-                }\n-\n-            } catch (Throwable e) {\n-                // ASM 3.x/4.x\n-                try {\n-                    Constructor<?> cons\n-                        = cwClass.getConstructor(new Class<?>[] {Integer.TYPE});\n-                    int i = cwClass.getField(\"COMPUTE_MAXS\").getInt(null);\n-                    i |= cwClass.getField(\"COMPUTE_FRAMES\").getInt(null);\n-                    newCw = cons.newInstance(new Object[] {Integer.valueOf(i)});\n-                } catch (Throwable e1) {\n-                    // ignore\n-                }\n-            }\n-        }\n-        if (newCw != null) {\n-            return ReflectionInvokationHandler.createProxyWrapper(newCw, ClassWriter.class);\n-        }\n-        return null;\n-    }\n-\n-\n-    public Class<?> loadClass(String className, Class<?> clz, byte[] bytes) {\n-        TypeHelperClassLoader loader = getTypeHelperClassLoader(clz);\n-        synchronized (loader) {\n-            Class<?> cls = loader.lookupDefinedClass(className);\n-            if (cls == null) {\n-                return loader.defineClass(className, bytes);\n-            }\n-            return cls;\n-        }\n-    }\n-    public Class<?> loadClass(String className, ClassLoader l, byte[] bytes) {\n-        TypeHelperClassLoader loader = getTypeHelperClassLoader(l);\n-        synchronized (loader) {\n-            Class<?> cls = loader.lookupDefinedClass(className);\n-            if (cls == null) {\n-                return loader.defineClass(className, bytes);\n-            }\n-            return cls;\n-        }\n-    }\n-    public Class<?> findClass(String className, Class<?> clz) {\n-        TypeHelperClassLoader loader = getTypeHelperClassLoader(clz);\n-        return loader.lookupDefinedClass(className);\n-    }\n-    public Class<?> findClass(String className, ClassLoader l) {\n-        TypeHelperClassLoader loader = getTypeHelperClassLoader(l);\n-        return loader.lookupDefinedClass(className);\n-    }\n-    public static void addExternalClass(String className, ClassLoader l, Class<?> cls) {\n-        TypeHelperClassLoader loader = getTypeHelperClassLoader(l);\n-        loader.addExternalClass(className, cls);\n-    }\n-    private static synchronized TypeHelperClassLoader getTypeHelperClassLoader(ClassLoader l) {\n-        WeakReference<TypeHelperClassLoader> ref = LOADER_MAP.get(l);\n-        TypeHelperClassLoader ret;\n-        if (ref == null || ref.get() == null) {\n-            ret = new TypeHelperClassLoader(l);\n-            LOADER_MAP.put(l, new WeakReference<TypeHelperClassLoader>(ret));\n-        } else {\n-            ret = ref.get();\n-        }\n-        return ret;\n-    }\n-    private static synchronized TypeHelperClassLoader getTypeHelperClassLoader(Class<?> cls) {\n-        WeakReference<TypeHelperClassLoader> ref = CLASS_MAP.get(cls);\n-        TypeHelperClassLoader ret;\n-        if (ref == null || ref.get() == null) {\n-            ret = new TypeHelperClassLoader(cls.getClassLoader());\n-            CLASS_MAP.put(cls, new WeakReference<TypeHelperClassLoader>(ret));\n-        } else {\n-            ret = ref.get();\n-        }\n-        return ret;\n-    }\n-\n-    public static class TypeHelperClassLoader extends ClassLoader {\n-        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n-\n-        TypeHelperClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-        public Class<?> lookupDefinedClass(String name) {\n-            return defined.get(name.replace('/', '.'));\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.endsWith(\"package-info\")) {\n-                return getParent().loadClass(name);\n-            }\n-            return super.findClass(name);\n-        }\n-        public void addExternalClass(String name, Class<?> cls) {\n-            if (name == null) {\n-                return;\n-            }\n-            defined.putIfAbsent(name.replace('/', '.'), cls);\n-        }\n-        public Class<?> defineClass(String name, byte[] bytes) {\n-            Class<?> ret = defined.get(name.replace('/', '.'));\n-            if (ret != null) {\n-                return ret;\n-            }\n-            if (name.endsWith(\"package-info\")) {\n-                Package p = super.getPackage(name.substring(0, name.length() - 13));\n-                if (p == null) {\n-                    definePackage(name.substring(0, name.length() - 13).replace('/', '.'),\n-                                    null,\n-                                    null,\n-                                    null,\n-                                    null,\n-                                    null,\n-                                    null,\n-                                    null);\n-                }\n-            }\n-\n-            ret = super.defineClass(name.replace('/', '.'), bytes, 0, bytes.length);\n-            Class<?> tmpRet = defined.putIfAbsent(name.replace('/', '.'), ret);\n-            if (tmpRet != null) {\n-                ret = tmpRet;\n-            }\n-            return ret;\n-        }\n-    }\n-    public ASMType getType(final String type) {\n-        try {\n-            final Class<?> cls = ClassLoaderUtils.loadClass(cwClass.getPackage().getName() + \".Type\", cwClass);\n-            final Method m = cls.getMethod(\"getType\", String.class);\n-            final Method m2 = cls.getMethod(\"getOpcode\", Integer.TYPE);\n-            @SuppressWarnings(\"unused\")\n-            ASMType t = new ASMType() {\n-                Object tp = ReflectionUtil.setAccessible(m).invoke(null, type);\n-                public Object getValue() {\n-                    return tp;\n-                }\n-                public Class<?> realType() {\n-                    return cls;\n-                }\n-                public int getOpcode(int ireturn) {\n-                    try {\n-                        return (Integer)ReflectionUtil.setAccessible(m2).invoke(tp, ireturn);\n-                    } catch (Exception e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            };\n-            return t;\n-        } catch (Exception ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        public int INVOKESTATIC = 0;\n+        public int ACC_STATIC = 0;\n+        public int PUTSTATIC = 0;\n+        public int GETSTATIC = 0;\n+        public int ARETURN = 0;\n+        public int ALOAD = 0;\n+        public int IFNULL = 0;\n+        public int CHECKCAST = 0;\n+        public int INVOKEINTERFACE = 0;\n+        public int GETFIELD = 0;\n+        public int GET= 0;\n+        public int ASTORE = 0;\n+        public int PUTFIELD = 0;\n+        public int PUT= 0;\n+        public int RETURN = 0;\n+        public int F_APPEND = 0;\n+        public int F_SAME = 0;\n+        public int F_SAME1 = 0;\n+        public int INVOKESPECIAL = 0;\n+        public int ACC_PUBLIC = 0;\n+        public int ACC_FINAL = 0;\n+        public int ACC_SUPER = 0;\n+        public int ACC_PRIVATE = 0;\n+        public int ACC_= 0;\n+        public int V1_5 = 0;\n+        public int V1_6 = 0;\n+        public int V1_7 = 0;\n+        public int ACC_ABSTRACT = 0;\n+        public int ACC_INTERFACE = 0;\n+        public int ACC_SYNTHETIC = 0;\n+        public int ILOAD = 0;\n+        public int ISTORE = 0;\n+        public int AALOAD = 0;\n+        public int ARRAYLENGTH = 0;\n+        public int IRETURN = 0;\n+        public int NEW = 0;\n+        public int ANEWARRAY = 0;\n+        public int DUP = 0;\n+        public int ATHROW = 0;\n+        public int INVOKEVIRTUAL = 0;\n+        public int GOTO = 0;\n+        public int POP = 0;\n+        public int ACONST_NULL = 0;\n+        public int IFNONNULL = 0;\n+        public int SIPUSH = 0;\n+        public int INVOKE= 0;\n+        public int ICONST_0;\n+        public int ICONST_1;\n+        public int LCONST_0;\n+        public int FCONST_0;\n+        public int DCONST_0;\n+        public int IF_ICMPLT = 0;\n+        public java.lang.Integer INTEGER;\n     }\n     public interface ASMType {\n         int getOpcode(int ireturn);\n     }\n-    public Label createLabel() {\n-        try {\n-            final Class<?> cls = ClassLoaderUtils.loadClass(cwClass.getPackage().getName() + \".Label\",\n-                                                      cwClass);\n-            @SuppressWarnings(\"unused\")\n-            Label l = new Label() {\n-                Object l = cls.newInstance();\n-                public Object getValue() {\n-                    return l;\n-                }\n-                public Class<?> realType() {\n-                    return cls;\n-                }\n-            };\n-            return l;\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n \n     public interface ClassWriter {\n         @WrapReturn(AnnotationVisitor.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MTIwOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r520971208", "bodyText": "Same as for createFactory, it would be better to distinguish the case when suitable factory exists vs creating a new one.", "author": "reta", "createdAt": "2020-11-11T00:54:53Z", "path": "core/src/main/java/org/apache/cxf/common/jaxb/JAXBUtils.java", "diffHunk": "@@ -1346,7 +1346,11 @@ private static Object createEclipseNamespaceMapper(Class<?> mcls, Map<String, St\n             + (\"RI\".equals(postFix) ? \"\" : \"internal/\")\n             + \"bind/marshaller/NamespacePrefixMapper\";\n         String postFixedName = \"org/apache/cxf/jaxb/NamespaceMapper\" + postFix;\n+        Class<?> cls = helper.findClass(className, ref);", "originalCommit": "4780b1cd1d888cd4b527aa8d1c7e214f165275f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5072cc99b31bdf8b01cc3eccee5c85184597995c", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/jaxb/JAXBUtils.java b/core/src/main/java/org/apache/cxf/common/jaxb/JAXBUtils.java\nindex 1c92422730..75cecc0731 100644\n--- a/core/src/main/java/org/apache/cxf/common/jaxb/JAXBUtils.java\n+++ b/core/src/main/java/org/apache/cxf/common/jaxb/JAXBUtils.java\n\n@@ -1338,7 +1341,12 @@ public final class JAXBUtils {\n             return null;\n         }\n     }\n-\n+    private static Class<?> getNamespaceWrapperInternal(ASMHelper helper, String postFix,\n+                                                            Class<?> ref) {\n+        String className = \"org.apache.cxf.jaxb.NamespaceMapper\" + postFix;\n+        Class<?> cls = helper.findClass(className, ref);\n+        return cls;\n+    }\n     private static Class<?> createNamespaceWrapperInternal(ASMHelper helper, ClassWriter cw,\n                                                            String postFix, Class<?> ref) {\n         String className = \"org.apache.cxf.jaxb.NamespaceMapper\" + postFix;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524836997", "bodyText": "I think we could delete this debug flag and related code. It could be easily achieved by introducing respective extension fe DumpingClassGeneratorClassLoader extends ClassGeneratorClassLoader", "author": "reta", "createdAt": "2020-11-17T02:03:36Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.BusFactory;\n+\n+public class ClassGeneratorClassLoader {\n+    //TODO handle that with system property\n+    private static final boolean DEBUG = false;", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkzNTExMw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524935113", "bodyText": "ok. I was thinking it is a cool feature to add. if I add a system property for that but ok. I will remove it.", "author": "dufoli", "createdAt": "2020-11-17T07:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0MTM3MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524941370", "bodyText": "Thinking out loud: if you replace the boolean by a string \"GENERATED_CLASS_OUTPUT\", wouldnt it help the build time generation? (null=deactivate=default)", "author": "rmannibucau", "createdAt": "2020-11-17T07:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0MzUxMQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524943511", "bodyText": "and make it public... @reta  ok for you ?", "author": "dufoli", "createdAt": "2020-11-17T07:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk1MDY4Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524950683", "bodyText": "or System.getProperty ;)", "author": "rmannibucau", "createdAt": "2020-11-17T08:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5OTc3Nw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525499777", "bodyText": "If you really need to have this capability (vs providing specialized extension), I would go with system property with location to dump generated bits.", "author": "reta", "createdAt": "2020-11-17T20:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY0NTg3Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526645872", "bodyText": "I have removed it. I do not need it. It was during debug and think it was a cool feature for users to debug their apps but ok.", "author": "dufoli", "createdAt": "2020-11-19T07:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMDkzMw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r527130933", "bodyText": "\ud83d\udc4d thanks!", "author": "reta", "createdAt": "2020-11-19T19:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNjk5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\ndeleted file mode 100644\nindex fc633b1104..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\n+++ /dev/null\n\n@@ -1,151 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.BusFactory;\n-\n-public class ClassGeneratorClassLoader {\n-    //TODO handle that with system property\n-    private static final boolean DEBUG = false;\n-    protected final Bus bus;\n-\n-    public ClassGeneratorClassLoader(final Bus bus) {\n-        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n-    }\n-\n-    private String getFilePath(String s) {\n-        String sep = System.getProperty(\"file.separator\");\n-        String relativePath = s.replace('.', sep.charAt(0));\n-        String userDir = System.getProperty(\"user.dir\");\n-        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n-    }\n-    private void saveClass(String className, byte[] bytes) {\n-\n-        File file;\n-        try {\n-            String classFileName = getFilePath(className);\n-            String finalFileName = classFileName;\n-            file = new File(finalFileName);\n-            int i = 1;\n-            while (file.exists()) {\n-                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n-                file = new File(finalFileName);\n-                i++;\n-            }\n-            file.getParentFile().mkdirs();\n-            try (FileOutputStream fop = new FileOutputStream(file)) {\n-                file.createNewFile();\n-                fop.write(bytes);\n-                fop.flush();\n-            }\n-        } catch (FileNotFoundException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    protected Class<?> loadClass(String className, byte[] bytes) {\n-        if (DEBUG) {\n-            saveClass(className, bytes);\n-        }\n-        TypeHelperClassLoader loader = getOrCreateLoader();\n-        synchronized (loader) {\n-            Class<?> cls = loader.lookupDefinedClass(className);\n-            if (cls == null) {\n-                return loader.defineClass(className, bytes);\n-            }\n-            return cls;\n-        }\n-    }\n-    protected Class<?> findClass(String className) {\n-        return getOrCreateLoader().lookupDefinedClass(className);\n-    }\n-    private TypeHelperClassLoader getOrCreateLoader() {\n-        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n-        if (loader == null) {\n-            synchronized (bus) {\n-                loader = bus.getExtension(TypeHelperClassLoader.class);\n-                if (loader == null) {\n-                    ClassLoader parent = bus.getExtension(ClassLoader.class);\n-                    if (parent == null) {\n-                        parent = Thread.currentThread().getContextClassLoader();\n-                    }\n-                    loader = new TypeHelperClassLoader(parent);\n-                    bus.setExtension(loader, TypeHelperClassLoader.class);\n-                }\n-            }\n-        }\n-        return loader;\n-    }\n-\n-\n-    public static class TypeHelperClassLoader extends ClassLoader {\n-        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n-\n-        TypeHelperClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-        public Class<?> lookupDefinedClass(String name) {\n-            return defined.get(name.replace('/', '.'));\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.endsWith(\"package-info\")) {\n-                return getParent().loadClass(name);\n-            }\n-            return super.findClass(name);\n-        }\n-\n-        public Class<?> defineClass(String name, byte[] bytes) {\n-            Class<?> ret = defined.get(name.replace('/', '.'));\n-            if (ret != null) {\n-                return ret;\n-            }\n-            if (name.endsWith(\"package-info\")) {\n-                Package p = super.getPackage(name.substring(0, name.length() - 13));\n-                if (p == null) {\n-                    definePackage(name.substring(0, name.length() - 13).replace('/', '.'),\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null);\n-                }\n-            }\n-\n-            ret = super.defineClass(name.replace('/', '.'), bytes, 0, bytes.length);\n-            Class<?> tmpRet = defined.putIfAbsent(name.replace('/', '.'), ret);\n-            if (tmpRet != null) {\n-                ret = tmpRet;\n-            }\n-            return ret;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNzk4NA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524837984", "bodyText": "AFAIK the access to bus is not synchronized anywhere, so I don't think you need it.", "author": "reta", "createdAt": "2020-11-17T02:06:51Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.BusFactory;\n+\n+public class ClassGeneratorClassLoader {\n+    //TODO handle that with system property\n+    private static final boolean DEBUG = false;\n+    protected final Bus bus;\n+\n+    public ClassGeneratorClassLoader(final Bus bus) {\n+        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n+    }\n+\n+    private String getFilePath(String s) {\n+        String sep = System.getProperty(\"file.separator\");\n+        String relativePath = s.replace('.', sep.charAt(0));\n+        String userDir = System.getProperty(\"user.dir\");\n+        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n+    }\n+    private void saveClass(String className, byte[] bytes) {\n+\n+        File file;\n+        try {\n+            String classFileName = getFilePath(className);\n+            String finalFileName = classFileName;\n+            file = new File(finalFileName);\n+            int i = 1;\n+            while (file.exists()) {\n+                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n+                file = new File(finalFileName);\n+                i++;\n+            }\n+            file.getParentFile().mkdirs();\n+            try (FileOutputStream fop = new FileOutputStream(file)) {\n+                file.createNewFile();\n+                fop.write(bytes);\n+                fop.flush();\n+            }\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    protected Class<?> loadClass(String className, byte[] bytes) {\n+        if (DEBUG) {\n+            saveClass(className, bytes);\n+        }\n+        TypeHelperClassLoader loader = getOrCreateLoader();\n+        synchronized (loader) {\n+            Class<?> cls = loader.lookupDefinedClass(className);\n+            if (cls == null) {\n+                return loader.defineClass(className, bytes);\n+            }\n+            return cls;\n+        }\n+    }\n+    protected Class<?> findClass(String className) {\n+        return getOrCreateLoader().lookupDefinedClass(className);\n+    }\n+    private TypeHelperClassLoader getOrCreateLoader() {\n+        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n+        if (loader == null) {\n+            synchronized (bus) {", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkyMjAwMQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524922001", "bodyText": "we must not have 2 loaders so the pattern must be a computeIfAbsent. I don't think it is exposed by the bus so having a synchro point these is good - but can be on \"this\", just needs a constant ref in this bus context.", "author": "rmannibucau", "createdAt": "2020-11-17T06:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNzk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE5NTA4Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525195086", "bodyText": "@rmannibucau this part in understandable, sadly bus.setExtension(loader, TypeHelperClassLoader.class); could happen anywhere so we are just localizing this particular single flow. I am fine with keeping it", "author": "reta", "createdAt": "2020-11-17T14:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNzk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE5NjY1OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525196659", "bodyText": "@reta I see, the only other case where it can be done programmatically is when a container/server does it during bootstrap so I wouldn't worry too much. Worse case, code would have to synchronize on the too - which can be added to the javadoc.", "author": "rmannibucau", "createdAt": "2020-11-17T14:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNzk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\ndeleted file mode 100644\nindex fc633b1104..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\n+++ /dev/null\n\n@@ -1,151 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.BusFactory;\n-\n-public class ClassGeneratorClassLoader {\n-    //TODO handle that with system property\n-    private static final boolean DEBUG = false;\n-    protected final Bus bus;\n-\n-    public ClassGeneratorClassLoader(final Bus bus) {\n-        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n-    }\n-\n-    private String getFilePath(String s) {\n-        String sep = System.getProperty(\"file.separator\");\n-        String relativePath = s.replace('.', sep.charAt(0));\n-        String userDir = System.getProperty(\"user.dir\");\n-        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n-    }\n-    private void saveClass(String className, byte[] bytes) {\n-\n-        File file;\n-        try {\n-            String classFileName = getFilePath(className);\n-            String finalFileName = classFileName;\n-            file = new File(finalFileName);\n-            int i = 1;\n-            while (file.exists()) {\n-                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n-                file = new File(finalFileName);\n-                i++;\n-            }\n-            file.getParentFile().mkdirs();\n-            try (FileOutputStream fop = new FileOutputStream(file)) {\n-                file.createNewFile();\n-                fop.write(bytes);\n-                fop.flush();\n-            }\n-        } catch (FileNotFoundException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    protected Class<?> loadClass(String className, byte[] bytes) {\n-        if (DEBUG) {\n-            saveClass(className, bytes);\n-        }\n-        TypeHelperClassLoader loader = getOrCreateLoader();\n-        synchronized (loader) {\n-            Class<?> cls = loader.lookupDefinedClass(className);\n-            if (cls == null) {\n-                return loader.defineClass(className, bytes);\n-            }\n-            return cls;\n-        }\n-    }\n-    protected Class<?> findClass(String className) {\n-        return getOrCreateLoader().lookupDefinedClass(className);\n-    }\n-    private TypeHelperClassLoader getOrCreateLoader() {\n-        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n-        if (loader == null) {\n-            synchronized (bus) {\n-                loader = bus.getExtension(TypeHelperClassLoader.class);\n-                if (loader == null) {\n-                    ClassLoader parent = bus.getExtension(ClassLoader.class);\n-                    if (parent == null) {\n-                        parent = Thread.currentThread().getContextClassLoader();\n-                    }\n-                    loader = new TypeHelperClassLoader(parent);\n-                    bus.setExtension(loader, TypeHelperClassLoader.class);\n-                }\n-            }\n-        }\n-        return loader;\n-    }\n-\n-\n-    public static class TypeHelperClassLoader extends ClassLoader {\n-        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n-\n-        TypeHelperClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-        public Class<?> lookupDefinedClass(String name) {\n-            return defined.get(name.replace('/', '.'));\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.endsWith(\"package-info\")) {\n-                return getParent().loadClass(name);\n-            }\n-            return super.findClass(name);\n-        }\n-\n-        public Class<?> defineClass(String name, byte[] bytes) {\n-            Class<?> ret = defined.get(name.replace('/', '.'));\n-            if (ret != null) {\n-                return ret;\n-            }\n-            if (name.endsWith(\"package-info\")) {\n-                Package p = super.getPackage(name.substring(0, name.length() - 13));\n-                if (p == null) {\n-                    definePackage(name.substring(0, name.length() - 13).replace('/', '.'),\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null);\n-                }\n-            }\n-\n-            ret = super.defineClass(name.replace('/', '.'), bytes, 0, bytes.length);\n-            Class<?> tmpRet = defined.putIfAbsent(name.replace('/', '.'), ret);\n-            if (tmpRet != null) {\n-                ret = tmpRet;\n-            }\n-            return ret;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzODgwOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524838808", "bodyText": "Since loader is a Bus extension (TypeHelperClassLoader fe), it could be access from anywhere basically, so the synchronization is not going to be useful, could be removed.", "author": "reta", "createdAt": "2020-11-17T02:09:51Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.BusFactory;\n+\n+public class ClassGeneratorClassLoader {\n+    //TODO handle that with system property\n+    private static final boolean DEBUG = false;\n+    protected final Bus bus;\n+\n+    public ClassGeneratorClassLoader(final Bus bus) {\n+        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n+    }\n+\n+    private String getFilePath(String s) {\n+        String sep = System.getProperty(\"file.separator\");\n+        String relativePath = s.replace('.', sep.charAt(0));\n+        String userDir = System.getProperty(\"user.dir\");\n+        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n+    }\n+    private void saveClass(String className, byte[] bytes) {\n+\n+        File file;\n+        try {\n+            String classFileName = getFilePath(className);\n+            String finalFileName = classFileName;\n+            file = new File(finalFileName);\n+            int i = 1;\n+            while (file.exists()) {\n+                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n+                file = new File(finalFileName);\n+                i++;\n+            }\n+            file.getParentFile().mkdirs();\n+            try (FileOutputStream fop = new FileOutputStream(file)) {\n+                file.createNewFile();\n+                fop.write(bytes);\n+                fop.flush();\n+            }\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    protected Class<?> loadClass(String className, byte[] bytes) {\n+        if (DEBUG) {\n+            saveClass(className, bytes);\n+        }\n+        TypeHelperClassLoader loader = getOrCreateLoader();\n+        synchronized (loader) {", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\ndeleted file mode 100644\nindex fc633b1104..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\n+++ /dev/null\n\n@@ -1,151 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.BusFactory;\n-\n-public class ClassGeneratorClassLoader {\n-    //TODO handle that with system property\n-    private static final boolean DEBUG = false;\n-    protected final Bus bus;\n-\n-    public ClassGeneratorClassLoader(final Bus bus) {\n-        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n-    }\n-\n-    private String getFilePath(String s) {\n-        String sep = System.getProperty(\"file.separator\");\n-        String relativePath = s.replace('.', sep.charAt(0));\n-        String userDir = System.getProperty(\"user.dir\");\n-        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n-    }\n-    private void saveClass(String className, byte[] bytes) {\n-\n-        File file;\n-        try {\n-            String classFileName = getFilePath(className);\n-            String finalFileName = classFileName;\n-            file = new File(finalFileName);\n-            int i = 1;\n-            while (file.exists()) {\n-                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n-                file = new File(finalFileName);\n-                i++;\n-            }\n-            file.getParentFile().mkdirs();\n-            try (FileOutputStream fop = new FileOutputStream(file)) {\n-                file.createNewFile();\n-                fop.write(bytes);\n-                fop.flush();\n-            }\n-        } catch (FileNotFoundException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    protected Class<?> loadClass(String className, byte[] bytes) {\n-        if (DEBUG) {\n-            saveClass(className, bytes);\n-        }\n-        TypeHelperClassLoader loader = getOrCreateLoader();\n-        synchronized (loader) {\n-            Class<?> cls = loader.lookupDefinedClass(className);\n-            if (cls == null) {\n-                return loader.defineClass(className, bytes);\n-            }\n-            return cls;\n-        }\n-    }\n-    protected Class<?> findClass(String className) {\n-        return getOrCreateLoader().lookupDefinedClass(className);\n-    }\n-    private TypeHelperClassLoader getOrCreateLoader() {\n-        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n-        if (loader == null) {\n-            synchronized (bus) {\n-                loader = bus.getExtension(TypeHelperClassLoader.class);\n-                if (loader == null) {\n-                    ClassLoader parent = bus.getExtension(ClassLoader.class);\n-                    if (parent == null) {\n-                        parent = Thread.currentThread().getContextClassLoader();\n-                    }\n-                    loader = new TypeHelperClassLoader(parent);\n-                    bus.setExtension(loader, TypeHelperClassLoader.class);\n-                }\n-            }\n-        }\n-        return loader;\n-    }\n-\n-\n-    public static class TypeHelperClassLoader extends ClassLoader {\n-        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n-\n-        TypeHelperClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-        public Class<?> lookupDefinedClass(String name) {\n-            return defined.get(name.replace('/', '.'));\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.endsWith(\"package-info\")) {\n-                return getParent().loadClass(name);\n-            }\n-            return super.findClass(name);\n-        }\n-\n-        public Class<?> defineClass(String name, byte[] bytes) {\n-            Class<?> ret = defined.get(name.replace('/', '.'));\n-            if (ret != null) {\n-                return ret;\n-            }\n-            if (name.endsWith(\"package-info\")) {\n-                Package p = super.getPackage(name.substring(0, name.length() - 13));\n-                if (p == null) {\n-                    definePackage(name.substring(0, name.length() - 13).replace('/', '.'),\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null);\n-                }\n-            }\n-\n-            ret = super.defineClass(name.replace('/', '.'), bytes, 0, bytes.length);\n-            Class<?> tmpRet = defined.putIfAbsent(name.replace('/', '.'), ret);\n-            if (tmpRet != null) {\n-                ret = tmpRet;\n-            }\n-            return ret;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzOTk1Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524839953", "bodyText": "It seems like we have recurrent patterns:\n\nname.replace('/', '.') slashes to periods (used many times)\nASMHelper:periodToSlashes periods to slashes\n\nWe could extract those to org.apache.cxf.common.util.StringUtils (and actually drop one method from ASMHelper interface)", "author": "reta", "createdAt": "2020-11-17T02:14:04Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.BusFactory;\n+\n+public class ClassGeneratorClassLoader {\n+    //TODO handle that with system property\n+    private static final boolean DEBUG = false;\n+    protected final Bus bus;\n+\n+    public ClassGeneratorClassLoader(final Bus bus) {\n+        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n+    }\n+\n+    private String getFilePath(String s) {\n+        String sep = System.getProperty(\"file.separator\");\n+        String relativePath = s.replace('.', sep.charAt(0));\n+        String userDir = System.getProperty(\"user.dir\");\n+        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n+    }\n+    private void saveClass(String className, byte[] bytes) {\n+\n+        File file;\n+        try {\n+            String classFileName = getFilePath(className);\n+            String finalFileName = classFileName;\n+            file = new File(finalFileName);\n+            int i = 1;\n+            while (file.exists()) {\n+                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n+                file = new File(finalFileName);\n+                i++;\n+            }\n+            file.getParentFile().mkdirs();\n+            try (FileOutputStream fop = new FileOutputStream(file)) {\n+                file.createNewFile();\n+                fop.write(bytes);\n+                fop.flush();\n+            }\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    protected Class<?> loadClass(String className, byte[] bytes) {\n+        if (DEBUG) {\n+            saveClass(className, bytes);\n+        }\n+        TypeHelperClassLoader loader = getOrCreateLoader();\n+        synchronized (loader) {\n+            Class<?> cls = loader.lookupDefinedClass(className);\n+            if (cls == null) {\n+                return loader.defineClass(className, bytes);\n+            }\n+            return cls;\n+        }\n+    }\n+    protected Class<?> findClass(String className) {\n+        return getOrCreateLoader().lookupDefinedClass(className);\n+    }\n+    private TypeHelperClassLoader getOrCreateLoader() {\n+        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n+        if (loader == null) {\n+            synchronized (bus) {\n+                loader = bus.getExtension(TypeHelperClassLoader.class);\n+                if (loader == null) {\n+                    ClassLoader parent = bus.getExtension(ClassLoader.class);\n+                    if (parent == null) {\n+                        parent = Thread.currentThread().getContextClassLoader();\n+                    }\n+                    loader = new TypeHelperClassLoader(parent);\n+                    bus.setExtension(loader, TypeHelperClassLoader.class);\n+                }\n+            }\n+        }\n+        return loader;\n+    }\n+\n+\n+    public static class TypeHelperClassLoader extends ClassLoader {\n+        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n+\n+        TypeHelperClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+        public Class<?> lookupDefinedClass(String name) {\n+            return defined.get(name.replace('/', '.'));", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\ndeleted file mode 100644\nindex fc633b1104..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\n+++ /dev/null\n\n@@ -1,151 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.BusFactory;\n-\n-public class ClassGeneratorClassLoader {\n-    //TODO handle that with system property\n-    private static final boolean DEBUG = false;\n-    protected final Bus bus;\n-\n-    public ClassGeneratorClassLoader(final Bus bus) {\n-        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n-    }\n-\n-    private String getFilePath(String s) {\n-        String sep = System.getProperty(\"file.separator\");\n-        String relativePath = s.replace('.', sep.charAt(0));\n-        String userDir = System.getProperty(\"user.dir\");\n-        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n-    }\n-    private void saveClass(String className, byte[] bytes) {\n-\n-        File file;\n-        try {\n-            String classFileName = getFilePath(className);\n-            String finalFileName = classFileName;\n-            file = new File(finalFileName);\n-            int i = 1;\n-            while (file.exists()) {\n-                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n-                file = new File(finalFileName);\n-                i++;\n-            }\n-            file.getParentFile().mkdirs();\n-            try (FileOutputStream fop = new FileOutputStream(file)) {\n-                file.createNewFile();\n-                fop.write(bytes);\n-                fop.flush();\n-            }\n-        } catch (FileNotFoundException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    protected Class<?> loadClass(String className, byte[] bytes) {\n-        if (DEBUG) {\n-            saveClass(className, bytes);\n-        }\n-        TypeHelperClassLoader loader = getOrCreateLoader();\n-        synchronized (loader) {\n-            Class<?> cls = loader.lookupDefinedClass(className);\n-            if (cls == null) {\n-                return loader.defineClass(className, bytes);\n-            }\n-            return cls;\n-        }\n-    }\n-    protected Class<?> findClass(String className) {\n-        return getOrCreateLoader().lookupDefinedClass(className);\n-    }\n-    private TypeHelperClassLoader getOrCreateLoader() {\n-        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n-        if (loader == null) {\n-            synchronized (bus) {\n-                loader = bus.getExtension(TypeHelperClassLoader.class);\n-                if (loader == null) {\n-                    ClassLoader parent = bus.getExtension(ClassLoader.class);\n-                    if (parent == null) {\n-                        parent = Thread.currentThread().getContextClassLoader();\n-                    }\n-                    loader = new TypeHelperClassLoader(parent);\n-                    bus.setExtension(loader, TypeHelperClassLoader.class);\n-                }\n-            }\n-        }\n-        return loader;\n-    }\n-\n-\n-    public static class TypeHelperClassLoader extends ClassLoader {\n-        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n-\n-        TypeHelperClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-        public Class<?> lookupDefinedClass(String name) {\n-            return defined.get(name.replace('/', '.'));\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.endsWith(\"package-info\")) {\n-                return getParent().loadClass(name);\n-            }\n-            return super.findClass(name);\n-        }\n-\n-        public Class<?> defineClass(String name, byte[] bytes) {\n-            Class<?> ret = defined.get(name.replace('/', '.'));\n-            if (ret != null) {\n-                return ret;\n-            }\n-            if (name.endsWith(\"package-info\")) {\n-                Package p = super.getPackage(name.substring(0, name.length() - 13));\n-                if (p == null) {\n-                    definePackage(name.substring(0, name.length() - 13).replace('/', '.'),\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null);\n-                }\n-            }\n-\n-            ret = super.defineClass(name.replace('/', '.'), bytes, 0, bytes.length);\n-            Class<?> tmpRet = defined.putIfAbsent(name.replace('/', '.'), ret);\n-            if (tmpRet != null) {\n-                ret = tmpRet;\n-            }\n-            return ret;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MTYxOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524841618", "bodyText": "Minor, probably computeIfAbsent would be a bit more helpful (may eliminate some calls to super.defineClass) but we could keep it like that", "author": "reta", "createdAt": "2020-11-17T02:19:39Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.BusFactory;\n+\n+public class ClassGeneratorClassLoader {\n+    //TODO handle that with system property\n+    private static final boolean DEBUG = false;\n+    protected final Bus bus;\n+\n+    public ClassGeneratorClassLoader(final Bus bus) {\n+        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n+    }\n+\n+    private String getFilePath(String s) {\n+        String sep = System.getProperty(\"file.separator\");\n+        String relativePath = s.replace('.', sep.charAt(0));\n+        String userDir = System.getProperty(\"user.dir\");\n+        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n+    }\n+    private void saveClass(String className, byte[] bytes) {\n+\n+        File file;\n+        try {\n+            String classFileName = getFilePath(className);\n+            String finalFileName = classFileName;\n+            file = new File(finalFileName);\n+            int i = 1;\n+            while (file.exists()) {\n+                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n+                file = new File(finalFileName);\n+                i++;\n+            }\n+            file.getParentFile().mkdirs();\n+            try (FileOutputStream fop = new FileOutputStream(file)) {\n+                file.createNewFile();\n+                fop.write(bytes);\n+                fop.flush();\n+            }\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    protected Class<?> loadClass(String className, byte[] bytes) {\n+        if (DEBUG) {\n+            saveClass(className, bytes);\n+        }\n+        TypeHelperClassLoader loader = getOrCreateLoader();\n+        synchronized (loader) {\n+            Class<?> cls = loader.lookupDefinedClass(className);\n+            if (cls == null) {\n+                return loader.defineClass(className, bytes);\n+            }\n+            return cls;\n+        }\n+    }\n+    protected Class<?> findClass(String className) {\n+        return getOrCreateLoader().lookupDefinedClass(className);\n+    }\n+    private TypeHelperClassLoader getOrCreateLoader() {\n+        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n+        if (loader == null) {\n+            synchronized (bus) {\n+                loader = bus.getExtension(TypeHelperClassLoader.class);\n+                if (loader == null) {\n+                    ClassLoader parent = bus.getExtension(ClassLoader.class);\n+                    if (parent == null) {\n+                        parent = Thread.currentThread().getContextClassLoader();\n+                    }\n+                    loader = new TypeHelperClassLoader(parent);\n+                    bus.setExtension(loader, TypeHelperClassLoader.class);\n+                }\n+            }\n+        }\n+        return loader;\n+    }\n+\n+\n+    public static class TypeHelperClassLoader extends ClassLoader {\n+        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n+\n+        TypeHelperClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+        public Class<?> lookupDefinedClass(String name) {\n+            return defined.get(name.replace('/', '.'));\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (name.endsWith(\"package-info\")) {\n+                return getParent().loadClass(name);\n+            }\n+            return super.findClass(name);\n+        }\n+\n+        public Class<?> defineClass(String name, byte[] bytes) {\n+            Class<?> ret = defined.get(name.replace('/', '.'));\n+            if (ret != null) {\n+                return ret;\n+            }\n+            if (name.endsWith(\"package-info\")) {\n+                Package p = super.getPackage(name.substring(0, name.length() - 13));\n+                if (p == null) {\n+                    definePackage(name.substring(0, name.length() - 13).replace('/', '.'),\n+                            null,\n+                            null,\n+                            null,\n+                            null,\n+                            null,\n+                            null,\n+                            null);\n+                }\n+            }\n+\n+            ret = super.defineClass(name.replace('/', '.'), bytes, 0, bytes.length);\n+            Class<?> tmpRet = defined.putIfAbsent(name.replace('/', '.'), ret);", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk1MjY1Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524952653", "bodyText": "done", "author": "dufoli", "createdAt": "2020-11-17T08:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MTYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\ndeleted file mode 100644\nindex fc633b1104..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\n+++ /dev/null\n\n@@ -1,151 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.BusFactory;\n-\n-public class ClassGeneratorClassLoader {\n-    //TODO handle that with system property\n-    private static final boolean DEBUG = false;\n-    protected final Bus bus;\n-\n-    public ClassGeneratorClassLoader(final Bus bus) {\n-        this.bus = bus == null ? BusFactory.getDefaultBus() : bus;\n-    }\n-\n-    private String getFilePath(String s) {\n-        String sep = System.getProperty(\"file.separator\");\n-        String relativePath = s.replace('.', sep.charAt(0));\n-        String userDir = System.getProperty(\"user.dir\");\n-        return userDir + sep + \"target\" + sep + \"dump\" + sep + relativePath + \".class\";\n-    }\n-    private void saveClass(String className, byte[] bytes) {\n-\n-        File file;\n-        try {\n-            String classFileName = getFilePath(className);\n-            String finalFileName = classFileName;\n-            file = new File(finalFileName);\n-            int i = 1;\n-            while (file.exists()) {\n-                finalFileName = classFileName.substring(0, classFileName.length() - 6) + String.valueOf(i) + \".class\";\n-                file = new File(finalFileName);\n-                i++;\n-            }\n-            file.getParentFile().mkdirs();\n-            try (FileOutputStream fop = new FileOutputStream(file)) {\n-                file.createNewFile();\n-                fop.write(bytes);\n-                fop.flush();\n-            }\n-        } catch (FileNotFoundException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    protected Class<?> loadClass(String className, byte[] bytes) {\n-        if (DEBUG) {\n-            saveClass(className, bytes);\n-        }\n-        TypeHelperClassLoader loader = getOrCreateLoader();\n-        synchronized (loader) {\n-            Class<?> cls = loader.lookupDefinedClass(className);\n-            if (cls == null) {\n-                return loader.defineClass(className, bytes);\n-            }\n-            return cls;\n-        }\n-    }\n-    protected Class<?> findClass(String className) {\n-        return getOrCreateLoader().lookupDefinedClass(className);\n-    }\n-    private TypeHelperClassLoader getOrCreateLoader() {\n-        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n-        if (loader == null) {\n-            synchronized (bus) {\n-                loader = bus.getExtension(TypeHelperClassLoader.class);\n-                if (loader == null) {\n-                    ClassLoader parent = bus.getExtension(ClassLoader.class);\n-                    if (parent == null) {\n-                        parent = Thread.currentThread().getContextClassLoader();\n-                    }\n-                    loader = new TypeHelperClassLoader(parent);\n-                    bus.setExtension(loader, TypeHelperClassLoader.class);\n-                }\n-            }\n-        }\n-        return loader;\n-    }\n-\n-\n-    public static class TypeHelperClassLoader extends ClassLoader {\n-        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n-\n-        TypeHelperClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-        public Class<?> lookupDefinedClass(String name) {\n-            return defined.get(name.replace('/', '.'));\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.endsWith(\"package-info\")) {\n-                return getParent().loadClass(name);\n-            }\n-            return super.findClass(name);\n-        }\n-\n-        public Class<?> defineClass(String name, byte[] bytes) {\n-            Class<?> ret = defined.get(name.replace('/', '.'));\n-            if (ret != null) {\n-                return ret;\n-            }\n-            if (name.endsWith(\"package-info\")) {\n-                Package p = super.getPackage(name.substring(0, name.length() - 13));\n-                if (p == null) {\n-                    definePackage(name.substring(0, name.length() - 13).replace('/', '.'),\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null,\n-                            null);\n-                }\n-            }\n-\n-            ret = super.defineClass(name.replace('/', '.'), bytes, 0, bytes.length);\n-            Class<?> tmpRet = defined.putIfAbsent(name.replace('/', '.'), ret);\n-            if (tmpRet != null) {\n-                ret = tmpRet;\n-            }\n-            return ret;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524842582", "bodyText": "Should we try to get the Classloader from bus?\nClassLoader classloader = bus.getExtension(ClassLoader.class); \n\n@rmannibucau wouldn't fallback to  Thread.currentThread().getContextClassLoader(); be more appropriate here?", "author": "reta", "createdAt": "2020-11-17T02:22:46Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+\n+import org.apache.cxf.Bus;\n+\n+public class ClassLoaderProxyService implements ClassLoaderService {\n+    NamespaceClassCreator srv;\n+    public ClassLoaderProxyService(Bus bus) {\n+        this(new NamespaceClassGenerator(bus));\n+    }\n+    public ClassLoaderProxyService(NamespaceClassCreator srv) {\n+        this.srv = srv;\n+    }\n+\n+    @Override\n+    public Object createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n+        Class<?> cls = srv.createNamespaceWrapper(mcls, map);\n+        try {\n+            return cls.getConstructor(Map.class).newInstance(map);\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+    public class LoadFirst extends ClassLoaderProxyService {\n+        public LoadFirst(Bus bus) {\n+            //TODO not sure here if I get class loader like that ???", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkyMjg2Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524922862", "bodyText": "It hink we have a classloaderutils which tries the tccl and if null uses the system classloader. Would be a saner default if the bus does not have one.", "author": "rmannibucau", "createdAt": "2020-11-17T07:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNTk2MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525005961", "bodyText": "@reta maybe we can skip bus param and class loader parameter and just use in GeneratedNamespaceClassLoader\nClassLoaderUtils.loadClass(String className, Class<?> callingClass) with callingClass equal to GeneratedNamespaceClassLoader.class\nand we use same pattern for all generated class. wdyt ?\n@rmannibucau  @reta", "author": "dufoli", "createdAt": "2020-11-17T09:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyNDY4Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525024682", "bodyText": "@dufoli any classloader usage should following this chain 1. bus one, 2. tccl, 3. system classloader (there is an utility for 2+3). Using any random class classloader will lead to a random behavior in all but flat classpath env sadly.", "author": "rmannibucau", "createdAt": "2020-11-17T09:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY0Njg1NQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526646855", "bodyText": "hmm I have use ClassLoaderUtils . It mean that all classloader service provider must start with bus instead of only ClassLoaderUtils.load ? It mean I have to get set bus in contructor and check bus.getExtension(Classloader) right ?", "author": "dufoli", "createdAt": "2020-11-19T07:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMjQyMA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r527132420", "bodyText": "May be we could introduce overloaded method to ClassLoaderUtils which also accepts bus and does the classloader resolution taking into account the extension?", "author": "reta", "createdAt": "2020-11-19T19:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMzgyNw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r527133827", "bodyText": "I have just push a solution with a common class to do that with bus", "author": "dufoli", "createdAt": "2020-11-19T19:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI1OTQ5Nw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r527259497", "bodyText": "\ud83d\udc4d , no objections, thank you", "author": "reta", "createdAt": "2020-11-19T22:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java b/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java\ndeleted file mode 100644\nindex 476534775e..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java\n+++ /dev/null\n\n@@ -1,57 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.util.Map;\n-\n-import org.apache.cxf.Bus;\n-\n-public class ClassLoaderProxyService implements ClassLoaderService {\n-    NamespaceClassCreator srv;\n-    public ClassLoaderProxyService(Bus bus) {\n-        this(new NamespaceClassGenerator(bus));\n-    }\n-    public ClassLoaderProxyService(NamespaceClassCreator srv) {\n-        this.srv = srv;\n-    }\n-\n-    @Override\n-    public Object createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n-        Class<?> cls = srv.createNamespaceWrapper(mcls, map);\n-        try {\n-            return cls.getConstructor(Map.class).newInstance(map);\n-        } catch (Throwable e) {\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-    public class LoadFirst extends ClassLoaderProxyService {\n-        public LoadFirst(Bus bus) {\n-            //TODO not sure here if I get class loader like that ???\n-            // or I need to inject another class loader from outside\n-            super(new GeneratedNamespaceClassLoader(LoadFirst.class.getClassLoader()));\n-        }\n-    }\n-    public class GenerateJustInTime extends ClassLoaderProxyService {\n-        public GenerateJustInTime(Bus bus) {\n-            super(new NamespaceClassGenerator(bus));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0Mjg5Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524842896", "bodyText": "Probably better to use standard CXF logging facilities please", "author": "reta", "createdAt": "2020-11-17T02:23:45Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+\n+import org.apache.cxf.Bus;\n+\n+public class ClassLoaderProxyService implements ClassLoaderService {\n+    NamespaceClassCreator srv;\n+    public ClassLoaderProxyService(Bus bus) {\n+        this(new NamespaceClassGenerator(bus));\n+    }\n+    public ClassLoaderProxyService(NamespaceClassCreator srv) {\n+        this.srv = srv;\n+    }\n+\n+    @Override\n+    public Object createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n+        Class<?> cls = srv.createNamespaceWrapper(mcls, map);\n+        try {\n+            return cls.getConstructor(Map.class).newInstance(map);\n+        } catch (Throwable e) {\n+            e.printStackTrace();", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java b/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java\ndeleted file mode 100644\nindex 476534775e..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java\n+++ /dev/null\n\n@@ -1,57 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.util.Map;\n-\n-import org.apache.cxf.Bus;\n-\n-public class ClassLoaderProxyService implements ClassLoaderService {\n-    NamespaceClassCreator srv;\n-    public ClassLoaderProxyService(Bus bus) {\n-        this(new NamespaceClassGenerator(bus));\n-    }\n-    public ClassLoaderProxyService(NamespaceClassCreator srv) {\n-        this.srv = srv;\n-    }\n-\n-    @Override\n-    public Object createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n-        Class<?> cls = srv.createNamespaceWrapper(mcls, map);\n-        try {\n-            return cls.getConstructor(Map.class).newInstance(map);\n-        } catch (Throwable e) {\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-    public class LoadFirst extends ClassLoaderProxyService {\n-        public LoadFirst(Bus bus) {\n-            //TODO not sure here if I get class loader like that ???\n-            // or I need to inject another class loader from outside\n-            super(new GeneratedNamespaceClassLoader(LoadFirst.class.getClassLoader()));\n-        }\n-    }\n-    public class GenerateJustInTime extends ClassLoaderProxyService {\n-        public GenerateJustInTime(Bus bus) {\n-            super(new NamespaceClassGenerator(bus));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MzgzNg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524843836", "bodyText": "If I am not mistaken, ClassLoader already use synchronization or/and locking internally for loading classes (@rmannibucau please correct me if I am wrong), why do you need  synchronized here?", "author": "reta", "createdAt": "2020-11-17T02:26:40Z", "path": "core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+\n+public class GeneratedNamespaceClassLoader implements NamespaceClassCreator {\n+    ClassLoader cl;\n+    GeneratedNamespaceClassLoader(ClassLoader cl) {\n+        this.cl = cl;\n+    }\n+    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkyMzI2Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524923266", "bodyText": "to avoid to generate twice the same class and register only once, +-0 to drop it", "author": "rmannibucau", "createdAt": "2020-11-17T07:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA0MTUyMA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525041520", "bodyText": "I have removed it then think that if I switch to ClassLoaderUtils.loadClass I will have an issue because it can be thread relative whereas we need that class is generated once then discover whatever the thread (request received). So not sure it is goot to used it. We need a single classloader by called class not by thread. Does it make sens to you ?", "author": "dufoli", "createdAt": "2020-11-17T10:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwMTM5Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525501392", "bodyText": "Let's keep it, I think we could implement simpler mechanism but not in scope of this PR", "author": "reta", "createdAt": "2020-11-17T20:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MzgzNg=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java\ndeleted file mode 100644\nindex c212c1a1dc..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java\n+++ /dev/null\n\n@@ -1,48 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.util.Map;\n-\n-public class GeneratedNamespaceClassLoader implements NamespaceClassCreator {\n-    ClassLoader cl;\n-    GeneratedNamespaceClassLoader(ClassLoader cl) {\n-        this.cl = cl;\n-    }\n-    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n-        String postFix = \"\";\n-\n-        if (mcls.getName().contains(\"eclipse\")) {\n-            try {\n-                return cl.loadClass(\"org.apache.cxf.jaxb.EclipseNamespaceMapper\");\n-            } catch (ClassNotFoundException e) {\n-            }\n-        } else if (mcls.getName().contains(\".internal\")) {\n-            postFix = \"Internal\";\n-        } else if (mcls.getName().contains(\"com.sun\")) {\n-            postFix = \"RI\";\n-        }\n-        try {\n-            return cl.loadClass(\"org.apache.cxf.jaxb.NamespaceMapper\" + postFix);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0ODM4MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524848380", "bodyText": "Also the use of synchronized is not really justified, this class seems to have no state to take care of, why you need it?", "author": "reta", "createdAt": "2020-11-17T02:41:41Z", "path": "core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java", "diffHunk": "@@ -0,0 +1,450 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+import org.apache.cxf.common.logging.LogUtils;\n+import org.apache.cxf.common.util.ASMHelper;\n+import org.apache.cxf.common.util.OpcodesProxy;\n+\n+public class NamespaceClassGenerator extends ClassGeneratorClassLoader implements NamespaceClassCreator {\n+\n+    private static final Logger LOG = LogUtils.getL7dLogger(ClassGeneratorClassLoader.class);\n+    ASMHelper helper;\n+\n+    public NamespaceClassGenerator(Bus bus) {\n+        super(bus);\n+        helper = bus.getExtension(ASMHelper.class);\n+    }\n+\n+    @Override\n+    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNzQxMg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525037412", "bodyText": "JaxBUtils.marshall is called by request so it seems to be multi threaded right ? so I guess that createNamespceWrapper need to be synchronized (compare to classLoader part) to avoid double class generation. ?", "author": "dufoli", "createdAt": "2020-11-17T10:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0ODM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwMjgzMw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525502833", "bodyText": "Yeah. seems like concurrent class generation is an issue, let's keep it as is for now, I think we could address it later", "author": "reta", "createdAt": "2020-11-17T20:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0ODM4MA=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java b/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java\ndeleted file mode 100644\nindex 46995f6d07..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java\n+++ /dev/null\n\n@@ -1,450 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.util.Map;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-import org.apache.cxf.common.logging.LogUtils;\n-import org.apache.cxf.common.util.ASMHelper;\n-import org.apache.cxf.common.util.OpcodesProxy;\n-\n-public class NamespaceClassGenerator extends ClassGeneratorClassLoader implements NamespaceClassCreator {\n-\n-    private static final Logger LOG = LogUtils.getL7dLogger(ClassGeneratorClassLoader.class);\n-    ASMHelper helper;\n-\n-    public NamespaceClassGenerator(Bus bus) {\n-        super(bus);\n-        helper = bus.getExtension(ASMHelper.class);\n-    }\n-\n-    @Override\n-    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n-        String postFix = \"\";\n-\n-        if (mcls.getName().contains(\"eclipse\")) {\n-            return createEclipseNamespaceMapper(mcls, map);\n-        } else if (mcls.getName().contains(\".internal\")) {\n-            postFix = \"Internal\";\n-        } else if (mcls.getName().contains(\"com.sun\")) {\n-            postFix = \"RI\";\n-        }\n-\n-        String className = \"org.apache.cxf.jaxb.NamespaceMapper\";\n-        className += postFix;\n-        Class<?> cls = findClass(className);\n-        Throwable t = null;\n-        if (cls == null) {\n-            try {\n-                byte[] bts = createNamespaceWrapperInternal(postFix);\n-                className = \"org.apache.cxf.jaxb.NamespaceMapper\" + postFix;\n-                return loadClass(className, bts);\n-            } catch (RuntimeException ex) {\n-                // continue\n-                t = ex;\n-            }\n-        }\n-        if (cls == null\n-                && (!mcls.getName().contains(\".internal.\") && mcls.getName().contains(\"com.sun\"))) {\n-            try {\n-                cls = ClassLoaderUtils.loadClass(\"org.apache.cxf.common.jaxb.NamespaceMapper\",\n-                        NamespaceClassGenerator.class);\n-            } catch (Throwable ex2) {\n-                // ignore\n-                t = ex2;\n-            }\n-        }\n-        LOG.log(Level.INFO, \"Could not create a NamespaceMapper compatible with Marshaller class \" + mcls.getName(), t);\n-        return cls;\n-    }\n-\n-    private Class<?> createEclipseNamespaceMapper(Class<?> mcls, Map<String, String> map) {\n-        String className = \"org.apache.cxf.jaxb.EclipseNamespaceMapper\";\n-        Class<?> cls = findClass(className);\n-        if (cls != null) {\n-            return cls;\n-        }\n-        byte[] bts = createEclipseNamespaceMapper();\n-        return loadClass(className, bts);\n-    }\n-\n-    /*\n-    // This is the \"prototype\" for the ASM generated class below\n-    public static class MapNamespacePrefixMapper2\n-        extends org.eclipse.persistence.internal.oxm.record.namespaces.MapNamespacePrefixMapper {\n-\n-        String[] nsctxt;\n-\n-        public MapNamespacePrefixMapper2(Map<String, String> foo) {\n-            super(foo);\n-        }\n-        public String[] getPreDeclaredNamespaceUris() {\n-            String[] sup = super.getPreDeclaredNamespaceUris();\n-            if (nsctxt == null) {\n-                return sup;\n-            }\n-            List<String> s = new ArrayList<>(Arrays.asList(sup));\n-            for (int x = 1; x < nsctxt.length; x = x + 2) {\n-                s.remove(nsctxt[x]);\n-            }\n-            return s.toArray(new String[s.size()]);\n-        }\n-        public void setContextualNamespaceDecls(String[] f) {\n-            nsctxt = f;\n-        }\n-        public String[] getContextualNamespaceDecls() {\n-            return nsctxt;\n-        }\n-    }\n-    */\n-    //CHECKSTYLE:OFF\n-    //bunch of really long ASM based methods that cannot be shortened easily\n-    private byte[] createEclipseNamespaceMapper() {\n-        OpcodesProxy Opcodes = helper.getOpCodes();\n-        String slashedName = \"org/apache/cxf/jaxb/EclipseNamespaceMapper\";\n-        ASMHelper.ClassWriter cw = helper.createClassWriter();\n-        if (cw == null) {\n-            return null;\n-        }\n-        String superName = \"org/eclipse/persistence/internal/oxm/record/namespaces/MapNamespacePrefixMapper\";\n-        ASMHelper.FieldVisitor fv;\n-        ASMHelper.MethodVisitor mv;\n-        cw.visit(Opcodes.V1_6,\n-                Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n-                slashedName, null,\n-                superName, null);\n-\n-        cw.visitSource(\"EclipseNamespaceMapper.java\", null);\n-\n-        fv = cw.visitField(Opcodes.ACC_PRIVATE, \"nsctxt\", \"[Ljava/lang/String;\", null, null);\n-        fv.visitEnd();\n-\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"(Ljava/util/Map;)V\",\n-                \"(Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V\", null);\n-        mv.visitCode();\n-        ASMHelper.Label l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 1);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,\n-                superName, \"<init>\", \"(Ljava/util/Map;)V\", false);\n-        ASMHelper.Label l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitInsn(Opcodes.RETURN);\n-        ASMHelper.Label l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n-\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"setContextualNamespaceDecls\", \"([Ljava/lang/String;)V\",\n-                null, null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(47, l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 1);\n-        mv.visitFieldInsn(Opcodes.PUTFIELD, slashedName, \"nsctxt\", \"[Ljava/lang/String;\");\n-        l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(48, l1);\n-        mv.visitInsn(Opcodes.RETURN);\n-        l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLocalVariable(\"this\", \"L\" + slashedName + \";\", null, l0, l2, 0);\n-        mv.visitLocalVariable(\"contextualNamespaceDecls\", \"[Ljava/lang/String;\", null, l0, l2, 1);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"getContextualNamespaceDecls\", \"()[Ljava/lang/String;\", null, null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(51, l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, slashedName, \"nsctxt\", \"[Ljava/lang/String;\");\n-        mv.visitInsn(Opcodes.ARETURN);\n-        l1 = helper.createLabel();\n-\n-        mv.visitLabel(l1);\n-        mv.visitLocalVariable(\"this\", \"L\" + slashedName + \";\", null, l0, l1, 0);\n-\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"getPreDeclaredNamespaceUris\", \"()[Ljava/lang/String;\", null, null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(1036, l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,\n-                superName,\n-                \"getPreDeclaredNamespaceUris\", \"()[Ljava/lang/String;\", false);\n-        mv.visitVarInsn(Opcodes.ASTORE, 1);\n-        l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(1037, l1);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, slashedName, \"nsctxt\", \"[Ljava/lang/String;\");\n-        l2 = helper.createLabel();\n-        mv.visitJumpInsn(Opcodes.IFNONNULL, l2);\n-        ASMHelper.Label l3 = helper.createLabel();\n-        mv.visitLabel(l3);\n-        mv.visitLineNumber(1038, l3);\n-        mv.visitVarInsn(Opcodes.ALOAD, 1);\n-        mv.visitInsn(Opcodes.ARETURN);\n-        mv.visitLabel(l2);\n-        mv.visitLineNumber(1040, l2);\n-        mv.visitFrame(Opcodes.F_APPEND, 1, new Object[] {\"[Ljava/lang/String;\"}, 0, null);\n-        mv.visitTypeInsn(Opcodes.NEW, \"java/util/ArrayList\");\n-        mv.visitInsn(Opcodes.DUP);\n-        mv.visitVarInsn(Opcodes.ALOAD, 1);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/util/Arrays\", \"asList\",\n-                \"([Ljava/lang/Object;)Ljava/util/List;\", false);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/util/ArrayList\", \"<init>\",\n-                \"(Ljava/util/Collection;)V\", false);\n-        mv.visitVarInsn(Opcodes.ASTORE, 2);\n-        ASMHelper.Label l4 = helper.createLabel();\n-        mv.visitLabel(l4);\n-        mv.visitLineNumber(1041, l4);\n-        mv.visitInsn(Opcodes.ICONST_1);\n-        mv.visitVarInsn(Opcodes.ISTORE, 3);\n-        ASMHelper.Label l5 = helper.createLabel();\n-        mv.visitLabel(l5);\n-        ASMHelper.Label l6 = helper.createLabel();\n-        mv.visitJumpInsn(Opcodes.GOTO, l6);\n-        ASMHelper.Label l7 = helper.createLabel();\n-        mv.visitLabel(l7);\n-        mv.visitLineNumber(1042, l7);\n-        mv.visitFrame(Opcodes.F_APPEND, 2, new Object[] {\"java/util/List\", Opcodes.INTEGER}, 0, null);\n-        mv.visitVarInsn(Opcodes.ALOAD, 2);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, slashedName, \"nsctxt\", \"[Ljava/lang/String;\");\n-        mv.visitVarInsn(Opcodes.ILOAD, 3);\n-        mv.visitInsn(Opcodes.AALOAD);\n-        mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java/util/List\", \"remove\", \"(Ljava/lang/Object;)Z\", true);\n-        mv.visitInsn(Opcodes.POP);\n-        ASMHelper.Label l8 = helper.createLabel();\n-        mv.visitLabel(l8);\n-        mv.visitLineNumber(1041, l8);\n-        mv.visitIincInsn(3, 2);\n-        mv.visitLabel(l6);\n-        mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-        mv.visitVarInsn(Opcodes.ILOAD, 3);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD,\n-                slashedName,\n-                \"nsctxt\", \"[Ljava/lang/String;\");\n-        mv.visitInsn(Opcodes.ARRAYLENGTH);\n-        mv.visitJumpInsn(Opcodes.IF_ICMPLT, l7);\n-        ASMHelper.Label l9 = helper.createLabel();\n-        mv.visitLabel(l9);\n-        mv.visitLineNumber(1044, l9);\n-        mv.visitVarInsn(Opcodes.ALOAD, 2);\n-        mv.visitVarInsn(Opcodes.ALOAD, 2);\n-        mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java/util/List\", \"size\", \"()I\", true);\n-        mv.visitTypeInsn(Opcodes.ANEWARRAY, \"java/lang/String\");\n-        mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java/util/List\",\n-                \"toArray\", \"([Ljava/lang/Object;)[Ljava/lang/Object;\", true);\n-        mv.visitTypeInsn(Opcodes.CHECKCAST, \"[Ljava/lang/String;\");\n-        mv.visitInsn(Opcodes.ARETURN);\n-        ASMHelper.Label l10 = helper.createLabel();\n-        mv.visitLabel(l10);\n-        mv.visitLocalVariable(\"this\", \"L\" + slashedName + \";\",\n-                null, l0, l10, 0);\n-        mv.visitLocalVariable(\"sup\", \"[Ljava/lang/String;\", null, l1, l10, 1);\n-        mv.visitLocalVariable(\"s\", \"Ljava/util/List;\", \"Ljava/util/List<Ljava/lang/String;>;\", l4, l10, 2);\n-        mv.visitLocalVariable(\"x\", \"I\", null, l5, l9, 3);\n-        mv.visitMaxs(3, 4);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-\n-        byte[] bts = cw.toByteArray();\n-        return bts;\n-    }\n-\n-    private byte[] createNamespaceWrapperInternal(String postFix) {\n-\n-        String superName = \"com/sun/xml/\"\n-                + (\"RI\".equals(postFix) ? \"\" : \"internal/\")\n-                + \"bind/marshaller/NamespacePrefixMapper\";\n-        String postFixedName = \"org/apache/cxf/jaxb/NamespaceMapper\" + postFix;\n-        ASMHelper.ClassWriter cw = helper.createClassWriter();\n-        if (cw == null) {\n-            return null;\n-        }\n-        ASMHelper.FieldVisitor fv;\n-        ASMHelper.MethodVisitor mv;\n-        OpcodesProxy Opcodes= helper.getOpCodes();\n-        cw.visit(Opcodes.V1_6,\n-                Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n-                postFixedName, null,\n-                superName, null);\n-\n-        cw.visitSource(\"NamespaceMapper.java\", null);\n-\n-        fv = cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL,\n-                \"nspref\", \"Ljava/util/Map;\",\n-                \"Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;\", null);\n-        fv.visitEnd();\n-\n-        fv = cw.visitField(Opcodes.ACC_PRIVATE, \"nsctxt\", \"[Ljava/lang/String;\", null, null);\n-        fv.visitEnd();\n-\n-        fv = cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC,\n-                \"EMPTY_STRING\", \"[Ljava/lang/String;\", null, null);\n-        fv.visitEnd();\n-\n-        mv = cw.visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        mv.visitCode();\n-        ASMHelper.Label l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(30, l0);\n-        mv.visitInsn(Opcodes.ICONST_0);\n-        mv.visitTypeInsn(Opcodes.ANEWARRAY, \"java/lang/String\");\n-        mv.visitFieldInsn(Opcodes.PUTSTATIC, postFixedName, \"EMPTY_STRING\", \"[Ljava/lang/String;\");\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(1, 0);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\",\n-                \"(Ljava/util/Map;)V\",\n-                \"(Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V\", null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(32, l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, superName, \"<init>\", \"()V\", false);\n-        ASMHelper.Label l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(29, l1);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitFieldInsn(Opcodes.GETSTATIC, postFixedName, \"EMPTY_STRING\", \"[Ljava/lang/String;\");\n-        mv.visitFieldInsn(Opcodes.PUTFIELD, postFixedName, \"nsctxt\", \"[Ljava/lang/String;\");\n-        ASMHelper.Label l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLineNumber(33, l2);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 1);\n-        mv.visitFieldInsn(Opcodes.PUTFIELD, postFixedName, \"nspref\", \"Ljava/util/Map;\");\n-        ASMHelper.Label l3 = helper.createLabel();\n-        mv.visitLabel(l3);\n-        mv.visitLineNumber(34, l3);\n-        mv.visitInsn(Opcodes.RETURN);\n-        ASMHelper.Label l4 = helper.createLabel();\n-        mv.visitLabel(l4);\n-        mv.visitLocalVariable(\"this\", \"L\" + postFixedName + \";\", null, l0, l4, 0);\n-        mv.visitLocalVariable(\"nspref\",\n-                \"Ljava/util/Map;\", \"Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;\",\n-                l0, l4, 1);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"getPreferredPrefix\",\n-                \"(Ljava/lang/String;Ljava/lang/String;Z)Ljava/lang/String;\",\n-                null, null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(39, l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, postFixedName, \"nspref\", \"Ljava/util/Map;\");\n-        mv.visitVarInsn(Opcodes.ALOAD, 1);\n-        mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java/util/Map\",\n-                \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n-        mv.visitTypeInsn(Opcodes.CHECKCAST, \"java/lang/String\");\n-        mv.visitVarInsn(Opcodes.ASTORE, 4);\n-        l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(40, l1);\n-        mv.visitVarInsn(Opcodes.ALOAD, 4);\n-        l2 = helper.createLabel();\n-        mv.visitJumpInsn(Opcodes.IFNULL, l2);\n-        l3 = helper.createLabel();\n-        mv.visitLabel(l3);\n-        mv.visitLineNumber(41, l3);\n-        mv.visitVarInsn(Opcodes.ALOAD, 4);\n-        mv.visitInsn(Opcodes.ARETURN);\n-        mv.visitLabel(l2);\n-        mv.visitLineNumber(43, l2);\n-        mv.visitFrame(Opcodes.F_APPEND, 1, new Object[] {\"java/lang/String\"}, 0, null);\n-        mv.visitVarInsn(Opcodes.ALOAD, 2);\n-        mv.visitInsn(Opcodes.ARETURN);\n-        l4 = helper.createLabel();\n-        mv.visitLabel(l4);\n-        mv.visitLocalVariable(\"this\", \"L\" + postFixedName + \";\", null, l0, l4, 0);\n-        mv.visitLocalVariable(\"namespaceUri\", \"Ljava/lang/String;\", null, l0, l4, 1);\n-        mv.visitLocalVariable(\"suggestion\", \"Ljava/lang/String;\", null, l0, l4, 2);\n-        mv.visitLocalVariable(\"requirePrefix\", \"Z\", null, l0, l4, 3);\n-        mv.visitLocalVariable(\"prefix\", \"Ljava/lang/String;\", null, l1, l4, 4);\n-        mv.visitMaxs(2, 5);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"setContextualNamespaceDecls\", \"([Ljava/lang/String;)V\", null, null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(47, l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 1);\n-        mv.visitFieldInsn(Opcodes.PUTFIELD, postFixedName, \"nsctxt\", \"[Ljava/lang/String;\");\n-        l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(48, l1);\n-        mv.visitInsn(Opcodes.RETURN);\n-        l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLocalVariable(\"this\", \"L\" + postFixedName + \";\", null, l0, l2, 0);\n-        mv.visitLocalVariable(\"contextualNamespaceDecls\", \"[Ljava/lang/String;\", null, l0, l2, 1);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"getContextualNamespaceDecls\", \"()[Ljava/lang/String;\", null, null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(51, l0);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, postFixedName, \"nsctxt\", \"[Ljava/lang/String;\");\n-        mv.visitInsn(Opcodes.ARETURN);\n-        l1 = helper.createLabel();\n-\n-        mv.visitLabel(l1);\n-        mv.visitLocalVariable(\"this\", \"L\" + postFixedName + \";\", null, l0, l1, 0);\n-\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-\n-        return cw.toByteArray();\n-    }\n-    //CHECKSTYLE:ON\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0OTQ0OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524849448", "bodyText": "Seems like you could use bus.getExtension(ASMHelper.class), correct?", "author": "reta", "createdAt": "2020-11-17T02:45:27Z", "path": "rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplGenerator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.binding.corba.utils;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.spi.ClassGeneratorClassLoader;\n+import org.apache.cxf.common.util.ASMHelper;\n+import org.apache.cxf.common.util.ASMHelperImpl;\n+import org.apache.cxf.common.util.OpcodesProxy;\n+\n+public class CorbaFixedAnyImplGenerator extends ClassGeneratorClassLoader {\n+\n+    public CorbaFixedAnyImplGenerator(Bus bus) {\n+        super(bus);\n+    }\n+    public Class<?> createFixedAnyClass() {\n+        //TODO move to bus.getExtension(ASMHelper.class)", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2ODUzMg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524868532", "bodyText": "Yes but no bus available.... So need refractor to get it...", "author": "dufoli", "createdAt": "2020-11-17T03:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0OTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkyMzUyNg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524923526", "bodyText": "it is in the constructor so it is available ;)", "author": "rmannibucau", "createdAt": "2020-11-17T07:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0OTQ0OA=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplGenerator.java b/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplGenerator.java\ndeleted file mode 100644\nindex 010d5832da..0000000000\n--- a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplGenerator.java\n+++ /dev/null\n\n@@ -1,277 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.binding.corba.utils;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.common.spi.ClassGeneratorClassLoader;\n-import org.apache.cxf.common.util.ASMHelper;\n-import org.apache.cxf.common.util.ASMHelperImpl;\n-import org.apache.cxf.common.util.OpcodesProxy;\n-\n-public class CorbaFixedAnyImplGenerator extends ClassGeneratorClassLoader {\n-\n-    public CorbaFixedAnyImplGenerator(Bus bus) {\n-        super(bus);\n-    }\n-    public Class<?> createFixedAnyClass() {\n-        //TODO move to bus.getExtension(ASMHelper.class)\n-        ASMHelper helper = new ASMHelperImpl();\n-        OpcodesProxy opCodes = helper.getOpCodes();\n-        ASMHelper.ClassWriter cw = helper.createClassWriter();\n-        ASMHelper.FieldVisitor fv;\n-\n-        cw.visit(opCodes.V1_6, opCodes.ACC_PUBLIC + opCodes.ACC_SUPER,\n-                \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n-                null, \"com/sun/corba/se/impl/corba/AnyImpl\", null);\n-\n-        cw.visitSource(\"FixedAnyImpl.java\", null);\n-\n-        fv = cw.visitField(0, \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\", null, null);\n-        fv.visitEnd();\n-        addFixedAnyConstructor(helper, cw);\n-        addInsertOverride(helper, cw);\n-        addExtractOverride(helper, cw);\n-        addWriteOverride(helper, cw);\n-        addReadOverride(helper, cw);\n-\n-        cw.visitEnd();\n-\n-        byte[] b = cw.toByteArray();\n-        Class<?> c = loadClass(\"org.apache.cxf.binding.corba.utils.FixedAnyImpl\", b);\n-        return c;\n-    }\n-\n-    private void addReadOverride(ASMHelper helper, ASMHelper.ClassWriter cw) {\n-        OpcodesProxy opCodes = helper.getOpCodes();\n-        ASMHelper.MethodVisitor mv = cw.visitMethod(opCodes.ACC_PUBLIC, \"read_value\",\n-                \"(Lorg/omg/CORBA/portable/InputStream;Lorg/omg/CORBA/TypeCode;)V\",\n-                null, null);\n-        mv.visitCode();\n-        ASMHelper.Label l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(54, l0);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitFieldInsn(opCodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n-                \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n-        ASMHelper.Label l1 = helper.createLabel();\n-        mv.visitJumpInsn(opCodes.IFNULL, l1);\n-        ASMHelper.Label l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLineNumber(55, l2);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitFieldInsn(opCodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n-                \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitMethodInsn(opCodes.INVOKEINTERFACE, \"org/omg/CORBA/portable/Streamable\",\n-                \"_read\", \"(Lorg/omg/CORBA/portable/InputStream;)V\", true);\n-        ASMHelper.Label l3 = helper.createLabel();\n-        mv.visitJumpInsn(opCodes.GOTO, l3);\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(57, l1);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitVarInsn(opCodes.ALOAD, 2);\n-        mv.visitMethodInsn(opCodes.INVOKESPECIAL, \"com/sun/corba/se/impl/corba/AnyImpl\",\n-                \"read_value\",\n-                \"(Lorg/omg/CORBA/portable/InputStream;Lorg/omg/CORBA/TypeCode;)V\", false);\n-        mv.visitLabel(l3);\n-        mv.visitLineNumber(59, l3);\n-        mv.visitInsn(opCodes.RETURN);\n-        ASMHelper.Label l4 = helper.createLabel();\n-        mv.visitLabel(l4);\n-        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n-                null, l0, l4, 0);\n-        mv.visitLocalVariable(\"is\", \"Lorg/omg/CORBA/portable/InputStream;\", null, l0, l4, 1);\n-        mv.visitLocalVariable(\"t\", \"Lorg/omg/CORBA/TypeCode;\", null, l0, l4, 2);\n-        mv.visitMaxs(3, 3);\n-        mv.visitEnd();\n-    }\n-\n-    private void addWriteOverride(ASMHelper helper, ASMHelper.ClassWriter cw) {\n-        OpcodesProxy opCodes = helper.getOpCodes();\n-        ASMHelper.MethodVisitor mv = cw.visitMethod(opCodes.ACC_PUBLIC, \"write_value\",\n-                \"(Lorg/omg/CORBA/portable/OutputStream;)V\", null, null);\n-        mv.visitCode();\n-        ASMHelper.Label l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(61, l0);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitFieldInsn(opCodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n-                \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n-        ASMHelper.Label l1 = helper.createLabel();\n-        mv.visitJumpInsn(opCodes.IFNULL, l1);\n-        ASMHelper.Label l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLineNumber(62, l2);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitFieldInsn(opCodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n-                \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n-\n-        ASMHelper.Label l3 = helper.createLabel();\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitMethodInsn(opCodes.INVOKEINTERFACE, \"org/omg/CORBA/portable/Streamable\",\n-                \"_write\", \"(Lorg/omg/CORBA/portable/OutputStream;)V\", true);\n-        mv.visitJumpInsn(opCodes.GOTO, l3);\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(64, l1);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitMethodInsn(opCodes.INVOKESPECIAL, \"com/sun/corba/se/impl/corba/AnyImpl\",\n-                \"write_value\", \"(Lorg/omg/CORBA/portable/OutputStream;)V\", false);\n-        mv.visitLabel(l3);\n-        mv.visitLineNumber(66, l3);\n-        mv.visitInsn(opCodes.RETURN);\n-        ASMHelper.Label l4 = helper.createLabel();\n-        mv.visitLabel(l4);\n-        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n-                null, l0, l4, 0);\n-        mv.visitLocalVariable(\"os\", \"Lorg/omg/CORBA/portable/OutputStream;\", null, l0, l4, 1);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n-\n-    }\n-\n-    private void addExtractOverride(ASMHelper helper, ASMHelper.ClassWriter cw) {\n-        OpcodesProxy opCodes = helper.getOpCodes();\n-        ASMHelper.MethodVisitor mv = cw.visitMethod(opCodes.ACC_PUBLIC, \"extract_Streamable\",\n-                \"()Lorg/omg/CORBA/portable/Streamable;\", null, null);\n-        mv.visitCode();\n-        ASMHelper.Label l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(47, l0);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitFieldInsn(opCodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n-                \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n-        ASMHelper.Label l1 = helper.createLabel();\n-        mv.visitJumpInsn(opCodes.IFNULL, l1);\n-        ASMHelper.Label l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLineNumber(48, l2);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitFieldInsn(opCodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n-                \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n-        mv.visitInsn(opCodes.ARETURN);\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(50, l1);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitMethodInsn(opCodes.INVOKESPECIAL, \"com/sun/corba/se/impl/corba/AnyImpl\",\n-                \"extract_Streamable\", \"()Lorg/omg/CORBA/portable/Streamable;\", false);\n-        mv.visitInsn(opCodes.ARETURN);\n-        ASMHelper.Label l3 = helper.createLabel();\n-        mv.visitLabel(l3);\n-        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\", null, l0, l3, 0);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-    }\n-\n-    private void addInsertOverride(ASMHelper helper, ASMHelper.ClassWriter cw) {\n-        OpcodesProxy opCodes = helper.getOpCodes();\n-        ASMHelper.MethodVisitor mv = cw.visitMethod(opCodes.ACC_PUBLIC,\n-                \"insert_Streamable\",\n-                \"(Lorg/omg/CORBA/portable/Streamable;)V\", null, null);\n-        mv.visitCode();\n-        ASMHelper.Label l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(43, l0);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitMethodInsn(opCodes.INVOKESPECIAL,\n-                \"com/sun/corba/se/impl/corba/AnyImpl\",\n-                \"insert_Streamable\",\n-                \"(Lorg/omg/CORBA/portable/Streamable;)V\", false);\n-        ASMHelper.Label l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(44, l1);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitFieldInsn(opCodes.PUTFIELD,\n-                \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\", \"obj\",\n-                \"Lorg/omg/CORBA/portable/Streamable;\");\n-        ASMHelper.Label l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLineNumber(45, l2);\n-        mv.visitInsn(opCodes.RETURN);\n-        ASMHelper.Label l3 = helper.createLabel();\n-        mv.visitLabel(l3);\n-        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n-                null, l0, l3, 0);\n-        mv.visitLocalVariable(\"s\", \"Lorg/omg/CORBA/portable/Streamable;\", null, l0, l3, 1);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n-    }\n-\n-    private void addFixedAnyConstructor(ASMHelper helper, ASMHelper.ClassWriter cw) {\n-        OpcodesProxy opCodes = helper.getOpCodes();\n-        ASMHelper.MethodVisitor mv = cw.visitMethod(opCodes.ACC_PUBLIC, \"<init>\", \"(Lorg/omg/CORBA/ORB;)V\", null, null);\n-        mv.visitCode();\n-        ASMHelper.Label l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(36, l0);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitTypeInsn(opCodes.CHECKCAST, \"com/sun/corba/se/spi/orb/ORB\");\n-        mv.visitMethodInsn(opCodes.INVOKESPECIAL,\n-                \"com/sun/corba/se/impl/corba/AnyImpl\",\n-                \"<init>\", \"(Lcom/sun/corba/se/spi/orb/ORB;)V\", false);\n-        ASMHelper.Label l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(37, l1);\n-        mv.visitInsn(opCodes.RETURN);\n-        ASMHelper.Label l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLocalVariable(\"this\",\n-                \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n-                null, l0, l2, 0);\n-        mv.visitLocalVariable(\"orb\", \"Lorg/omg/CORBA/ORB;\", null, l0, l2, 1);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n-\n-\n-        mv = cw.visitMethod(opCodes.ACC_PUBLIC, \"<init>\",\n-                \"(Lorg/omg/CORBA/ORB;Lorg/omg/CORBA/Any;)V\",\n-                null, null);\n-        mv.visitCode();\n-        l0 = helper.createLabel();\n-        mv.visitLabel(l0);\n-        mv.visitLineNumber(39, l0);\n-        mv.visitVarInsn(opCodes.ALOAD, 0);\n-        mv.visitVarInsn(opCodes.ALOAD, 1);\n-        mv.visitTypeInsn(opCodes.CHECKCAST, \"com/sun/corba/se/spi/orb/ORB\");\n-        mv.visitVarInsn(opCodes.ALOAD, 2);\n-        mv.visitMethodInsn(opCodes.INVOKESPECIAL,\n-                \"com/sun/corba/se/impl/corba/AnyImpl\",\n-                \"<init>\",\n-                \"(Lcom/sun/corba/se/spi/orb/ORB;Lorg/omg/CORBA/Any;)V\", false);\n-        l1 = helper.createLabel();\n-        mv.visitLabel(l1);\n-        mv.visitLineNumber(40, l1);\n-        mv.visitInsn(opCodes.RETURN);\n-        l2 = helper.createLabel();\n-        mv.visitLabel(l2);\n-        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n-                null, l0, l2, 0);\n-        mv.visitLocalVariable(\"orb\", \"Lorg/omg/CORBA/ORB;\", null, l0, l2, 1);\n-        mv.visitLocalVariable(\"any\", \"Lorg/omg/CORBA/Any;\", null, l0, l2, 2);\n-        mv.visitMaxs(3, 3);\n-        mv.visitEnd();\n-\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MDQzNA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524850434", "bodyText": "Is the comment still relevant? It seems like you the correct classloader", "author": "reta", "createdAt": "2020-11-17T02:48:57Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxb;\n+\n+import org.apache.cxf.Bus;\n+\n+public class FactoryClassProxyService implements FactoryClassCreator {\n+    FactoryClassCreator srv;\n+    public FactoryClassProxyService(Bus bus) {\n+        this(new FactoryClassGenerator(bus));\n+    }\n+    public FactoryClassProxyService(FactoryClassCreator srv) {\n+        super();\n+        this.srv = srv;\n+    }\n+\n+    @Override\n+    public Class<?> createFactory(Class<?> cls) {\n+        return srv.createFactory(cls);\n+    }\n+\n+    public class LoadFirst extends FactoryClassProxyService {\n+        public LoadFirst(ClassLoader cl) {\n+            //TODO not sure here if I get class loader like that ???", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA0NTkzMQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525045931", "bodyText": "loadFirst will be initialize by outside code I guess but if we change it in bus-extensions.txt it will failed because bus extensions expect a Bus as first argument. So I guess, I have to put bus for every loadFirst ctor. On master, we have the system with Map of class and classloader and I think it was done on purpose to avoid the following cases:\n2 requests arrive => 2 threads are created (right ?) => each one want to get a class generated => get a classloader which are common on all thread (need synchronized) => ry to find class => if not found generate class and load them in classLoader. I think that s why class loader was on a static map to handle multi thread. wdyt ?", "author": "dufoli", "createdAt": "2020-11-17T10:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MDQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEwODA5Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r525108093", "bodyText": "I don't think so, the static variables were a lazy+leaky impl IMHO.\nGenerating twice the class is not an issue while the classloader ensures it does findClass before any registration in a correctly locked context.\nWorse case you lost some CPU cycles but didn't block a thread.", "author": "rmannibucau", "createdAt": "2020-11-17T12:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MDQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java\ndeleted file mode 100644\nindex ae907389af..0000000000\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java\n+++ /dev/null\n\n@@ -1,50 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxb;\n-\n-import org.apache.cxf.Bus;\n-\n-public class FactoryClassProxyService implements FactoryClassCreator {\n-    FactoryClassCreator srv;\n-    public FactoryClassProxyService(Bus bus) {\n-        this(new FactoryClassGenerator(bus));\n-    }\n-    public FactoryClassProxyService(FactoryClassCreator srv) {\n-        super();\n-        this.srv = srv;\n-    }\n-\n-    @Override\n-    public Class<?> createFactory(Class<?> cls) {\n-        return srv.createFactory(cls);\n-    }\n-\n-    public class LoadFirst extends FactoryClassProxyService {\n-        public LoadFirst(ClassLoader cl) {\n-            //TODO not sure here if I get class loader like that ???\n-            // or I need to inject another class loader from outside\n-            super(new FactoryClassLoader(cl));\n-        }\n-    }\n-    public class GenerateJustInTime extends FactoryClassProxyService {\n-        public GenerateJustInTime(Bus bus) {\n-            super(new FactoryClassGenerator(bus));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MTI5MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r524851291", "bodyText": "Is it still relevant comment?", "author": "reta", "createdAt": "2020-11-17T02:51:47Z", "path": "rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxws.spi;\n+\n+import java.util.Set;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.jaxws.WrapperClassGenerator;\n+import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n+import org.apache.cxf.service.model.InterfaceInfo;\n+\n+public class WrapperClassCreatorProxyService implements WrapperClassCreator {\n+    WrapperClassCreator srv;\n+    public WrapperClassCreatorProxyService(final Bus bus) {\n+        this(new WrapperClassGenerator(bus));\n+    }\n+    public WrapperClassCreatorProxyService(WrapperClassCreator srv) {\n+        super();\n+        this.srv = srv;\n+    }\n+\n+    @Override\n+    public Set<Class<?>> generate(Bus bus, JaxWsServiceFactoryBean fact, InterfaceInfo inf, boolean q) {\n+        return srv.generate(bus, fact, inf, q);\n+    }\n+\n+    public class LoadFirst extends WrapperClassCreatorProxyService {\n+        public LoadFirst(ClassLoader cl) {\n+            //TODO not sure here if I get class loader like that ???", "originalCommit": "87acf2b00e538178b9f6fe6fa598645cd56b007a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java\ndeleted file mode 100644\nindex 6f3d1743f2..0000000000\n--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java\n+++ /dev/null\n\n@@ -1,55 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxws.spi;\n-\n-import java.util.Set;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.jaxws.WrapperClassGenerator;\n-import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n-import org.apache.cxf.service.model.InterfaceInfo;\n-\n-public class WrapperClassCreatorProxyService implements WrapperClassCreator {\n-    WrapperClassCreator srv;\n-    public WrapperClassCreatorProxyService(final Bus bus) {\n-        this(new WrapperClassGenerator(bus));\n-    }\n-    public WrapperClassCreatorProxyService(WrapperClassCreator srv) {\n-        super();\n-        this.srv = srv;\n-    }\n-\n-    @Override\n-    public Set<Class<?>> generate(Bus bus, JaxWsServiceFactoryBean fact, InterfaceInfo inf, boolean q) {\n-        return srv.generate(bus, fact, inf, q);\n-    }\n-\n-    public class LoadFirst extends WrapperClassCreatorProxyService {\n-        public LoadFirst(ClassLoader cl) {\n-            //TODO not sure here if I get class loader like that ???\n-            // or I need to inject another class loader from outside\n-            super(new GeneratedWrapperClassLoader(cl));\n-        }\n-    }\n-    public class GenerateJustInTime extends WrapperClassCreatorProxyService {\n-        public GenerateJustInTime(final Bus bus) {\n-            super(new WrapperClassGenerator(bus));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNjE4OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526506189", "bodyText": "\ud83d\udc4d thank you", "author": "reta", "createdAt": "2020-11-19T00:10:12Z", "path": "core/src/main/java/org/apache/cxf/common/util/StringUtils.java", "diffHunk": "@@ -160,4 +160,18 @@ static void byteToHex(byte b, StringBuilder sb) {\n         sb.append(HEX[(0xF0 & b) >> 4]);\n         sb.append(HEX[0x0F & b]);\n     }\n+\n+    public static String periodToSlashes(String s) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/util/StringUtils.java b/core/src/main/java/org/apache/cxf/common/util/StringUtils.java\nindex 9f7c012f69..2da80a981e 100644\n--- a/core/src/main/java/org/apache/cxf/common/util/StringUtils.java\n+++ b/core/src/main/java/org/apache/cxf/common/util/StringUtils.java\n\n@@ -160,18 +160,4 @@ public final class StringUtils {\n         sb.append(HEX[(0xF0 & b) >> 4]);\n         sb.append(HEX[0x0F & b]);\n     }\n-\n-    public static String periodToSlashes(String s) {\n-        char[] ch = s.toCharArray();\n-        for (int x = 0; x < ch.length; x++) {\n-            if (ch[x] == '.') {\n-                ch[x] = '/';\n-            }\n-        }\n-        return new String(ch);\n-    }\n-    public static String slashesToPeriod(String s) {\n-        return s.replace('/', '.');\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwODUwOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526508509", "bodyText": "Don't like that, but we probably need synchronized block here, the original static method createFixedAnyConstructor was declared static synchronized probably to protected against concurrent generation.", "author": "reta", "createdAt": "2020-11-19T00:17:11Z", "path": "rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java", "diffHunk": "@@ -273,257 +267,19 @@ public static void extractPrimitiveFromAny(Any a, CorbaPrimitiveHandler primitiv\n     }\n \n     private static Any createFixedAny(ORB orb, Any any) {\n-        createFixedAnyConstructor();\n+        if (fixedAnyConstructor == null) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java b/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java\nindex 9d43995d61..fe50c1b685 100644\n--- a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java\n+++ b/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java\n\n@@ -267,19 +273,257 @@ public final class CorbaAnyHelper {\n     }\n \n     private static Any createFixedAny(ORB orb, Any any) {\n-        if (fixedAnyConstructor == null) {\n-            CorbaFixedAnyImplGenerator corbaFixedAnyImplGenerator = new CorbaFixedAnyImplGenerator(null);\n-            Class<?> c = corbaFixedAnyImplGenerator.createFixedAnyClass();\n-            try {\n-                fixedAnyConstructor = c.getConstructor(ORB.class, Any.class);\n-            } catch (Exception e) {\n-                //shouldn't happen since we generated that constructor\n-            }\n-        }\n+        createFixedAnyConstructor();\n         try {\n             return (Any)fixedAnyConstructor.newInstance(orb, any);\n         } catch (Exception e) {\n             return any;\n         }\n     }\n+    private static synchronized void createFixedAnyConstructor() {\n+        if (fixedAnyConstructor != null) {\n+            return;\n+        }\n+\n+        ASMHelper helper = new ASMHelper();\n+        ClassWriter cw = helper.createClassWriter();\n+        FieldVisitor fv;\n+\n+        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER,\n+                 \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n+                 null, \"com/sun/corba/se/impl/corba/AnyImpl\", null);\n+\n+        cw.visitSource(\"FixedAnyImpl.java\", null);\n+\n+        fv = cw.visitField(0, \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\", null, null);\n+        fv.visitEnd();\n+        addFixedAnyConstructor(helper, cw);\n+        addInsertOverride(helper, cw);\n+        addExtractOverride(helper, cw);\n+        addWriteOverride(helper, cw);\n+        addReadOverride(helper, cw);\n+\n+        cw.visitEnd();\n+\n+        byte[] b = cw.toByteArray();\n+        Class<?> c = helper.loadClass(\"org.apache.cxf.binding.corba.utils.FixedAnyImpl\",\n+                                      CorbaAnyHelper.class, b);\n+        try {\n+            fixedAnyConstructor = c.getConstructor(ORB.class, Any.class);\n+        } catch (Exception e) {\n+            //shouldn't happen since we generated that constructor\n+        }\n+    }\n+\n+    private static void addReadOverride(ASMHelper helper, ClassWriter cw) {\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"read_value\",\n+                            \"(Lorg/omg/CORBA/portable/InputStream;Lorg/omg/CORBA/TypeCode;)V\",\n+                            null, null);\n+        mv.visitCode();\n+        Label l0 = helper.createLabel();\n+        mv.visitLabel(l0);\n+        mv.visitLineNumber(54, l0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n+                          \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n+        Label l1 = helper.createLabel();\n+        mv.visitJumpInsn(Opcodes.IFNULL, l1);\n+        Label l2 = helper.createLabel();\n+        mv.visitLabel(l2);\n+        mv.visitLineNumber(55, l2);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n+                          \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"org/omg/CORBA/portable/Streamable\",\n+                           \"_read\", \"(Lorg/omg/CORBA/portable/InputStream;)V\", true);\n+        Label l3 = helper.createLabel();\n+        mv.visitJumpInsn(Opcodes.GOTO, l3);\n+        mv.visitLabel(l1);\n+        mv.visitLineNumber(57, l1);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitVarInsn(Opcodes.ALOAD, 2);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"com/sun/corba/se/impl/corba/AnyImpl\",\n+                           \"read_value\",\n+                           \"(Lorg/omg/CORBA/portable/InputStream;Lorg/omg/CORBA/TypeCode;)V\", false);\n+        mv.visitLabel(l3);\n+        mv.visitLineNumber(59, l3);\n+        mv.visitInsn(Opcodes.RETURN);\n+        Label l4 = helper.createLabel();\n+        mv.visitLabel(l4);\n+        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n+                              null, l0, l4, 0);\n+        mv.visitLocalVariable(\"is\", \"Lorg/omg/CORBA/portable/InputStream;\", null, l0, l4, 1);\n+        mv.visitLocalVariable(\"t\", \"Lorg/omg/CORBA/TypeCode;\", null, l0, l4, 2);\n+        mv.visitMaxs(3, 3);\n+        mv.visitEnd();\n+    }\n+\n+    private static void addWriteOverride(ASMHelper helper, ClassWriter cw) {\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"write_value\",\n+                            \"(Lorg/omg/CORBA/portable/OutputStream;)V\", null, null);\n+        mv.visitCode();\n+        Label l0 = helper.createLabel();\n+        mv.visitLabel(l0);\n+        mv.visitLineNumber(61, l0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n+                          \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n+        Label l1 = helper.createLabel();\n+        mv.visitJumpInsn(Opcodes.IFNULL, l1);\n+        Label l2 = helper.createLabel();\n+        mv.visitLabel(l2);\n+        mv.visitLineNumber(62, l2);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n+                          \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n+\n+        Label l3 = helper.createLabel();\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"org/omg/CORBA/portable/Streamable\",\n+                           \"_write\", \"(Lorg/omg/CORBA/portable/OutputStream;)V\", true);\n+        mv.visitJumpInsn(Opcodes.GOTO, l3);\n+        mv.visitLabel(l1);\n+        mv.visitLineNumber(64, l1);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"com/sun/corba/se/impl/corba/AnyImpl\",\n+                           \"write_value\", \"(Lorg/omg/CORBA/portable/OutputStream;)V\", false);\n+        mv.visitLabel(l3);\n+        mv.visitLineNumber(66, l3);\n+        mv.visitInsn(Opcodes.RETURN);\n+        Label l4 = helper.createLabel();\n+        mv.visitLabel(l4);\n+        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n+                              null, l0, l4, 0);\n+        mv.visitLocalVariable(\"os\", \"Lorg/omg/CORBA/portable/OutputStream;\", null, l0, l4, 1);\n+        mv.visitMaxs(2, 2);\n+        mv.visitEnd();\n+\n+    }\n+\n+    private static void addExtractOverride(ASMHelper helper, ClassWriter cw) {\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"extract_Streamable\",\n+                            \"()Lorg/omg/CORBA/portable/Streamable;\", null, null);\n+        mv.visitCode();\n+        Label l0 = helper.createLabel();\n+        mv.visitLabel(l0);\n+        mv.visitLineNumber(47, l0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n+                          \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n+        Label l1 = helper.createLabel();\n+        mv.visitJumpInsn(Opcodes.IFNULL, l1);\n+        Label l2 = helper.createLabel();\n+        mv.visitLabel(l2);\n+        mv.visitLineNumber(48, l2);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\",\n+                          \"obj\", \"Lorg/omg/CORBA/portable/Streamable;\");\n+        mv.visitInsn(Opcodes.ARETURN);\n+        mv.visitLabel(l1);\n+        mv.visitLineNumber(50, l1);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"com/sun/corba/se/impl/corba/AnyImpl\",\n+                           \"extract_Streamable\", \"()Lorg/omg/CORBA/portable/Streamable;\", false);\n+        mv.visitInsn(Opcodes.ARETURN);\n+        Label l3 = helper.createLabel();\n+        mv.visitLabel(l3);\n+        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\", null, l0, l3, 0);\n+        mv.visitMaxs(1, 1);\n+        mv.visitEnd();\n+\n+    }\n+\n+    private static void addInsertOverride(ASMHelper helper, ClassWriter cw) {\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC,\n+                            \"insert_Streamable\",\n+                            \"(Lorg/omg/CORBA/portable/Streamable;)V\", null, null);\n+        mv.visitCode();\n+        Label l0 = helper.createLabel();\n+        mv.visitLabel(l0);\n+        mv.visitLineNumber(43, l0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,\n+                           \"com/sun/corba/se/impl/corba/AnyImpl\",\n+                           \"insert_Streamable\",\n+                           \"(Lorg/omg/CORBA/portable/Streamable;)V\", false);\n+        Label l1 = helper.createLabel();\n+        mv.visitLabel(l1);\n+        mv.visitLineNumber(44, l1);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitFieldInsn(Opcodes.PUTFIELD,\n+                          \"org/apache/cxf/binding/corba/utils/FixedAnyImpl\", \"obj\",\n+                          \"Lorg/omg/CORBA/portable/Streamable;\");\n+        Label l2 = helper.createLabel();\n+        mv.visitLabel(l2);\n+        mv.visitLineNumber(45, l2);\n+        mv.visitInsn(Opcodes.RETURN);\n+        Label l3 = helper.createLabel();\n+        mv.visitLabel(l3);\n+        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n+                              null, l0, l3, 0);\n+        mv.visitLocalVariable(\"s\", \"Lorg/omg/CORBA/portable/Streamable;\", null, l0, l3, 1);\n+        mv.visitMaxs(2, 2);\n+        mv.visitEnd();\n+    }\n+\n+    private static void addFixedAnyConstructor(ASMHelper helper, ClassWriter cw) {\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"(Lorg/omg/CORBA/ORB;)V\", null, null);\n+        mv.visitCode();\n+        Label l0 = helper.createLabel();\n+        mv.visitLabel(l0);\n+        mv.visitLineNumber(36, l0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitTypeInsn(Opcodes.CHECKCAST, \"com/sun/corba/se/spi/orb/ORB\");\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,\n+                           \"com/sun/corba/se/impl/corba/AnyImpl\",\n+                           \"<init>\", \"(Lcom/sun/corba/se/spi/orb/ORB;)V\", false);\n+        Label l1 = helper.createLabel();\n+        mv.visitLabel(l1);\n+        mv.visitLineNumber(37, l1);\n+        mv.visitInsn(Opcodes.RETURN);\n+        Label l2 = helper.createLabel();\n+        mv.visitLabel(l2);\n+        mv.visitLocalVariable(\"this\",\n+                              \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n+                              null, l0, l2, 0);\n+        mv.visitLocalVariable(\"orb\", \"Lorg/omg/CORBA/ORB;\", null, l0, l2, 1);\n+        mv.visitMaxs(2, 2);\n+        mv.visitEnd();\n+\n+\n+        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\",\n+                            \"(Lorg/omg/CORBA/ORB;Lorg/omg/CORBA/Any;)V\",\n+                            null, null);\n+        mv.visitCode();\n+        l0 = helper.createLabel();\n+        mv.visitLabel(l0);\n+        mv.visitLineNumber(39, l0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitVarInsn(Opcodes.ALOAD, 1);\n+        mv.visitTypeInsn(Opcodes.CHECKCAST, \"com/sun/corba/se/spi/orb/ORB\");\n+        mv.visitVarInsn(Opcodes.ALOAD, 2);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,\n+                           \"com/sun/corba/se/impl/corba/AnyImpl\",\n+                           \"<init>\",\n+                           \"(Lcom/sun/corba/se/spi/orb/ORB;Lorg/omg/CORBA/Any;)V\", false);\n+        l1 = helper.createLabel();\n+        mv.visitLabel(l1);\n+        mv.visitLineNumber(40, l1);\n+        mv.visitInsn(Opcodes.RETURN);\n+        l2 = helper.createLabel();\n+        mv.visitLabel(l2);\n+        mv.visitLocalVariable(\"this\", \"Lorg/apache/cxf/binding/corba/utils/FixedAnyImpl;\",\n+                              null, l0, l2, 0);\n+        mv.visitLocalVariable(\"orb\", \"Lorg/omg/CORBA/ORB;\", null, l0, l2, 1);\n+        mv.visitLocalVariable(\"any\", \"Lorg/omg/CORBA/Any;\", null, l0, l2, 2);\n+        mv.visitMaxs(3, 3);\n+        mv.visitEnd();\n+\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxMjY5OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526512698", "bodyText": "It should not be instance field anymore, could be instantiated in generate and filled along the way (probably needed to pass through as an argument to a few methods)", "author": "reta", "createdAt": "2020-11-19T00:29:40Z", "path": "rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java", "diffHunk": "@@ -56,19 +59,18 @@\n import org.apache.cxf.service.model.SchemaInfo;\n import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n \n-public final class WrapperClassGenerator extends ASMHelper {\n+public final class WrapperClassGenerator extends ClassGeneratorClassLoader implements WrapperClassCreator {\n     public static final String DEFAULT_PACKAGE_NAME = \"defaultnamespace\";\n \n     private static final Logger LOG = LogUtils.getL7dLogger(WrapperClassGenerator.class);\n-    private Set<Class<?>> wrapperBeans = new LinkedHashSet<>();\n-    private InterfaceInfo interfaceInfo;\n+    private Set<Class<?>> wrapperBeans;", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY0MzQ5Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526643496", "bodyText": "I was thinking the same when I move the code.", "author": "dufoli", "createdAt": "2020-11-19T07:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxMjY5OA=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java\nindex adc7317809..bcd851eb04 100644\n--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java\n+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java\n\n@@ -59,18 +56,19 @@ import org.apache.cxf.service.model.OperationInfo;\n import org.apache.cxf.service.model.SchemaInfo;\n import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n \n-public final class WrapperClassGenerator extends ClassGeneratorClassLoader implements WrapperClassCreator {\n+public final class WrapperClassGenerator extends ASMHelper {\n     public static final String DEFAULT_PACKAGE_NAME = \"defaultnamespace\";\n \n     private static final Logger LOG = LogUtils.getL7dLogger(WrapperClassGenerator.class);\n-    private Set<Class<?>> wrapperBeans;\n+    private Set<Class<?>> wrapperBeans = new LinkedHashSet<>();\n+    private InterfaceInfo interfaceInfo;\n     private boolean qualified;\n     private JaxWsServiceFactoryBean factory;\n-    private InterfaceInfo interfaceInfo;\n-    private ASMHelper helper;\n \n-    public WrapperClassGenerator(final Bus bus) {\n-        super(bus);\n+    public WrapperClassGenerator(JaxWsServiceFactoryBean fact, InterfaceInfo inf, boolean q) {\n+        factory = fact;\n+        interfaceInfo = inf;\n+        qualified = q;\n     }\n \n     private String getPackageName(Method method) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNDMxMQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526514311", "bodyText": "Similarly to WrapperClassGenerator, we could probably don't need instance field but create the collection in place, wdyt?", "author": "reta", "createdAt": "2020-11-19T00:34:36Z", "path": "rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxws.spi;\n+\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+import org.apache.cxf.common.util.PackageUtils;\n+import org.apache.cxf.common.util.StringUtils;\n+import org.apache.cxf.jaxws.WrapperClassGenerator;\n+import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n+import org.apache.cxf.service.model.InterfaceInfo;\n+import org.apache.cxf.service.model.MessageInfo;\n+import org.apache.cxf.service.model.MessagePartInfo;\n+import org.apache.cxf.service.model.OperationInfo;\n+import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n+\n+public class GeneratedWrapperClassLoader implements WrapperClassCreator {\n+    private Set<Class<?>> wrapperBeans = new LinkedHashSet<>();", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY0MzY2OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526643668", "bodyText": "ok for me", "author": "dufoli", "createdAt": "2020-11-19T07:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNDMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTExNA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r527131114", "bodyText": "\ud83d\udc4d", "author": "reta", "createdAt": "2020-11-19T19:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNDMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java\ndeleted file mode 100644\nindex 5b7f507452..0000000000\n--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxws.spi;\n-\n-import java.lang.reflect.Method;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-import org.apache.cxf.common.util.PackageUtils;\n-import org.apache.cxf.common.util.StringUtils;\n-import org.apache.cxf.jaxws.WrapperClassGenerator;\n-import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n-import org.apache.cxf.service.model.InterfaceInfo;\n-import org.apache.cxf.service.model.MessageInfo;\n-import org.apache.cxf.service.model.MessagePartInfo;\n-import org.apache.cxf.service.model.OperationInfo;\n-import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n-\n-public class GeneratedWrapperClassLoader implements WrapperClassCreator {\n-    private Set<Class<?>> wrapperBeans = new LinkedHashSet<>();\n-    private InterfaceInfo interfaceInfo;\n-    private JaxWsServiceFactoryBean factory;\n-\n-    public GeneratedWrapperClassLoader() {\n-    }\n-\n-    @Override\n-    public Set<Class<?>> generate(Bus bus, JaxWsServiceFactoryBean fact, InterfaceInfo ii, boolean q) {\n-        factory = fact;\n-        this.interfaceInfo = ii;\n-        for (OperationInfo opInfo : interfaceInfo.getOperations()) {\n-            if (opInfo.isUnwrappedCapable()) {\n-                Method method = (Method)opInfo.getProperty(ReflectionServiceFactoryBean.METHOD);\n-                if (method == null) {\n-                    continue;\n-                }\n-                MessagePartInfo inf = opInfo.getInput().getFirstMessagePart();\n-                if (inf.getTypeClass() == null) {\n-                    MessageInfo messageInfo = opInfo.getUnwrappedOperation().getInput();\n-                    createWrapperClass(inf,\n-                            messageInfo,\n-                            opInfo,\n-                            method,\n-                            true);\n-                }\n-                MessageInfo messageInfo = opInfo.getUnwrappedOperation().getOutput();\n-                if (messageInfo != null) {\n-                    inf = opInfo.getOutput().getFirstMessagePart();\n-                    if (inf.getTypeClass() == null) {\n-                        createWrapperClass(inf,\n-                                messageInfo,\n-                                opInfo,\n-                                method,\n-                                false);\n-                    }\n-                }\n-            }\n-        }\n-        return wrapperBeans;\n-    }\n-\n-    private void createWrapperClass(MessagePartInfo wrapperPart,\n-                                    MessageInfo messageInfo,\n-                                    OperationInfo op,\n-                                    Method method,\n-                                    boolean isRequest) {\n-        boolean anonymous = factory.getAnonymousWrapperTypes();\n-\n-        String pkg = getPackageName(method) + \".jaxws_asm\" + (anonymous ? \"_an\" : \"\");\n-        String className = pkg + \".\"\n-                + StringUtils.capitalize(op.getName().getLocalPart());\n-        if (!isRequest) {\n-            className = className + \"Response\";\n-        }\n-\n-        Class<?> clz = null;\n-        try {\n-            clz = ClassLoaderUtils.loadClass(className, GeneratedWrapperClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        wrapperPart.setTypeClass(clz);\n-        wrapperBeans.add(clz);\n-    }\n-    private String getPackageName(Method method) {\n-        String pkg = PackageUtils.getPackageName(method.getDeclaringClass());\n-        return pkg.length() == 0 ? WrapperClassGenerator.DEFAULT_PACKAGE_NAME : pkg;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNTgyOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526515828", "bodyText": "Probably we should log the exception here (debug or trace), just to help with troubleshooting", "author": "reta", "createdAt": "2020-11-19T00:39:09Z", "path": "rt/wsdl/src/main/java/org/apache/cxf/wsdl/ExtensionClassLoader.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.wsdl;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+\n+public class ExtensionClassLoader implements ExtensionClassCreator {\n+\n+    public ExtensionClassLoader() {\n+    }\n+    @Override\n+    public Class<?> createExtensionClass(Class<?> cls, QName qname, ClassLoader loader) {\n+        try {\n+            return ClassLoaderUtils.loadClass(cls.getName() + \"Extensibility\", ExtensionClassLoader.class);\n+        } catch (ClassNotFoundException e) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/wsdl/src/main/java/org/apache/cxf/wsdl/ExtensionClassLoader.java b/rt/wsdl/src/main/java/org/apache/cxf/wsdl/ExtensionClassLoader.java\ndeleted file mode 100644\nindex 766736859f..0000000000\n--- a/rt/wsdl/src/main/java/org/apache/cxf/wsdl/ExtensionClassLoader.java\n+++ /dev/null\n\n@@ -1,38 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.wsdl;\n-\n-import javax.xml.namespace.QName;\n-\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-\n-public class ExtensionClassLoader implements ExtensionClassCreator {\n-\n-    public ExtensionClassLoader() {\n-    }\n-    @Override\n-    public Class<?> createExtensionClass(Class<?> cls, QName qname, ClassLoader loader) {\n-        try {\n-            return ClassLoaderUtils.loadClass(cls.getName() + \"Extensibility\", ExtensionClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNTg2OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526515869", "bodyText": "Probably we should log the exception here (debug or trace), just to help with troubleshooting", "author": "reta", "createdAt": "2020-11-19T00:39:19Z", "path": "core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+\n+public class GeneratedNamespaceClassLoader implements NamespaceClassCreator {\n+    GeneratedNamespaceClassLoader() {\n+    }\n+    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n+        String postFix = \"\";\n+\n+        if (mcls.getName().contains(\"eclipse\")) {\n+            try {\n+                return ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.EclipseNamespaceMapper\",\n+                        GeneratedNamespaceClassLoader.class);\n+            } catch (ClassNotFoundException e) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java\ndeleted file mode 100644\nindex 29d48ece8c..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java\n+++ /dev/null\n\n@@ -1,50 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.util.Map;\n-\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-\n-public class GeneratedNamespaceClassLoader implements NamespaceClassCreator {\n-    GeneratedNamespaceClassLoader() {\n-    }\n-    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n-        String postFix = \"\";\n-\n-        if (mcls.getName().contains(\"eclipse\")) {\n-            try {\n-                return ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.EclipseNamespaceMapper\",\n-                        GeneratedNamespaceClassLoader.class);\n-            } catch (ClassNotFoundException e) {\n-            }\n-        } else if (mcls.getName().contains(\".internal\")) {\n-            postFix = \"Internal\";\n-        } else if (mcls.getName().contains(\"com.sun\")) {\n-            postFix = \"RI\";\n-        }\n-        try {\n-            return ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.NamespaceMapper\" + postFix,\n-                    GeneratedNamespaceClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNTg5OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526515899", "bodyText": "Probably we should log the exception here (debug or trace), just to help with troubleshooting", "author": "reta", "createdAt": "2020-11-19T00:39:24Z", "path": "core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+\n+public class GeneratedNamespaceClassLoader implements NamespaceClassCreator {\n+    GeneratedNamespaceClassLoader() {\n+    }\n+    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n+        String postFix = \"\";\n+\n+        if (mcls.getName().contains(\"eclipse\")) {\n+            try {\n+                return ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.EclipseNamespaceMapper\",\n+                        GeneratedNamespaceClassLoader.class);\n+            } catch (ClassNotFoundException e) {\n+            }\n+        } else if (mcls.getName().contains(\".internal\")) {\n+            postFix = \"Internal\";\n+        } else if (mcls.getName().contains(\"com.sun\")) {\n+            postFix = \"RI\";\n+        }\n+        try {\n+            return ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.NamespaceMapper\" + postFix,\n+                    GeneratedNamespaceClassLoader.class);\n+        } catch (ClassNotFoundException e) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java\ndeleted file mode 100644\nindex 29d48ece8c..0000000000\n--- a/core/src/main/java/org/apache/cxf/common/spi/GeneratedNamespaceClassLoader.java\n+++ /dev/null\n\n@@ -1,50 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.common.spi;\n-\n-import java.util.Map;\n-\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-\n-public class GeneratedNamespaceClassLoader implements NamespaceClassCreator {\n-    GeneratedNamespaceClassLoader() {\n-    }\n-    public synchronized Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map) {\n-        String postFix = \"\";\n-\n-        if (mcls.getName().contains(\"eclipse\")) {\n-            try {\n-                return ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.EclipseNamespaceMapper\",\n-                        GeneratedNamespaceClassLoader.class);\n-            } catch (ClassNotFoundException e) {\n-            }\n-        } else if (mcls.getName().contains(\".internal\")) {\n-            postFix = \"Internal\";\n-        } else if (mcls.getName().contains(\"com.sun\")) {\n-            postFix = \"RI\";\n-        }\n-        try {\n-            return ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.NamespaceMapper\" + postFix,\n-                    GeneratedNamespaceClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNTk3MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526515970", "bodyText": "Probably we should log the exception here (debug or trace), just to help with troubleshooting", "author": "reta", "createdAt": "2020-11-19T00:39:34Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassLoader.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.jaxb;\n+\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+\n+public class FactoryClassLoader implements FactoryClassCreator {\n+    public FactoryClassLoader() {\n+    }\n+    @Override\n+    public Class<?> createFactory(Class<?> cls) {\n+        String newClassName = cls.getName() + \"Factory\";\n+        try {\n+            return ClassLoaderUtils.loadClass(newClassName, FactoryClassLoader.class);\n+        } catch (ClassNotFoundException e) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassLoader.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassLoader.java\ndeleted file mode 100644\nindex 8aea2e2c02..0000000000\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassLoader.java\n+++ /dev/null\n\n@@ -1,36 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.jaxb;\n-\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-\n-public class FactoryClassLoader implements FactoryClassCreator {\n-    public FactoryClassLoader() {\n-    }\n-    @Override\n-    public Class<?> createFactory(Class<?> cls) {\n-        String newClassName = cls.getName() + \"Factory\";\n-        try {\n-            return ClassLoaderUtils.loadClass(newClassName, FactoryClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNjQ3NQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526516475", "bodyText": "Please log the exception here (debug or trace), just to help with troubleshooting (no e.printStackTrace(); please)", "author": "reta", "createdAt": "2020-11-19T00:41:03Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxb;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+import org.apache.cxf.databinding.WrapperHelper;\n+\n+public class WrapperHelperClassLoader implements WrapperHelperCreator {\n+    public WrapperHelperClassLoader() {\n+    }\n+\n+    @Override\n+    public WrapperHelper compile(Bus bus, Class<?> wrapperType, Method[] setMethods, Method[] getMethods,\n+                                 Method[] jaxbMethods, Field[] fields, Object objectFactory) {\n+\n+        int count = 1;\n+        String newClassName = wrapperType.getName() + \"_WrapperTypeHelper\" + count;\n+\n+        Class<?> cls = null;\n+        try {\n+            cls = ClassLoaderUtils.loadClass(newClassName, WrapperHelperClassLoader.class);\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java\ndeleted file mode 100644\nindex bcb9ccc4cb..0000000000\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxb;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-import org.apache.cxf.databinding.WrapperHelper;\n-\n-public class WrapperHelperClassLoader implements WrapperHelperCreator {\n-    public WrapperHelperClassLoader() {\n-    }\n-\n-    @Override\n-    public WrapperHelper compile(Bus bus, Class<?> wrapperType, Method[] setMethods, Method[] getMethods,\n-                                 Method[] jaxbMethods, Field[] fields, Object objectFactory) {\n-\n-        int count = 1;\n-        String newClassName = wrapperType.getName() + \"_WrapperTypeHelper\" + count;\n-\n-        Class<?> cls = null;\n-        try {\n-            cls = ClassLoaderUtils.loadClass(newClassName, WrapperHelperClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        while (cls != null) {\n-            try {\n-                WrapperHelper helper = WrapperHelper.class.cast(cls.newInstance());\n-                if (!helper.getSignature().equals(WrapperHelperCompiler.computeSignature(setMethods, getMethods))) {\n-                    count++;\n-                    newClassName = wrapperType.getName() + \"_WrapperTypeHelper\" + count;\n-                    cls = ClassLoaderUtils.loadClass(newClassName, WrapperHelperClassLoader.class);\n-                } else {\n-                    return helper;\n-                }\n-            } catch (Exception e) {\n-                return null;\n-            }\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNjY3OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526516678", "bodyText": "Probably we should log the exception here (debug or trace), just to help with troubleshooting", "author": "reta", "createdAt": "2020-11-19T00:41:40Z", "path": "rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxws.spi;\n+\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+import org.apache.cxf.common.util.PackageUtils;\n+import org.apache.cxf.common.util.StringUtils;\n+import org.apache.cxf.jaxws.WrapperClassGenerator;\n+import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n+import org.apache.cxf.service.model.InterfaceInfo;\n+import org.apache.cxf.service.model.MessageInfo;\n+import org.apache.cxf.service.model.MessagePartInfo;\n+import org.apache.cxf.service.model.OperationInfo;\n+import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n+\n+public class GeneratedWrapperClassLoader implements WrapperClassCreator {\n+    private Set<Class<?>> wrapperBeans = new LinkedHashSet<>();\n+    private InterfaceInfo interfaceInfo;\n+    private JaxWsServiceFactoryBean factory;\n+\n+    public GeneratedWrapperClassLoader() {\n+    }\n+\n+    @Override\n+    public Set<Class<?>> generate(Bus bus, JaxWsServiceFactoryBean fact, InterfaceInfo ii, boolean q) {\n+        factory = fact;\n+        this.interfaceInfo = ii;\n+        for (OperationInfo opInfo : interfaceInfo.getOperations()) {\n+            if (opInfo.isUnwrappedCapable()) {\n+                Method method = (Method)opInfo.getProperty(ReflectionServiceFactoryBean.METHOD);\n+                if (method == null) {\n+                    continue;\n+                }\n+                MessagePartInfo inf = opInfo.getInput().getFirstMessagePart();\n+                if (inf.getTypeClass() == null) {\n+                    MessageInfo messageInfo = opInfo.getUnwrappedOperation().getInput();\n+                    createWrapperClass(inf,\n+                            messageInfo,\n+                            opInfo,\n+                            method,\n+                            true);\n+                }\n+                MessageInfo messageInfo = opInfo.getUnwrappedOperation().getOutput();\n+                if (messageInfo != null) {\n+                    inf = opInfo.getOutput().getFirstMessagePart();\n+                    if (inf.getTypeClass() == null) {\n+                        createWrapperClass(inf,\n+                                messageInfo,\n+                                opInfo,\n+                                method,\n+                                false);\n+                    }\n+                }\n+            }\n+        }\n+        return wrapperBeans;\n+    }\n+\n+    private void createWrapperClass(MessagePartInfo wrapperPart,\n+                                    MessageInfo messageInfo,\n+                                    OperationInfo op,\n+                                    Method method,\n+                                    boolean isRequest) {\n+        boolean anonymous = factory.getAnonymousWrapperTypes();\n+\n+        String pkg = getPackageName(method) + \".jaxws_asm\" + (anonymous ? \"_an\" : \"\");\n+        String className = pkg + \".\"\n+                + StringUtils.capitalize(op.getName().getLocalPart());\n+        if (!isRequest) {\n+            className = className + \"Response\";\n+        }\n+\n+        Class<?> clz = null;\n+        try {\n+            clz = ClassLoaderUtils.loadClass(className, GeneratedWrapperClassLoader.class);\n+        } catch (ClassNotFoundException e) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java\ndeleted file mode 100644\nindex 5b7f507452..0000000000\n--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxws.spi;\n-\n-import java.lang.reflect.Method;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-import org.apache.cxf.common.util.PackageUtils;\n-import org.apache.cxf.common.util.StringUtils;\n-import org.apache.cxf.jaxws.WrapperClassGenerator;\n-import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n-import org.apache.cxf.service.model.InterfaceInfo;\n-import org.apache.cxf.service.model.MessageInfo;\n-import org.apache.cxf.service.model.MessagePartInfo;\n-import org.apache.cxf.service.model.OperationInfo;\n-import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n-\n-public class GeneratedWrapperClassLoader implements WrapperClassCreator {\n-    private Set<Class<?>> wrapperBeans = new LinkedHashSet<>();\n-    private InterfaceInfo interfaceInfo;\n-    private JaxWsServiceFactoryBean factory;\n-\n-    public GeneratedWrapperClassLoader() {\n-    }\n-\n-    @Override\n-    public Set<Class<?>> generate(Bus bus, JaxWsServiceFactoryBean fact, InterfaceInfo ii, boolean q) {\n-        factory = fact;\n-        this.interfaceInfo = ii;\n-        for (OperationInfo opInfo : interfaceInfo.getOperations()) {\n-            if (opInfo.isUnwrappedCapable()) {\n-                Method method = (Method)opInfo.getProperty(ReflectionServiceFactoryBean.METHOD);\n-                if (method == null) {\n-                    continue;\n-                }\n-                MessagePartInfo inf = opInfo.getInput().getFirstMessagePart();\n-                if (inf.getTypeClass() == null) {\n-                    MessageInfo messageInfo = opInfo.getUnwrappedOperation().getInput();\n-                    createWrapperClass(inf,\n-                            messageInfo,\n-                            opInfo,\n-                            method,\n-                            true);\n-                }\n-                MessageInfo messageInfo = opInfo.getUnwrappedOperation().getOutput();\n-                if (messageInfo != null) {\n-                    inf = opInfo.getOutput().getFirstMessagePart();\n-                    if (inf.getTypeClass() == null) {\n-                        createWrapperClass(inf,\n-                                messageInfo,\n-                                opInfo,\n-                                method,\n-                                false);\n-                    }\n-                }\n-            }\n-        }\n-        return wrapperBeans;\n-    }\n-\n-    private void createWrapperClass(MessagePartInfo wrapperPart,\n-                                    MessageInfo messageInfo,\n-                                    OperationInfo op,\n-                                    Method method,\n-                                    boolean isRequest) {\n-        boolean anonymous = factory.getAnonymousWrapperTypes();\n-\n-        String pkg = getPackageName(method) + \".jaxws_asm\" + (anonymous ? \"_an\" : \"\");\n-        String className = pkg + \".\"\n-                + StringUtils.capitalize(op.getName().getLocalPart());\n-        if (!isRequest) {\n-            className = className + \"Response\";\n-        }\n-\n-        Class<?> clz = null;\n-        try {\n-            clz = ClassLoaderUtils.loadClass(className, GeneratedWrapperClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        wrapperPart.setTypeClass(clz);\n-        wrapperBeans.add(clz);\n-    }\n-    private String getPackageName(Method method) {\n-        String pkg = PackageUtils.getPackageName(method.getDeclaringClass());\n-        return pkg.length() == 0 ? WrapperClassGenerator.DEFAULT_PACKAGE_NAME : pkg;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNjc3OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r526516778", "bodyText": "Probably we should log the exception here (debug or trace), just to help with troubleshooting", "author": "reta", "createdAt": "2020-11-19T00:41:55Z", "path": "rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassLoader.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.endpoint.dynamic;\n+\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+\n+public class ExceptionClassLoader implements ExceptionClassCreator {\n+\n+    public ExceptionClassLoader() {\n+    }\n+\n+    @Override\n+    public Class<?> createExceptionClass(Class<?> bean) {\n+        String newClassName = bean.getName() + \"_Exception\";\n+        try {\n+            return ClassLoaderUtils.loadClass(newClassName, ExceptionClassLoader.class);\n+        } catch (ClassNotFoundException e) {", "originalCommit": "c0b3af80f23e1caa22e0cad16f34c471109e4af3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassLoader.java b/rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassLoader.java\ndeleted file mode 100644\nindex c292d1fcbf..0000000000\n--- a/rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassLoader.java\n+++ /dev/null\n\n@@ -1,37 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.endpoint.dynamic;\n-\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-\n-public class ExceptionClassLoader implements ExceptionClassCreator {\n-\n-    public ExceptionClassLoader() {\n-    }\n-\n-    @Override\n-    public Class<?> createExceptionClass(Class<?> bean) {\n-        String newClassName = bean.getName() + \"_Exception\";\n-        try {\n-            return ClassLoaderUtils.loadClass(newClassName, ExceptionClassLoader.class);\n-        } catch (ClassNotFoundException e) {\n-        }\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQxNTMxMw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r528415313", "bodyText": "Please catch Throwable here to cover XxxError (like VerifyError fe)", "author": "reta", "createdAt": "2020-11-22T22:33:49Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxb;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.spi.GeneratedClassClassLoader;\n+import org.apache.cxf.databinding.WrapperHelper;\n+\n+public class WrapperHelperClassLoader extends GeneratedClassClassLoader implements WrapperHelperCreator {\n+    public WrapperHelperClassLoader(Bus bus) {\n+        super(bus);\n+    }\n+\n+    @Override\n+    public WrapperHelper compile(Class<?> wrapperType, Method[] setMethods, Method[] getMethods,\n+                                 Method[] jaxbMethods, Field[] fields, Object objectFactory) {\n+\n+        int count = 1;\n+        String newClassName = wrapperType.getName() + \"_WrapperTypeHelper\" + count;\n+\n+        Class<?> cls = loadClass(newClassName, WrapperHelperClassLoader.class);\n+        while (cls != null) {\n+            try {\n+                WrapperHelper helper = WrapperHelper.class.cast(cls.getDeclaredConstructor().newInstance());\n+                if (!helper.getSignature().equals(WrapperHelperCompiler.computeSignature(setMethods, getMethods))) {\n+                    count++;\n+                    newClassName = wrapperType.getName() + \"_WrapperTypeHelper\" + count;\n+                    cls = loadClass(newClassName, WrapperHelperClassLoader.class);\n+                } else {\n+                    return helper;\n+                }\n+            } catch (Exception e) {", "originalCommit": "3f43af940b62b4c7aaa8a282b394480718c071be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQyNzk0OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r528427949", "bodyText": "Strange because I have check previous code and it was the same...", "author": "dufoli", "createdAt": "2020-11-23T00:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQxNTMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ0MzU5NQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r528443595", "bodyText": "Yes, the code seems to be fine but the context has changed, I believe it corresponds to this block:\ntry {\n            return new WrapperHelperCompiler(wrapperType,\n                                        setMethods,\n                                        getMethods,\n                                        jaxbMethods,\n                                        fields,\n                                        objectFactory).compile();\n\n        } catch (Throwable t) {\n            // Some error - probably a bad version of ASM or similar\n        }\n        return null;\n\nFrom WrapperHelperCompiler.java", "author": "reta", "createdAt": "2020-11-23T02:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQxNTMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUwMjMyMA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r528502320", "bodyText": "Ensuring you use COMPUTE_FRAMES and visitMaxs(0, 0) all will be computed but if some class writer don't use that, the refactoring can have changed some stack and the hardcoded ones can be wrong now. One thing to try is to dump the .class, convert it in .java (using jd-gui or so) and try to import it in a project, sometimes something obvious appear.", "author": "rmannibucau", "createdAt": "2020-11-23T07:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQxNTMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU2NDU0MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r528564540", "bodyText": "@rmannibucau @reta just implement your 2 feedbacks.", "author": "dufoli", "createdAt": "2020-11-23T09:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQxNTMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java\ndeleted file mode 100644\nindex 243730adff..0000000000\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassLoader.java\n+++ /dev/null\n\n@@ -1,57 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxb;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.common.spi.GeneratedClassClassLoader;\n-import org.apache.cxf.databinding.WrapperHelper;\n-\n-public class WrapperHelperClassLoader extends GeneratedClassClassLoader implements WrapperHelperCreator {\n-    public WrapperHelperClassLoader(Bus bus) {\n-        super(bus);\n-    }\n-\n-    @Override\n-    public WrapperHelper compile(Class<?> wrapperType, Method[] setMethods, Method[] getMethods,\n-                                 Method[] jaxbMethods, Field[] fields, Object objectFactory) {\n-\n-        int count = 1;\n-        String newClassName = wrapperType.getName() + \"_WrapperTypeHelper\" + count;\n-\n-        Class<?> cls = loadClass(newClassName, WrapperHelperClassLoader.class);\n-        while (cls != null) {\n-            try {\n-                WrapperHelper helper = WrapperHelper.class.cast(cls.getDeclaredConstructor().newInstance());\n-                if (!helper.getSignature().equals(WrapperHelperCompiler.computeSignature(setMethods, getMethods))) {\n-                    count++;\n-                    newClassName = wrapperType.getName() + \"_WrapperTypeHelper\" + count;\n-                    cls = loadClass(newClassName, WrapperHelperClassLoader.class);\n-                } else {\n-                    return helper;\n-                }\n-            } catch (Exception e) {\n-                return null;\n-            }\n-        }\n-        return null;\n-    }\n-}\n"}}, {"oid": "b32d45e5f61fdae4f2e615efca7910d2aeedf577", "url": "https://github.com/apache/cxf/commit/b32d45e5f61fdae4f2e615efca7910d2aeedf577", "message": "[cxf-8340] add precompiled class for Graalvm native support", "committedDate": "2020-11-24T09:15:37Z", "type": "commit"}, {"oid": "5072cc99b31bdf8b01cc3eccee5c85184597995c", "url": "https://github.com/apache/cxf/commit/5072cc99b31bdf8b01cc3eccee5c85184597995c", "message": "move findClass outside of generation class", "committedDate": "2020-11-24T09:15:38Z", "type": "commit"}, {"oid": "f9a8be7241c621988b2ed48754bf9f32a17dc09f", "url": "https://github.com/apache/cxf/commit/f9a8be7241c621988b2ed48754bf9f32a17dc09f", "message": "start big refactoring to have ASMHelper as SPI", "committedDate": "2020-11-24T09:15:39Z", "type": "commit"}, {"oid": "cca63d573bdc0d13d6e27d2c42b65578edc08a20", "url": "https://github.com/apache/cxf/commit/cca63d573bdc0d13d6e27d2c42b65578edc08a20", "message": "start to remove all static in ASMHelper and use instance instead", "committedDate": "2020-11-24T09:15:41Z", "type": "commit"}, {"oid": "8d55e56af942c9038e484a544470fa53e8fec876", "url": "https://github.com/apache/cxf/commit/8d55e56af942c9038e484a544470fa53e8fec876", "message": "implement the target for JAXBUtils and createNamespaceWrapper", "committedDate": "2020-11-24T09:15:41Z", "type": "commit"}, {"oid": "73c4b20cd0e00d8c5acb30e3e195467379cf7017", "url": "https://github.com/apache/cxf/commit/73c4b20cd0e00d8c5acb30e3e195467379cf7017", "message": "migrate all class except corba to support injection of pre compiled class", "committedDate": "2020-11-24T09:15:42Z", "type": "commit"}, {"oid": "7071a4a750b0f2c6e6090cd87754c68e03181993", "url": "https://github.com/apache/cxf/commit/7071a4a750b0f2c6e6090cd87754c68e03181993", "message": "fix missing part", "committedDate": "2020-11-24T09:15:43Z", "type": "commit"}, {"oid": "6af30b173575fcfa80758cc6307822c9d132eec1", "url": "https://github.com/apache/cxf/commit/6af30b173575fcfa80758cc6307822c9d132eec1", "message": "fix iinjection and few test", "committedDate": "2020-11-24T09:15:44Z", "type": "commit"}, {"oid": "7a309473dc425ecc95289ec7c7f71dae31f48cc1", "url": "https://github.com/apache/cxf/commit/7a309473dc425ecc95289ec7c7f71dae31f48cc1", "message": "fix missing bus", "committedDate": "2020-11-24T09:15:45Z", "type": "commit"}, {"oid": "6f3e997ef39938dca53de8cdce4a7fe70bb5ba07", "url": "https://github.com/apache/cxf/commit/6f3e997ef39938dca53de8cdce4a7fe70bb5ba07", "message": "fix missing bus", "committedDate": "2020-11-24T09:15:46Z", "type": "commit"}, {"oid": "566c60bf08ec57f4339fc730f86ffc9b53405ae2", "url": "https://github.com/apache/cxf/commit/566c60bf08ec57f4339fc730f86ffc9b53405ae2", "message": "add exception creator for simple rt", "committedDate": "2020-11-24T09:15:46Z", "type": "commit"}, {"oid": "ff4e2fc79ab345d9b73967e4c87818155a8f4427", "url": "https://github.com/apache/cxf/commit/ff4e2fc79ab345d9b73967e4c87818155a8f4427", "message": "migrate corba too", "committedDate": "2020-11-24T09:15:47Z", "type": "commit"}, {"oid": "22f578fb84e52b510dfda0c18e675aa72eb356c2", "url": "https://github.com/apache/cxf/commit/22f578fb84e52b510dfda0c18e675aa72eb356c2", "message": "fucking syntax issue because no auto format", "committedDate": "2020-11-24T09:15:48Z", "type": "commit"}, {"oid": "d4559be905d54c7860b4d8072ee7fe00a7d35aa0", "url": "https://github.com/apache/cxf/commit/d4559be905d54c7860b4d8072ee7fe00a7d35aa0", "message": "add a test for ASMHelper", "committedDate": "2020-11-24T09:15:49Z", "type": "commit"}, {"oid": "cd05aafa40434f0fbf577eb0b016d67f9a48b937", "url": "https://github.com/apache/cxf/commit/cd05aafa40434f0fbf577eb0b016d67f9a48b937", "message": "add debug dump of ASMHelper class", "committedDate": "2020-11-24T09:15:50Z", "type": "commit"}, {"oid": "2a13bf228e42911eca4e39d5686265abccf5d29e", "url": "https://github.com/apache/cxf/commit/2a13bf228e42911eca4e39d5686265abccf5d29e", "message": "fix bug with singleton not reset", "committedDate": "2020-11-24T09:15:51Z", "type": "commit"}, {"oid": "f73ad6359ea57b851f27d5d663fd9d62547a46b7", "url": "https://github.com/apache/cxf/commit/f73ad6359ea57b851f27d5d663fd9d62547a46b7", "message": "disable dump of class", "committedDate": "2020-11-24T09:15:51Z", "type": "commit"}, {"oid": "2d1e6d55559ff25cd9bee6b69e9727b20d82eea6", "url": "https://github.com/apache/cxf/commit/2d1e6d55559ff25cd9bee6b69e9727b20d82eea6", "message": "integrate partially patch of romain and remove unneeded param and import", "committedDate": "2020-11-24T09:15:53Z", "type": "commit"}, {"oid": "953d82cf8ae9141b849103be5f172cb2083bef1b", "url": "https://github.com/apache/cxf/commit/953d82cf8ae9141b849103be5f172cb2083bef1b", "message": "fix load of corba", "committedDate": "2020-11-24T09:15:53Z", "type": "commit"}, {"oid": "f96a756457a1d34da66f6c49589febe23e144840", "url": "https://github.com/apache/cxf/commit/f96a756457a1d34da66f6c49589febe23e144840", "message": "refactor to follow the reviews", "committedDate": "2020-11-24T09:15:55Z", "type": "commit"}, {"oid": "a1cdacbcb1d4c2473bf3a4f40ef634ac512c05bd", "url": "https://github.com/apache/cxf/commit/a1cdacbcb1d4c2473bf3a4f40ef634ac512c05bd", "message": "second pass of review", "committedDate": "2020-11-24T09:15:56Z", "type": "commit"}, {"oid": "efcebf570c47a7e7704e0773b08a584e017eb992", "url": "https://github.com/apache/cxf/commit/efcebf570c47a7e7704e0773b08a584e017eb992", "message": "fix build", "committedDate": "2020-11-24T09:15:56Z", "type": "commit"}, {"oid": "e83b948fe43429f84f3fac3b1d2ffd9fb7aa3cb4", "url": "https://github.com/apache/cxf/commit/e83b948fe43429f84f3fac3b1d2ffd9fb7aa3cb4", "message": "fix style", "committedDate": "2020-11-24T09:15:58Z", "type": "commit"}, {"oid": "95f81e4bb7affafa552556ba9afd0ad0ecac1f3e", "url": "https://github.com/apache/cxf/commit/95f81e4bb7affafa552556ba9afd0ad0ecac1f3e", "message": "fix visitMaxs and catch throwable", "committedDate": "2020-11-24T09:15:59Z", "type": "commit"}, {"oid": "04cf7106d8c54d645216d484722148709a48d525", "url": "https://github.com/apache/cxf/commit/04cf7106d8c54d645216d484722148709a48d525", "message": "fix corba generation", "committedDate": "2020-11-24T09:15:59Z", "type": "commit"}, {"oid": "04cf7106d8c54d645216d484722148709a48d525", "url": "https://github.com/apache/cxf/commit/04cf7106d8c54d645216d484722148709a48d525", "message": "fix corba generation", "committedDate": "2020-11-24T09:15:59Z", "type": "forcePushed"}, {"oid": "6f0b35ccccc19b4275764c2704845f3f99397a6a", "url": "https://github.com/apache/cxf/commit/6f0b35ccccc19b4275764c2704845f3f99397a6a", "message": "use classGeneratorClassLoader class loader instead o thread one", "committedDate": "2020-11-25T22:14:59Z", "type": "commit"}, {"oid": "7729b6c5db63b78f278ce179bdb8faa0236d79ab", "url": "https://github.com/apache/cxf/commit/7729b6c5db63b78f278ce179bdb8faa0236d79ab", "message": "add a static instant to hadle multiple bus", "committedDate": "2020-11-27T20:09:49Z", "type": "commit"}, {"oid": "c6af47dd4c626b290cdd79bb5b35b6ab76e8a4eb", "url": "https://github.com/apache/cxf/commit/c6af47dd4c626b290cdd79bb5b35b6ab76e8a4eb", "message": "rollback class loading", "committedDate": "2020-11-27T21:41:58Z", "type": "commit"}, {"oid": "3e9e946c365340e4c96df61c01d6347c83e78052", "url": "https://github.com/apache/cxf/commit/3e9e946c365340e4c96df61c01d6347c83e78052", "message": "handle sync as before", "committedDate": "2020-11-28T16:09:17Z", "type": "commit"}, {"oid": "e57e89ada4c52fe11e4e14f3db5d2bfd8bd991ac", "url": "https://github.com/apache/cxf/commit/e57e89ada4c52fe11e4e14f3db5d2bfd8bd991ac", "message": "fix unit test with badASM", "committedDate": "2020-11-29T08:56:12Z", "type": "commit"}, {"oid": "b56890eac545b7b323cafbc9cd14299670ed5e5c", "url": "https://github.com/apache/cxf/commit/b56890eac545b7b323cafbc9cd14299670ed5e5c", "message": "add a unit test for precompiled class", "committedDate": "2020-11-29T10:02:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532185638", "bodyText": "shouldnt all this glue code be in \"main\" instead of test to be reusable just by setting a few extensions on its bus?", "author": "rmannibucau", "createdAt": "2020-11-29T10:03:44Z", "path": "rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/WrapperNamespaceClassGeneratorTest.java", "diffHunk": "@@ -119,5 +126,170 @@ public void testForXmlList() throws Exception {\n         assertTrue(\"The generated response wrapper class is not correct\", bout.toString().contains(expected));\n \n     }\n+    public class CustomClassLoader extends ClassLoader {", "originalCommit": "b56890eac545b7b323cafbc9cd14299670ed5e5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NjE2OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532186169", "bodyText": "@rmannibucau exactly my issue I found that not very easy to set up. So How to found a solution for that.\nThe second issue is that when code is generated just in time,  it depend of class loader or class to store it in the map. So I need to do so on generated first part.", "author": "dufoli", "createdAt": "2020-11-29T10:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NjI2MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532186260", "bodyText": "That was my point at the very bginning to said that I am affraid that it is complicated to cache generated class. Help needed to go the cleaner and easier way ;-)", "author": "dufoli", "createdAt": "2020-11-29T10:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NjM4Nw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532186387", "bodyText": "Guess we must arrive at something like:\nbus.setExtension(X.class, new BuiltInCaptureImpl())\n\nBuiltInCaptureImpl should trigger the loading of all potentially generated classes (by reflection) and provide a Map<String, byte[]> of generated classes (then user can getGeneratedClasses() and dump it somehwere.\nwdyt?", "author": "rmannibucau", "createdAt": "2020-11-29T10:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNjIxMA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532216210", "bodyText": "Agree with @rmannibucau, goes back to DEBUG flag discussion, since we now have the extensions in right places, we could add one to collect generated classes (and delegate for actual generation).", "author": "reta", "createdAt": "2020-11-29T14:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ4NjY5Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532486696", "bodyText": "I have start to code something for that.\n\nI think that it can be used on cxf side too by having a tool like the wsdl2java tool but to pregenerate all classes.\nI have code something with start and restore to save all class bytes and classNames. and restore but my issue with the 2 maps (always them).\n\nFor CLASS_MAP, I can store the key classname and restore must find original class so I think to Class.forName but not sur it will work.\nsummary :\npublic interface ClassGeneratorCapture {\n    void save(String className, Class<?> cls, byte[] bytes);\n\n    Map<? extends Class<?>,? extends WeakReference<ClassGeneratorClassLoader.TypeHelperClassLoader>> getClassMap();\n\n    Map<? extends ClassLoader,? extends WeakReference<ClassGeneratorClassLoader.TypeHelperClassLoader>> getLoaderMap();\n}\nSo previously loaded side will change.\nBecause Instead of inherit of GeneratedClassClassLoader, I will inherit to ClassGeneratorClassLoader (same as generation part). It is more consistent but restore of classloader map is not doable I think. I need to see if we can move all to class map", "author": "dufoli", "createdAt": "2020-11-30T10:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5NTMxMA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532495310", "bodyText": "If it moves to services it does not need the weak reference since the classloader life time will be the bus lifetime.\nCan need a destroy() callback called when the bus is destroyed (don't recall if extensions can implement autocloseable but can be an option, worse case you can add a bus lifecycle listener to call it from the listener when getting the bus instance).\nI'm also pretty sure it does not need to be in the contract, contract only needs Map<String, byte[]> to export the generated classes.\nInternally the generator class can use a map of classloaders but it must not leak outside the implementation IMHO.\nTypically for build time generation, most flat classpath deployments - including quarkus - it willl not be needed and will just make it more complex with no real gain for end user and our integration code.\nAbout how to generate, I spoke earlier of doing a new mojo to complete the e2e feature, think it still makes sense (ensure to extract in a \"tool\" class what you need in your quarkus build step so can be a Runnable which will be called in the mojo and your build step) but I don't think it should be merged to any existing mojo. It should be usable \"alone\" probably.\nHope it makes sense.", "author": "rmannibucau", "createdAt": "2020-11-30T10:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMzMyOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532513329", "bodyText": "WeakReference => aggreed. It was kind of proof of concept to have the system of stop the world save a picture... then reload. ;-)\nMy issue is this damn Maps... I prefer to kill the key reference to class loader or class which have been calling findClass. Anyway when I try to kill it was a nightmare... All test failed ;-(\nI am not sure about the Map<String, byte[]>. I prefer to have Map<String, Class<?>>. Are you ok with that ?\nwhat is e2e feature ?", "author": "dufoli", "createdAt": "2020-11-30T11:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUyMzIyOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532523229", "bodyText": "E2e = your write an app, setup a maven plugin execution and get pregenerated runtime. This is the story we want to enable ;).\nI understand the test nightmare but we must not design an api for tests IMHO and from all other products doing this kind of generation we know it is not needed so let's keep the SPI clean and we will clean up the impl later. If you need to expose this internal it means the spi is not at the right point maybe - but think the classloader itself shoude the spi in this particular case.\nIf you find a failling test i can run easily, i can have a look later this week.", "author": "rmannibucau", "createdAt": "2020-11-30T11:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1OTA5MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532759091", "bodyText": "ok so todo list is to go back to classLoader solution. But I will to embded my own classloader with singleton pattern to load className and byte[] and put a method restore  with Capture class Object as parameter", "author": "dufoli", "createdAt": "2020-11-30T17:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3OTYyNw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r532979627", "bodyText": "ok hope now it is better. test is ok and API seems better.", "author": "dufoli", "createdAt": "2020-11-30T23:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE4NTYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "e2bf7b48be57a992c6ad993a3d1c1628a7d179de", "chunk": "diff --git a/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/WrapperNamespaceClassGeneratorTest.java b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/WrapperNamespaceClassGeneratorTest.java\nindex ddf6138176..7e00d4a7e2 100644\n--- a/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/WrapperNamespaceClassGeneratorTest.java\n+++ b/rt/frontend/jaxws/src/test/java/org/apache/cxf/jaxws/WrapperNamespaceClassGeneratorTest.java\n\n@@ -126,90 +129,17 @@ public class WrapperNamespaceClassGeneratorTest {\n         assertTrue(\"The generated response wrapper class is not correct\", bout.toString().contains(expected));\n \n     }\n-    public class CustomClassLoader extends ClassLoader {\n-        ConcurrentHashMap<String, Class<?>> defined = new ConcurrentHashMap<>();\n-\n-        CustomClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-        public Class<?> lookupDefinedClass(String name) {\n-            return defined.get(StringUtils.slashesToPeriod(name));\n-        }\n-\n-        public Class<?> defineClass(String name, byte[] bytes) {\n-            Class<?> ret = defined.get(StringUtils.slashesToPeriod(name));\n-            if (ret != null) {\n-                return ret;\n-            }\n-\n-            ret = defined.computeIfAbsent(StringUtils.slashesToPeriod(name),\n-                key -> CustomClassLoader.super.defineClass(key, bytes, 0, bytes.length));\n-\n-            return ret;\n-        }\n-    }\n-    public class ProxyASMHelper extends ASMHelperImpl {\n-        private CustomClassLoader customClassLoader;\n-\n-        public ProxyASMHelper(CustomClassLoader customClassLoader) {\n-            this.customClassLoader = customClassLoader;\n+    public class Capture implements ClassGeneratorCapture {\n+        private Map<String, byte[]> sources;\n+        public Capture() {\n+            sources = new HashMap<>();\n         }\n-        public ClassWriter createClassWriter() {\n-            ClassWriter parent = super.createClassWriter();\n-            return new ProxyClassWriter(parent, this);\n+        public void save(String className, byte[] bytes) {\n+            sources.put(className, bytes);\n         }\n \n-        public void notif(String className, byte[] bytes) {\n-            customClassLoader.defineClass(className, bytes);\n-        }\n-    }\n-    public class ProxyClassWriter implements ASMHelper.ClassWriter {\n-        private final ASMHelper.ClassWriter proxy;\n-        private final ProxyASMHelper handler;\n-        private String className;\n-\n-        public ProxyClassWriter(ASMHelper.ClassWriter parent, ProxyASMHelper handler) {\n-            this.proxy = parent;\n-            this.handler = handler;\n-        }\n-        @Override\n-        public ASMHelper.AnnotationVisitor visitAnnotation(String cls, boolean t) {\n-            return proxy.visitAnnotation(cls, t);\n-        }\n-\n-        @Override\n-        public ASMHelper.FieldVisitor visitField(int accPrivate, String fieldName, String classCode,\n-                                                 String fieldDescriptor, Object object) {\n-            return proxy.visitField(accPrivate, fieldName, classCode, fieldDescriptor, object);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            proxy.visitEnd();\n-        }\n-\n-        @Override\n-        public byte[] toByteArray() {\n-            byte[] bytes = proxy.toByteArray();\n-            handler.notif(className, bytes);\n-            return bytes;\n-        }\n-\n-        @Override\n-        public ASMHelper.MethodVisitor visitMethod(int accPublic, String string, String string2, String s3,\n-                                                   String[] s4) {\n-            return proxy.visitMethod(accPublic, string, string2, s3, s4);\n-        }\n-\n-        @Override\n-        public void visit(int v15, int i, String newClassName, String object, String string, String[] object2) {\n-            className = newClassName;\n-            proxy.visit(v15, i, newClassName, object, string, object2);\n-        }\n-\n-        @Override\n-        public void visitSource(String arg0, String arg1) {\n-            proxy.visitSource(arg0, arg1);\n+        public Map<String, byte[]> restore(){\n+            return sources;\n         }\n     }\n     @org.junit.Test\n"}}, {"oid": "e2bf7b48be57a992c6ad993a3d1c1628a7d179de", "url": "https://github.com/apache/cxf/commit/e2bf7b48be57a992c6ad993a3d1c1628a7d179de", "message": "add capture system and a unit test", "committedDate": "2020-11-30T18:20:36Z", "type": "commit"}, {"oid": "e2bf7b48be57a992c6ad993a3d1c1628a7d179de", "url": "https://github.com/apache/cxf/commit/e2bf7b48be57a992c6ad993a3d1c1628a7d179de", "message": "add capture system and a unit test", "committedDate": "2020-11-30T18:20:36Z", "type": "forcePushed"}, {"oid": "525d2dd8305f6830a6b53cf9582911cc4671720c", "url": "https://github.com/apache/cxf/commit/525d2dd8305f6830a6b53cf9582911cc4671720c", "message": "fix test", "committedDate": "2020-11-30T23:49:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMDIyOA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r533030228", "bodyText": "This extension point is not used by class generators but class loaders (GeneratedClassClassLoader & ClassGeneratorClassLoader). I think GeneratedClassClassLoaderCapture would be longer and more descriptive name, wdyt?", "author": "reta", "createdAt": "2020-12-01T02:22:53Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorCapture.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+\n+public interface ClassGeneratorCapture {", "originalCommit": "525d2dd8305f6830a6b53cf9582911cc4671720c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3861e867dd74d8a78498a113de705faa23ee1b55", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorCapture.java b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorCapture.java\nindex 5749366760..22424e39ef 100644\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorCapture.java\n+++ b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorCapture.java\n\n@@ -18,10 +18,6 @@\n  */\n package org.apache.cxf.common.spi;\n \n-import java.util.Map;\n-\n public interface ClassGeneratorCapture {\n     void save(String className, byte[] bytes);\n-\n-    Map<String, byte[]> restore();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMjg1OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r533032858", "bodyText": "I don't think you need this method, is it supposed to be used outside of tests?", "author": "reta", "createdAt": "2020-12-01T02:31:15Z", "path": "core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoader.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+import org.apache.cxf.common.logging.LogUtils;\n+import org.apache.cxf.common.util.StringUtils;\n+\n+public class GeneratedClassClassLoader {\n+    private static final Logger LOG = LogUtils.getL7dLogger(ClassLoaderProxyService.class);\n+    protected final Bus bus;\n+\n+    public GeneratedClassClassLoader(Bus bus) {\n+        this.bus = bus;\n+    }\n+    protected Class<?> findClass(String className, Class<?> callingClass) {\n+        ClassLoader cl = getClassLoader();\n+        try {\n+            return cl.loadClass(className);\n+        } catch (ClassNotFoundException e) {\n+            //ignore and try with other class loader\n+        }\n+        try {\n+            return ClassLoaderUtils.loadClass(className, callingClass);\n+        } catch (ClassNotFoundException e) {\n+            LOG.fine(\"Failed to load class :\" + e.toString());\n+        }\n+        return null;\n+    }\n+    public TypeHelperClassLoader getClassLoader() {\n+        TypeHelperClassLoader loader = bus.getExtension(TypeHelperClassLoader.class);\n+        if (loader == null) {\n+            loader = bus.getExtension(TypeHelperClassLoader.class);\n+            if (loader == null) {\n+                ClassLoader parent = bus.getExtension(ClassLoader.class);\n+                if (parent == null) {\n+                    parent = Thread.currentThread().getContextClassLoader();\n+                }\n+                loader = new TypeHelperClassLoader(parent);\n+                bus.setExtension(loader, TypeHelperClassLoader.class);\n+            }\n+        }\n+        return loader;\n+    }\n+\n+    public void restore(ClassGeneratorCapture capture) {", "originalCommit": "525d2dd8305f6830a6b53cf9582911cc4671720c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzExODQ4NQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r533118485", "bodyText": "hmm outside of test, I will proceed like that:\n\nmake my own capture\nwrite in .class file the bytes\nHow to inject the class files generated and available in app to the ClassLoader used in GeneratedClassClassLoader.java?\nsorry if my question seems dumb but I am a bit lost....", "author": "dufoli", "createdAt": "2020-12-01T07:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyOTEzMg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r533129132", "bodyText": "Outside of a test you have written the .class in target/classes (maven/gradle) or in classloader singleton of quarkus (= it is int the future runtime classloader, no need to do anything special except have a stable name to reuse it and load it, xxhash64 of all parameters can help there, you can check the openwebbeans impl which has this option). The main trick is to ensure CXF uses a SPI to load the class. Generally the \"write\"/capture and \"read\"/load is the same SPI to ensure both sides match. One \"already written\" impl will throw an UnsupportedOperationException in write but it is a detail. In OWB the read/write methods are merged as a \"defineAndLoad\" ([1]) one but it is not required. The defineAndLoad deep implementation (actual classloader load) is either the one we currently have with a map in a classloader or a more aggressive one using Unsafe ([2]).\n[1] https://github.com/apache/openwebbeans/blob/master/webbeans-impl/src/main/java/org/apache/webbeans/service/ClassLoaderProxyService.java\n[2] https://github.com/apache/openwebbeans/blob/master/webbeans-impl/src/main/java/org/apache/webbeans/proxy/Unsafe.java#L132", "author": "rmannibucau", "createdAt": "2020-12-01T07:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIwMzU5OQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r533203599", "bodyText": "hmm so it mean that I expose Map<String, byte[]> proxies = new HashMap<>(); as they do ?\nI do not like to expose byte. I prefer to inject class loader of Map<String, Class<?>> proxies;\nbecause load a byte to class is not really needed at runtime.  no ?", "author": "dufoli", "createdAt": "2020-12-01T09:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0MTgxMg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r533241812", "bodyText": "You dont have to expose the map, you can provide a getter from the classloader (because it is what these classes do at the end) and it is convenient for libs like yours which will then just dump everything from there but it is not required. Your lib can also extend it and dump it on the fly. The getter does not cost anything and is a simple option but forcing a subclass is not that complicated too. Also note that the runtime mode does NOT use the map of bytes, it is the capture mode, the runtime mode just loadClass directly.", "author": "rmannibucau", "createdAt": "2020-12-01T09:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMTc2Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r534401762", "bodyText": "I have removed restore response. I guess it is right now ;-)", "author": "dufoli", "createdAt": "2020-12-02T18:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMjg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "3861e867dd74d8a78498a113de705faa23ee1b55", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoader.java\nindex 5584d0718b..d057a827a6 100644\n--- a/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoader.java\n+++ b/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoader.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.cxf.common.spi;\n \n-import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.logging.Logger;\n \n"}}, {"oid": "3861e867dd74d8a78498a113de705faa23ee1b55", "url": "https://github.com/apache/cxf/commit/3861e867dd74d8a78498a113de705faa23ee1b55", "message": "remove restore method", "committedDate": "2020-12-02T18:47:53Z", "type": "commit"}, {"oid": "45452327bd64c09b8d93095bba881ee03f3b3fc1", "url": "https://github.com/apache/cxf/commit/45452327bd64c09b8d93095bba881ee03f3b3fc1", "message": "rename capture", "committedDate": "2020-12-03T20:32:20Z", "type": "commit"}, {"oid": "f19e12dcd48f7328c0724b48fe11887651e95a8c", "url": "https://github.com/apache/cxf/commit/f19e12dcd48f7328c0724b48fe11887651e95a8c", "message": "add capture on loadClass for loader", "committedDate": "2020-12-03T21:18:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc5MzY1MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r535793651", "bodyText": "Please remove qualified and interfaceInfo from class members, pass them as arguments along the chain.", "author": "reta", "createdAt": "2020-12-04T02:41:13Z", "path": "rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java", "diffHunk": "@@ -109,7 +109,11 @@ private String getPackageName(Method method) {\n         return list;\n     }\n \n-    public Set<Class<?>> generate() {\n+    public Set<Class<?>> generate(JaxWsServiceFactoryBean factory, InterfaceInfo ii, boolean q) {\n+        this.qualified = q;", "originalCommit": "f19e12dcd48f7328c0724b48fe11887651e95a8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc5ODM1Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r535798356", "bodyText": "I can not. The verify limit the number of parameters to seven max. Else I have to create an internal class context to forward it between method.", "author": "dufoli", "createdAt": "2020-12-04T02:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc5MzY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc5OTM0Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r535799343", "bodyText": "You mean checkstyle?\n// CHECKSTYLE: OFF\n....\n// CHECKSTYLE: ON\n(no very great but will do the job)", "author": "reta", "createdAt": "2020-12-04T02:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc5MzY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "68f9955a2ea54a11e76b3e1224f426f2d074db40", "chunk": "diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java\nindex e07b382947..51266a7ad2 100644\n--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java\n+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/WrapperClassGenerator.java\n\n@@ -109,9 +107,7 @@ public final class WrapperClassGenerator extends ClassGeneratorClassLoader imple\n         return list;\n     }\n \n-    public Set<Class<?>> generate(JaxWsServiceFactoryBean factory, InterfaceInfo ii, boolean q) {\n-        this.qualified = q;\n-        this.interfaceInfo = ii;\n+    public Set<Class<?>> generate(JaxWsServiceFactoryBean factory, InterfaceInfo interfaceInfo, boolean qualified) {\n         helper = bus.getExtension(ASMHelper.class);\n         Set<Class<?>> wrapperBeans = new LinkedHashSet<>();\n         for (OperationInfo opInfo : interfaceInfo.getOperations()) {\n"}}, {"oid": "68f9955a2ea54a11e76b3e1224f426f2d074db40", "url": "https://github.com/apache/cxf/commit/68f9955a2ea54a11e76b3e1224f426f2d074db40", "message": "switch property to arg of method", "committedDate": "2020-12-04T07:18:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk1NDEzNA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r536954134", "bodyText": "This pattern of changing class state during method execution is the cause of test failures, could you please replace class members\n        this.wrapperType = wt;\n        this.setMethods = setters;\n        this.getMethods = getters;\n        this.jaxbMethods = jms;\n        this.fields = fs;\n\nwith arguments (or move some of them into constructor please)?", "author": "reta", "createdAt": "2020-12-06T04:37:27Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java", "diffHunk": "@@ -24,78 +24,56 @@\n \n import javax.xml.bind.JAXBElement;\n \n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.spi.ClassGeneratorClassLoader;\n import org.apache.cxf.common.util.ASMHelper;\n+import org.apache.cxf.common.util.OpcodesProxy;\n+import org.apache.cxf.common.util.StringUtils;\n import org.apache.cxf.databinding.WrapperHelper;\n \n-final class WrapperHelperCompiler extends ASMHelper {\n-\n-\n-    final Class<?> wrapperType;\n-    final Method[] setMethods;\n-    final Method[] getMethods;\n-    final Method[] jaxbMethods;\n-    final Field[] fields;\n-    final Object objectFactory;\n-    final ClassWriter cw;\n-\n-    private WrapperHelperCompiler(Class<?> wrapperType,\n-                                  Method[] setMethods,\n-                                  Method[] getMethods,\n-                                  Method[] jaxbMethods,\n-                                  Field[] fields,\n-                                  Object objectFactory) {\n-        this.wrapperType = wrapperType;\n-        this.setMethods = setMethods;\n-        this.getMethods = getMethods;\n-        this.jaxbMethods = jaxbMethods;\n-        this.fields = fields;\n-        this.objectFactory = objectFactory;\n-        cw = createClassWriter();\n-    }\n-\n-    static WrapperHelper compileWrapperHelper(Class<?> wrapperType,\n-                                              Method[] setMethods,\n-                                              Method[] getMethods,\n-                                              Method[] jaxbMethods,\n-                                              Field[] fields,\n-                                              Object objectFactory) {\n-        try {\n-            return new WrapperHelperCompiler(wrapperType,\n-                                        setMethods,\n-                                        getMethods,\n-                                        jaxbMethods,\n-                                        fields,\n-                                        objectFactory).compile();\n-\n-        } catch (Throwable t) {\n-            // Some error - probably a bad version of ASM or similar\n-        }\n-        return null;\n-    }\n-\n+public final class WrapperHelperCompiler extends ClassGeneratorClassLoader implements WrapperHelperCreator {\n \n+    private Class<?> wrapperType;\n+    private Method[] setMethods;\n+    private Method[] getMethods;\n+    private Method[] jaxbMethods;\n+    private Field[] fields;\n+    private ASMHelper.ClassWriter cw;\n+    private ASMHelper asmhelper;\n \n+    WrapperHelperCompiler(Bus bus) {\n+        super(bus);\n+    }\n \n+    public WrapperHelper compile(Class<?> wt, Method[] setters,\n+                                 Method[] getters, Method[] jms,\n+                                 Field[] fs, Object objectFactory) {\n+        this.wrapperType = wt;", "originalCommit": "68f9955a2ea54a11e76b3e1224f426f2d074db40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5NjY5MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r537096690", "bodyText": "hmmm. it is because bus.getExtension is a singleton so always same instance all properties must move to arg to avoid that it is modified by 2 processes. great catch....  I have check other class generator. And the only other case is ASMHelper and no properties in it which can lead to issue (cwClass can be shared). So it can be set and reuse without issue. The classwriter in the other hand must been send as args... but it was not the case.", "author": "dufoli", "createdAt": "2020-12-06T18:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk1NDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5NjkyNg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r537096926", "bodyText": "Do you think I must move ASMHelper too to be sure ?", "author": "dufoli", "createdAt": "2020-12-06T18:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk1NDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5OTE1Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r537099156", "bodyText": "Yes, I think making it local (fetch from the bus) would be better, thanks. Basically, we should not change the class members beside the construction phase.", "author": "reta", "createdAt": "2020-12-06T18:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk1NDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzExODkwNA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r537118904", "bodyText": "done", "author": "dufoli", "createdAt": "2020-12-06T20:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk1NDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE2NTAwMw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r537165003", "bodyText": "\ud83d\udc4d thank you, things are back on track", "author": "reta", "createdAt": "2020-12-07T00:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk1NDEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "150c9bea88d2994e92a5288f38e90b8e8b0fe41e", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java\nindex c9f5d999c9..51cbc6ceef 100644\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java\n+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java\n\n@@ -33,28 +33,15 @@ import org.apache.cxf.databinding.WrapperHelper;\n \n public final class WrapperHelperCompiler extends ClassGeneratorClassLoader implements WrapperHelperCreator {\n \n-    private Class<?> wrapperType;\n-    private Method[] setMethods;\n-    private Method[] getMethods;\n-    private Method[] jaxbMethods;\n-    private Field[] fields;\n-    private ASMHelper.ClassWriter cw;\n-    private ASMHelper asmhelper;\n-\n     WrapperHelperCompiler(Bus bus) {\n         super(bus);\n     }\n \n-    public WrapperHelper compile(Class<?> wt, Method[] setters,\n-                                 Method[] getters, Method[] jms,\n-                                 Field[] fs, Object objectFactory) {\n-        this.wrapperType = wt;\n-        this.setMethods = setters;\n-        this.getMethods = getters;\n-        this.jaxbMethods = jms;\n-        this.fields = fs;\n-        asmhelper = bus.getExtension(ASMHelper.class);\n-        cw = asmhelper.createClassWriter();\n+    public WrapperHelper compile(Class<?> wrapperType, Method[] setMethods,\n+                                 Method[] getMethods, Method[] jaxbMethods,\n+                                 Field[] fields, Object objectFactory) {\n+        ASMHelper asmhelper = bus.getExtension(ASMHelper.class);\n+        ASMHelper.ClassWriter cw = asmhelper.createClassWriter();\n \n         if (cw == null) {\n             return null;\n"}}, {"oid": "150c9bea88d2994e92a5288f38e90b8e8b0fe41e", "url": "https://github.com/apache/cxf/commit/150c9bea88d2994e92a5288f38e90b8e8b0fe41e", "message": "move field to parameter because singleton share same instance", "committedDate": "2020-12-06T18:22:37Z", "type": "commit"}, {"oid": "170a74260aff7d8a2bd52bcd235a28c0714d355a", "url": "https://github.com/apache/cxf/commit/170a74260aff7d8a2bd52bcd235a28c0714d355a", "message": "init helper in ctor to avoid new init of helper during build", "committedDate": "2020-12-06T19:31:56Z", "type": "commit"}, {"oid": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "url": "https://github.com/apache/cxf/commit/72930d287d6e94e6ed742331bbf4f0d2ce645129", "message": "add javadoc", "committedDate": "2020-12-07T10:36:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMyMzc4MA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540323780", "bodyText": "Please declare srv as private final", "author": "reta", "createdAt": "2020-12-10T16:41:57Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+import java.util.logging.Logger;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.logging.LogUtils;\n+\n+public class ClassLoaderProxyService implements ClassLoaderService {\n+    private static final Logger LOG = LogUtils.getL7dLogger(ClassLoaderProxyService.class);\n+    NamespaceClassCreator srv;", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java b/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java\nindex ab32776d74..aed992250b 100644\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java\n+++ b/core/src/main/java/org/apache/cxf/common/spi/ClassLoaderProxyService.java\n\n@@ -27,7 +27,7 @@ import org.apache.cxf.common.logging.LogUtils;\n \n public class ClassLoaderProxyService implements ClassLoaderService {\n     private static final Logger LOG = LogUtils.getL7dLogger(ClassLoaderProxyService.class);\n-    NamespaceClassCreator srv;\n+    private final NamespaceClassCreator srv;\n     public ClassLoaderProxyService(Bus bus) {\n         this(new NamespaceClassGenerator(bus));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMyOTYxMg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540329612", "bodyText": "Minor, may be better name for this method would be capture, wdyt?", "author": "reta", "createdAt": "2020-12-10T16:49:23Z", "path": "core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoaderCapture.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.common.spi;\n+\n+/** Implement this interface to store class generated in order during build phase\n+ *  inject it back before runtime to avoid class generation.\n+ *  produce dot class file thanks to save method.\n+ *  You can check WrapperNamespaceClassGeneratorTest.testGeneratedFirst for usage\n+ *  Here is list of extensions to set in order to avoid class loading after generation during build time.\n+ *  bus.setExtension(new WrapperHelperClassLoader(bus), WrapperHelperCreator.class);\n+ *  bus.setExtension(new ExtensionClassLoader(bus), ExtensionClassCreator.class);\n+ *  bus.setExtension(new ExceptionClassLoader(bus), ExceptionClassCreator.class);\n+ *  bus.setExtension(new GeneratedWrapperClassLoader(bus), WrapperClassCreator.class);\n+ *  bus.setExtension(new FactoryClassLoader(bus), FactoryClassCreator.class);\n+ *  bus.setExtension(new GeneratedNamespaceClassLoader(bus), NamespaceClassCreator.class);\n+ * @author olivier dufour\n+ */\n+public interface GeneratedClassClassLoaderCapture {\n+    void save(String className, byte[] bytes);", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoaderCapture.java b/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoaderCapture.java\nindex 2a44ea3d14..b71d582a75 100644\n--- a/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoaderCapture.java\n+++ b/core/src/main/java/org/apache/cxf/common/spi/GeneratedClassClassLoaderCapture.java\n\n@@ -32,5 +32,5 @@ package org.apache.cxf.common.spi;\n  * @author olivier dufour\n  */\n public interface GeneratedClassClassLoaderCapture {\n-    void save(String className, byte[] bytes);\n+    void capture(String className, byte[] bytes);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzNzg0MQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540337841", "bodyText": "We have this method createNamespaceWrapper here and in ClassLoaderService. The name is the same but those do slightly different things. May be we could rename this one to createNamespaceWrapperClass or  the one in ClassLoaderService to createNamespaceWrapperInstance, wdy?", "author": "reta", "createdAt": "2020-12-10T16:59:56Z", "path": "core/src/main/java/org/apache/cxf/common/spi/NamespaceClassCreator.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+\n+/**\n+ * SPI interface to implement the proxy defining logic.\n+ * It enables to switch from unsafe to classloader logic for instance for java >= 9.\n+ */\n+public interface NamespaceClassCreator {\n+\n+    Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map);", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassCreator.java b/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassCreator.java\nindex 4e2fb3e73d..c951e4b15a 100644\n--- a/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassCreator.java\n+++ b/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassCreator.java\n\n@@ -27,6 +27,6 @@ import java.util.Map;\n  */\n public interface NamespaceClassCreator {\n \n-    Class<?> createNamespaceWrapper(Class<?> mcls, Map<String, String> map);\n+    Class<?> createNamespaceWrapperClass(Class<?> mcls, Map<String, String> map);\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzODQzMw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540338433", "bodyText": "Please declare helper as private final", "author": "reta", "createdAt": "2020-12-10T17:00:42Z", "path": "core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+import org.apache.cxf.common.logging.LogUtils;\n+import org.apache.cxf.common.util.ASMHelper;\n+import org.apache.cxf.common.util.OpcodesProxy;\n+\n+public class NamespaceClassGenerator extends ClassGeneratorClassLoader implements NamespaceClassCreator {\n+\n+    private static final Logger LOG = LogUtils.getL7dLogger(ClassGeneratorClassLoader.class);\n+    ASMHelper helper;", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java b/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java\nindex fba98981ac..fbdc5244e1 100644\n--- a/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java\n+++ b/core/src/main/java/org/apache/cxf/common/spi/NamespaceClassGenerator.java\n\n@@ -32,7 +32,7 @@ import org.apache.cxf.common.util.OpcodesProxy;\n public class NamespaceClassGenerator extends ClassGeneratorClassLoader implements NamespaceClassCreator {\n \n     private static final Logger LOG = LogUtils.getL7dLogger(ClassGeneratorClassLoader.class);\n-    ASMHelper helper;\n+    private final ASMHelper helper;\n \n     public NamespaceClassGenerator(Bus bus) {\n         super(bus);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0Nzg2Nw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540347867", "bodyText": "Please remove this method (setBadASM), it is internal impl only and is not used anywhere", "author": "reta", "createdAt": "2020-12-10T17:13:33Z", "path": "core/src/main/java/org/apache/cxf/common/util/ASMHelper.java", "diffHunk": "@@ -19,447 +19,29 @@\n \n package org.apache.cxf.common.util;\n \n-import java.lang.ref.WeakReference;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Method;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.TypeVariable;\n-import java.lang.reflect.WildcardType;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n \n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n import org.apache.cxf.common.util.ReflectionInvokationHandler.Optional;\n import org.apache.cxf.common.util.ReflectionInvokationHandler.UnwrapParam;\n import org.apache.cxf.common.util.ReflectionInvokationHandler.WrapReturn;\n \n-public class ASMHelper {\n-    protected static final Map<Class<?>, String> PRIMITIVE_MAP = new HashMap<>();\n-    protected static final Map<Class<?>, String> NONPRIMITIVE_MAP = new HashMap<>();\n-    protected static final Map<Class<?>, Integer> PRIMITIVE_ZERO_MAP = new HashMap<>();\n \n-    protected static final Map<ClassLoader, WeakReference<TypeHelperClassLoader>> LOADER_MAP\n-        = new WeakIdentityHashMap<>();\n-    protected static final Map<Class<?>, WeakReference<TypeHelperClassLoader>> CLASS_MAP\n-        = new WeakIdentityHashMap<>();\n+public interface ASMHelper {\n+    String getClassCode(Class<?> cl);\n+    String getClassCode(java.lang.reflect.Type type);\n+    ClassWriter createClassWriter();\n+    ASMType getType(String type);\n+    Label createLabel();\n+    OpcodesProxy getOpCodes();\n+    Class<?> getASMClass() throws ClassNotFoundException;\n+    String getMethodSignature(Method m);\n+    String getNonPrimitive(Class<?> tp);\n+    String getPrimitive(Class<?> tp);\n+    void setBadASM(boolean b);", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java b/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java\nindex 6c3e8e5edd..16a79d9975 100644\n--- a/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java\n+++ b/core/src/main/java/org/apache/cxf/common/util/ASMHelper.java\n\n@@ -37,7 +37,6 @@ public interface ASMHelper {\n     String getMethodSignature(Method m);\n     String getNonPrimitive(Class<?> tp);\n     String getPrimitive(Class<?> tp);\n-    void setBadASM(boolean b);\n \n     public interface ASMType {\n         int getOpcode(int ireturn);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0ODY0Mg==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540348642", "bodyText": "Please use Method m = helper.getClass().getMethod(\"setBadASM\", Boolean.TYPE);", "author": "reta", "createdAt": "2020-12-10T17:14:37Z", "path": "systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/ClientServerMiscTest.java", "diffHunk": "@@ -419,9 +420,11 @@ public void testWrappedHolderOutNull() throws Exception {\n     }\n \n     private void setASM(boolean b) throws Exception {\n-        Field f = ASMHelper.class.getDeclaredField(\"badASM\");\n-        ReflectionUtil.setAccessible(f);\n-        f.set(null, !b);\n+\n+        ASMHelper helper = getBus().getExtension(ASMHelper.class);\n+        Method m = ASMHelper.class.getMethod(\"setBadASM\", Boolean.TYPE);", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/ClientServerMiscTest.java b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/ClientServerMiscTest.java\nindex daf864cc79..c75e6e0727 100644\n--- a/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/ClientServerMiscTest.java\n+++ b/systests/jaxws/src/test/java/org/apache/cxf/systest/jaxws/ClientServerMiscTest.java\n\n@@ -422,7 +422,7 @@ public class ClientServerMiscTest extends AbstractBusClientServerTestBase {\n     private void setASM(boolean b) throws Exception {\n \n         ASMHelper helper = getBus().getExtension(ASMHelper.class);\n-        Method m = ASMHelper.class.getMethod(\"setBadASM\", Boolean.TYPE);\n+        Method m = helper.getClass().getMethod(\"setBadASM\", Boolean.TYPE);\n         ReflectionUtil.setAccessible(m);\n         m.invoke(helper, !b);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2Mzk2Mw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540363963", "bodyText": "It seems like we did shortcut here by not passing the bus, could you please add Bus to method arguments? The bus instance is present in all flows, just needs to be passed around: CorbaConduit / CorbaDestination / CorbaServerConduit would need to be modified to accept Bus in constructors, and in CorbaStreamInInterceptor you could get the bus from exchange instance available in place.", "author": "reta", "createdAt": "2020-12-10T17:36:16Z", "path": "rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java", "diffHunk": "@@ -272,258 +266,20 @@ public static void extractPrimitiveFromAny(Any a, CorbaPrimitiveHandler primitiv\n         IDL_TO_SCHEMA_TYPES.put(CorbaConstants.NT_CORBA_ANY, W3CConstants.NT_SCHEMA_ANYTYPE);\n     }\n \n-    private static Any createFixedAny(ORB orb, Any any) {\n-        createFixedAnyConstructor();\n+    private static synchronized Any createFixedAny(ORB orb, Any any) {\n+        if (fixedAnyConstructor == null) {\n+            CorbaFixedAnyImplGenerator corbaFixedAnyImplGenerator = new CorbaFixedAnyImplGenerator(null);", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java b/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java\nindex 083142985d..533719394e 100644\n--- a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java\n+++ b/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaAnyHelper.java\n\n@@ -266,10 +267,11 @@ public final class CorbaAnyHelper {\n         IDL_TO_SCHEMA_TYPES.put(CorbaConstants.NT_CORBA_ANY, W3CConstants.NT_SCHEMA_ANYTYPE);\n     }\n \n-    private static synchronized Any createFixedAny(ORB orb, Any any) {\n+    private static synchronized Any createFixedAny(ORB orb, Any any, Bus bus) {\n         if (fixedAnyConstructor == null) {\n-            CorbaFixedAnyImplGenerator corbaFixedAnyImplGenerator = new CorbaFixedAnyImplGenerator(null);\n-            Class<?> c = corbaFixedAnyImplGenerator.createFixedAnyClass();\n+            CorbaFixedAnyImplClassCreator corbaFixedAnyImplClassCreator =\n+                    bus.getExtension(CorbaFixedAnyImplClassCreator.class);\n+            Class<?> c = corbaFixedAnyImplClassCreator.createFixedAnyClass();\n             try {\n                 fixedAnyConstructor = c.getConstructor(ORB.class, Any.class);\n             } catch (Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2NTk1Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540365956", "bodyText": "Please declare srv as private final", "author": "reta", "createdAt": "2020-12-10T17:38:39Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxb;\n+\n+import org.apache.cxf.Bus;\n+\n+public class FactoryClassProxyService implements FactoryClassCreator {\n+    FactoryClassCreator srv;", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java\nindex e0c20a8f4d..0d82b781c5 100644\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java\n+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/FactoryClassProxyService.java\n\n@@ -21,7 +21,7 @@ package org.apache.cxf.jaxb;\n import org.apache.cxf.Bus;\n \n public class FactoryClassProxyService implements FactoryClassCreator {\n-    FactoryClassCreator srv;\n+    private final FactoryClassCreator srv;\n     public FactoryClassProxyService(Bus bus) {\n         this(new FactoryClassGenerator(bus));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3NjM0OA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540376348", "bodyText": "I think we have to rename it to WrapperHelperClassGenerator to be on par with WrapperHelperClassLoader and others: FactoryClassGenerator / FactoryClassLoader, etc.", "author": "reta", "createdAt": "2020-12-10T17:52:22Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java", "diffHunk": "@@ -24,78 +24,43 @@\n \n import javax.xml.bind.JAXBElement;\n \n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.spi.ClassGeneratorClassLoader;\n import org.apache.cxf.common.util.ASMHelper;\n+import org.apache.cxf.common.util.OpcodesProxy;\n+import org.apache.cxf.common.util.StringUtils;\n import org.apache.cxf.databinding.WrapperHelper;\n \n-final class WrapperHelperCompiler extends ASMHelper {\n-\n-\n-    final Class<?> wrapperType;\n-    final Method[] setMethods;\n-    final Method[] getMethods;\n-    final Method[] jaxbMethods;\n-    final Field[] fields;\n-    final Object objectFactory;\n-    final ClassWriter cw;\n-\n-    private WrapperHelperCompiler(Class<?> wrapperType,\n-                                  Method[] setMethods,\n-                                  Method[] getMethods,\n-                                  Method[] jaxbMethods,\n-                                  Field[] fields,\n-                                  Object objectFactory) {\n-        this.wrapperType = wrapperType;\n-        this.setMethods = setMethods;\n-        this.getMethods = getMethods;\n-        this.jaxbMethods = jaxbMethods;\n-        this.fields = fields;\n-        this.objectFactory = objectFactory;\n-        cw = createClassWriter();\n-    }\n+public final class WrapperHelperCompiler extends ClassGeneratorClassLoader implements WrapperHelperCreator {", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassGenerator.java\nsimilarity index 99%\nrename from rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java\nrename to rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassGenerator.java\nindex 51cbc6ceef..c01d6c4137 100644\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperCompiler.java\n+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperClassGenerator.java\n\n@@ -31,9 +31,9 @@ import org.apache.cxf.common.util.OpcodesProxy;\n import org.apache.cxf.common.util.StringUtils;\n import org.apache.cxf.databinding.WrapperHelper;\n \n-public final class WrapperHelperCompiler extends ClassGeneratorClassLoader implements WrapperHelperCreator {\n+public final class WrapperHelperClassGenerator extends ClassGeneratorClassLoader implements WrapperHelperCreator {\n \n-    WrapperHelperCompiler(Bus bus) {\n+    WrapperHelperClassGenerator(Bus bus) {\n         super(bus);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3Njc3Ng==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540376776", "bodyText": "Please declare srv as private final", "author": "reta", "createdAt": "2020-12-10T17:53:01Z", "path": "rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperProxyService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxb;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.databinding.WrapperHelper;\n+\n+public class WrapperHelperProxyService implements WrapperHelperCreator {\n+    WrapperHelperCreator srv;", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperProxyService.java b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperProxyService.java\nindex 1dd84f8a14..5205264aed 100644\n--- a/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperProxyService.java\n+++ b/rt/databinding/jaxb/src/main/java/org/apache/cxf/jaxb/WrapperHelperProxyService.java\n\n@@ -25,9 +25,9 @@ import org.apache.cxf.Bus;\n import org.apache.cxf.databinding.WrapperHelper;\n \n public class WrapperHelperProxyService implements WrapperHelperCreator {\n-    WrapperHelperCreator srv;\n+    private final WrapperHelperCreator srv;\n     public WrapperHelperProxyService(Bus bus) {\n-        this(new WrapperHelperCompiler(bus));\n+        this(new WrapperHelperClassGenerator(bus));\n     }\n     public WrapperHelperProxyService(WrapperHelperCreator srv) {\n         super();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3ODc0Nw==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540378747", "bodyText": "Please declare srv as private final", "author": "reta", "createdAt": "2020-12-10T17:55:55Z", "path": "rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxws.spi;\n+\n+import java.util.Set;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.jaxws.WrapperClassGenerator;\n+import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n+import org.apache.cxf.service.model.InterfaceInfo;\n+\n+public class WrapperClassCreatorProxyService implements WrapperClassCreator {\n+    WrapperClassCreator srv;", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java\nindex 3d99d04398..75ea8db383 100644\n--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java\n+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassCreatorProxyService.java\n\n@@ -26,7 +26,7 @@ import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n import org.apache.cxf.service.model.InterfaceInfo;\n \n public class WrapperClassCreatorProxyService implements WrapperClassCreator {\n-    WrapperClassCreator srv;\n+    private final WrapperClassCreator srv;\n     public WrapperClassCreatorProxyService(final Bus bus) {\n         this(new WrapperClassGenerator(bus));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5MTYzMQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540391631", "bodyText": "Please rename to WrapperClassLoader to follow the convention:  ExceptionClassGenerator / ExceptionClassLoader, WrapperHelperClassLoader / WrapperHelperClassGenerator", "author": "reta", "createdAt": "2020-12-10T18:15:04Z", "path": "rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.jaxws.spi;\n+\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.common.spi.GeneratedClassClassLoader;\n+import org.apache.cxf.common.util.PackageUtils;\n+import org.apache.cxf.common.util.StringUtils;\n+import org.apache.cxf.jaxws.WrapperClassGenerator;\n+import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n+import org.apache.cxf.service.model.InterfaceInfo;\n+import org.apache.cxf.service.model.MessageInfo;\n+import org.apache.cxf.service.model.MessagePartInfo;\n+import org.apache.cxf.service.model.OperationInfo;\n+import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n+\n+/** If class has been generated during build time\n+ *  (use @see org.apache.cxf.common.spi.GeneratedClassClassLoaderCapture capture to save bytes)\n+ *  you can set class loader to avoid class generation during runtime:\n+ *  bus.setExtension(new GeneratedWrapperClassLoader(bus), WrapperClassCreator.class);\n+ * @author olivier dufour\n+ */\n+public class GeneratedWrapperClassLoader extends GeneratedClassClassLoader implements WrapperClassCreator {", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassLoader.java\nsimilarity index 96%\nrename from rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java\nrename to rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassLoader.java\nindex d12080bb16..dfaf195996 100644\n--- a/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/GeneratedWrapperClassLoader.java\n+++ b/rt/frontend/jaxws/src/main/java/org/apache/cxf/jaxws/spi/WrapperClassLoader.java\n\n@@ -40,8 +40,8 @@ import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n  *  bus.setExtension(new GeneratedWrapperClassLoader(bus), WrapperClassCreator.class);\n  * @author olivier dufour\n  */\n-public class GeneratedWrapperClassLoader extends GeneratedClassClassLoader implements WrapperClassCreator {\n-    public GeneratedWrapperClassLoader(Bus bus) {\n+public class WrapperClassLoader extends GeneratedClassClassLoader implements WrapperClassCreator {\n+    public WrapperClassLoader(Bus bus) {\n         super(bus);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5MzI3NA==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540393274", "bodyText": "Please declare srv as private final", "author": "reta", "createdAt": "2020-12-10T18:17:35Z", "path": "rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassCreatorProxyService.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.endpoint.dynamic;\n+\n+import org.apache.cxf.Bus;\n+\n+public class ExceptionClassCreatorProxyService implements ExceptionClassCreator {\n+    ExceptionClassCreator srv;", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassCreatorProxyService.java b/rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassCreatorProxyService.java\nindex 39707e097d..0fb73d8e2d 100644\n--- a/rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassCreatorProxyService.java\n+++ b/rt/frontend/simple/src/main/java/org/apache/cxf/endpoint/dynamic/ExceptionClassCreatorProxyService.java\n\n@@ -21,7 +21,7 @@ package org.apache.cxf.endpoint.dynamic;\n import org.apache.cxf.Bus;\n \n public class ExceptionClassCreatorProxyService implements ExceptionClassCreator {\n-    ExceptionClassCreator srv;\n+    private final ExceptionClassCreator srv;\n     public ExceptionClassCreatorProxyService(Bus bus) {\n         this(new ExceptionClassGenerator(bus));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc0MzgxOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r540743819", "bodyText": "The length of this line breaks checkstyle (120 chars max)", "author": "coheigea", "createdAt": "2020-12-11T07:30:42Z", "path": "core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.common.spi;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.BusFactory;\n+import org.apache.cxf.common.util.StringUtils;\n+import org.apache.cxf.common.util.WeakIdentityHashMap;\n+\n+/** Class loader used to store and retrieve class generated during runtime to avoid class generation each time.\n+ *  inherited class use asmHelper to generate bytes and use @see #loadClass(String, Class&lt;?&gt;, byte[])\n+ *  or @see #loadClass(String, ClassLoader, byte[]) to store generated class.\n+ *  Class can be generated during buildtime. equivalent class is @see org.apache.cxf.common.spi.GeneratedClassClassLoader", "originalCommit": "72930d287d6e94e6ed742331bbf4f0d2ce645129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "chunk": "diff --git a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\nindex bbb37634cd..f7cc719fbe 100644\n--- a/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\n+++ b/core/src/main/java/org/apache/cxf/common/spi/ClassGeneratorClassLoader.java\n\n@@ -30,8 +30,8 @@ import org.apache.cxf.common.util.WeakIdentityHashMap;\n \n /** Class loader used to store and retrieve class generated during runtime to avoid class generation each time.\n  *  inherited class use asmHelper to generate bytes and use @see #loadClass(String, Class&lt;?&gt;, byte[])\n- *  or @see #loadClass(String, ClassLoader, byte[]) to store generated class.\n- *  Class can be generated during buildtime. equivalent class is @see org.apache.cxf.common.spi.GeneratedClassClassLoader\n+ *  or @see #loadClass(String, ClassLoader, byte[]) to store generated class.Class can be generated during buildtime.\n+ *  equivalent class is @see org.apache.cxf.common.spi.GeneratedClassClassLoader\n  * @author olivier dufour\n  */\n public class ClassGeneratorClassLoader {\n"}}, {"oid": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "url": "https://github.com/apache/cxf/commit/fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "message": "add corbaFixedAnyImpl service proxy", "committedDate": "2020-12-11T16:29:18Z", "type": "commit"}, {"oid": "434e67f54f6e5f800daac7d7be1f61bd423bc91e", "url": "https://github.com/apache/cxf/commit/434e67f54f6e5f800daac7d7be1f61bd423bc91e", "message": "fix corba unit test", "committedDate": "2020-12-12T10:29:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc1NjYyOQ==", "url": "https://github.com/apache/cxf/pull/721#discussion_r541756629", "bodyText": "Please also declare it private final", "author": "reta", "createdAt": "2020-12-12T19:43:06Z", "path": "rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplClassCreatorProxyService.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.cxf.binding.corba.utils;\n+\n+import org.apache.cxf.Bus;\n+\n+public class CorbaFixedAnyImplClassCreatorProxyService implements CorbaFixedAnyImplClassCreator {\n+    CorbaFixedAnyImplClassCreator srv;", "originalCommit": "fefcb7ab1a566ba00d6091a4a9d0cd3a93a6b8d0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ad85342ffdc7dcd521d3cc36a32f5eb7e3ba83b", "chunk": "diff --git a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplClassCreatorProxyService.java b/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplClassCreatorProxyService.java\nindex 6a9c0a7dce..bcdb1ca08b 100644\n--- a/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplClassCreatorProxyService.java\n+++ b/rt/bindings/corba/src/main/java/org/apache/cxf/binding/corba/utils/CorbaFixedAnyImplClassCreatorProxyService.java\n\n@@ -21,7 +21,7 @@ package org.apache.cxf.binding.corba.utils;\n import org.apache.cxf.Bus;\n \n public class CorbaFixedAnyImplClassCreatorProxyService implements CorbaFixedAnyImplClassCreator {\n-    CorbaFixedAnyImplClassCreator srv;\n+    private final CorbaFixedAnyImplClassCreator srv;\n     public CorbaFixedAnyImplClassCreatorProxyService(Bus bus) {\n         this(new CorbaFixedAnyImplGenerator(bus));\n     }\n"}}, {"oid": "0ad85342ffdc7dcd521d3cc36a32f5eb7e3ba83b", "url": "https://github.com/apache/cxf/commit/0ad85342ffdc7dcd521d3cc36a32f5eb7e3ba83b", "message": "few little improvment", "committedDate": "2020-12-13T08:06:47Z", "type": "commit"}]}