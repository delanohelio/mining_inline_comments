{"pr_number": 2662, "pr_title": "[java] UnnecessaryCaseChange can not detect the case like: foo.equals(bar.toLowerCase())", "pr_createdAt": "2020-07-24T08:39:37Z", "pr_url": "https://github.com/pmd/pmd/pull/2662", "timeline": [{"oid": "b8d878b4012de2211c253af185284ba3ae7943a2", "url": "https://github.com/pmd/pmd/commit/b8d878b4012de2211c253af185284ba3ae7943a2", "message": "[java] UnnecessaryCaseChange can not detect the case like: foo.equals(bar.toLowerCase())", "committedDate": "2020-07-24T08:25:14Z", "type": "commit"}, {"oid": "d69520f68fc68e40dc541604aa301246c8612ca7", "url": "https://github.com/pmd/pmd/commit/d69520f68fc68e40dc541604aa301246c8612ca7", "message": "UnnecessaryCaseChangeRule: NullPointerException in constructor fix", "committedDate": "2020-07-24T09:46:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg0NjUyOA==", "url": "https://github.com/pmd/pmd/pull/2662#discussion_r462846528", "bodyText": "We seem to visit only one type in this rule, so you can make use of the rulechain: https://pmd.github.io/latest/pmd_userdocs_extending_writing_java_rules.html#economic-traversal-the-rulechain", "author": "adangel", "createdAt": "2020-07-30T08:47:21Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "diffHunk": "@@ -4,83 +4,111 @@\n \n package net.sourceforge.pmd.lang.java.rule.errorprone;\n \n-import net.sourceforge.pmd.lang.ast.Node;\n+import static java.util.Arrays.asList;\n+\n+import java.util.List;\n+\n+import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\n+import net.sourceforge.pmd.lang.java.ast.ASTArguments;\n import net.sourceforge.pmd.lang.java.ast.ASTName;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n \n public class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n \n+    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n+    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n+\n     @Override\n-    public Object visit(ASTPrimaryExpression exp, Object data) {\n-        int n = exp.getNumChildren();\n-        if (n < 4) {\n-            return data;\n+    public Object visit(ASTPrimaryExpression expr, Object data) {\n+        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n+        if (caseChangingCallIndex != -1) {\n+            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n+            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n+                    || isArgumentOfEqualsMethodCall(expr)) {\n+                addViolation(data, expr);\n+            }\n         }\n+        return super.visit(expr, data);", "originalCommit": "d69520f68fc68e40dc541604aa301246c8612ca7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b205806124e668607fa7e9fe9db2bf901604def9", "chunk": "diff --git a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\nindex c407fc9d7d..cca861233a 100644\n--- a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n+++ b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n\n@@ -30,16 +30,18 @@ public class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n             if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                     || isArgumentOfEqualsMethodCall(expr)) {\n                 addViolation(data, expr);\n+                return data;\n             }\n         }\n         return super.visit(expr, data);\n     }\n \n     private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n-        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n-        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n+        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n+            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n             int callIndex = callArgsIndex - 1;\n-            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n+            JavaNode methodCall = expr.getChild(callIndex);\n+            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                 return callIndex;\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg0ODQ5OQ==", "url": "https://github.com/pmd/pmd/pull/2662#discussion_r462848499", "bodyText": "Just use sth. like this:\nfor (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n    int callIndex = callArgsIndex - 1;\n    JavaNode node = expr.getChild(callIndex);\n...\nThere is no need to search for children by type if you don't look for a specific type....\n}", "author": "adangel", "createdAt": "2020-07-30T08:50:37Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "diffHunk": "@@ -4,83 +4,111 @@\n \n package net.sourceforge.pmd.lang.java.rule.errorprone;\n \n-import net.sourceforge.pmd.lang.ast.Node;\n+import static java.util.Arrays.asList;\n+\n+import java.util.List;\n+\n+import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\n+import net.sourceforge.pmd.lang.java.ast.ASTArguments;\n import net.sourceforge.pmd.lang.java.ast.ASTName;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n \n public class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n \n+    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n+    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n+\n     @Override\n-    public Object visit(ASTPrimaryExpression exp, Object data) {\n-        int n = exp.getNumChildren();\n-        if (n < 4) {\n-            return data;\n+    public Object visit(ASTPrimaryExpression expr, Object data) {\n+        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n+        if (caseChangingCallIndex != -1) {\n+            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n+            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n+                    || isArgumentOfEqualsMethodCall(expr)) {\n+                addViolation(data, expr);\n+            }\n         }\n+        return super.visit(expr, data);\n+    }\n \n-        int first = getBadPrefixOrNull(exp, n);\n-        if (first == -1) {\n-            return data;\n+    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n+        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);", "originalCommit": "d69520f68fc68e40dc541604aa301246c8612ca7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b205806124e668607fa7e9fe9db2bf901604def9", "chunk": "diff --git a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\nindex c407fc9d7d..cca861233a 100644\n--- a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n+++ b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n\n@@ -30,16 +30,18 @@ public class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n             if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                     || isArgumentOfEqualsMethodCall(expr)) {\n                 addViolation(data, expr);\n+                return data;\n             }\n         }\n         return super.visit(expr, data);\n     }\n \n     private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n-        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n-        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n+        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n+            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n             int callIndex = callArgsIndex - 1;\n-            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n+            JavaNode methodCall = expr.getChild(callIndex);\n+            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                 return callIndex;\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg0OTM5MQ==", "url": "https://github.com/pmd/pmd/pull/2662#discussion_r462849391", "bodyText": "I think, it would make sense to integrate the null check into the method isNameOfCaseChangingMethod, wdyt?", "author": "adangel", "createdAt": "2020-07-30T08:52:10Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "diffHunk": "@@ -4,83 +4,111 @@\n \n package net.sourceforge.pmd.lang.java.rule.errorprone;\n \n-import net.sourceforge.pmd.lang.ast.Node;\n+import static java.util.Arrays.asList;\n+\n+import java.util.List;\n+\n+import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\n+import net.sourceforge.pmd.lang.java.ast.ASTArguments;\n import net.sourceforge.pmd.lang.java.ast.ASTName;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n \n public class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n \n+    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n+    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n+\n     @Override\n-    public Object visit(ASTPrimaryExpression exp, Object data) {\n-        int n = exp.getNumChildren();\n-        if (n < 4) {\n-            return data;\n+    public Object visit(ASTPrimaryExpression expr, Object data) {\n+        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n+        if (caseChangingCallIndex != -1) {\n+            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n+            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n+                    || isArgumentOfEqualsMethodCall(expr)) {\n+                addViolation(data, expr);\n+            }\n         }\n+        return super.visit(expr, data);\n+    }\n \n-        int first = getBadPrefixOrNull(exp, n);\n-        if (first == -1) {\n-            return data;\n+    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n+        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n+        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n+            int callIndex = callArgsIndex - 1;\n+            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n+                return callIndex;\n+            }\n         }\n+        return -1;\n+    }\n \n-        String second = getBadSuffixOrNull(exp, first + 2);\n-        if (second == null) {\n-            return data;\n-        }\n+    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n+        String methodName = getCalledMethodName(methodCall);\n+        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n+        return methodName != null\n+                && isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;", "originalCommit": "d69520f68fc68e40dc541604aa301246c8612ca7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b205806124e668607fa7e9fe9db2bf901604def9", "chunk": "diff --git a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\nindex c407fc9d7d..cca861233a 100644\n--- a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n+++ b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n\n@@ -30,16 +30,18 @@ public class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n             if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                     || isArgumentOfEqualsMethodCall(expr)) {\n                 addViolation(data, expr);\n+                return data;\n             }\n         }\n         return super.visit(expr, data);\n     }\n \n     private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n-        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n-        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n+        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n+            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n             int callIndex = callArgsIndex - 1;\n-            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n+            JavaNode methodCall = expr.getChild(callIndex);\n+            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                 return callIndex;\n             }\n         }\n"}}, {"oid": "b205806124e668607fa7e9fe9db2bf901604def9", "url": "https://github.com/pmd/pmd/commit/b205806124e668607fa7e9fe9db2bf901604def9", "message": "UnnecessaryCaseChangeRule: violation reporting fix", "committedDate": "2020-07-30T10:22:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUwMjIyMQ==", "url": "https://github.com/pmd/pmd/pull/2662#discussion_r463502221", "bodyText": "Since we don't use rule chain, you need to return super.visit(expr, data) here.... just returning data would skip nested classes etc.", "author": "adangel", "createdAt": "2020-07-31T09:21:17Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "diffHunk": "@@ -30,16 +30,18 @@ public Object visit(ASTPrimaryExpression expr, Object data) {\n             if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                     || isArgumentOfEqualsMethodCall(expr)) {\n                 addViolation(data, expr);\n+                return data;", "originalCommit": "b205806124e668607fa7e9fe9db2bf901604def9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUwNTIxOA==", "url": "https://github.com/pmd/pmd/pull/2662#discussion_r463505218", "bodyText": "Ohh, sorry. I thought it would be okay to skip processing nested expressions in case we have already reported a problem here. I'll fix that", "author": "Drofff", "createdAt": "2020-07-31T09:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUwMjIyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "eca547b5054814933f87f0718e0432bc2e27e5da", "chunk": "diff --git a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\nindex cca861233a..62512bedc8 100644\n--- a/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n+++ b/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java\n\n@@ -24,94 +21,102 @@ public class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n \n     @Override\n     public Object visit(ASTPrimaryExpression expr, Object data) {\n-        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n-        if (caseChangingCallIndex != -1) {\n-            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n-            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n-                    || isArgumentOfEqualsMethodCall(expr)) {\n-                addViolation(data, expr);\n-                return data;\n-            }\n+        if (hasUnnecessaryCaseChange(expr)) {\n+            addViolation(data, expr);\n         }\n         return super.visit(expr, data);\n     }\n \n-    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n-        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n-            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n-            int callIndex = callArgsIndex - 1;\n+    private boolean hasUnnecessaryCaseChange(ASTPrimaryExpression expr) {\n+        int equalsMethodCallIndex = getEqualsMethodCallIndex(expr);\n+        if (equalsMethodCallIndex != -1) {\n+            int equalsMethodCallArgsIndex = equalsMethodCallIndex + 1;\n+            ASTPrimaryExpression equalsCallArgs = getMethodCallArgsAtPosition(expr, equalsMethodCallArgsIndex);\n+            return anyHasCaseChangingMethodCall(expr, equalsCallArgs);\n+        }\n+        return false;\n+    }\n+\n+    private int getEqualsMethodCallIndex(ASTPrimaryExpression expr) {\n+        for (int callIndex = 0; callIndex < expr.getNumChildren(); callIndex++) {\n             JavaNode methodCall = expr.getChild(callIndex);\n-            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n+            if (isEqualsMethodCall(methodCall)) {\n                 return callIndex;\n             }\n         }\n         return -1;\n     }\n \n-    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n-        String methodName = getCalledMethodName(methodCall);\n-        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n-        return isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n+    private boolean isEqualsMethodCall(JavaNode methodCall) {\n+        return calledMethodHasNameFromList(methodCall, EQUALITY_METHODS);\n     }\n \n-    private String getCalledMethodName(JavaNode methodCall) {\n-        if (methodCall instanceof ASTPrimaryPrefix) {\n-            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n-            return methodName != null ? methodName.getImage() : null;\n+    private ASTPrimaryExpression getMethodCallArgsAtPosition(ASTPrimaryExpression expr, int argsPos) {\n+        if (hasChildAtPosition(expr, argsPos)) {\n+            JavaNode methodCallArgs = expr.getChild(argsPos);\n+            return methodCallArgs.getFirstDescendantOfType(ASTPrimaryExpression.class);\n         }\n-        return methodCall.getImage();\n+        return null;\n     }\n \n-    private boolean isNameOfCaseChangingMethod(String methodName) {\n-        if (methodName != null) {\n-            for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n-                if (methodName.endsWith(caseChangingMethod)) {\n-                    return true;\n-                }\n+    private boolean hasChildAtPosition(ASTPrimaryExpression expr, int pos) {\n+        return expr.getNumChildren() > pos;\n+    }\n+\n+    private boolean anyHasCaseChangingMethodCall(ASTPrimaryExpression ... exprs) {\n+        for (ASTPrimaryExpression expr : exprs) {\n+            if (expr != null && hasCaseChangingMethodCall(expr)) {\n+                return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n-        int argsPos = pos + 1;\n-        if (hasNodeAtPosition(expr, argsPos)) {\n-            JavaNode chainedMethodCall = expr.getChild(pos);\n-            JavaNode chainedMethodCallArgs = expr.getChild(argsPos);\n-            return isEqualsMethodCall(chainedMethodCall, chainedMethodCallArgs);\n+    private boolean hasCaseChangingMethodCall(ASTPrimaryExpression expr) {\n+        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n+            JavaNode methodCall = expr.getChild(callArgsIndex - 1);\n+            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n+            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n+                return true;\n+            }\n         }\n         return false;\n     }\n \n-    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n-        return pos < expr.getNumChildren();\n-    }\n-\n-    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n-        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n-        if (parentMethodCallArgs != null) {\n-            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n-            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n-            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n-            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n+    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n+        if (calledMethodHasNameFromList(methodCall, CASE_CHANGING_METHODS)) {\n+            ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n+            return args != null && args.size() == 0;\n         }\n         return false;\n     }\n \n-    private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n-        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n-        return parent instanceof ASTArgumentList\n-                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n-                : null;\n+    private boolean calledMethodHasNameFromList(JavaNode methodCall, List<String> nameList) {\n+        String methodName = getCalledMethodName(methodCall);\n+        if (methodName != null) {\n+            for (String nameFromList : nameList) {\n+                if (methodName.endsWith(nameFromList)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n     }\n \n-    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n-        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n-        return EQUALITY_METHODS.contains(methodCall.getImage()) && methodArgsCount == 1;\n+    private String getCalledMethodName(JavaNode methodCall) {\n+        String methodName = methodCall.getImage();\n+        if (methodName == null) {\n+            ASTName name = methodCall.getFirstDescendantOfType(ASTName.class);\n+            return name != null ? methodNameFromCallImage(name.getImage()) : null;\n+        }\n+        return methodName;\n     }\n \n-    private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n-        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n-        return args != null ? args.size() : -1;\n+    private String methodNameFromCallImage(String methodCallImage) {\n+        if (methodCallImage.contains(\".\")) {\n+            String[] callParts = methodCallImage.split(\"\\\\.\");\n+            return callParts[1];\n+        }\n+        return methodCallImage;\n     }\n }\n"}}, {"oid": "eca547b5054814933f87f0718e0432bc2e27e5da", "url": "https://github.com/pmd/pmd/commit/eca547b5054814933f87f0718e0432bc2e27e5da", "message": "UnnecessaryCaseChangeRule: nested expressions traversing fix", "committedDate": "2020-08-01T21:54:27Z", "type": "commit"}]}