{"pr_number": 2195, "pr_title": "[modelica] Normalize invalid node ranges", "pr_createdAt": "2020-01-03T11:30:13Z", "pr_url": "https://github.com/pmd/pmd/pull/2195", "timeline": [{"oid": "4f3db86a7087d706e0946f99efff049a111be6e1", "url": "https://github.com/pmd/pmd/commit/4f3db86a7087d706e0946f99efff049a111be6e1", "message": "[modelica] Normalize invalid node ranges\n\nSome files were parsed into ASTs with nodes having negative ranges.\nFor example:\n\npackage TestPackage\n  package EmptyPackage\n  end EmptyPackage;\nend TestPackage;\n\nhas subtree:\n\n  SimpleLongClassSpecifier \"EmptyPackage\"\n    SimpleName \"EmptyPackage\"\n    Composition\n      ElementList <-- start = 3:3, end = 2:22\n    SimpleName \"EmptyPackage\"", "committedDate": "2020-01-03T11:29:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r362961364", "bodyText": "You could avoid doing any of that (in jjtOpen/Close) if instead of using the fields of AbstractNode, you delegated the method calls to the tokens, eg:\n\n  \n    \n      pmd/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaNode.java\n    \n    \n        Lines 33 to 51\n      in\n      a802874\n    \n    \n    \n    \n\n        \n          \n           @Override \n        \n\n        \n          \n           public int getBeginLine() { \n        \n\n        \n          \n               return jjtGetFirstToken().getBeginLine(); \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           @Override \n        \n\n        \n          \n           public int getBeginColumn() { \n        \n\n        \n          \n               return jjtGetFirstToken().getBeginColumn(); \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           @Override \n        \n\n        \n          \n           public int getEndLine() { \n        \n\n        \n          \n               return jjtGetLastToken().getEndLine(); \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           @Override \n        \n\n        \n          \n           public int getEndColumn() { \n        \n\n        \n          \n               return jjtGetLastToken().getEndColumn(); \n        \n\n        \n          \n           }", "author": "oowekyala", "createdAt": "2020-01-03T21:06:42Z", "path": "pmd-modelica/src/main/java/net/sourceforge/pmd/lang/modelica/ast/AbstractModelicaNode.java", "diffHunk": "@@ -66,6 +66,14 @@ public void jjtClose() {\n         }\n         endLine = parser.token.endLine;\n         endColumn = parser.token.endColumn;\n+\n+        if (endLine < beginLine) {", "originalCommit": "4f3db86a7087d706e0946f99efff049a111be6e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3NDE5Mg==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r363074192", "bodyText": "Thanks, this definitely looks significantly less hackish. Unfortunately, some nodes end up not containing any tokens (like in the example above), leading to invalid ranges. Are such grammars invalid or maybe it is a minor issue in common code?", "author": "atrosinenko", "createdAt": "2020-01-05T07:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3NDYxNg==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r363074616", "bodyText": "The range [3:3, 2:22] for ElemementList suggests that [FirstToken, LastToken] takes the form [t, t-1]", "author": "atrosinenko", "createdAt": "2020-01-05T07:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwNzE3Ng==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r363107176", "bodyText": "I'd first create a unit test, that verifies the locations of the nodes in the given code example. Then you can be sure, that a) the bug is fixed, b) it is not reintroduced later on.\nThe grammar creates the node ElementList, even though, there are no Element children. You can avoid creating the ElementList node by using a conditional node in the grammar:\n-void ElementList(Visibility v): {}\n+void ElementList(Visibility v) #ElementList(>1): {}\n(see line 353 in Modelica.jjt)\nWhether this makes sense here, I can't say. You seem to set the visibility on the node, although it is always \"UNSPEC\". The same would need to be applied for the node Composition and possibly other nodes.", "author": "adangel", "createdAt": "2020-01-05T17:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwNzgzMw==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r363107833", "bodyText": "I thought on making this node conditional. On one hand, it cleans up the AST and in this particular case it may be the best solution. On the other hand, it is interesting, whether either some generic solution exists or such token-free subtrees are explicitly considered an issue.\nRelated to previous, on adding a test: it do exists, but in SCM repo. I agree, it is worth moving it here in slightly reduced form. It is still interesting, is this condition expected to hold for every language module?", "author": "atrosinenko", "createdAt": "2020-01-05T17:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwODIwMg==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r363108202", "bodyText": "You seem to set the visibility on the node, although it is always \"UNSPEC\".\n\nVisibility is public, private, etc. modifiers set in source file:\npackage TestPackage\npublic\n  package EmptyPackage\n  end EmptyPackage;\nend TestPackage;\nThis creates two ElementLists, one of them is PUBLIC. But, frankly speaking, I have never used such modifiers and not yet handle them in type resolution.", "author": "atrosinenko", "createdAt": "2020-01-05T18:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwOTI3NA==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r363109274", "bodyText": "Token free subtrees are not a bug, they're useful to make the parsed AST more regular. This is used for example in the Scala AST, and I'd like to introduce that in the Java AST in 7.0. It's probably just an oversight of JJTree not to handle this case, but we shouldn't limit PMD to it.\nI've pushed a solution, that uses an implicit zero-length token. I expect this is how we'll handle it in PMD 7 for the Java tree, though at that point we'll share the solution between language modules, and not do this ad-hoc in jjtClose (eg fixing JJTree).", "author": "oowekyala", "createdAt": "2020-01-05T18:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQwMTAzOQ==", "url": "https://github.com/pmd/pmd/pull/2195#discussion_r363401039", "bodyText": "FYI - we are using Javacc 5.0, which is a old version. It might be different with a newer javacc version.", "author": "adangel", "createdAt": "2020-01-06T17:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk2MTM2NA=="}], "type": "inlineReview", "revised_code": {"commit": "e9dbe0233facac2a907dce716e0a3376e96e2cc6", "chunk": "diff --git a/pmd-modelica/src/main/java/net/sourceforge/pmd/lang/modelica/ast/AbstractModelicaNode.java b/pmd-modelica/src/main/java/net/sourceforge/pmd/lang/modelica/ast/AbstractModelicaNode.java\nindex 89dfdb4b95..3b01d8cd40 100644\n--- a/pmd-modelica/src/main/java/net/sourceforge/pmd/lang/modelica/ast/AbstractModelicaNode.java\n+++ b/pmd-modelica/src/main/java/net/sourceforge/pmd/lang/modelica/ast/AbstractModelicaNode.java\n\n@@ -49,30 +57,66 @@ abstract class AbstractModelicaNode extends AbstractNode implements Node, Modeli\n     }\n \n     @Override\n-    public void jjtOpen() {\n-        if (beginLine == -1 && parser.token.next != null) {\n-            beginLine = parser.token.next.beginLine;\n-            beginColumn = parser.token.next.beginColumn;\n-        }\n+    public int getBeginLine() {\n+        return jjtGetFirstToken().getBeginLine();\n+    }\n+\n+    @Override\n+    public int getBeginColumn() {\n+        return jjtGetFirstToken().getBeginColumn();\n+    }\n+\n+    @Override\n+    public int getEndLine() {\n+        return jjtGetLastToken().getEndLine();\n+    }\n+\n+    @Override\n+    public int getEndColumn() {\n+        return jjtGetLastToken().getEndColumn();\n     }\n \n     @Override\n     public void jjtClose() {\n-        if (beginLine == -1 && (children == null || children.length == 0)) {\n-            beginColumn = parser.token.beginColumn;\n-        }\n-        if (beginLine == -1) {\n-            beginLine = parser.token.beginLine;\n-        }\n-        endLine = parser.token.endLine;\n-        endColumn = parser.token.endColumn;\n \n-        if (endLine < beginLine) {\n-            beginLine = endLine;\n-            beginColumn = endColumn;\n+        // in jjtClose, jjtSetLastToken has not been called yet, so we use parser.token.next\n+        if (parser.token.next == jjtGetFirstToken()) {\n+            // Reversed, this node consumed no token.\n+            // Forge a token with the correct coordinates, and zero length\n+\n+            Token next = parser.token.next;\n+\n+            Token implicit = new Token(IMPLICIT_TOKEN);\n+            implicit.beginColumn = next.beginColumn;\n+            implicit.endColumn = next.beginColumn - 1; // because of inclusive columns..\n+            implicit.beginLine = next.beginLine;\n+            implicit.endLine = next.beginLine;\n+\n+            // insert it right before the next token\n+            // as a special token\n+            implicit.next = next;\n+\n+            if (next.specialToken != null) {\n+                next.specialToken.next = implicit;\n+                implicit.specialToken = next.specialToken;\n+            }\n+\n+            next.specialToken = implicit;\n+\n+\n+            // set it as both first and last\n+            // beware, JJTree calls jjtSetLastToken after this routine..\n+            // hence the override below\n+            jjtSetFirstToken(implicit);\n+            jjtSetLastToken(implicit);\n         }\n-        if (endLine == beginLine && endColumn < beginColumn) {\n-            beginColumn = endColumn;\n+    }\n+\n+    @Override\n+    public void jjtSetLastToken(GenericToken token) {\n+        // don't let jjtree override tokens we've chosen\n+        if (lastToken != null) {\n+            super.jjtSetLastToken(token);\n         }\n     }\n \n"}}, {"oid": "e9dbe0233facac2a907dce716e0a3376e96e2cc6", "url": "https://github.com/pmd/pmd/commit/e9dbe0233facac2a907dce716e0a3376e96e2cc6", "message": "Use implicit zero-length token in modelica", "committedDate": "2020-01-05T18:06:32Z", "type": "commit"}, {"oid": "6f61522971773d62f97e433a324c9d6a898bc732", "url": "https://github.com/pmd/pmd/commit/6f61522971773d62f97e433a324c9d6a898bc732", "message": "Test", "committedDate": "2020-01-05T18:22:17Z", "type": "commit"}, {"oid": "394de28a0d3c0ee7dee91a25f3100ac884fd3511", "url": "https://github.com/pmd/pmd/commit/394de28a0d3c0ee7dee91a25f3100ac884fd3511", "message": "Set image", "committedDate": "2020-01-05T18:32:09Z", "type": "commit"}]}