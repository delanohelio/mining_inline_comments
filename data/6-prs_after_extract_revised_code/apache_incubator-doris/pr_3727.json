{"pr_number": 3727, "pr_title": "(#3726) [Spark Load] Rollup Tree Builder", "pr_createdAt": "2020-05-29T11:59:44Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3727", "timeline": [{"oid": "8ab591f737206c55d0706e53979c4ca7c635edbe", "url": "https://github.com/apache/incubator-doris/commit/8ab591f737206c55d0706e53979c4ca7c635edbe", "message": "(#3726) [Spark Load] Rollup Tree Builder", "committedDate": "2020-05-29T11:57:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0MDA3Mg==", "url": "https://github.com/apache/incubator-doris/pull/3727#discussion_r443140072", "bodyText": "seems to be not needed", "author": "wyb", "createdAt": "2020-06-20T15:43:59Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2.dpp;\n+\n+import org.apache.doris.load.loadv2.etl.EtlJobConfig;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+// Build RollupTree by using minimum coverage strategy,\n+// which is to find the index with the minimum columns that\n+// has all columns of rollup index as parent index node.\n+// Eg:\n+// There are three indexes:\n+//   index1(c1, c2, c3, c4, c5)\n+//   index2(c1, c2, c4)\n+//   index3(c1, c2)\n+//   index4(c3, c4)\n+//   index5(c1, c2, c5)\n+// then the result tree is:\n+//          index1\n+//      |     \\      \\\n+//  index2  index4   index5\n+//    |\n+//  index3\n+// Now, if there are more than one indexes meet the column coverage requirement,\n+// have the same column size(eg: index2 vs index5), child rollup is preferred\n+// builded from the front index(eg: index3 is the child of index2). This can be\n+// further optimized based on the row number of the index.\n+public class MinimumCoverageRollupTreeBuilder implements RollupTreeBuilder {\n+    public RollupTreeNode build(EtlJobConfig.EtlTable tableMeta) {\n+        List<EtlJobConfig.EtlIndex> indexes = tableMeta.indexes;\n+        List<EtlJobConfig.EtlIndex> indexMetas = new ArrayList<>();\n+        EtlJobConfig.EtlIndex baseIndex = null;\n+        for (EtlJobConfig.EtlIndex indexMeta : indexes) {\n+            if (indexMeta.isBaseIndex) {\n+                baseIndex = indexMeta;\n+                continue;\n+            }\n+            indexMetas.add(indexMeta);\n+        }\n+        List<EtlJobConfig.EtlColumn> baseIndexColumns = baseIndex.columns;\n+        List<String> baseKeyColumns = new ArrayList<>();\n+        List<String> baseValueColumns = new ArrayList<>();\n+        for (EtlJobConfig.EtlColumn columnMeta : baseIndexColumns) {\n+            if (columnMeta.isKey) {\n+                baseKeyColumns.add(columnMeta.columnName);\n+            } else {\n+                baseValueColumns.add(columnMeta.columnName);\n+            }\n+        }\n+        RollupTreeNode root = new RollupTreeNode();\n+        root.parent = null;\n+        root.keyColumnNames = baseKeyColumns;\n+        root.valueColumnNames = baseValueColumns;\n+        root.indexId = baseIndex.indexId;\n+        root.indexMeta = baseIndex;\n+\n+        // sort the index metas to make sure the column number decrease\n+        Collections.sort(indexMetas, new EtlJobConfig.EtlIndexComparator().reversed());\n+        boolean[] flags = new boolean[indexMetas.size()];\n+        for (int i = 0; i < indexMetas.size(); ++i) {\n+            flags[i] = false;\n+        }\n+        for (int i = 0; i < indexMetas.size(); ++i) {\n+            List<String> keyColumns = new ArrayList<>();\n+            List<String> valueColumns = new ArrayList<>();\n+            for (EtlJobConfig.EtlColumn column : indexMetas.get(i).columns) {\n+                if (column.isKey) {\n+                    keyColumns.add(column.columnName);\n+                } else {\n+                    valueColumns.add(column.columnName);\n+                }\n+            }\n+            insertIndex(root, indexMetas.get(i), keyColumns, valueColumns, i, flags);\n+        }\n+        return root;\n+    }\n+\n+    // DFS traverse to build the rollup tree\n+    private void insertIndex(RollupTreeNode root, EtlJobConfig.EtlIndex indexMeta,\n+                             List<String> keyColumns,\n+                             List<String> valueColumns, int id, boolean[] flags) {\n+        if (root.children != null) {\n+            for (RollupTreeNode child : root.children) {\n+                insertIndex(child, indexMeta, keyColumns, valueColumns, id, flags);\n+                if (flags[id]) {\n+                    return;\n+                }\n+            }\n+        }\n+        if (flags[id]) {", "originalCommit": "8ab591f737206c55d0706e53979c4ca7c635edbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3ODQ4Nw==", "url": "https://github.com/apache/incubator-doris/pull/3727#discussion_r443278487", "bodyText": "Recursive happends when root node has children, so it is needed", "author": "wangbo", "createdAt": "2020-06-22T01:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0MDA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "94237188fffb3e52550c1b9e809d34886e8d8bed", "chunk": "diff --git a/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java b/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java\nindex 4d62a9a4b..03d6f0949 100644\n--- a/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java\n+++ b/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java\n\n@@ -88,26 +88,29 @@ public class MinimumCoverageRollupTreeBuilder implements RollupTreeBuilder {\n                     valueColumns.add(column.columnName);\n                 }\n             }\n-            insertIndex(root, indexMetas.get(i), keyColumns, valueColumns, i, flags);\n+            if(!insertIndex(root, indexMetas.get(i), keyColumns, valueColumns)) {\n+                throw new RuntimeException(String.format(\"can't find a parent rollup for rollup %s, rollup tree is %s\", indexMetas.get(i).toString(),\n+                        root.toString()));\n+            }\n         }\n         return root;\n     }\n \n     // DFS traverse to build the rollup tree\n-    private void insertIndex(RollupTreeNode root, EtlJobConfig.EtlIndex indexMeta,\n+    // return true means we find a parent rollup for current rollup table\n+    private boolean insertIndex(RollupTreeNode root, EtlJobConfig.EtlIndex indexMeta,\n                              List<String> keyColumns,\n-                             List<String> valueColumns, int id, boolean[] flags) {\n+                             List<String> valueColumns) {\n+        // find suitable parent rollup from current node's children\n         if (root.children != null) {\n-            for (RollupTreeNode child : root.children) {\n-                insertIndex(child, indexMeta, keyColumns, valueColumns, id, flags);\n-                if (flags[id]) {\n-                    return;\n+            for (int i = root.children.size() - 1; i >= 0; i--) {\n+                if(insertIndex(root.children.get(i), indexMeta, keyColumns, valueColumns)){\n+                    return true;\n                 }\n             }\n         }\n-        if (flags[id]) {\n-            return;\n-        }\n+\n+        // find suitable parent rollup from current node\n         if (root.keyColumnNames.containsAll(keyColumns) && root.valueColumnNames.containsAll(valueColumns)) {\n             if (root.children == null) {\n                 root.children = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0MDM5OQ==", "url": "https://github.com/apache/incubator-doris/pull/3727#discussion_r443140399", "bodyText": "It's better to check from back.\nbase: c1,c2,c3,c4,c5\nrollup index1: c1,c2,c3,c4\nrollup index2: c1,c2,c5\nrollup index3: c1,c2\nIt is better that rollup index3 is the child of rollup index2 than rollup index1.", "author": "wyb", "createdAt": "2020-06-20T15:49:10Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2.dpp;\n+\n+import org.apache.doris.load.loadv2.etl.EtlJobConfig;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+// Build RollupTree by using minimum coverage strategy,\n+// which is to find the index with the minimum columns that\n+// has all columns of rollup index as parent index node.\n+// Eg:\n+// There are three indexes:\n+//   index1(c1, c2, c3, c4, c5)\n+//   index2(c1, c2, c4)\n+//   index3(c1, c2)\n+//   index4(c3, c4)\n+//   index5(c1, c2, c5)\n+// then the result tree is:\n+//          index1\n+//      |     \\      \\\n+//  index2  index4   index5\n+//    |\n+//  index3\n+// Now, if there are more than one indexes meet the column coverage requirement,\n+// have the same column size(eg: index2 vs index5), child rollup is preferred\n+// builded from the front index(eg: index3 is the child of index2). This can be\n+// further optimized based on the row number of the index.\n+public class MinimumCoverageRollupTreeBuilder implements RollupTreeBuilder {\n+    public RollupTreeNode build(EtlJobConfig.EtlTable tableMeta) {\n+        List<EtlJobConfig.EtlIndex> indexes = tableMeta.indexes;\n+        List<EtlJobConfig.EtlIndex> indexMetas = new ArrayList<>();\n+        EtlJobConfig.EtlIndex baseIndex = null;\n+        for (EtlJobConfig.EtlIndex indexMeta : indexes) {\n+            if (indexMeta.isBaseIndex) {\n+                baseIndex = indexMeta;\n+                continue;\n+            }\n+            indexMetas.add(indexMeta);\n+        }\n+        List<EtlJobConfig.EtlColumn> baseIndexColumns = baseIndex.columns;\n+        List<String> baseKeyColumns = new ArrayList<>();\n+        List<String> baseValueColumns = new ArrayList<>();\n+        for (EtlJobConfig.EtlColumn columnMeta : baseIndexColumns) {\n+            if (columnMeta.isKey) {\n+                baseKeyColumns.add(columnMeta.columnName);\n+            } else {\n+                baseValueColumns.add(columnMeta.columnName);\n+            }\n+        }\n+        RollupTreeNode root = new RollupTreeNode();\n+        root.parent = null;\n+        root.keyColumnNames = baseKeyColumns;\n+        root.valueColumnNames = baseValueColumns;\n+        root.indexId = baseIndex.indexId;\n+        root.indexMeta = baseIndex;\n+\n+        // sort the index metas to make sure the column number decrease\n+        Collections.sort(indexMetas, new EtlJobConfig.EtlIndexComparator().reversed());\n+        boolean[] flags = new boolean[indexMetas.size()];\n+        for (int i = 0; i < indexMetas.size(); ++i) {\n+            flags[i] = false;\n+        }\n+        for (int i = 0; i < indexMetas.size(); ++i) {\n+            List<String> keyColumns = new ArrayList<>();\n+            List<String> valueColumns = new ArrayList<>();\n+            for (EtlJobConfig.EtlColumn column : indexMetas.get(i).columns) {\n+                if (column.isKey) {\n+                    keyColumns.add(column.columnName);\n+                } else {\n+                    valueColumns.add(column.columnName);\n+                }\n+            }\n+            insertIndex(root, indexMetas.get(i), keyColumns, valueColumns, i, flags);\n+        }\n+        return root;\n+    }\n+\n+    // DFS traverse to build the rollup tree\n+    private void insertIndex(RollupTreeNode root, EtlJobConfig.EtlIndex indexMeta,\n+                             List<String> keyColumns,\n+                             List<String> valueColumns, int id, boolean[] flags) {\n+        if (root.children != null) {\n+            for (RollupTreeNode child : root.children) {", "originalCommit": "8ab591f737206c55d0706e53979c4ca7c635edbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4MDE1MA==", "url": "https://github.com/apache/incubator-doris/pull/3727#discussion_r443280150", "bodyText": "For current Dpp implementation which every rollup need a shuffle, it's better to check from back.\nIf we change Dpp logic later which one level rollup shuffle once, we need to from head, because  we need to control the level the tree to reduce shuffle times.", "author": "wangbo", "createdAt": "2020-06-22T01:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0MDM5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "94237188fffb3e52550c1b9e809d34886e8d8bed", "chunk": "diff --git a/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java b/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java\nindex 4d62a9a4b..03d6f0949 100644\n--- a/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java\n+++ b/fe/src/main/java/org/apache/doris/load/loadv2/dpp/MinimumCoverageRollupTreeBuilder.java\n\n@@ -88,26 +88,29 @@ public class MinimumCoverageRollupTreeBuilder implements RollupTreeBuilder {\n                     valueColumns.add(column.columnName);\n                 }\n             }\n-            insertIndex(root, indexMetas.get(i), keyColumns, valueColumns, i, flags);\n+            if(!insertIndex(root, indexMetas.get(i), keyColumns, valueColumns)) {\n+                throw new RuntimeException(String.format(\"can't find a parent rollup for rollup %s, rollup tree is %s\", indexMetas.get(i).toString(),\n+                        root.toString()));\n+            }\n         }\n         return root;\n     }\n \n     // DFS traverse to build the rollup tree\n-    private void insertIndex(RollupTreeNode root, EtlJobConfig.EtlIndex indexMeta,\n+    // return true means we find a parent rollup for current rollup table\n+    private boolean insertIndex(RollupTreeNode root, EtlJobConfig.EtlIndex indexMeta,\n                              List<String> keyColumns,\n-                             List<String> valueColumns, int id, boolean[] flags) {\n+                             List<String> valueColumns) {\n+        // find suitable parent rollup from current node's children\n         if (root.children != null) {\n-            for (RollupTreeNode child : root.children) {\n-                insertIndex(child, indexMeta, keyColumns, valueColumns, id, flags);\n-                if (flags[id]) {\n-                    return;\n+            for (int i = root.children.size() - 1; i >= 0; i--) {\n+                if(insertIndex(root.children.get(i), indexMeta, keyColumns, valueColumns)){\n+                    return true;\n                 }\n             }\n         }\n-        if (flags[id]) {\n-            return;\n-        }\n+\n+        // find suitable parent rollup from current node\n         if (root.keyColumnNames.containsAll(keyColumns) && root.valueColumnNames.containsAll(valueColumns)) {\n             if (root.children == null) {\n                 root.children = new ArrayList<>();\n"}}, {"oid": "94237188fffb3e52550c1b9e809d34886e8d8bed", "url": "https://github.com/apache/incubator-doris/commit/94237188fffb3e52550c1b9e809d34886e8d8bed", "message": "1 remove flag[]\n2 find parent rollup from back", "committedDate": "2020-06-22T01:50:47Z", "type": "commit"}, {"oid": "f265586da94611fe9f70bf5da24822c3c73a09da", "url": "https://github.com/apache/incubator-doris/commit/f265586da94611fe9f70bf5da24822c3c73a09da", "message": "remove flag", "committedDate": "2020-06-22T03:37:52Z", "type": "commit"}, {"oid": "c1005dc2ffd5d0ffcfe07ca392a1cd1a4d11934e", "url": "https://github.com/apache/incubator-doris/commit/c1005dc2ffd5d0ffcfe07ca392a1cd1a4d11934e", "message": "Merge branch 'upstream_master' into rollup_tree_builder", "committedDate": "2020-06-22T04:21:35Z", "type": "commit"}]}