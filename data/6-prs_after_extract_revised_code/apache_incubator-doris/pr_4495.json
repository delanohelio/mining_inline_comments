{"pr_number": 4495, "pr_title": "[Bug] function str_to_date()'s behavior on BE and FE is inconsistent", "pr_createdAt": "2020-09-01T06:42:02Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4495", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNTE2OA==", "url": "https://github.com/apache/incubator-doris/pull/4495#discussion_r480905168", "bodyText": "Move these util methods to a single util class?", "author": "kangkaisen", "createdAt": "2020-09-01T07:12:55Z", "path": "fe/fe-core/src/main/java/org/apache/doris/analysis/DateLiteral.java", "diffHunk": "@@ -632,4 +669,435 @@ public long getSecond() {\n     public int hashCode() {\n         return 31 * super.hashCode() + Objects.hashCode(unixTimestamp(TimeZone.getDefault()));\n     }\n+\n+    // parset the date string value in 'value' by 'format' pattern.\n+    // return the next position to parse if hasSubVal is true.\n+    // throw InvalidFormatException if encounter errors.\n+    // this method is exaclty same as from_date_format_str() in be/src/runtime/datetime_value.cpp\n+    // change this method should also change that.\n+    public int fromDateFormatStr(String format, String value, boolean hasSubVal) throws InvalidFormatException {", "originalCommit": "f08da9836d61aa034df6ea17bddb30a6907245bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0NzM4NA==", "url": "https://github.com/apache/incubator-doris/pull/4495#discussion_r481747384", "bodyText": "It is now only used for DateLiteral, and this method is also in datetime_value.cpp in BE.\nSo I think we can just leave it here.", "author": "morningman", "createdAt": "2020-09-02T05:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg2ODkzMA==", "url": "https://github.com/apache/incubator-doris/pull/4495#discussion_r481868930", "bodyText": "Ok. I think the Literal class should be simple. But which isn't a big issue.", "author": "kangkaisen", "createdAt": "2020-09-02T08:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNTE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "ac28b2e996539c486ca860fe7d0919871107207a", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/analysis/DateLiteral.java b/fe/fe-core/src/main/java/org/apache/doris/analysis/DateLiteral.java\nindex 732b8943c..993f61fbe 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/analysis/DateLiteral.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/analysis/DateLiteral.java\n\n@@ -669,435 +633,4 @@ public class DateLiteral extends LiteralExpr {\n     public int hashCode() {\n         return 31 * super.hashCode() + Objects.hashCode(unixTimestamp(TimeZone.getDefault()));\n     }\n-\n-    // parset the date string value in 'value' by 'format' pattern.\n-    // return the next position to parse if hasSubVal is true.\n-    // throw InvalidFormatException if encounter errors.\n-    // this method is exaclty same as from_date_format_str() in be/src/runtime/datetime_value.cpp\n-    // change this method should also change that.\n-    public int fromDateFormatStr(String format, String value, boolean hasSubVal) throws InvalidFormatException {\n-        int fp = 0; // pointer to the current format string\n-        int fend = format.length(); // end of format string\n-        int vp = 0; // pointer to the date string value\n-        int vend = value.length(); // end of date string value\n-\n-        boolean datePartUsed = false;\n-        boolean timePartUsed = false;\n-\n-        int dayPart = 0;\n-        long weekday = -1;\n-        long yearday = -1;\n-        long weekNum = -1;\n-\n-        boolean strictWeekNumber = false;\n-        boolean sundayFirst = false;\n-        boolean strictWeekNumberYearType = false;\n-        long strictWeekNumberYear = -1;\n-        boolean usaTime = false;\n-\n-        char f;\n-        while (fp < fend && vp < vend) {\n-            // Skip space character\n-            while (vp < vend && Character.isSpaceChar(value.charAt(vp))) {\n-                vp++;\n-            }\n-            if (vp >= vend) {\n-                break;\n-            }\n-\n-            // Check switch\n-            f = format.charAt(fp);\n-            if (f == '%' && fp + 1 < fend) {\n-                int tmp = 0;\n-                long intValue = 0;\n-                fp++;\n-                f = format.charAt(fp);\n-                fp++;\n-                switch (f) {\n-                    // Year\n-                    case 'y':\n-                        // Year, numeric (two digits)\n-                        tmp = vp + Math.min(2, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        intValue += intValue >= 70 ? 1900 : 2000;\n-                        this.year = intValue;\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    case 'Y':\n-                        // Year, numeric, four digits\n-                        tmp = vp + Math.min(4, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        if (tmp - vp <= 2) {\n-                            intValue += intValue >= 70 ? 1900 : 2000;\n-                        }\n-                        this.year = intValue;\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    // Month\n-                    case 'm':\n-                    case 'c':\n-                        tmp = vp + Math.min(2, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        this.month = intValue;\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    case 'M': {\n-                        int nextPos = findWord(value, vp);\n-                        intValue = checkWord(MONTH_NAME_DICT, value.substring(vp, nextPos));\n-                        this.month = intValue;\n-                        vp = nextPos;\n-                        break;\n-                    }\n-                    case 'b': {\n-                        int nextPos = findWord(value, vp);\n-                        intValue = checkWord(MONTH_ABBR_NAME_DICT, value.substring(vp, nextPos));\n-                        this.month = intValue;\n-                        vp = nextPos;\n-                        break;\n-                    }\n-                    // Day\n-                    case 'd':\n-                    case 'e':\n-                        tmp = vp + Math.min(2, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        this.day = intValue;\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    case 'D':\n-                        tmp = vp + Math.min(2, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        this.day = intValue;\n-                        vp = tmp + Math.min(2, vend - tmp);\n-                        datePartUsed = true;\n-                        break;\n-                    // Hour\n-                    case 'h':\n-                    case 'I':\n-                    case 'l':\n-                        usaTime = true;\n-                        // Fall through\n-                    case 'k':\n-                    case 'H':\n-                        tmp = findNumber(value, vp, 2);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        this.hour = intValue;\n-                        vp = tmp;\n-                        timePartUsed = true;\n-                        break;\n-                    // Minute\n-                    case 'i':\n-                        tmp = vp + Math.min(2, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        this.minute = intValue;\n-                        vp = tmp;\n-                        timePartUsed = true;\n-                        break;\n-                    // Second\n-                    case 's':\n-                    case 'S':\n-                        tmp = vp + Math.min(2, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        this.second = intValue;\n-                        vp = tmp;\n-                        timePartUsed = true;\n-                        break;\n-                    // Micro second\n-                    case 'f':\n-                        // micro second is not supported, so just eat it and go one.\n-                        tmp = vp + Math.min(6, vend - vp);\n-                        vp = tmp;\n-                        break;\n-                    // AM/PM\n-                    case 'p':\n-                        if ((vend - vp) < 2 || Character.toUpperCase(value.charAt(vp + 1)) != 'M' || !usaTime) {\n-                            throw new InvalidFormatException(\"Invalid %p format\");\n-                        }\n-                        if (Character.toUpperCase(value.charAt(vp)) == 'P') {\n-                            // PM\n-                            dayPart = 12;\n-                        }\n-                        timePartUsed = true;\n-                        vp += 2;\n-                        break;\n-                    // Weekday\n-                    case 'W': {\n-                        int nextPos = findWord(value, vp);\n-                        intValue = checkWord(WEEK_DAY_NAME_DICT, value.substring(vp, nextPos));\n-                        intValue++;\n-                        weekday = intValue;\n-                        datePartUsed = true;\n-                        break;\n-                    }\n-                    case 'a': {\n-                        int nextPos = findWord(value, vp);\n-                        intValue = checkWord(WEEK_DAY_NAME_DICT, value.substring(vp, nextPos));\n-                        intValue++;\n-                        weekday = intValue;\n-                        datePartUsed = true;\n-                        break;\n-                    }\n-                    case 'w':\n-                        tmp = vp + Math.min(1, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        if (intValue >= 7) {\n-                            throw new InvalidFormatException(\"invalid day of week: \" + intValue);\n-                        }\n-                        if (intValue == 0) {\n-                            intValue = 7;\n-                        }\n-                        weekday = intValue;\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    case 'j':\n-                        tmp = vp + Math.min(3, vend - vp);\n-                        intValue = strToLong(value.substring(vp, tmp));\n-                        yearday = intValue;\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    case 'u':\n-                    case 'v':\n-                    case 'U':\n-                    case 'V':\n-                        sundayFirst = (format.charAt(fp - 1) == 'U' || format.charAt(fp - 1) == 'V');\n-                        // Used to check if there is %x or %X\n-                        strictWeekNumber = (format.charAt(fp - 1) == 'V' || format.charAt(fp - 1) == 'v');\n-                        tmp = vp + Math.min(2, vend - vp);\n-                        intValue = Long.valueOf(value.substring(vp, tmp));\n-                        weekNum = intValue;\n-                        if (weekNum > 53 || (strictWeekNumber && weekNum == 0)) {\n-                            throw new InvalidFormatException(\"invalid num of week: \" + weekNum);\n-                        }\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    // strict week number, must be used with %V or %v\n-                    case 'x':\n-                    case 'X':\n-                        strictWeekNumberYearType = (format.charAt(fp - 1) == 'X');\n-                        tmp = vp + Math.min(4, vend - vp);\n-                        intValue = Long.valueOf(value.substring(vp, tmp));\n-                        strictWeekNumberYear = intValue;\n-                        vp = tmp;\n-                        datePartUsed = true;\n-                        break;\n-                    case 'r':\n-                        tmp = fromDateFormatStr(\"%I:%i:%S %p\", value.substring(vp, vend), true);\n-                        vp = tmp;\n-                        timePartUsed = true;\n-                        break;\n-                    case 'T':\n-                        tmp = fromDateFormatStr(\"%H:%i:%S\", value.substring(vp, vend), true);\n-                        vp = tmp;\n-                        timePartUsed = true;\n-                        break;\n-                    case '.':\n-                        while (vp < vend && Character.toString(value.charAt(vp)).matches(\"\\\\p{Punct}\")) {\n-                            vp++;\n-                        }\n-                        break;\n-                    case '@':\n-                        while (vp < vend && Character.isLetter(value.charAt(vp))) {\n-                            vp++;\n-                        }\n-                        break;\n-                    case '#':\n-                        while (vp < vend && Character.isDigit(value.charAt(vp))) {\n-                            vp++;\n-                        }\n-                        break;\n-                    case '%': // %%, escape the %\n-                        if ('%' != value.charAt(vp)) {\n-                            throw new InvalidFormatException(\"invalid char after %: \" + value.charAt(vp));\n-                        }\n-                        vp++;\n-                        break;\n-                    default:\n-                        throw new InvalidFormatException(\"Invalid format pattern: \" + f);\n-                }\n-            } else if (format.charAt(fp) != ' ') {\n-                if (format.charAt(fp) != value.charAt(vp)) {\n-                    throw new InvalidFormatException(\"Invalid char: \" + value.charAt(vp) + \", expected: \" + format.charAt(fp));\n-                }\n-                fp++;\n-                vp++;\n-            } else {\n-                fp++;\n-            }\n-        }\n-\n-        // continue to iterate pattern if has\n-        // to find out if it has time part.\n-        while (fp < fend) {\n-            f = format.charAt(fp);\n-            if (f == '%' && fp + 1 < fend) {\n-                fp++;\n-                f = format.charAt(fp);\n-                fp++;\n-                switch (f) {\n-                    case 'H':\n-                    case 'h':\n-                    case 'I':\n-                    case 'i':\n-                    case 'k':\n-                    case 'l':\n-                    case 'r':\n-                    case 's':\n-                    case 'S':\n-                    case 'p':\n-                    case 'T':\n-                        timePartUsed = true;\n-                        break;\n-                    default:\n-                        break;\n-                }\n-            } else {\n-                fp++;\n-            }\n-        }\n-\n-        if (usaTime) {\n-            if (this.hour > 12 || this.hour < 1) {\n-                throw new InvalidFormatException(\"Invalid hour: \" + hour);\n-            }\n-            this.hour = (this.hour % 12) + dayPart;\n-        }\n-\n-        if (hasSubVal) {\n-            return vp;\n-        }\n-\n-        // Year day\n-        if (yearday > 0) {\n-            long days = calcDaynr(this.year, 1, 1) + yearday - 1;\n-            getDateFromDaynr(days);\n-        }\n-\n-        // weekday\n-        if (weekNum >= 0 && weekday > 0) {\n-            // Check\n-            if ((strictWeekNumber && (strictWeekNumberYear < 0\n-                    || strictWeekNumberYearType != sundayFirst))\n-                    || (!strictWeekNumber && strictWeekNumberYear >= 0)) {\n-                throw new InvalidFormatException(\"invalid week number\");\n-            }\n-            long days = calcDaynr(strictWeekNumber ? strictWeekNumberYear : this.year, 1, 1);\n-\n-            long weekday_b = calcWeekday(days, sundayFirst);\n-\n-            if (sundayFirst) {\n-                days += ((weekday_b == 0) ? 0 : 7) - weekday_b + (weekNum - 1) * 7 + weekday % 7;\n-            } else {\n-                days += ((weekday_b <= 3) ? 0 : 7) - weekday_b + (weekNum - 1) * 7 + weekday - 1;\n-            }\n-            getDateFromDaynr(days);\n-        }\n-\n-        // Compute timestamp type\n-        if (datePartUsed) {\n-            if (timePartUsed) {\n-                this.type = Type.DATETIME;\n-            } else {\n-                this.type = Type.DATE;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    private long strToLong(String l) throws InvalidFormatException {\n-        try {\n-            return Long.valueOf(l);\n-        } catch (NumberFormatException e) {\n-            throw new InvalidFormatException(e.getMessage());\n-        }\n-    }\n-\n-    // calculate the number of days from year 0000-00-00 to year-month-day\n-    private long calcDaynr(long year, long month, long day) {\n-        long delsum = 0;\n-        long y = year;\n-\n-        if (year == 0 && month == 0) {\n-            return 0;\n-        }\n-\n-        /* Cast to int to be able to handle month == 0 */\n-        delsum = 365 * y + 31 * (month - 1) + day;\n-        if (month <= 2) {\n-            // No leap year\n-            y--;\n-        } else {\n-            // This is great!!!\n-            // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n-            // 0, 0, 3, 3, 4, 4, 5, 5, 5,  6,  7,  8\n-            delsum -= (month * 4 + 23) / 10;\n-        }\n-        // Every 400 year has 97 leap year, 100, 200, 300 are not leap year.\n-        return delsum + y / 4 - y / 100 + y / 400;\n-    }\n-\n-    private long calcWeekday(long dayNr, boolean isSundayFirstDay) {\n-        return (dayNr + 5L + (isSundayFirstDay ? 1L : 0L)) % 7;\n-    }\n-\n-    private void getDateFromDaynr(long daynr) throws InvalidFormatException {\n-        if (daynr <= 0 || daynr > 3652424) {\n-            throw new InvalidFormatException(\"Invalid days to year: \" + daynr);\n-        }\n-        this.year = daynr / 365;\n-        long daysBeforeYear = 0;\n-        while (daynr < (daysBeforeYear = calcDaynr(this.year, 1, 1))) {\n-            this.year--;\n-        }\n-        long daysOfYear = daynr - daysBeforeYear + 1;\n-        int leapDay = 0;\n-        if (Year.isLeap(this.year)) {\n-            if (daysOfYear > 31 + 28) {\n-                daysOfYear--;\n-                if (daysOfYear == 31 + 28) {\n-                    leapDay = 1;\n-                }\n-            }\n-        }\n-        this.month = 1;\n-        while (daysOfYear > DAYS_IN_MONTH.get((int) this.month)) {\n-            daysOfYear -= DAYS_IN_MONTH.get((int) this.month);\n-            this.month++;\n-        }\n-        this.day = daysOfYear + leapDay;\n-    }\n-\n-    // find a word start from 'start' from value.\n-    private int findWord(String value, int start) {\n-        int p = start;\n-        while (p < value.length() && Character.isLetter(value.charAt(p))) {\n-            p++;\n-        }\n-        return p;\n-    }\n-\n-    // find a number start from 'start' from value.\n-    private int findNumber(String value, int start, int maxLen) {\n-        int p = start;\n-        int left = maxLen;\n-        while (p < value.length() && Character.isDigit(value.charAt(p)) && left > 0) {\n-            p++;\n-            left--;\n-        }\n-        return p;\n-    }\n-\n-    // check if the given value exist in dict, return dict value.\n-    private int checkWord(Map<String, Integer> dict, String value) throws InvalidFormatException {\n-        Integer i = dict.get(value.toLowerCase());\n-        if (i != null) {\n-            return i;\n-        }\n-        throw new InvalidFormatException(\"'\" + value + \"' is invalid\");\n-    }\n }\n"}}, {"oid": "ac28b2e996539c486ca860fe7d0919871107207a", "url": "https://github.com/apache/incubator-doris/commit/ac28b2e996539c486ca860fe7d0919871107207a", "message": "first", "committedDate": "2020-09-01T09:12:35Z", "type": "commit"}, {"oid": "af10a535acdc2d14c4564e7972ecbc980d777eab", "url": "https://github.com/apache/incubator-doris/commit/af10a535acdc2d14c4564e7972ecbc980d777eab", "message": "rewrite fe", "committedDate": "2020-09-01T09:12:35Z", "type": "commit"}, {"oid": "b7c8f29b11a391e85966328fc1a6a2f109547922", "url": "https://github.com/apache/incubator-doris/commit/b7c8f29b11a391e85966328fc1a6a2f109547922", "message": "second", "committedDate": "2020-09-01T09:12:35Z", "type": "commit"}, {"oid": "a9ff1a7da412320332af677fa7b5129379ac49f5", "url": "https://github.com/apache/incubator-doris/commit/a9ff1a7da412320332af677fa7b5129379ac49f5", "message": "third", "committedDate": "2020-09-01T09:12:35Z", "type": "commit"}, {"oid": "e8a5db6321a55e23dbd7f3102aa6d78e4b53153b", "url": "https://github.com/apache/incubator-doris/commit/e8a5db6321a55e23dbd7f3102aa6d78e4b53153b", "message": "four", "committedDate": "2020-09-01T09:12:35Z", "type": "commit"}, {"oid": "e8a5db6321a55e23dbd7f3102aa6d78e4b53153b", "url": "https://github.com/apache/incubator-doris/commit/e8a5db6321a55e23dbd7f3102aa6d78e4b53153b", "message": "four", "committedDate": "2020-09-01T09:12:35Z", "type": "forcePushed"}]}