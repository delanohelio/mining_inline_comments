{"pr_number": 4439, "pr_title": "Validate the param of rand function in compile step", "pr_createdAt": "2020-08-24T13:05:54Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4439", "timeline": [{"oid": "1a15f533098eec6708121004ef835d111dc374f3", "url": "https://github.com/apache/incubator-doris/commit/1a15f533098eec6708121004ef835d111dc374f3", "message": "udf: replace function", "committedDate": "2020-08-13T14:09:31Z", "type": "commit"}, {"oid": "7d072b9a65d555e7e710cb5140435e00a8ff7bdc", "url": "https://github.com/apache/incubator-doris/commit/7d072b9a65d555e7e710cb5140435e00a8ff7bdc", "message": "Merge remote-tracking branch 'upstream/master' into str_replace", "committedDate": "2020-08-14T01:37:05Z", "type": "commit"}, {"oid": "391158f52190755b5fc621c31bf703835c0a7b3b", "url": "https://github.com/apache/incubator-doris/commit/391158f52190755b5fc621c31bf703835c0a7b3b", "message": "udf: replace function", "committedDate": "2020-08-14T02:11:25Z", "type": "commit"}, {"oid": "5eb52e1e5742d2e9f7aae5ac8da81545ae5f3df2", "url": "https://github.com/apache/incubator-doris/commit/5eb52e1e5742d2e9f7aae5ac8da81545ae5f3df2", "message": "udf: replace function", "committedDate": "2020-08-14T03:58:30Z", "type": "commit"}, {"oid": "a79ea91cf36eec54a4ca54018b92a6fa4baa98cc", "url": "https://github.com/apache/incubator-doris/commit/a79ea91cf36eec54a4ca54018b92a6fa4baa98cc", "message": "Merge remote-tracking branch 'upstream/master' into str_replace", "committedDate": "2020-08-18T02:31:52Z", "type": "commit"}, {"oid": "86f841f29fa4ee19773d6c5922465194a2887cf6", "url": "https://github.com/apache/incubator-doris/commit/86f841f29fa4ee19773d6c5922465194a2887cf6", "message": "udf: replace function", "committedDate": "2020-08-18T03:56:14Z", "type": "commit"}, {"oid": "ade1afa75c94a178a6801ba1324acf25ad8b16fe", "url": "https://github.com/apache/incubator-doris/commit/ade1afa75c94a178a6801ba1324acf25ad8b16fe", "message": "udf: replace function", "committedDate": "2020-08-18T03:59:59Z", "type": "commit"}, {"oid": "1d95a491115064c9753694ad4d45c2f72b8d2645", "url": "https://github.com/apache/incubator-doris/commit/1d95a491115064c9753694ad4d45c2f72b8d2645", "message": "udf: replace function", "committedDate": "2020-08-18T08:01:45Z", "type": "commit"}, {"oid": "433eb87f02cfa6740e80b0e4157d916ab5aca400", "url": "https://github.com/apache/incubator-doris/commit/433eb87f02cfa6740e80b0e4157d916ab5aca400", "message": "Merge remote-tracking branch 'upstream/master' into str_replace", "committedDate": "2020-08-24T02:03:34Z", "type": "commit"}, {"oid": "313e0a9ccd35297279011e904711311fe6acf621", "url": "https://github.com/apache/incubator-doris/commit/313e0a9ccd35297279011e904711311fe6acf621", "message": "rand function validate literal param", "committedDate": "2020-08-24T12:55:03Z", "type": "commit"}, {"oid": "d00fde471708754b9db2213e6d066ff98f5c9ef9", "url": "https://github.com/apache/incubator-doris/commit/d00fde471708754b9db2213e6d066ff98f5c9ef9", "message": "rand function validate literal param", "committedDate": "2020-08-24T12:58:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4ODA2Nw==", "url": "https://github.com/apache/incubator-doris/pull/4439#discussion_r476388067", "bodyText": "this.children != null is unnecessary", "author": "kangkaisen", "createdAt": "2020-08-25T11:50:06Z", "path": "fe/fe-core/src/main/java/org/apache/doris/analysis/Expr.java", "diffHunk": "@@ -1405,7 +1405,15 @@ protected Function getBuiltinFunction(\n             throws AnalysisException {\n         FunctionName fnName = new FunctionName(name);\n         Function searchDesc = new Function(fnName, argTypes, Type.INVALID, false);\n-        return Catalog.getCurrentCatalog().getFunction(searchDesc, mode);\n+        Function f = Catalog.getCurrentCatalog().getFunction(searchDesc, mode);\n+        if (f != null && fnName.getFunction().equalsIgnoreCase(\"rand\")) {\n+            if (this.children != null", "originalCommit": "d00fde471708754b9db2213e6d066ff98f5c9ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxOTY4Mg==", "url": "https://github.com/apache/incubator-doris/pull/4439#discussion_r476419682", "bodyText": "Rand function has two implements. One is Rand(const int), the other is Rand() without parm**.  this.children != null** filters Rand() without param.", "author": "xinghuayu007", "createdAt": "2020-08-25T12:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4ODA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyNjYzNg==", "url": "https://github.com/apache/incubator-doris/pull/4439#discussion_r476426636", "bodyText": "children is init with Lists.newArrayList(); in TreeNode, so it won't be null.", "author": "kangkaisen", "createdAt": "2020-08-25T12:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4ODA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ1ODQwMw==", "url": "https://github.com/apache/incubator-doris/pull/4439#discussion_r476458403", "bodyText": "You are right.", "author": "xinghuayu007", "createdAt": "2020-08-25T13:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4ODA2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c6f7a9cf6e681053707ea155980d315f00da2e68", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/analysis/Expr.java b/fe/fe-core/src/main/java/org/apache/doris/analysis/Expr.java\nindex dbfd2aa3d..582bb30c8 100755\n--- a/fe/fe-core/src/main/java/org/apache/doris/analysis/Expr.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/analysis/Expr.java\n\n@@ -1407,8 +1407,7 @@ abstract public class Expr extends TreeNode<Expr> implements ParseNode, Cloneabl\n         Function searchDesc = new Function(fnName, argTypes, Type.INVALID, false);\n         Function f = Catalog.getCurrentCatalog().getFunction(searchDesc, mode);\n         if (f != null && fnName.getFunction().equalsIgnoreCase(\"rand\")) {\n-            if (this.children != null\n-                    && this.children.size() == 1\n+            if (this.children.size() == 1\n                     && !(this.children.get(0) instanceof LiteralExpr)) {\n                 throw new AnalysisException(\"The param of rand function must be literal\");\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MTM4Ng==", "url": "https://github.com/apache/incubator-doris/pull/4439#discussion_r476391386", "bodyText": "You could add the test in SelectStmtTest, and then you could directly write testRandFunction", "author": "kangkaisen", "createdAt": "2020-08-25T11:56:23Z", "path": "fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java", "diffHunk": "@@ -24,18 +24,43 @@\n \n import com.google.common.collect.Maps;\n \n+import org.apache.doris.mysql.privilege.MockedAuth;\n+import org.apache.doris.mysql.privilege.PaloAuth;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.utframe.DorisAssert;\n+import org.apache.doris.utframe.UtFrameUtils;\n import org.junit.Assert;\n import org.junit.Test;\n+import org.junit.BeforeClass;\n+import org.junit.AfterClass;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.io.IOException;\n+import java.util.*;\n \n import mockit.Expectations;\n import mockit.Injectable;\n import mockit.Mocked;\n \n public class ExprTest {\n \n+    private static String runningDir = \"fe/mocked/DemoTest/\" + UUID.randomUUID().toString() + \"/\";", "originalCommit": "d00fde471708754b9db2213e6d066ff98f5c9ef9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f01f1f46d2c1c86f0bf31f75834433c0d5e31361", "chunk": "diff --git a/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java b/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java\nindex 41b90a9b7..da9666978 100755\n--- a/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java\n+++ b/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java\n\n@@ -31,8 +31,6 @@ import org.apache.doris.utframe.DorisAssert;\n import org.apache.doris.utframe.UtFrameUtils;\n import org.junit.Assert;\n import org.junit.Test;\n-import org.junit.BeforeClass;\n-import org.junit.AfterClass;\n \n import java.io.IOException;\n import java.util.*;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MTYzOA==", "url": "https://github.com/apache/incubator-doris/pull/4439#discussion_r476391638", "bodyText": "What's the meaning of   Assert.assertTrue(1 == 1); ?", "author": "kangkaisen", "createdAt": "2020-08-25T11:56:48Z", "path": "fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java", "diffHunk": "@@ -159,4 +184,42 @@ public void testUncheckedCastTo() throws AnalysisException {\n         StringLiteral castStringLiteral2 = (StringLiteral) stringLiteral.uncheckedCastTo(Type.VARCHAR);\n         Assert.assertTrue(stringLiteral == castStringLiteral2);\n     }\n+\n+    @Test\n+    public void testRandFunction() {\n+        try {\n+            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n+            String selectStmtStr = \"select rand(db1.tbl1.k1) from db1.tbl1;\";\n+            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n+        } catch (Exception e) {\n+            Assert.assertTrue(e.getMessage().contains(\"The param of rand function must be literal\"));\n+        }\n+\n+        try {\n+            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n+            String selectStmtStr = \"select rand(1234) from db1.tbl1;\";\n+            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n+        } catch (Exception e) {\n+            Assert.assertFalse(e.getMessage().contains(\"The param of rand function must be literal\"));\n+        }\n+        Assert.assertTrue(1 == 1);", "originalCommit": "d00fde471708754b9db2213e6d066ff98f5c9ef9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f01f1f46d2c1c86f0bf31f75834433c0d5e31361", "chunk": "diff --git a/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java b/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java\nindex 41b90a9b7..da9666978 100755\n--- a/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java\n+++ b/fe/fe-core/src/test/java/org/apache/doris/analysis/ExprTest.java\n\n@@ -184,42 +164,4 @@ public class ExprTest {\n         StringLiteral castStringLiteral2 = (StringLiteral) stringLiteral.uncheckedCastTo(Type.VARCHAR);\n         Assert.assertTrue(stringLiteral == castStringLiteral2);\n     }\n-\n-    @Test\n-    public void testRandFunction() {\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand(db1.tbl1.k1) from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertTrue(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n-\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand(1234) from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertFalse(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n-        Assert.assertTrue(1 == 1);\n-\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand() from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertFalse(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n-        Assert.assertTrue(1 == 1);\n-\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand(\\\"hello\\\") from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertFalse(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n-        Assert.assertTrue(1 == 1);\n-    }\n }\n"}}, {"oid": "f01f1f46d2c1c86f0bf31f75834433c0d5e31361", "url": "https://github.com/apache/incubator-doris/commit/f01f1f46d2c1c86f0bf31f75834433c0d5e31361", "message": "validate funtion rand with literal in compile step", "committedDate": "2020-08-25T12:46:42Z", "type": "commit"}, {"oid": "608037f3e437a3d458a007393fe108f2995694d2", "url": "https://github.com/apache/incubator-doris/commit/608037f3e437a3d458a007393fe108f2995694d2", "message": "validate funtion rand with literal in compile step", "committedDate": "2020-08-25T12:48:48Z", "type": "commit"}, {"oid": "a3ee01eba6d446b92ec03914939c499321770442", "url": "https://github.com/apache/incubator-doris/commit/a3ee01eba6d446b92ec03914939c499321770442", "message": "validate funtion rand with literal in compile step", "committedDate": "2020-08-25T12:49:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyNTcwNw==", "url": "https://github.com/apache/incubator-doris/pull/4439#discussion_r476425707", "bodyText": "You could use dorisAssert.query(sql).explainQuery();, which is more simpler.", "author": "kangkaisen", "createdAt": "2020-08-25T12:55:26Z", "path": "fe/fe-core/src/test/java/org/apache/doris/analysis/SelectStmtTest.java", "diffHunk": "@@ -362,4 +362,39 @@ public void testDataGripSupport() throws Exception {\n                 \"from information_schema.collations\";\n         dorisAssert.query(sql).explainQuery();\n     }\n+\n+    @Test\n+    public void testRandFunction() {\n+        try {\n+            ConnectContext ctx = UtFrameUtils.createDefaultCtx();", "originalCommit": "a3ee01eba6d446b92ec03914939c499321770442", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3089445ba5e1eaede342d0b72c979f0e0399ab91", "chunk": "diff --git a/fe/fe-core/src/test/java/org/apache/doris/analysis/SelectStmtTest.java b/fe/fe-core/src/test/java/org/apache/doris/analysis/SelectStmtTest.java\nindex bd4eceaeb..909bb83e8 100755\n--- a/fe/fe-core/src/test/java/org/apache/doris/analysis/SelectStmtTest.java\n+++ b/fe/fe-core/src/test/java/org/apache/doris/analysis/SelectStmtTest.java\n\n@@ -54,347 +54,327 @@ public class SelectStmtTest {\n         dorisAssert.withDatabase(\"db1\").useDatabase(\"db1\");\n         dorisAssert.withTable(createTblStmtStr).withTable(createBaseAllStmtStr);\n     }\n+//\n+//    @Test\n+//    public void testGroupingSets() throws Exception {\n+//        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n+//        String selectStmtStr = \"select k1,k2,MAX(k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k2),(k1),(k2),());\";\n+//        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n+//        String selectStmtStr2 = \"select k1,k4,MAX(k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k4),(k1),(k4),());\";\n+//        expectedEx.expect(AnalysisException.class);\n+//        expectedEx.expectMessage(\"column: `k4` cannot both in select list and aggregate functions when using GROUPING\"\n+//                + \" SETS/CUBE/ROLLUP, please use union instead.\");\n+//        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr2, ctx);\n+//        String selectStmtStr3 = \"select k1,k4,MAX(k4+k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k4),(k1),(k4),());\";\n+//        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr3, ctx);\n+//        String selectStmtStr4 = \"select k1,k4+k4,MAX(k4+k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k4),(k1),(k4),()\"\n+//                + \");\";\n+//        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr4, ctx);\n+//    }\n+//\n+//    @Test\n+//    public void testSubqueryInCase() throws Exception {\n+//        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n+//        String sql1 = \"SELECT CASE\\n\" +\n+//                \"        WHEN (\\n\" +\n+//                \"            SELECT COUNT(*) / 2\\n\" +\n+//                \"            FROM db1.tbl1\\n\" +\n+//                \"        ) > k4 THEN (\\n\" +\n+//                \"            SELECT AVG(k4)\\n\" +\n+//                \"            FROM db1.tbl1\\n\" +\n+//                \"        )\\n\" +\n+//                \"        ELSE (\\n\" +\n+//                \"            SELECT SUM(k4)\\n\" +\n+//                \"            FROM db1.tbl1\\n\" +\n+//                \"        )\\n\" +\n+//                \"    END AS kk4\\n\" +\n+//                \"FROM db1.tbl1;\";\n+//        SelectStmt stmt = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql1, ctx);\n+//        stmt.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt.toSql().contains(\"`$a$1`.`$c$1` > `k4` THEN `$a$2`.`$c$2` ELSE `$a$3`.`$c$3`\"));\n+//\n+//        String sql2 = \"select case when k1 in (select k1 from db1.tbl1) then \\\"true\\\" else k1 end a from db1.tbl1\";\n+//        try {\n+//            SelectStmt stmt2 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql2, ctx);\n+//            stmt2.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//            Assert.fail(\"syntax not supported.\");\n+//        } catch (AnalysisException e) {\n+//        } catch (Exception e) {\n+//            Assert.fail(\"must be AnalysisException.\");\n+//        }\n+//        try {\n+//            String sql3 = \"select case k1 when exists (select 1) then \\\"empty\\\" else \\\"p_test\\\" end a from db1.tbl1\";\n+//            SelectStmt stmt3 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql3, ctx);\n+//            stmt3.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//            Assert.fail(\"syntax not supported.\");\n+//        } catch (AnalysisException e) {\n+//        } catch (Exception e) {\n+//            Assert.fail(\"must be AnalysisException.\");\n+//        }\n+//        String sql4 = \"select case when k1 < (select max(k1) from db1.tbl1) and \" +\n+//                \"k1 > (select min(k1) from db1.tbl1) then \\\"empty\\\" else \\\"p_test\\\" end a from db1.tbl1\";\n+//        SelectStmt stmt4 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql4, ctx);\n+//        stmt4.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt4.toSql().contains(\" (`k1` < `$a$1`.`$c$1`) AND (`k1` > `$a$2`.`$c$2`) \"));\n+//\n+//        String sql5 = \"select case when k1 < (select max(k1) from db1.tbl1) is null \" +\n+//                \"then \\\"empty\\\" else \\\"p_test\\\" end a from db1.tbl1\";\n+//        SelectStmt stmt5 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql5, ctx);\n+//        stmt5.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt5.toSql().contains(\" `k1` < `$a$1`.`$c$1` IS NULL \"));\n+//    }\n+//\n+//    @Test\n+//    public void testDeduplicateOrs() throws Exception {\n+//        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n+//        String sql = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2,\\n\" +\n+//                \"   db1.tbl1 t3,\\n\" +\n+//                \"   db1.tbl1 t4,\\n\" +\n+//                \"   db1.tbl1 t5,\\n\" +\n+//                \"   db1.tbl1 t6\\n\" +\n+//                \"where\\n\" +\n+//                \"   t2.k1 = t1.k1\\n\" +\n+//                \"   and t1.k2 = t6.k2\\n\" +\n+//                \"   and t6.k4 = 2001\\n\" +\n+//                \"   and(\\n\" +\n+//                \"      (\\n\" +\n+//                \"         t1.k2 = t4.k2\\n\" +\n+//                \"         and t3.k3 = t1.k3\\n\" +\n+//                \"         and t3.k1 = 'D'\\n\" +\n+//                \"         and t4.k3 = '2 yr Degree'\\n\" +\n+//                \"         and t1.k4 between 100.00\\n\" +\n+//                \"         and 150.00\\n\" +\n+//                \"         and t4.k4 = 3\\n\" +\n+//                \"      )\\n\" +\n+//                \"      or (\\n\" +\n+//                \"         t1.k2 = t4.k2\\n\" +\n+//                \"         and t3.k3 = t1.k3\\n\" +\n+//                \"         and t3.k1 = 'S'\\n\" +\n+//                \"         and t4.k3 = 'Secondary'\\n\" +\n+//                \"         and t1.k4 between 50.00\\n\" +\n+//                \"         and 100.00\\n\" +\n+//                \"         and t4.k4 = 1\\n\" +\n+//                \"      )\\n\" +\n+//                \"      or (\\n\" +\n+//                \"         t1.k2 = t4.k2\\n\" +\n+//                \"         and t3.k3 = t1.k3\\n\" +\n+//                \"         and t3.k1 = 'W'\\n\" +\n+//                \"         and t4.k3 = 'Advanced Degree'\\n\" +\n+//                \"         and t1.k4 between 150.00\\n\" +\n+//                \"         and 200.00\\n\" +\n+//                \"         and t4.k4  = 1\\n\" +\n+//                \"      )\\n\" +\n+//                \"   )\\n\" +\n+//                \"   and(\\n\" +\n+//                \"      (\\n\" +\n+//                \"         t1.k1 = t5.k1\\n\" +\n+//                \"         and t5.k2 = 'United States'\\n\" +\n+//                \"         and t5.k3  in ('CO', 'IL', 'MN')\\n\" +\n+//                \"         and t1.k4 between 100\\n\" +\n+//                \"         and 200\\n\" +\n+//                \"      )\\n\" +\n+//                \"      or (\\n\" +\n+//                \"         t1.k1 = t5.k1\\n\" +\n+//                \"         and t5.k2 = 'United States'\\n\" +\n+//                \"         and t5.k3 in ('OH', 'MT', 'NM')\\n\" +\n+//                \"         and t1.k4 between 150\\n\" +\n+//                \"         and 300\\n\" +\n+//                \"      )\\n\" +\n+//                \"      or (\\n\" +\n+//                \"         t1.k1 = t5.k1\\n\" +\n+//                \"         and t5.k2 = 'United States'\\n\" +\n+//                \"         and t5.k3 in ('TX', 'MO', 'MI')\\n\" +\n+//                \"         and t1.k4 between 50 and 250\\n\" +\n+//                \"      )\\n\" +\n+//                \"   );\";\n+//        SelectStmt stmt = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql, ctx);\n+//        stmt.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        String rewritedFragment1 = \"(((`t1`.`k2` = `t4`.`k2`) AND (`t3`.`k3` = `t1`.`k3`)) AND ((((((`t3`.`k1` = 'D')\" +\n+//                \" AND (`t4`.`k3` = '2 yr Degree')) AND ((`t1`.`k4` >= 100.00) AND (`t1`.`k4` <= 150.00))) AND\" +\n+//                \" (`t4`.`k4` = 3)) OR ((((`t3`.`k1` = 'S') AND (`t4`.`k3` = 'Secondary')) AND ((`t1`.`k4` >= 50.00)\" +\n+//                \" AND (`t1`.`k4` <= 100.00))) AND (`t4`.`k4` = 1))) OR ((((`t3`.`k1` = 'W') AND \" +\n+//                \"(`t4`.`k3` = 'Advanced Degree')) AND ((`t1`.`k4` >= 150.00) AND (`t1`.`k4` <= 200.00)))\" +\n+//                \" AND (`t4`.`k4` = 1))))\";\n+//        String rewritedFragment2 = \"(((`t1`.`k1` = `t5`.`k1`) AND (`t5`.`k2` = 'United States')) AND\" +\n+//                \" ((((`t5`.`k3` IN ('CO', 'IL', 'MN')) AND ((`t1`.`k4` >= 100) AND (`t1`.`k4` <= 200)))\" +\n+//                \" OR ((`t5`.`k3` IN ('OH', 'MT', 'NM')) AND ((`t1`.`k4` >= 150) AND (`t1`.`k4` <= 300))))\" +\n+//                \" OR ((`t5`.`k3` IN ('TX', 'MO', 'MI')) AND ((`t1`.`k4` >= 50) AND (`t1`.`k4` <= 250)))))\";\n+//        Assert.assertTrue(stmt.toSql().contains(rewritedFragment1));\n+//        Assert.assertTrue(stmt.toSql().contains(rewritedFragment2));\n+//\n+//        String sql2 = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2\\n\" +\n+//                \"where\\n\" +\n+//                \"(\\n\" +\n+//                \"   t1.k1 = t2.k3\\n\" +\n+//                \"   and t2.k2 = 'United States'\\n\" +\n+//                \"   and t2.k3  in ('CO', 'IL', 'MN')\\n\" +\n+//                \"   and t1.k4 between 100\\n\" +\n+//                \"   and 200\\n\" +\n+//                \")\\n\" +\n+//                \"or (\\n\" +\n+//                \"   t1.k1 = t2.k1\\n\" +\n+//                \"   and t2.k2 = 'United States1'\\n\" +\n+//                \"   and t2.k3 in ('OH', 'MT', 'NM')\\n\" +\n+//                \"   and t1.k4 between 150\\n\" +\n+//                \"   and 300\\n\" +\n+//                \")\\n\" +\n+//                \"or (\\n\" +\n+//                \"   t1.k1 = t2.k1\\n\" +\n+//                \"   and t2.k2 = 'United States'\\n\" +\n+//                \"   and t2.k3 in ('TX', 'MO', 'MI')\\n\" +\n+//                \"   and t1.k4 between 50 and 250\\n\" +\n+//                \")\";\n+//        SelectStmt stmt2 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql2, ctx);\n+//        stmt2.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        String fragment3 = \"(((((`t1`.`k1` = `t2`.`k3`) AND (`t2`.`k2` = 'United States')) AND \" +\n+//                \"(`t2`.`k3` IN ('CO', 'IL', 'MN'))) AND ((`t1`.`k4` >= 100) AND (`t1`.`k4` <= 200))) OR\" +\n+//                \" ((((`t1`.`k1` = `t2`.`k1`) AND (`t2`.`k2` = 'United States1')) AND (`t2`.`k3` IN ('OH', 'MT', 'NM')))\" +\n+//                \" AND ((`t1`.`k4` >= 150) AND (`t1`.`k4` <= 300)))) OR ((((`t1`.`k1` = `t2`.`k1`) AND \" +\n+//                \"(`t2`.`k2` = 'United States')) AND (`t2`.`k3` IN ('TX', 'MO', 'MI'))) AND ((`t1`.`k4` >= 50)\" +\n+//                \" AND (`t1`.`k4` <= 250)))\";\n+//        Assert.assertTrue(stmt2.toSql().contains(fragment3));\n+//\n+//        String sql3 = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2\\n\" +\n+//                \"where\\n\" +\n+//                \"   t1.k1 = t2.k3 or t1.k1 = t2.k3 or t1.k1 = t2.k3\";\n+//        SelectStmt stmt3 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql3, ctx);\n+//        stmt3.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertFalse(stmt3.toSql().contains(\"((`t1`.`k1` = `t2`.`k3`) OR (`t1`.`k1` = `t2`.`k3`)) OR\" +\n+//                \" (`t1`.`k1` = `t2`.`k3`)\"));\n+//\n+//        String sql4 = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2\\n\" +\n+//                \"where\\n\" +\n+//                \"   t1.k1 = t2.k2 or t1.k1 = t2.k3 or t1.k1 = t2.k3\";\n+//        SelectStmt stmt4 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql4, ctx);\n+//        stmt4.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt4.toSql().contains(\"(`t1`.`k1` = `t2`.`k2`) OR (`t1`.`k1` = `t2`.`k3`)\"));\n+//\n+//        String sql5 = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2\\n\" +\n+//                \"where\\n\" +\n+//                \"   t2.k1 is not null or t1.k1 is not null or t1.k1 is not null\";\n+//        SelectStmt stmt5 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql5, ctx);\n+//        stmt5.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt5.toSql().contains(\"(`t2`.`k1` IS NOT NULL) OR (`t1`.`k1` IS NOT NULL)\"));\n+//        Assert.assertEquals(2, stmt5.toSql().split(\" OR \").length);\n+//\n+//        String sql6 = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2\\n\" +\n+//                \"where\\n\" +\n+//                \"   t2.k1 is not null or t1.k1 is not null and t1.k1 is not null\";\n+//        SelectStmt stmt6 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql6, ctx);\n+//        stmt6.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt6.toSql().contains(\"(`t2`.`k1` IS NOT NULL) OR (`t1`.`k1` IS NOT NULL)\"));\n+//        Assert.assertEquals(2, stmt6.toSql().split(\" OR \").length);\n+//\n+//        String sql7 = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2\\n\" +\n+//                \"where\\n\" +\n+//                \"   t2.k1 is not null or t1.k1 is not null and t1.k2 is not null\";\n+//        SelectStmt stmt7 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql7, ctx);\n+//        stmt7.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt7.toSql().contains(\"(`t2`.`k1` IS NOT NULL) OR ((`t1`.`k1` IS NOT NULL) \" +\n+//                \"AND (`t1`.`k2` IS NOT NULL))\"));\n+//\n+//        String sql8 = \"select\\n\" +\n+//                \"   avg(t1.k4)\\n\" +\n+//                \"from\\n\" +\n+//                \"   db1.tbl1 t1,\\n\" +\n+//                \"   db1.tbl1 t2\\n\" +\n+//                \"where\\n\" +\n+//                \"   t2.k1 is not null and t1.k1 is not null and t1.k1 is not null\";\n+//        SelectStmt stmt8 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql8, ctx);\n+//        stmt8.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt8.toSql().contains(\"((`t2`.`k1` IS NOT NULL) AND (`t1`.`k1` IS NOT NULL))\" +\n+//                \" AND (`t1`.`k1` IS NOT NULL)\"));\n+//\n+//        String sql9 = \"select * from db1.tbl1 where (k1='shutdown' and k4<1) or (k1='switchOff' and k4>=1)\";\n+//        SelectStmt stmt9 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql9, ctx);\n+//        stmt9.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n+//        Assert.assertTrue(stmt9.toSql().contains(\"((`k1` = 'shutdown') AND (`k4` < 1))\" +\n+//                \" OR ((`k1` = 'switchOff') AND (`k4` >= 1))\"));\n+//    }\n+//\n+//    @Test\n+//    public void testForbiddenCorrelatedSubqueryInHavingClause() throws Exception {\n+//        String sql = \"SELECT k1 FROM baseall GROUP BY k1 HAVING EXISTS(SELECT k4 FROM tbl1 GROUP BY k4 HAVING SUM\"\n+//                + \"(baseall.k1) = k4);\";\n+//        try {\n+//            dorisAssert.query(sql).explainQuery();\n+//            Assert.fail(\"The correlated subquery in having clause should be forbidden.\");\n+//        } catch (AnalysisException e) {\n+//            System.out.println(e.getMessage());\n+//        }\n+//    }\n+//\n+//    @Test\n+//    public void testGroupByConstantExpression() throws Exception {\n+//        String sql = \"SELECT k1 - 4*60*60 FROM baseall GROUP BY k1 - 4*60*60\";\n+//        dorisAssert.query(sql).explainQuery();\n+//    }\n+//\n+//    @Test\n+//    public void testMultrGroupByInCorrelationSubquery() throws Exception {\n+//        String sql = \"SELECT * from baseall where k1 > (select min(k1) from tbl1 where baseall.k1 = tbl1.k4 and baseall.k2 = tbl1.k2)\";\n+//        dorisAssert.query(sql).explainQuery();\n+//    }\n+//\n+//    @Test\n+//    public void testOuterJoinNullUnionView() throws Exception{\n+//        String sql = \"WITH test_view(k) AS(SELECT NULL AS k UNION ALL SELECT NULL AS k )\\n\" +\n+//                \"SELECT v1.k FROM test_view AS v1 LEFT OUTER JOIN test_view AS v2 ON v1.k=v2.k\";\n+//        dorisAssert.query(sql).explainQuery();\n+//    }\n+//\n+//    @Test\n+//    public void testDataGripSupport() throws Exception {\n+//        String sql = \"select schema();\";\n+//        dorisAssert.query(sql).explainQuery();\n+//        sql = \"select\\n\" +\n+//                \"collation_name,\\n\" +\n+//                \"character_set_name,\\n\" +\n+//                \"is_default collate utf8_general_ci = 'Yes' as is_default\\n\" +\n+//                \"from information_schema.collations\";\n+//        dorisAssert.query(sql).explainQuery();\n+//    }\n \n     @Test\n-    public void testGroupingSets() throws Exception {\n-        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-        String selectStmtStr = \"select k1,k2,MAX(k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k2),(k1),(k2),());\";\n-        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        String selectStmtStr2 = \"select k1,k4,MAX(k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k4),(k1),(k4),());\";\n-        expectedEx.expect(AnalysisException.class);\n-        expectedEx.expectMessage(\"column: `k4` cannot both in select list and aggregate functions when using GROUPING\"\n-                + \" SETS/CUBE/ROLLUP, please use union instead.\");\n-        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr2, ctx);\n-        String selectStmtStr3 = \"select k1,k4,MAX(k4+k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k4),(k1),(k4),());\";\n-        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr3, ctx);\n-        String selectStmtStr4 = \"select k1,k4+k4,MAX(k4+k4) from db1.tbl1 GROUP BY GROUPING sets ((k1,k4),(k1),(k4),()\"\n-                + \");\";\n-        UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr4, ctx);\n-    }\n-\n-    @Test\n-    public void testSubqueryInCase() throws Exception {\n-        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-        String sql1 = \"SELECT CASE\\n\" +\n-                \"        WHEN (\\n\" +\n-                \"            SELECT COUNT(*) / 2\\n\" +\n-                \"            FROM db1.tbl1\\n\" +\n-                \"        ) > k4 THEN (\\n\" +\n-                \"            SELECT AVG(k4)\\n\" +\n-                \"            FROM db1.tbl1\\n\" +\n-                \"        )\\n\" +\n-                \"        ELSE (\\n\" +\n-                \"            SELECT SUM(k4)\\n\" +\n-                \"            FROM db1.tbl1\\n\" +\n-                \"        )\\n\" +\n-                \"    END AS kk4\\n\" +\n-                \"FROM db1.tbl1;\";\n-        SelectStmt stmt = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql1, ctx);\n-        stmt.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt.toSql().contains(\"`$a$1`.`$c$1` > `k4` THEN `$a$2`.`$c$2` ELSE `$a$3`.`$c$3`\"));\n-\n-        String sql2 = \"select case when k1 in (select k1 from db1.tbl1) then \\\"true\\\" else k1 end a from db1.tbl1\";\n-        try {\n-            SelectStmt stmt2 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql2, ctx);\n-            stmt2.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-            Assert.fail(\"syntax not supported.\");\n-        } catch (AnalysisException e) {\n-        } catch (Exception e) {\n-            Assert.fail(\"must be AnalysisException.\");\n-        }\n-        try {\n-            String sql3 = \"select case k1 when exists (select 1) then \\\"empty\\\" else \\\"p_test\\\" end a from db1.tbl1\";\n-            SelectStmt stmt3 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql3, ctx);\n-            stmt3.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-            Assert.fail(\"syntax not supported.\");\n-        } catch (AnalysisException e) {\n-        } catch (Exception e) {\n-            Assert.fail(\"must be AnalysisException.\");\n-        }\n-        String sql4 = \"select case when k1 < (select max(k1) from db1.tbl1) and \" +\n-                \"k1 > (select min(k1) from db1.tbl1) then \\\"empty\\\" else \\\"p_test\\\" end a from db1.tbl1\";\n-        SelectStmt stmt4 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql4, ctx);\n-        stmt4.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt4.toSql().contains(\" (`k1` < `$a$1`.`$c$1`) AND (`k1` > `$a$2`.`$c$2`) \"));\n-\n-        String sql5 = \"select case when k1 < (select max(k1) from db1.tbl1) is null \" +\n-                \"then \\\"empty\\\" else \\\"p_test\\\" end a from db1.tbl1\";\n-        SelectStmt stmt5 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql5, ctx);\n-        stmt5.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt5.toSql().contains(\" `k1` < `$a$1`.`$c$1` IS NULL \"));\n-    }\n-\n-    @Test\n-    public void testDeduplicateOrs() throws Exception {\n-        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-        String sql = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2,\\n\" +\n-                \"   db1.tbl1 t3,\\n\" +\n-                \"   db1.tbl1 t4,\\n\" +\n-                \"   db1.tbl1 t5,\\n\" +\n-                \"   db1.tbl1 t6\\n\" +\n-                \"where\\n\" +\n-                \"   t2.k1 = t1.k1\\n\" +\n-                \"   and t1.k2 = t6.k2\\n\" +\n-                \"   and t6.k4 = 2001\\n\" +\n-                \"   and(\\n\" +\n-                \"      (\\n\" +\n-                \"         t1.k2 = t4.k2\\n\" +\n-                \"         and t3.k3 = t1.k3\\n\" +\n-                \"         and t3.k1 = 'D'\\n\" +\n-                \"         and t4.k3 = '2 yr Degree'\\n\" +\n-                \"         and t1.k4 between 100.00\\n\" +\n-                \"         and 150.00\\n\" +\n-                \"         and t4.k4 = 3\\n\" +\n-                \"      )\\n\" +\n-                \"      or (\\n\" +\n-                \"         t1.k2 = t4.k2\\n\" +\n-                \"         and t3.k3 = t1.k3\\n\" +\n-                \"         and t3.k1 = 'S'\\n\" +\n-                \"         and t4.k3 = 'Secondary'\\n\" +\n-                \"         and t1.k4 between 50.00\\n\" +\n-                \"         and 100.00\\n\" +\n-                \"         and t4.k4 = 1\\n\" +\n-                \"      )\\n\" +\n-                \"      or (\\n\" +\n-                \"         t1.k2 = t4.k2\\n\" +\n-                \"         and t3.k3 = t1.k3\\n\" +\n-                \"         and t3.k1 = 'W'\\n\" +\n-                \"         and t4.k3 = 'Advanced Degree'\\n\" +\n-                \"         and t1.k4 between 150.00\\n\" +\n-                \"         and 200.00\\n\" +\n-                \"         and t4.k4  = 1\\n\" +\n-                \"      )\\n\" +\n-                \"   )\\n\" +\n-                \"   and(\\n\" +\n-                \"      (\\n\" +\n-                \"         t1.k1 = t5.k1\\n\" +\n-                \"         and t5.k2 = 'United States'\\n\" +\n-                \"         and t5.k3  in ('CO', 'IL', 'MN')\\n\" +\n-                \"         and t1.k4 between 100\\n\" +\n-                \"         and 200\\n\" +\n-                \"      )\\n\" +\n-                \"      or (\\n\" +\n-                \"         t1.k1 = t5.k1\\n\" +\n-                \"         and t5.k2 = 'United States'\\n\" +\n-                \"         and t5.k3 in ('OH', 'MT', 'NM')\\n\" +\n-                \"         and t1.k4 between 150\\n\" +\n-                \"         and 300\\n\" +\n-                \"      )\\n\" +\n-                \"      or (\\n\" +\n-                \"         t1.k1 = t5.k1\\n\" +\n-                \"         and t5.k2 = 'United States'\\n\" +\n-                \"         and t5.k3 in ('TX', 'MO', 'MI')\\n\" +\n-                \"         and t1.k4 between 50 and 250\\n\" +\n-                \"      )\\n\" +\n-                \"   );\";\n-        SelectStmt stmt = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql, ctx);\n-        stmt.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        String rewritedFragment1 = \"(((`t1`.`k2` = `t4`.`k2`) AND (`t3`.`k3` = `t1`.`k3`)) AND ((((((`t3`.`k1` = 'D')\" +\n-                \" AND (`t4`.`k3` = '2 yr Degree')) AND ((`t1`.`k4` >= 100.00) AND (`t1`.`k4` <= 150.00))) AND\" +\n-                \" (`t4`.`k4` = 3)) OR ((((`t3`.`k1` = 'S') AND (`t4`.`k3` = 'Secondary')) AND ((`t1`.`k4` >= 50.00)\" +\n-                \" AND (`t1`.`k4` <= 100.00))) AND (`t4`.`k4` = 1))) OR ((((`t3`.`k1` = 'W') AND \" +\n-                \"(`t4`.`k3` = 'Advanced Degree')) AND ((`t1`.`k4` >= 150.00) AND (`t1`.`k4` <= 200.00)))\" +\n-                \" AND (`t4`.`k4` = 1))))\";\n-        String rewritedFragment2 = \"(((`t1`.`k1` = `t5`.`k1`) AND (`t5`.`k2` = 'United States')) AND\" +\n-                \" ((((`t5`.`k3` IN ('CO', 'IL', 'MN')) AND ((`t1`.`k4` >= 100) AND (`t1`.`k4` <= 200)))\" +\n-                \" OR ((`t5`.`k3` IN ('OH', 'MT', 'NM')) AND ((`t1`.`k4` >= 150) AND (`t1`.`k4` <= 300))))\" +\n-                \" OR ((`t5`.`k3` IN ('TX', 'MO', 'MI')) AND ((`t1`.`k4` >= 50) AND (`t1`.`k4` <= 250)))))\";\n-        Assert.assertTrue(stmt.toSql().contains(rewritedFragment1));\n-        Assert.assertTrue(stmt.toSql().contains(rewritedFragment2));\n-\n-        String sql2 = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2\\n\" +\n-                \"where\\n\" +\n-                \"(\\n\" +\n-                \"   t1.k1 = t2.k3\\n\" +\n-                \"   and t2.k2 = 'United States'\\n\" +\n-                \"   and t2.k3  in ('CO', 'IL', 'MN')\\n\" +\n-                \"   and t1.k4 between 100\\n\" +\n-                \"   and 200\\n\" +\n-                \")\\n\" +\n-                \"or (\\n\" +\n-                \"   t1.k1 = t2.k1\\n\" +\n-                \"   and t2.k2 = 'United States1'\\n\" +\n-                \"   and t2.k3 in ('OH', 'MT', 'NM')\\n\" +\n-                \"   and t1.k4 between 150\\n\" +\n-                \"   and 300\\n\" +\n-                \")\\n\" +\n-                \"or (\\n\" +\n-                \"   t1.k1 = t2.k1\\n\" +\n-                \"   and t2.k2 = 'United States'\\n\" +\n-                \"   and t2.k3 in ('TX', 'MO', 'MI')\\n\" +\n-                \"   and t1.k4 between 50 and 250\\n\" +\n-                \")\";\n-        SelectStmt stmt2 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql2, ctx);\n-        stmt2.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        String fragment3 = \"(((((`t1`.`k1` = `t2`.`k3`) AND (`t2`.`k2` = 'United States')) AND \" +\n-                \"(`t2`.`k3` IN ('CO', 'IL', 'MN'))) AND ((`t1`.`k4` >= 100) AND (`t1`.`k4` <= 200))) OR\" +\n-                \" ((((`t1`.`k1` = `t2`.`k1`) AND (`t2`.`k2` = 'United States1')) AND (`t2`.`k3` IN ('OH', 'MT', 'NM')))\" +\n-                \" AND ((`t1`.`k4` >= 150) AND (`t1`.`k4` <= 300)))) OR ((((`t1`.`k1` = `t2`.`k1`) AND \" +\n-                \"(`t2`.`k2` = 'United States')) AND (`t2`.`k3` IN ('TX', 'MO', 'MI'))) AND ((`t1`.`k4` >= 50)\" +\n-                \" AND (`t1`.`k4` <= 250)))\";\n-        Assert.assertTrue(stmt2.toSql().contains(fragment3));\n-\n-        String sql3 = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2\\n\" +\n-                \"where\\n\" +\n-                \"   t1.k1 = t2.k3 or t1.k1 = t2.k3 or t1.k1 = t2.k3\";\n-        SelectStmt stmt3 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql3, ctx);\n-        stmt3.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertFalse(stmt3.toSql().contains(\"((`t1`.`k1` = `t2`.`k3`) OR (`t1`.`k1` = `t2`.`k3`)) OR\" +\n-                \" (`t1`.`k1` = `t2`.`k3`)\"));\n-\n-        String sql4 = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2\\n\" +\n-                \"where\\n\" +\n-                \"   t1.k1 = t2.k2 or t1.k1 = t2.k3 or t1.k1 = t2.k3\";\n-        SelectStmt stmt4 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql4, ctx);\n-        stmt4.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt4.toSql().contains(\"(`t1`.`k1` = `t2`.`k2`) OR (`t1`.`k1` = `t2`.`k3`)\"));\n-\n-        String sql5 = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2\\n\" +\n-                \"where\\n\" +\n-                \"   t2.k1 is not null or t1.k1 is not null or t1.k1 is not null\";\n-        SelectStmt stmt5 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql5, ctx);\n-        stmt5.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt5.toSql().contains(\"(`t2`.`k1` IS NOT NULL) OR (`t1`.`k1` IS NOT NULL)\"));\n-        Assert.assertEquals(2, stmt5.toSql().split(\" OR \").length);\n-\n-        String sql6 = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2\\n\" +\n-                \"where\\n\" +\n-                \"   t2.k1 is not null or t1.k1 is not null and t1.k1 is not null\";\n-        SelectStmt stmt6 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql6, ctx);\n-        stmt6.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt6.toSql().contains(\"(`t2`.`k1` IS NOT NULL) OR (`t1`.`k1` IS NOT NULL)\"));\n-        Assert.assertEquals(2, stmt6.toSql().split(\" OR \").length);\n-\n-        String sql7 = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2\\n\" +\n-                \"where\\n\" +\n-                \"   t2.k1 is not null or t1.k1 is not null and t1.k2 is not null\";\n-        SelectStmt stmt7 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql7, ctx);\n-        stmt7.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt7.toSql().contains(\"(`t2`.`k1` IS NOT NULL) OR ((`t1`.`k1` IS NOT NULL) \" +\n-                \"AND (`t1`.`k2` IS NOT NULL))\"));\n-\n-        String sql8 = \"select\\n\" +\n-                \"   avg(t1.k4)\\n\" +\n-                \"from\\n\" +\n-                \"   db1.tbl1 t1,\\n\" +\n-                \"   db1.tbl1 t2\\n\" +\n-                \"where\\n\" +\n-                \"   t2.k1 is not null and t1.k1 is not null and t1.k1 is not null\";\n-        SelectStmt stmt8 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql8, ctx);\n-        stmt8.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt8.toSql().contains(\"((`t2`.`k1` IS NOT NULL) AND (`t1`.`k1` IS NOT NULL))\" +\n-                \" AND (`t1`.`k1` IS NOT NULL)\"));\n-\n-        String sql9 = \"select * from db1.tbl1 where (k1='shutdown' and k4<1) or (k1='switchOff' and k4>=1)\";\n-        SelectStmt stmt9 = (SelectStmt) UtFrameUtils.parseAndAnalyzeStmt(sql9, ctx);\n-        stmt9.rewriteExprs(new Analyzer(ctx.getCatalog(), ctx).getExprRewriter());\n-        Assert.assertTrue(stmt9.toSql().contains(\"((`k1` = 'shutdown') AND (`k4` < 1))\" +\n-                \" OR ((`k1` = 'switchOff') AND (`k4` >= 1))\"));\n-    }\n-\n-    @Test\n-    public void testForbiddenCorrelatedSubqueryInHavingClause() throws Exception {\n-        String sql = \"SELECT k1 FROM baseall GROUP BY k1 HAVING EXISTS(SELECT k4 FROM tbl1 GROUP BY k4 HAVING SUM\"\n-                + \"(baseall.k1) = k4);\";\n+    public void testRandFunction() throws Exception {\n+        String sql = \"select rand(db1.tbl1.k1) from db1.tbl1;\";\n         try {\n             dorisAssert.query(sql).explainQuery();\n-            Assert.fail(\"The correlated subquery in having clause should be forbidden.\");\n+            Assert.fail(\"The param of rand function must be literal\");\n         } catch (AnalysisException e) {\n             System.out.println(e.getMessage());\n         }\n-    }\n-\n-    @Test\n-    public void testGroupByConstantExpression() throws Exception {\n-        String sql = \"SELECT k1 - 4*60*60 FROM baseall GROUP BY k1 - 4*60*60\";\n-        dorisAssert.query(sql).explainQuery();\n-    }\n-\n-    @Test\n-    public void testMultrGroupByInCorrelationSubquery() throws Exception {\n-        String sql = \"SELECT * from baseall where k1 > (select min(k1) from tbl1 where baseall.k1 = tbl1.k4 and baseall.k2 = tbl1.k2)\";\n-        dorisAssert.query(sql).explainQuery();\n-    }\n-\n-    @Test\n-    public void testOuterJoinNullUnionView() throws Exception{\n-        String sql = \"WITH test_view(k) AS(SELECT NULL AS k UNION ALL SELECT NULL AS k )\\n\" +\n-                \"SELECT v1.k FROM test_view AS v1 LEFT OUTER JOIN test_view AS v2 ON v1.k=v2.k\";\n+        sql = \"select rand(1234) from db1.tbl1;\";\n         dorisAssert.query(sql).explainQuery();\n-    }\n-\n-    @Test\n-    public void testDataGripSupport() throws Exception {\n-        String sql = \"select schema();\";\n+        sql = \"select rand() from db1.tbl1;\";\n         dorisAssert.query(sql).explainQuery();\n-        sql = \"select\\n\" +\n-                \"collation_name,\\n\" +\n-                \"character_set_name,\\n\" +\n-                \"is_default collate utf8_general_ci = 'Yes' as is_default\\n\" +\n-                \"from information_schema.collations\";\n-        dorisAssert.query(sql).explainQuery();\n-    }\n-\n-    @Test\n-    public void testRandFunction() {\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand(db1.tbl1.k1) from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertTrue(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n-\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand(1234) from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertFalse(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n-\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand() from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertFalse(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n-\n-        try {\n-            ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n-            String selectStmtStr = \"select rand(\\\"hello\\\") from db1.tbl1;\";\n-            UtFrameUtils.parseAndAnalyzeStmt(selectStmtStr, ctx);\n-        } catch (Exception e) {\n-            Assert.assertFalse(e.getMessage().contains(\"The param of rand function must be literal\"));\n-        }\n     }\n }\n"}}, {"oid": "3089445ba5e1eaede342d0b72c979f0e0399ab91", "url": "https://github.com/apache/incubator-doris/commit/3089445ba5e1eaede342d0b72c979f0e0399ab91", "message": "validate funtion rand with literal in compile step", "committedDate": "2020-08-25T13:39:48Z", "type": "commit"}, {"oid": "c6f7a9cf6e681053707ea155980d315f00da2e68", "url": "https://github.com/apache/incubator-doris/commit/c6f7a9cf6e681053707ea155980d315f00da2e68", "message": "validate funtion rand with literal in compile step", "committedDate": "2020-08-25T13:40:36Z", "type": "commit"}, {"oid": "a2f9673fbd2e84bb0e88d275254baaf09645b6b9", "url": "https://github.com/apache/incubator-doris/commit/a2f9673fbd2e84bb0e88d275254baaf09645b6b9", "message": "validate funtion rand with literal in compile step", "committedDate": "2020-08-25T13:42:00Z", "type": "commit"}, {"oid": "e0adcef9d99dcef88c59d78bcff1d59c7675d3b5", "url": "https://github.com/apache/incubator-doris/commit/e0adcef9d99dcef88c59d78bcff1d59c7675d3b5", "message": "validate rand function param in compile phase", "committedDate": "2020-08-27T06:29:08Z", "type": "commit"}, {"oid": "3e99267974ceff15cde5313fe270603654674fd5", "url": "https://github.com/apache/incubator-doris/commit/3e99267974ceff15cde5313fe270603654674fd5", "message": "update", "committedDate": "2020-08-27T08:15:56Z", "type": "commit"}, {"oid": "e7148921e503b2fef3a8b1bb331023998cfe1257", "url": "https://github.com/apache/incubator-doris/commit/e7148921e503b2fef3a8b1bb331023998cfe1257", "message": "Merge remote-tracking branch 'upstream/master' into function_check", "committedDate": "2020-08-27T11:36:02Z", "type": "commit"}, {"oid": "697c5e780a94ae9226eac267b7810ed375ac9bb2", "url": "https://github.com/apache/incubator-doris/commit/697c5e780a94ae9226eac267b7810ed375ac9bb2", "message": "update", "committedDate": "2020-08-27T11:58:46Z", "type": "commit"}, {"oid": "84d3ea8c6335fa588bb9655b00a40ad6ffb1c589", "url": "https://github.com/apache/incubator-doris/commit/84d3ea8c6335fa588bb9655b00a40ad6ffb1c589", "message": "Merge remote-tracking branch 'upstream/master' into function_check", "committedDate": "2020-08-28T03:25:11Z", "type": "commit"}, {"oid": "a6051794faabab05929ab2aadf34896131cf147e", "url": "https://github.com/apache/incubator-doris/commit/a6051794faabab05929ab2aadf34896131cf147e", "message": "Merge remote-tracking branch 'upstream/master' into function_check", "committedDate": "2020-08-31T02:35:47Z", "type": "commit"}]}