{"pr_number": 5010, "pr_title": "[Rebalancer] support partition rebalancer", "pr_createdAt": "2020-12-02T10:51:26Z", "pr_url": "https://github.com/apache/incubator-doris/pull/5010", "timeline": [{"oid": "ac63a03adb48dff9a7f48d8513c4e5d1e4390a79", "url": "https://github.com/apache/incubator-doris/commit/ac63a03adb48dff9a7f48d8513c4e5d1e4390a79", "message": "[] partition rebalancer", "committedDate": "2020-12-02T10:44:48Z", "type": "commit"}, {"oid": "dc5361dcf71dd423fdfdfaca6dab8bcc98065790", "url": "https://github.com/apache/incubator-doris/commit/dc5361dcf71dd423fdfdfaca6dab8bcc98065790", "message": "[] comments & rename", "committedDate": "2020-12-03T03:22:25Z", "type": "commit"}, {"oid": "f81a67b90ca0c7c341bfa952b9f0e30ab8c9decf", "url": "https://github.com/apache/incubator-doris/commit/f81a67b90ca0c7c341bfa952b9f0e30ab8c9decf", "message": "[] fix config & add docs", "committedDate": "2020-12-03T07:15:52Z", "type": "commit"}, {"oid": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "url": "https://github.com/apache/incubator-doris/commit/700a6069acce1a3bbc3d814f7b1f196a564635b2", "message": "[] comments & logs fix", "committedDate": "2020-12-03T08:52:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NDg0NA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r539064844", "bodyText": "selectAlternativeTabletsForCluster method selects all tablets for maxSkew partition from highload be. If there is no check whether the move will make partition balance better, we may fall into endless loop in such case:\n3 tablets on maxload be\n1 tablet on minload be\nwe move 2 tablets from maxload be to minload be, and maxload be switchs to minload be.", "author": "gengjun-git", "createdAt": "2020-12-09T07:20:13Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyAlgo algo = new TwoDimensionalGreedyAlgo();\n+    protected final MovesInProgressCache movesInProgressCache = new MovesInProgressCache();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesInProgressCache.Cell movesInProgress = movesInProgressCache.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesInProgressMap should have the same entry\");\n+\n+        // iterating through cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<ReplicaMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<ReplicaMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        if (movesInProgressCache.size() > Config.max_balancing_tablets) {\n+            LOG.debug(\"Total in-progress moves > {}\", Config.max_balancing_tablets);\n+            return Lists.newArrayList();\n+        }\n+\n+        NavigableSet<Long> skews = clusterBalanceInfo.partitionInfoBySkew.keySet();\n+        LOG.debug(\"Cluster {}-{}: peek max skew {}, assume {} in-progress moves are succeeded {}\", clusterName, medium,\n+                skews.isEmpty() ? 0 : skews.last(), movesInProgressList.size(), movesInProgressList);\n+\n+        List<TwoDimensionalGreedyAlgo.PartitionReplicaMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.rebalance_max_moves_num_per_selection);\n+\n+        List<TabletSchedCtx> alternativeTablets = Lists.newArrayList();\n+        List<Long> inProgressIds = movesInProgressList.stream().map(m -> m.tabletId).collect(Collectors.toList());\n+        for (TwoDimensionalGreedyAlgo.PartitionReplicaMove move : moves) {\n+            // Find all tablets of the specified partition that would have a replica at the source be,\n+            // but would not have a replica at the destination be. That is to satisfy the restriction\n+            // of having no more than one replica of the same tablet per be.\n+            List<Long> tabletIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.fromBe, medium);\n+            List<Long> invalidIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.toBe, medium);\n+            tabletIds.removeAll(invalidIds);\n+            // In-progress tablets can't be the candidate too.\n+            tabletIds.removeAll(inProgressIds);\n+\n+            Map<Long, TabletMeta> tabletCandidates = Maps.newHashMap();\n+            for (long tabletId : tabletIds) {\n+                TabletMeta tabletMeta = invertedIndex.getTabletMeta(tabletId);\n+                if (tabletMeta != null && tabletMeta.getPartitionId() == move.partitionId\n+                        && tabletMeta.getIndexId() == move.indexId) {\n+                    tabletCandidates.put(tabletId, tabletMeta);\n+                }\n+            }\n+            LOG.debug(\"Find {} candidates for move {}\", tabletCandidates.size(), move);\n+            if (tabletCandidates.isEmpty()) {\n+                continue;\n+            }\n+\n+            // Random pick one candidate to create tabletSchedCtx\n+            Random rand = new Random();\n+            Object[] keys = tabletCandidates.keySet().toArray();\n+            long pickedTabletId = (long) keys[rand.nextInt(keys.length)];\n+            LOG.debug(\"Picked tablet id for move {}: {}\", move, pickedTabletId);\n+\n+            TabletMeta tabletMeta = tabletCandidates.get(pickedTabletId);\n+            TabletSchedCtx tabletCtx = new TabletSchedCtx(TabletSchedCtx.Type.BALANCE, clusterName,\n+                    tabletMeta.getDbId(), tabletMeta.getTableId(), tabletMeta.getPartitionId(),\n+                    tabletMeta.getIndexId(), pickedTabletId, System.currentTimeMillis());\n+            // Balance task's priority is always LOW\n+            tabletCtx.setOrigPriority(TabletSchedCtx.Priority.LOW);\n+            alternativeTablets.add(tabletCtx);\n+            // Pair<Move, ToDeleteReplicaId>, ToDeleteReplicaId should be -1L before scheduled successfully\n+            movesInProgress.get().put(pickedTabletId, new Pair<>(new ReplicaMove(pickedTabletId, move.fromBe, move.toBe), -1L));\n+            counterBalanceMoveCreated.incrementAndGet();\n+            // synchronize with movesInProgress\n+            inProgressIds.add(pickedTabletId);\n+        }\n+\n+        if (moves.isEmpty()) {\n+            // Balanced cluster should not print too much log messages.\n+            LOG.debug(\"Cluster {}-{}: cluster is balanced.\", clusterName, medium);\n+        } else {\n+            LOG.info(\"Cluster {}-{}: get {} moves, actually select {} alternative tablets to move. Tablets detail: {}\",\n+                    clusterName, medium, moves.size(), alternativeTablets.size(),\n+                    alternativeTablets.stream().mapToLong(TabletSchedCtx::getTabletId).toArray());\n+        }\n+        return alternativeTablets;\n+    }\n+\n+    private boolean buildClusterInfo(ClusterLoadStatistic clusterStat, TStorageMedium medium,\n+                                     List<ReplicaMove> movesInProgress, ClusterBalanceInfo info, List<Long> toDeleteKeys) {\n+        Preconditions.checkState(info.beByTotalReplicaCount.isEmpty() && info.partitionInfoBySkew.isEmpty(), \"\");\n+\n+        // If we wanna modify the PartitionBalanceInfo in info.beByTotalReplicaCount, deep-copy it\n+        info.beByTotalReplicaCount.putAll(clusterStat.getBeByTotalReplicaMap(medium));\n+        info.partitionInfoBySkew.putAll(clusterStat.getSkewMap(medium));\n+\n+        // Skip the toDeleteKeys\n+        List<ReplicaMove> filteredMoves = movesInProgress.stream().filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+\n+        for (ReplicaMove move : filteredMoves) {\n+            TabletMeta meta = invertedIndex.getTabletMeta(move.tabletId);\n+            if (meta == null) {\n+                // Move's tablet is invalid, need delete it\n+                toDeleteKeys.add(move.tabletId);\n+                continue;\n+            }\n+\n+            TwoDimensionalGreedyAlgo.PartitionReplicaMove partitionMove = new TwoDimensionalGreedyAlgo.\n+                    PartitionReplicaMove(meta.getPartitionId(), meta.getIndexId(), move.fromBe, move.toBe);\n+            boolean st = TwoDimensionalGreedyAlgo.applyMove(partitionMove, info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (!st) {\n+                // Can't apply this move, mark it failed, continue to apply the next.\n+                toDeleteKeys.add(move.tabletId);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void checkMovesCompleted(List<ReplicaMove> moves, List<Long> toDeleteKeys) {\n+        boolean move_is_complete;\n+        for (ReplicaMove move : moves) {\n+            move_is_complete = checkMoveCompleted(move);\n+            // If the move was completed, remove it\n+            if (move_is_complete) {\n+                toDeleteKeys.add(move.tabletId);\n+                LOG.debug(\"Move {} is completed. The cur dist: {}\", move,\n+                        invertedIndex.getReplicasByTabletId(move.tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList()));\n+                counterBalanceMoveSucceeded.incrementAndGet();\n+            }\n+        }\n+    }\n+\n+    // Move completed: fromBe doesn't have a replica and toBe has a replica\n+    private boolean checkMoveCompleted(ReplicaMove move) {\n+        Long tabletId = move.tabletId;\n+        List<Long> bes = invertedIndex.getReplicasByTabletId(tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList());\n+        return !bes.contains(move.fromBe) && bes.contains(move.toBe);\n+    }\n+\n+    @Override\n+    protected void completeSchedCtx(TabletSchedCtx tabletCtx, Map<Long, TabletScheduler.PathSlot> backendsWorkingSlots)\n+            throws SchedException {\n+        MovesInProgressCache.Cell movesInProgress = movesInProgressCache.getCache(tabletCtx.getCluster(), tabletCtx.getStorageMedium());\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesInProgressMap should have the same entry\");\n+\n+        try {\n+            Pair<ReplicaMove, Long> pair = movesInProgress.get().getIfPresent(tabletCtx.getTabletId());\n+            Preconditions.checkNotNull(pair, \"No cached move for tablet: \" + tabletCtx.getTabletId());\n+\n+            ReplicaMove move = pair.first;\n+            checkMoveValidation(move);\n+\n+            // Check src replica's validation\n+            Replica srcReplica = tabletCtx.getTablet().getReplicaByBackendId(move.fromBe);\n+            Preconditions.checkNotNull(srcReplica);\n+            TabletScheduler.PathSlot slot = backendsWorkingSlots.get(srcReplica.getBackendId());\n+            Preconditions.checkNotNull(slot, \"unable to get fromBe \" + srcReplica.getBackendId() + \" slot\");\n+            if (slot.takeBalanceSlot(srcReplica.getPathHash()) != -1) {\n+                tabletCtx.setSrc(srcReplica);\n+            } else {\n+                throw new SchedException(SchedException.Status.SCHEDULE_FAILED, \"no slot for src replica \" + srcReplica + \", pathHash \" + srcReplica.getPathHash());\n+            }\n+\n+            // Choose a path in destination\n+            ClusterLoadStatistic clusterStat = statisticMap.get(tabletCtx.getCluster());\n+            Preconditions.checkNotNull(clusterStat, \"cluster does not exist: \" + tabletCtx.getCluster());\n+            BackendLoadStatistic beStat = clusterStat.getBackendLoadStatistic(move.toBe);\n+            Preconditions.checkNotNull(beStat);\n+            slot = backendsWorkingSlots.get(move.toBe);\n+            Preconditions.checkNotNull(slot, \"unable to get slot of toBe \" + move.toBe);\n+\n+            List<RootPathLoadStatistic> paths = beStat.getPathStatistics();\n+            Set<Long> availPath = paths.stream().filter(path -> path.getStorageMedium() == tabletCtx.getStorageMedium()\n+                    && path.isFit(tabletCtx.getTabletSize(), false) == BalanceStatus.OK)\n+                    .map(RootPathLoadStatistic::getPathHash).collect(Collectors.toSet());\n+            long pathHash = slot.takeAnAvailBalanceSlotFrom(availPath);\n+            if (pathHash == -1) {\n+                throw new SchedException(SchedException.Status.SCHEDULE_FAILED, \"paths has no available balance slot: \" + availPath);\n+            } else {\n+                tabletCtx.setDest(beStat.getBeId(), pathHash);\n+            }\n+\n+            // ToDeleteReplica is the source replica\n+            pair.second = srcReplica.getId();\n+        } catch (IllegalStateException | NullPointerException e) {\n+            // Problematic move should be invalidated immediately\n+            movesInProgress.get().invalidate(tabletCtx.getTabletId());\n+            throw new SchedException(SchedException.Status.UNRECOVERABLE, e.getMessage());\n+        }\n+    }\n+\n+    // The validation check cannot be accurate, cuz the production of moves do have ordering.\n+    // If some moves failed, the cluster & partition skew is different to the skew when we getNextMove.\n+    // So we can't do skew check.\n+    // Just do some basic checks, e.g. server available.\n+    private void checkMoveValidation(ReplicaMove move) throws IllegalStateException {\n+        boolean fromAvailable = infoService.checkBackendAvailable(move.fromBe);\n+        boolean toAvailable = infoService.checkBackendAvailable(move.toBe);\n+        Preconditions.checkState(fromAvailable && toAvailable, move + \"'s bes are not all available: from \" + fromAvailable + \", to \" + toAvailable);\n+        // To be improved\n+    }", "originalCommit": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE2NTc0NQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r539165745", "bodyText": "Not all, just pick one tablet to generate one move. and apply the move to current balance info, it's in the algo implement.", "author": "vagetablechicken", "createdAt": "2020-12-09T09:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5OTY2OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r539199668", "bodyText": "OK", "author": "gengjun-git", "createdAt": "2020-12-09T10:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NDg0NA=="}], "type": "inlineReview", "revised_code": {"commit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\nindex 0aff34886..206c3fb4e 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n\n@@ -93,7 +93,7 @@ public class PartitionRebalancer extends Rebalancer {\n         LOG.debug(\"Cluster {}-{}: peek max skew {}, assume {} in-progress moves are succeeded {}\", clusterName, medium,\n                 skews.isEmpty() ? 0 : skews.last(), movesInProgressList.size(), movesInProgressList);\n \n-        List<TwoDimensionalGreedyAlgo.PartitionReplicaMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.rebalance_max_moves_num_per_selection);\n+        List<TwoDimensionalGreedyAlgo.PartitionReplicaMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.partition_rebalance_max_moves_num_per_selection);\n \n         List<TabletSchedCtx> alternativeTablets = Lists.newArrayList();\n         List<Long> inProgressIds = movesInProgressList.stream().map(m -> m.tabletId).collect(Collectors.toList());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjA0MA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r546702040", "bodyText": "tablet_rebalancer_type?", "author": "kangkaisen", "createdAt": "2020-12-21T13:21:37Z", "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -1010,6 +1010,18 @@\n     @ConfField(mutable = true, masterOnly = true)\n     public static int max_balancing_tablets = 100;\n \n+    // Rebalancer type(ignore case): BeLoad, Partition. If type parse failed, use BeLoad as default.\n+    @ConfField(masterOnly = true)\n+    public static String rebalancer_type = \"BeLoad\";", "originalCommit": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMjkwOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547032909", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-22T02:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjA0MA=="}], "type": "inlineReview", "revised_code": {"commit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/common/Config.java b/fe/fe-core/src/main/java/org/apache/doris/common/Config.java\nindex 3b5a0d44e..ccb9f2138 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/common/Config.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/common/Config.java\n\n@@ -1012,15 +1012,15 @@ public class Config extends ConfigBase {\n \n     // Rebalancer type(ignore case): BeLoad, Partition. If type parse failed, use BeLoad as default.\n     @ConfField(masterOnly = true)\n-    public static String rebalancer_type = \"BeLoad\";\n+    public static String tablet_rebalancer_type = \"BeLoad\";\n \n     // Valid only if use PartitionRebalancer.\n     @ConfField(mutable = true, masterOnly = true)\n-    public static long rebalance_move_expire_after_access = 600; // 600s\n+    public static long partition_rebalance_move_expire_after_access = 600; // 600s\n \n     // Valid only if use PartitionRebalancer\n     @ConfField(mutable = true, masterOnly = true)\n-    public static int rebalance_max_moves_num_per_selection = 10;\n+    public static int partition_rebalance_max_moves_num_per_selection = 10;\n \n     // This threshold is to avoid piling up too many report task in FE, which may cause OOM exception.\n     // In some large Doris cluster, eg: 100 Backends with ten million replicas, a tablet report may cost\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjYzNg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r546702636", "bodyText": "If only valid for PartitionRebalancer, the name would better add a partition prefix.", "author": "kangkaisen", "createdAt": "2020-12-21T13:23:01Z", "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -1010,6 +1010,18 @@\n     @ConfField(mutable = true, masterOnly = true)\n     public static int max_balancing_tablets = 100;\n \n+    // Rebalancer type(ignore case): BeLoad, Partition. If type parse failed, use BeLoad as default.\n+    @ConfField(masterOnly = true)\n+    public static String rebalancer_type = \"BeLoad\";\n+\n+    // Valid only if use PartitionRebalancer.\n+    @ConfField(mutable = true, masterOnly = true)\n+    public static long rebalance_move_expire_after_access = 600; // 600s", "originalCommit": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMzM1OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547033358", "bodyText": "ok", "author": "vagetablechicken", "createdAt": "2020-12-22T02:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/common/Config.java b/fe/fe-core/src/main/java/org/apache/doris/common/Config.java\nindex 3b5a0d44e..ccb9f2138 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/common/Config.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/common/Config.java\n\n@@ -1012,15 +1012,15 @@ public class Config extends ConfigBase {\n \n     // Rebalancer type(ignore case): BeLoad, Partition. If type parse failed, use BeLoad as default.\n     @ConfField(masterOnly = true)\n-    public static String rebalancer_type = \"BeLoad\";\n+    public static String tablet_rebalancer_type = \"BeLoad\";\n \n     // Valid only if use PartitionRebalancer.\n     @ConfField(mutable = true, masterOnly = true)\n-    public static long rebalance_move_expire_after_access = 600; // 600s\n+    public static long partition_rebalance_move_expire_after_access = 600; // 600s\n \n     // Valid only if use PartitionRebalancer\n     @ConfField(mutable = true, masterOnly = true)\n-    public static int rebalance_max_moves_num_per_selection = 10;\n+    public static int partition_rebalance_max_moves_num_per_selection = 10;\n \n     // This threshold is to avoid piling up too many report task in FE, which may cause OOM exception.\n     // In some large Doris cluster, eg: 100 Backends with ten million replicas, a tablet report may cost\n"}}, {"oid": "db0c06d655f8edd5b5c889768815cc8400b266c2", "url": "https://github.com/apache/incubator-doris/commit/db0c06d655f8edd5b5c889768815cc8400b266c2", "message": "fix by review", "committedDate": "2020-12-22T02:35:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODc1NA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547278754", "bodyText": "Add a comment for cache what?", "author": "kangkaisen", "createdAt": "2020-12-22T13:31:01Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.thrift.TStorageMedium;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+public class MovesInProgressCache {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQyNzE4OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548427188", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-24T07:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "6a267bebec5c53fe67fca1853b079538a298728f", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java b/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java\nindex 224ed44e9..d7aa80456 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java\n\n@@ -22,6 +22,8 @@ import com.google.common.cache.CacheBuilder;\n import com.google.common.collect.Maps;\n import org.apache.doris.common.Pair;\n import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n import java.util.Arrays;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547278972", "bodyText": "maybe need a better name", "author": "kangkaisen", "createdAt": "2020-12-22T13:31:29Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.thrift.TStorageMedium;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+public class MovesInProgressCache {\n+    // cluster -> medium -> moves in progress\n+    private final Map<String, Map<TStorageMedium, Cell>> movesInProgressMap = Maps.newHashMap();\n+\n+    // TabletId -> Pair<Move, ToDeleteReplicaId>, 'ToDeleteReplicaId == -1' means this move haven't been scheduled successfully.\n+    public static class Cell {\n+        Cache<Long, Pair<PartitionRebalancer.ReplicaMove, Long>> cache;\n+\n+        Cell(long duration, TimeUnit unit) {\n+            cache = CacheBuilder.newBuilder().expireAfterAccess(duration, unit).build();\n+        }\n+\n+        public Cache<Long, Pair<PartitionRebalancer.ReplicaMove, Long>> get() {\n+            return cache;\n+        }\n+    }\n+\n+    public void updateCatalog(Map<String, ClusterLoadStatistic> statisticMap, long expireAfterAccessSecond) {\n+        updateCatalog(statisticMap, expireAfterAccessSecond, TimeUnit.SECONDS);\n+    }\n+\n+    public void updateCatalog(Map<String, ClusterLoadStatistic> statisticMap, long duration, TimeUnit unit) {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ0MDcxOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548440719", "bodyText": "how about updateMapping?", "author": "vagetablechicken", "createdAt": "2020-12-24T08:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUzMTg3Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548531872", "bodyText": "\u8fd9\u4e2a\u65b9\u6cd5\u4e0d\u662f\u5728 update cache \u5417\uff1f \u4f60\u7684\u7c7b\u540d\u662fMovesInProgressCache\uff0c \u800c\u4e14\u6709getCache\u3002 \u6240\u4ee5updateCache \u662f\u4e0d\u662f\u66f4\u597d\u7406\u89e3\uff1f", "author": "kangkaisen", "createdAt": "2020-12-24T13:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU0MzM2Nw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548543367", "bodyText": "\u8fd9\u91cc\u662f\u5728\u66f4\u65b0map\u7684\u7ed3\u6784\uff0c\u5e76\u4e0d\u662f\u8981\u5bf9\u5df2\u6709\u7684cache\u505a\u4ec0\u4e48\u66f4\u65b0\u3002", "author": "vagetablechicken", "createdAt": "2020-12-24T14:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc3OTYwOA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548779608", "bodyText": "\u6240\u4ee5\u8fd9\u4e2a\u7c7b\u7684\u8bbe\u8ba1\u662f\u4e0d\u662f\u6709\u4e9b\u95ee\u9898\uff1a\n1 map\u548ccache\u7684\u533a\u522b\u662f\u5565\uff1f\u4e3a\u5565cache \u53ea\u6709get \u65b9\u6cd5\uff0c map\u53ea\u6709update \u65b9\u6cd5\uff1f\n2 \u6211\u770b LoadingCache \u6ca1\u6709\u5b9a\u4e49 load\u65b9\u6cd5\uff0c\u8fd9\u91cccache\u7684\u66f4\u65b0\u662f\u5565\u65f6\u5019\u53d1\u751f\u5462\uff1f", "author": "kangkaisen", "createdAt": "2020-12-25T02:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4NTEwNg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548785106", "bodyText": "\u8fd9\u91cc\u7684\u66f4\u65b0\u662f<cluster, <meduim, cache>\u8fd9\u4e2a\u6620\u5c04\u7684\u66f4\u65b0\uff0c\u4e0d\u662f\u53bb\u66f4\u65b0cache\uff0c\u56e0\u4e3acluster\u76ee\u524d\u8fd8\u662f\u53ef\u4ee5add\u7684\uff0c\u5728\u5468\u671f\u6027update\u5404\u79cd\u4fe1\u606f\u65f6\u987a\u5e26\u628a\u6620\u5c04\u66f4\u65b0\u4e86\uff0c\u4ee5\u514dselectTablet\u65f6\u627e\u4e0d\u5230cache\u3002\ncache\u7528Cell\u7c7b\u88c5\u8d77\u6765\uff0c\u662f\u4e3a\u4e86\u9690\u85cfcache\u7684\u5177\u4f53\u521b\u5efa\uff0c\u9700\u8981\u4fee\u6539\u65f6\u4e5f\u65b9\u4fbf\uff0c\u800c\u4e14Cache\u7684\u540d\u5b57\u592a\u957f\u4e86\u3002\u62ff\u5230cell\u540e\u7528get()\u76f4\u63a5\u64cd\u4f5c\uff0c\u6bd4\u8f83\u65b9\u4fbf\u3002\n\u8fd9\u90e8\u5206\u547d\u540d\u8fd8\u4e0d\u591f\u6e05\u6670\uff0c\u6211\u518d\u6574\u7406\u4e0b", "author": "vagetablechicken", "createdAt": "2020-12-25T02:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MDMzMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548790332", "bodyText": "\u597d\u7684\u3002", "author": "kangkaisen", "createdAt": "2020-12-25T03:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6a267bebec5c53fe67fca1853b079538a298728f", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java b/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java\nindex 224ed44e9..d7aa80456 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java\n\n@@ -22,6 +22,8 @@ import com.google.common.cache.CacheBuilder;\n import com.google.common.collect.Maps;\n import org.apache.doris.common.Pair;\n import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n import java.util.Arrays;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYxNzM5Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547617392", "bodyText": "Could copy the description in the doc to this class comment.", "author": "kangkaisen", "createdAt": "2020-12-23T03:18:44Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class PartitionRebalancer extends Rebalancer {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQyMjYyMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548422622", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-24T07:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYxNzM5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6a267bebec5c53fe67fca1853b079538a298728f", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\nindex 206c3fb4e..477db26eb 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n\n@@ -40,10 +40,17 @@ import java.util.Set;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.stream.Collectors;\n \n+/*\n+ * PartitionRebalancer will decrease the skew of partitions. The skew of the partition is defined as the difference\n+ * between the maximum replica count of the partition over all bes and the minimum replica count over all bes.\n+ * Only consider about the replica count for each partition, never consider the replica size(disk usage).\n+ * To fewer moves, we use TwoDimensionalGreedyAlgo which two dims are cluster & partition.\n+ * It prefers a move that reduce the skew of the cluster when we want to rebalance a max skew partition.\n+ */\n public class PartitionRebalancer extends Rebalancer {\n     private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n \n-    private final TwoDimensionalGreedyAlgo algo = new TwoDimensionalGreedyAlgo();\n+    private final TwoDimensionalGreedyRebalanceAlgo algo = new TwoDimensionalGreedyRebalanceAlgo();\n     protected final MovesInProgressCache movesInProgressCache = new MovesInProgressCache();\n \n     private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTU5Ng==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547621596", "bodyText": "\u6211\u89c9\u5f97\u8fd9\u4e2a\u7c7b\u540d\u5e94\u8be5\u4f53\u73b0\u51fa \u8fd9\u662f\u4e00\u4e2a rebalancing \u76f8\u5173\u7684\u7b97\u6cd5\u3002\n\u7136\u540e \u6ce8\u91ca \u6700\u597d\u89e3\u91ca\u4e0b \u4e24\u7ef4 \u662f\u54ea\u4e24\u7ef4\uff1f", "author": "kangkaisen", "createdAt": "2020-12-23T03:37:31Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyAlgo.java", "diffHunk": "@@ -0,0 +1,326 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+// A two-dimensional greedy rebalancing algorithm. From among moves that\n+// decrease the skew of a most skewed partition, it prefers ones that reduce the\n+// skew of the cluster. A cluster is considered balanced when the skew of every\n+// partition is <= 1 and the skew of the cluster is <= 1.\n+//\n+// The skew of the cluster is defined as the difference between the maximum\n+// total replica count over all bes and the minimum total replica\n+// count over all bes.\n+public class TwoDimensionalGreedyAlgo {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjU2MQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547622561", "bodyText": "\u8fd9\u91cc\u53ef\u4ee5\u6ce8\u660e\u662f \u8fd9\u4e2a\u7c7b\u662f  inspire  \u6216\u8005modify from kudu.", "author": "kangkaisen", "createdAt": "2020-12-23T03:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ0MjY5Ng==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548442696", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-24T08:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6a267bebec5c53fe67fca1853b079538a298728f", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyAlgo.java b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\nsimilarity index 95%\nrename from fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyAlgo.java\nrename to fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\nindex 48946cb0d..179120024 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyAlgo.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n\n@@ -34,16 +34,14 @@ import java.util.Random;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n-// A two-dimensional greedy rebalancing algorithm. From among moves that\n-// decrease the skew of a most skewed partition, it prefers ones that reduce the\n-// skew of the cluster. A cluster is considered balanced when the skew of every\n-// partition is <= 1 and the skew of the cluster is <= 1.\n-//\n-// The skew of the cluster is defined as the difference between the maximum\n-// total replica count over all bes and the minimum total replica\n-// count over all bes.\n-public class TwoDimensionalGreedyAlgo {\n-    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyAlgo.class);\n+// A two-dimensional greedy rebalancing algorithm. The two dim are cluster and partition.\n+// From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+// A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+// The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+// minimum total replica count over all bes.\n+// This class is modified from kudu TwoDimensionalGreedyAlgo.\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n \n     private final EqualSkewOption equalSkewOption;\n     private static final Random rand = new Random(System.currentTimeMillis());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547622309", "bodyText": "\u6211\u4eec\u53ef\u4ee5\u628amove \u8fd9\u4e2a\u6982\u5ff5\u5b8c\u5168\u53bb\u6389\u5417\uff1f \u6539\u6210 balancing \u6216\u8005 balancing_tablets\u3002 \u6211\u4eec\u7cfb\u7edf\u91cc\u9762\u7684\u6982\u5ff5\u5e94\u8be5\u5c3d\u53ef\u80fd\u5c11\uff0c\u4fdd\u6301\u7edf\u4e00\u3002", "author": "kangkaisen", "createdAt": "2020-12-23T03:40:34Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyAlgo algo = new TwoDimensionalGreedyAlgo();\n+    protected final MovesInProgressCache movesInProgressCache = new MovesInProgressCache();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesInProgressCache.Cell movesInProgress = movesInProgressCache.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesInProgressMap should have the same entry\");\n+\n+        // iterating through cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<ReplicaMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<ReplicaMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        if (movesInProgressCache.size() > Config.max_balancing_tablets) {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQxODc2OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548418768", "bodyText": "move\u4e0d\u53ef\u80fd\u53bb\u6389\uff0c\u8c03\u5ea6\u5355\u4f4d\u5c31\u662fReplicaMove\u3002\nmovesInProgressCache.size() > Config.max_balancing_tablets \u8fd9\u4e00\u53e5\u5982\u679c\u89c9\u5f97\u96be\u7406\u89e3\uff0c\u53ef\u4ee5\u52a0\u70b9\u6ce8\u91ca", "author": "vagetablechicken", "createdAt": "2020-12-24T06:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUzMTQwNQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548531405", "bodyText": "\u4e0d\u662f\u554a\u3002 move \u662f\u4e2a\u5f88\u62bd\u8c61\u7684\u6982\u5ff5\u3002\u6211\u89c9\u5f97\uff0c \u4e00\u4e2a \u7684balance \u7cfb\u7edf\u662f\u6ca1\u5fc5\u8981\u51fa\u73b0\u8fd9\u4e2a\u6982\u5ff5\u7684\uff0c\u4f60\u7684\u4e00\u4e2amove\u5c31\u662f\u4e00\u4e2abalancing\u7684Replica\u3002\n\nmovesInProgressCache.size() > Config.max_balancing_tablets \u8fd9\u4e00\u53e5\u5982\u679c\u89c9\u5f97\u96be\u7406\u89e3\uff0c\u53ef\u4ee5\u52a0\u70b9\u6ce8\u91ca\n\n\u6211\u4e0d\u662f\u7279\u6307\u8fd9\u4e00\u5904\uff0c\u800c\u662f\u8fd9\u4e2aPR\u3002\n\u6240\u6709balancing \u7b97\u6cd5\u7684\u6982\u5ff5\u5e94\u8be5\u662f\u7edf\u4e00\u7684\uff0c\u8fd9\u6837\u5176\u4ed6\u4eba\u53ef\u4ee5\u5feb\u901f\u7406\u89e3\u6bcf\u4e2abalancing\u7b97\u6cd5\u7684\u5f02\u540c\u3002", "author": "kangkaisen", "createdAt": "2020-12-24T13:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU0NDQ3MA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548544470", "bodyText": "PartitionRebalancer\u5df2\u7ecf\u662f\u4e2a\u5177\u4f53\u7684rebalancer\uff0c\u5b83\u7684\u4efb\u52a1\u5c31\u662f\u4ecealgo\u90a3\u91cc\u62ff\u5230\u9700\u8981\u6267\u884c\u7684moves\uff0c\u7136\u540e\u53bb\u6267\u884cmoves\uff0c\u7ba1\u7406moves\uff0c\u804c\u8d23\u5df2\u7ecf\u5f88\u5c0f\u4e86\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u8981\u53bb\u9690\u85cfmove\u7684\u6982\u5ff5\uff1f", "author": "vagetablechicken", "createdAt": "2020-12-24T14:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc3OTcxOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548779719", "bodyText": "\u6240\u4ee5\u4f60\u53ef\u4ee5\u7528\u7b80\u5355\u7684\u4e00\u53e5\u8bdd\u6e05\u6670\u5730\u5b9a\u4e49\u5565\u662fmove \u5417\uff1f", "author": "kangkaisen", "createdAt": "2020-12-25T02:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4NjQwNA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548786404", "bodyText": "move\u5c31\u662f\u4e3a\u5f53\u524dreplica\u5206\u5e03\u5982\u4f55\u8fbe\u5230\u5e73\u8861\u800c\u8ba1\u7b97\u51fa\u6765\u7684\u8fc1\u79fb\u6b65\u9aa4\u3002\nalgo\u7684\u89d2\u5ea6move\u5c31\u662f<partition id, from be, to be>\uff0cpartition rebalancer\u9009\u62e9\u7279\u5b9atablet\u540e\u7684move\u5c31\u662f<tablet id, from be, to be>\u3002", "author": "vagetablechicken", "createdAt": "2020-12-25T03:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MDc2MQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548790761", "bodyText": "algo\u7684\u89d2\u5ea6move\u5c31\u662f<partition id, from be, to be>\uff0cpartition rebalancer\u9009\u62e9\u7279\u5b9atablet\u540e\u7684move\u5c31\u662f<tablet id, from be, to be>\u3002\n\n\u55ef\uff0c\u8fd9\u4e2a\u662f\u597d\u7406\u89e3\u7684\u3002 \u6240\u4ee5\u6211\u7684\u610f\u601d\u6211\u4eec\u53ef\u4ee5\u547d\u540d\u6210 balancingPartition \u548c balancingTablet\uff1f \u5373\u4f7f\u4e00\u5b9a\u8981\u7528move\u7684\u8bdd\uff0c\u4e5f\u53ef\u4ee5\u6539\u6210 partitionMove \u548c tabletMove ?  \u56e0\u4e3a \u6211\u611f\u89c9 move \u8fd9\u4e2a\u547d\u540d\u592a\u62bd\u8c61\u4e86\u3002", "author": "kangkaisen", "createdAt": "2020-12-25T03:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NDYwNQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548794605", "bodyText": "move\u662f\u7b97\u6cd5\u7684\u57fa\u672c\u7ed3\u679c\uff0c\u8fd8\u662f\u4fdd\u7559\u5427\uff0cReplicaMove\u8fd9\u4e2a\u540d\u5b57\u6539\u6210TabletMove, PartitionReplicaMove\u6539\u4e3aPartitionMove\u5427", "author": "vagetablechicken", "createdAt": "2020-12-25T04:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgwMDE3Mw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548800173", "bodyText": "\u597d\u7684\u3002", "author": "kangkaisen", "createdAt": "2020-12-25T04:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a267bebec5c53fe67fca1853b079538a298728f", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\nindex 206c3fb4e..477db26eb 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n\n@@ -40,10 +40,17 @@ import java.util.Set;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.stream.Collectors;\n \n+/*\n+ * PartitionRebalancer will decrease the skew of partitions. The skew of the partition is defined as the difference\n+ * between the maximum replica count of the partition over all bes and the minimum replica count over all bes.\n+ * Only consider about the replica count for each partition, never consider the replica size(disk usage).\n+ * To fewer moves, we use TwoDimensionalGreedyAlgo which two dims are cluster & partition.\n+ * It prefers a move that reduce the skew of the cluster when we want to rebalance a max skew partition.\n+ */\n public class PartitionRebalancer extends Rebalancer {\n     private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n \n-    private final TwoDimensionalGreedyAlgo algo = new TwoDimensionalGreedyAlgo();\n+    private final TwoDimensionalGreedyRebalanceAlgo algo = new TwoDimensionalGreedyRebalanceAlgo();\n     protected final MovesInProgressCache movesInProgressCache = new MovesInProgressCache();\n \n     private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n"}}, {"oid": "6a267bebec5c53fe67fca1853b079538a298728f", "url": "https://github.com/apache/incubator-doris/commit/6a267bebec5c53fe67fca1853b079538a298728f", "message": "[] fixed by review", "committedDate": "2020-12-24T08:20:30Z", "type": "commit"}, {"oid": "d0ee249fc3eb81897b05c2e4e0b55f4640f87886", "url": "https://github.com/apache/incubator-doris/commit/d0ee249fc3eb81897b05c2e4e0b55f4640f87886", "message": "[] fix", "committedDate": "2020-12-24T08:25:17Z", "type": "commit"}, {"oid": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "url": "https://github.com/apache/incubator-doris/commit/5ef852d3a8ba19a2de2819066fb89addca6db4a5", "message": "[] fixed by review", "committedDate": "2020-12-25T10:42:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM2OTMyNA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549369324", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            long min_count = pbi.beByReplicaCount.keySet().first();\n          \n          \n            \n                            long minCount = pbi.beByReplicaCount.keySet().first();", "author": "morningman", "createdAt": "2020-12-28T14:35:31Z", "path": "fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java", "diffHunk": "@@ -602,5 +604,96 @@ public void clear() {\n     public Map<Long, Long> getReplicaToTabletMap() {\n         return replicaToTabletMap;\n     }\n+\n+    // Only build from available bes, exclude colocate tables\n+    public Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> buildPartitionInfoBySkew(List<Long> availableBeIds) {\n+        readLock();\n+\n+        // 1. gen <partitionId-indexId, <beId, replicaCount>>\n+        // for each replica(all tablets):\n+        //      find beId, then replicaCount++\n+        Map<TStorageMedium, Table<Long, Long, Map<Long, Long>>> partitionReplicasInfoMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            partitionReplicasInfoMaps.put(medium, HashBasedTable.create());\n+        }\n+        try {\n+            // Changes to the returned set will update the underlying table\n+            // tablet id -> (backend id -> replica)\n+            Set<Table.Cell<Long, Long, Replica>> cells = replicaMetaTable.cellSet();\n+            for (Table.Cell<Long, Long, Replica> cell : cells) {\n+                Long tabletId = cell.getRowKey();\n+                Long beId = cell.getColumnKey();\n+                try {\n+                    Preconditions.checkState(availableBeIds.contains(beId), \"dead be \" + beId);\n+                    TabletMeta tabletMeta = tabletMetaMap.get(tabletId);\n+                    Preconditions.checkNotNull(tabletMeta, \"invalid tablet \" + tabletId);\n+                    Preconditions.checkState(!Catalog.getCurrentColocateIndex().isColocateTable(tabletMeta.getTableId()),\n+                            \"should not be the colocate table\");\n+\n+                    TStorageMedium medium = tabletMeta.getStorageMedium();\n+                    Table<Long, Long, Map<Long, Long>> partitionReplicasInfo = partitionReplicasInfoMaps.get(medium);\n+                    Map<Long, Long> countMap = partitionReplicasInfo.get(tabletMeta.getPartitionId(), tabletMeta.getIndexId());\n+                    if (countMap == null) {\n+                        // If one be doesn't have any replica of one partition, it should be counted too.\n+                        countMap = availableBeIds.stream().collect(Collectors.toMap(i -> i, i -> 0L));\n+                    }\n+\n+                    Long count = countMap.get(beId);\n+                    countMap.put(beId, count + 1L);\n+                    partitionReplicasInfo.put(tabletMeta.getPartitionId(), tabletMeta.getIndexId(), countMap);\n+                    partitionReplicasInfoMaps.put(medium, partitionReplicasInfo);\n+                } catch (IllegalStateException | NullPointerException e) {\n+                    // If the tablet or be has some problem, don't count in\n+                    LOG.debug(e.getMessage());\n+                }\n+            }\n+        } finally {\n+            readUnlock();\n+        }\n+\n+        // 2. Populate ClusterBalanceInfo::table_info_by_skew\n+        // for each PartitionId-MaterializedIndex:\n+        //      for each beId: record max_count, min_count(replicaCount)\n+        //      put <max_count-min_count, TableBalanceInfo> to table_info_by_skew\n+        Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> skewMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            TreeMultimap<Long, PartitionBalanceInfo> partitionInfoBySkew = TreeMultimap.create(Ordering.natural(), Ordering.arbitrary());\n+            Set<Table.Cell<Long, Long, Map<Long, Long>>> mapCells = partitionReplicasInfoMaps.getOrDefault(medium, HashBasedTable.create()).cellSet();\n+            for (Table.Cell<Long, Long, Map<Long, Long>> cell : mapCells) {\n+                Map<Long, Long> countMap = cell.getValue();\n+                Preconditions.checkNotNull(countMap);\n+                PartitionBalanceInfo pbi = new PartitionBalanceInfo(cell.getRowKey(), cell.getColumnKey());\n+                for (Map.Entry<Long, Long> entry : countMap.entrySet()) {\n+                    Long beID = entry.getKey();\n+                    Long replicaCount = entry.getValue();\n+                    pbi.beByReplicaCount.put(replicaCount, beID);\n+                }\n+                // beByReplicaCount values are natural ordering\n+                long min_count = pbi.beByReplicaCount.keySet().first();", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java b/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java\nindex 8237f194f..edad1e0e6 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java\n\n@@ -669,9 +669,9 @@ public class TabletInvertedIndex {\n                     pbi.beByReplicaCount.put(replicaCount, beID);\n                 }\n                 // beByReplicaCount values are natural ordering\n-                long min_count = pbi.beByReplicaCount.keySet().first();\n-                long max_count = pbi.beByReplicaCount.keySet().last();\n-                partitionInfoBySkew.put(max_count - min_count, pbi);\n+                long minCount = pbi.beByReplicaCount.keySet().first();\n+                long maxCount = pbi.beByReplicaCount.keySet().last();\n+                partitionInfoBySkew.put(maxCount - minCount, pbi);\n             }\n             skewMaps.put(medium, partitionInfoBySkew);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM2OTQwMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549369402", "bodyText": "maxCount", "author": "morningman", "createdAt": "2020-12-28T14:35:44Z", "path": "fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java", "diffHunk": "@@ -602,5 +604,96 @@ public void clear() {\n     public Map<Long, Long> getReplicaToTabletMap() {\n         return replicaToTabletMap;\n     }\n+\n+    // Only build from available bes, exclude colocate tables\n+    public Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> buildPartitionInfoBySkew(List<Long> availableBeIds) {\n+        readLock();\n+\n+        // 1. gen <partitionId-indexId, <beId, replicaCount>>\n+        // for each replica(all tablets):\n+        //      find beId, then replicaCount++\n+        Map<TStorageMedium, Table<Long, Long, Map<Long, Long>>> partitionReplicasInfoMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            partitionReplicasInfoMaps.put(medium, HashBasedTable.create());\n+        }\n+        try {\n+            // Changes to the returned set will update the underlying table\n+            // tablet id -> (backend id -> replica)\n+            Set<Table.Cell<Long, Long, Replica>> cells = replicaMetaTable.cellSet();\n+            for (Table.Cell<Long, Long, Replica> cell : cells) {\n+                Long tabletId = cell.getRowKey();\n+                Long beId = cell.getColumnKey();\n+                try {\n+                    Preconditions.checkState(availableBeIds.contains(beId), \"dead be \" + beId);\n+                    TabletMeta tabletMeta = tabletMetaMap.get(tabletId);\n+                    Preconditions.checkNotNull(tabletMeta, \"invalid tablet \" + tabletId);\n+                    Preconditions.checkState(!Catalog.getCurrentColocateIndex().isColocateTable(tabletMeta.getTableId()),\n+                            \"should not be the colocate table\");\n+\n+                    TStorageMedium medium = tabletMeta.getStorageMedium();\n+                    Table<Long, Long, Map<Long, Long>> partitionReplicasInfo = partitionReplicasInfoMaps.get(medium);\n+                    Map<Long, Long> countMap = partitionReplicasInfo.get(tabletMeta.getPartitionId(), tabletMeta.getIndexId());\n+                    if (countMap == null) {\n+                        // If one be doesn't have any replica of one partition, it should be counted too.\n+                        countMap = availableBeIds.stream().collect(Collectors.toMap(i -> i, i -> 0L));\n+                    }\n+\n+                    Long count = countMap.get(beId);\n+                    countMap.put(beId, count + 1L);\n+                    partitionReplicasInfo.put(tabletMeta.getPartitionId(), tabletMeta.getIndexId(), countMap);\n+                    partitionReplicasInfoMaps.put(medium, partitionReplicasInfo);\n+                } catch (IllegalStateException | NullPointerException e) {\n+                    // If the tablet or be has some problem, don't count in\n+                    LOG.debug(e.getMessage());\n+                }\n+            }\n+        } finally {\n+            readUnlock();\n+        }\n+\n+        // 2. Populate ClusterBalanceInfo::table_info_by_skew\n+        // for each PartitionId-MaterializedIndex:\n+        //      for each beId: record max_count, min_count(replicaCount)\n+        //      put <max_count-min_count, TableBalanceInfo> to table_info_by_skew\n+        Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> skewMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            TreeMultimap<Long, PartitionBalanceInfo> partitionInfoBySkew = TreeMultimap.create(Ordering.natural(), Ordering.arbitrary());\n+            Set<Table.Cell<Long, Long, Map<Long, Long>>> mapCells = partitionReplicasInfoMaps.getOrDefault(medium, HashBasedTable.create()).cellSet();\n+            for (Table.Cell<Long, Long, Map<Long, Long>> cell : mapCells) {\n+                Map<Long, Long> countMap = cell.getValue();\n+                Preconditions.checkNotNull(countMap);\n+                PartitionBalanceInfo pbi = new PartitionBalanceInfo(cell.getRowKey(), cell.getColumnKey());\n+                for (Map.Entry<Long, Long> entry : countMap.entrySet()) {\n+                    Long beID = entry.getKey();\n+                    Long replicaCount = entry.getValue();\n+                    pbi.beByReplicaCount.put(replicaCount, beID);\n+                }\n+                // beByReplicaCount values are natural ordering\n+                long min_count = pbi.beByReplicaCount.keySet().first();\n+                long max_count = pbi.beByReplicaCount.keySet().last();", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java b/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java\nindex 8237f194f..edad1e0e6 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java\n\n@@ -669,9 +669,9 @@ public class TabletInvertedIndex {\n                     pbi.beByReplicaCount.put(replicaCount, beID);\n                 }\n                 // beByReplicaCount values are natural ordering\n-                long min_count = pbi.beByReplicaCount.keySet().first();\n-                long max_count = pbi.beByReplicaCount.keySet().last();\n-                partitionInfoBySkew.put(max_count - min_count, pbi);\n+                long minCount = pbi.beByReplicaCount.keySet().first();\n+                long maxCount = pbi.beByReplicaCount.keySet().last();\n+                partitionInfoBySkew.put(maxCount - minCount, pbi);\n             }\n             skewMaps.put(medium, partitionInfoBySkew);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM5NTE1Nw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549395157", "bodyText": "Is 1 too strict here?", "author": "morningman", "createdAt": "2020-12-28T15:51:26Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDIxNA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549560214", "bodyText": "The algo should get accurate calculation results. And I think there is no reason yet to relax the condition.", "author": "vagetablechicken", "createdAt": "2020-12-29T04:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM5NTE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\nindex 162765160..cabb5afe1 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n\n@@ -178,7 +178,7 @@ public class TwoDimensionalGreedyRebalanceAlgo {\n \n             Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n             Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n-            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+            LOG.debug(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n                     pbi.partitionId, pbi.indexId, maxPartitionSkew,\n                     minReplicaCount, maxReplicaCount);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0MzM1Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549543352", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean move_is_complete;\n          \n          \n            \n                    boolean isMoveComplete;", "author": "morningman", "createdAt": "2020-12-29T02:13:29Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,337 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * PartitionRebalancer will decrease the skew of partitions. The skew of the partition is defined as the difference\n+ * between the maximum replica count of the partition over all bes and the minimum replica count over all bes.\n+ * Only consider about the replica count for each partition, never consider the replica size(disk usage).\n+ *\n+ * We use TwoDimensionalGreedyRebalanceAlgo to get partition moves(one PartitionMove is <partition id, from be, to be>).\n+ * It prefers a move that reduce the skew of the cluster when we want to rebalance a max skew partition.\n+ *\n+ * selectAlternativeTabletsForCluster() must set the tablet id, so we need to select tablet for each move in this phase\n+ * (as TabletMove).\n+ */\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyRebalanceAlgo algo = new TwoDimensionalGreedyRebalanceAlgo();\n+\n+    private final MovesCacheMap movesCacheMap = new MovesCacheMap();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesCacheMap.MovesCache movesInProgress = movesCacheMap.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesCacheMap should have the same entry\");\n+\n+        // Iterating through Cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<TabletMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<TabletMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        // The balancing tasks of other cluster or medium might have failed. We use the upper limit value\n+        // `total num of in-progress moves` to avoid useless selections.\n+        if (movesCacheMap.size() > Config.max_balancing_tablets) {\n+            LOG.debug(\"Total in-progress moves > {}\", Config.max_balancing_tablets);\n+            return Lists.newArrayList();\n+        }\n+\n+        NavigableSet<Long> skews = clusterBalanceInfo.partitionInfoBySkew.keySet();\n+        LOG.debug(\"Cluster {}-{}: peek max skew {}, assume {} in-progress moves are succeeded {}\", clusterName, medium,\n+                skews.isEmpty() ? 0 : skews.last(), movesInProgressList.size(), movesInProgressList);\n+\n+        List<TwoDimensionalGreedyRebalanceAlgo.PartitionMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.partition_rebalance_max_moves_num_per_selection);\n+\n+        List<TabletSchedCtx> alternativeTablets = Lists.newArrayList();\n+        List<Long> inProgressIds = movesInProgressList.stream().map(m -> m.tabletId).collect(Collectors.toList());\n+        for (TwoDimensionalGreedyRebalanceAlgo.PartitionMove move : moves) {\n+            // Find all tablets of the specified partition that would have a replica at the source be,\n+            // but would not have a replica at the destination be. That is to satisfy the restriction\n+            // of having no more than one replica of the same tablet per be.\n+            List<Long> tabletIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.fromBe, medium);\n+            List<Long> invalidIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.toBe, medium);\n+            tabletIds.removeAll(invalidIds);\n+            // In-progress tablets can't be the candidate too.\n+            tabletIds.removeAll(inProgressIds);\n+\n+            Map<Long, TabletMeta> tabletCandidates = Maps.newHashMap();\n+            for (long tabletId : tabletIds) {\n+                TabletMeta tabletMeta = invertedIndex.getTabletMeta(tabletId);\n+                if (tabletMeta != null && tabletMeta.getPartitionId() == move.partitionId\n+                        && tabletMeta.getIndexId() == move.indexId) {\n+                    tabletCandidates.put(tabletId, tabletMeta);\n+                }\n+            }\n+            LOG.debug(\"Find {} candidates for move {}\", tabletCandidates.size(), move);\n+            if (tabletCandidates.isEmpty()) {\n+                continue;\n+            }\n+\n+            // Random pick one candidate to create tabletSchedCtx\n+            Random rand = new Random();\n+            Object[] keys = tabletCandidates.keySet().toArray();\n+            long pickedTabletId = (long) keys[rand.nextInt(keys.length)];\n+            LOG.debug(\"Picked tablet id for move {}: {}\", move, pickedTabletId);\n+\n+            TabletMeta tabletMeta = tabletCandidates.get(pickedTabletId);\n+            TabletSchedCtx tabletCtx = new TabletSchedCtx(TabletSchedCtx.Type.BALANCE, clusterName,\n+                    tabletMeta.getDbId(), tabletMeta.getTableId(), tabletMeta.getPartitionId(),\n+                    tabletMeta.getIndexId(), pickedTabletId, System.currentTimeMillis());\n+            // Balance task's priority is always LOW\n+            tabletCtx.setOrigPriority(TabletSchedCtx.Priority.LOW);\n+            alternativeTablets.add(tabletCtx);\n+            // Pair<Move, ToDeleteReplicaId>, ToDeleteReplicaId should be -1L before scheduled successfully\n+            movesInProgress.get().put(pickedTabletId, new Pair<>(new TabletMove(pickedTabletId, move.fromBe, move.toBe), -1L));\n+            counterBalanceMoveCreated.incrementAndGet();\n+            // Synchronize with movesInProgress\n+            inProgressIds.add(pickedTabletId);\n+        }\n+\n+        if (moves.isEmpty()) {\n+            // Balanced cluster should not print too much log messages, so we log it with level debug.\n+            LOG.debug(\"Cluster {}-{}: cluster is balanced.\", clusterName, medium);\n+        } else {\n+            LOG.info(\"Cluster {}-{}: get {} moves, actually select {} alternative tablets to move. Tablets detail: {}\",\n+                    clusterName, medium, moves.size(), alternativeTablets.size(),\n+                    alternativeTablets.stream().mapToLong(TabletSchedCtx::getTabletId).toArray());\n+        }\n+        return alternativeTablets;\n+    }\n+\n+    private boolean buildClusterInfo(ClusterLoadStatistic clusterStat, TStorageMedium medium,\n+                                     List<TabletMove> movesInProgress, ClusterBalanceInfo info, List<Long> toDeleteKeys) {\n+        Preconditions.checkState(info.beByTotalReplicaCount.isEmpty() && info.partitionInfoBySkew.isEmpty(), \"\");\n+\n+        // If we wanna modify the PartitionBalanceInfo in info.beByTotalReplicaCount, deep-copy it\n+        info.beByTotalReplicaCount.putAll(clusterStat.getBeByTotalReplicaMap(medium));\n+        info.partitionInfoBySkew.putAll(clusterStat.getSkewMap(medium));\n+\n+        // Skip the toDeleteKeys\n+        List<TabletMove> filteredMoves = movesInProgress.stream().filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+\n+        for (TabletMove move : filteredMoves) {\n+            TabletMeta meta = invertedIndex.getTabletMeta(move.tabletId);\n+            if (meta == null) {\n+                // Move's tablet is invalid, need delete it\n+                toDeleteKeys.add(move.tabletId);\n+                continue;\n+            }\n+\n+            TwoDimensionalGreedyRebalanceAlgo.PartitionMove partitionMove = new TwoDimensionalGreedyRebalanceAlgo.PartitionMove(meta.getPartitionId(), meta.getIndexId(), move.fromBe, move.toBe);\n+            boolean st = TwoDimensionalGreedyRebalanceAlgo.applyMove(partitionMove, info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (!st) {\n+                // Can't apply this move, mark it failed, continue to apply the next.\n+                toDeleteKeys.add(move.tabletId);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void checkMovesCompleted(List<TabletMove> moves, List<Long> toDeleteKeys) {\n+        boolean move_is_complete;", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\nindex 03d4843bd..d4cd812a5 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n\n@@ -195,11 +195,11 @@ public class PartitionRebalancer extends Rebalancer {\n     }\n \n     private void checkMovesCompleted(List<TabletMove> moves, List<Long> toDeleteKeys) {\n-        boolean move_is_complete;\n+        boolean moveIsComplete;\n         for (TabletMove move : moves) {\n-            move_is_complete = checkMoveCompleted(move);\n+            moveIsComplete = checkMoveCompleted(move);\n             // If the move was completed, remove it\n-            if (move_is_complete) {\n+            if (moveIsComplete) {\n                 toDeleteKeys.add(move.tabletId);\n                 LOG.debug(\"Move {} is completed. The cur dist: {}\", move,\n                         invertedIndex.getReplicasByTabletId(move.tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NDIyMA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549544220", "bodyText": "The new replica will be added to the tablet at the beginning of clone task with state CLONE.\nAnd the \"fromBE\" replica may be dropped for other reason such as \"data broken on BE\".\nSo are you sure !bes.contains(move.fromBe) && bes.contains(move.toBe) can be treated as move complete?", "author": "morningman", "createdAt": "2020-12-29T02:18:45Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,337 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * PartitionRebalancer will decrease the skew of partitions. The skew of the partition is defined as the difference\n+ * between the maximum replica count of the partition over all bes and the minimum replica count over all bes.\n+ * Only consider about the replica count for each partition, never consider the replica size(disk usage).\n+ *\n+ * We use TwoDimensionalGreedyRebalanceAlgo to get partition moves(one PartitionMove is <partition id, from be, to be>).\n+ * It prefers a move that reduce the skew of the cluster when we want to rebalance a max skew partition.\n+ *\n+ * selectAlternativeTabletsForCluster() must set the tablet id, so we need to select tablet for each move in this phase\n+ * (as TabletMove).\n+ */\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyRebalanceAlgo algo = new TwoDimensionalGreedyRebalanceAlgo();\n+\n+    private final MovesCacheMap movesCacheMap = new MovesCacheMap();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesCacheMap.MovesCache movesInProgress = movesCacheMap.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesCacheMap should have the same entry\");\n+\n+        // Iterating through Cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<TabletMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<TabletMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        // The balancing tasks of other cluster or medium might have failed. We use the upper limit value\n+        // `total num of in-progress moves` to avoid useless selections.\n+        if (movesCacheMap.size() > Config.max_balancing_tablets) {\n+            LOG.debug(\"Total in-progress moves > {}\", Config.max_balancing_tablets);\n+            return Lists.newArrayList();\n+        }\n+\n+        NavigableSet<Long> skews = clusterBalanceInfo.partitionInfoBySkew.keySet();\n+        LOG.debug(\"Cluster {}-{}: peek max skew {}, assume {} in-progress moves are succeeded {}\", clusterName, medium,\n+                skews.isEmpty() ? 0 : skews.last(), movesInProgressList.size(), movesInProgressList);\n+\n+        List<TwoDimensionalGreedyRebalanceAlgo.PartitionMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.partition_rebalance_max_moves_num_per_selection);\n+\n+        List<TabletSchedCtx> alternativeTablets = Lists.newArrayList();\n+        List<Long> inProgressIds = movesInProgressList.stream().map(m -> m.tabletId).collect(Collectors.toList());\n+        for (TwoDimensionalGreedyRebalanceAlgo.PartitionMove move : moves) {\n+            // Find all tablets of the specified partition that would have a replica at the source be,\n+            // but would not have a replica at the destination be. That is to satisfy the restriction\n+            // of having no more than one replica of the same tablet per be.\n+            List<Long> tabletIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.fromBe, medium);\n+            List<Long> invalidIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.toBe, medium);\n+            tabletIds.removeAll(invalidIds);\n+            // In-progress tablets can't be the candidate too.\n+            tabletIds.removeAll(inProgressIds);\n+\n+            Map<Long, TabletMeta> tabletCandidates = Maps.newHashMap();\n+            for (long tabletId : tabletIds) {\n+                TabletMeta tabletMeta = invertedIndex.getTabletMeta(tabletId);\n+                if (tabletMeta != null && tabletMeta.getPartitionId() == move.partitionId\n+                        && tabletMeta.getIndexId() == move.indexId) {\n+                    tabletCandidates.put(tabletId, tabletMeta);\n+                }\n+            }\n+            LOG.debug(\"Find {} candidates for move {}\", tabletCandidates.size(), move);\n+            if (tabletCandidates.isEmpty()) {\n+                continue;\n+            }\n+\n+            // Random pick one candidate to create tabletSchedCtx\n+            Random rand = new Random();\n+            Object[] keys = tabletCandidates.keySet().toArray();\n+            long pickedTabletId = (long) keys[rand.nextInt(keys.length)];\n+            LOG.debug(\"Picked tablet id for move {}: {}\", move, pickedTabletId);\n+\n+            TabletMeta tabletMeta = tabletCandidates.get(pickedTabletId);\n+            TabletSchedCtx tabletCtx = new TabletSchedCtx(TabletSchedCtx.Type.BALANCE, clusterName,\n+                    tabletMeta.getDbId(), tabletMeta.getTableId(), tabletMeta.getPartitionId(),\n+                    tabletMeta.getIndexId(), pickedTabletId, System.currentTimeMillis());\n+            // Balance task's priority is always LOW\n+            tabletCtx.setOrigPriority(TabletSchedCtx.Priority.LOW);\n+            alternativeTablets.add(tabletCtx);\n+            // Pair<Move, ToDeleteReplicaId>, ToDeleteReplicaId should be -1L before scheduled successfully\n+            movesInProgress.get().put(pickedTabletId, new Pair<>(new TabletMove(pickedTabletId, move.fromBe, move.toBe), -1L));\n+            counterBalanceMoveCreated.incrementAndGet();\n+            // Synchronize with movesInProgress\n+            inProgressIds.add(pickedTabletId);\n+        }\n+\n+        if (moves.isEmpty()) {\n+            // Balanced cluster should not print too much log messages, so we log it with level debug.\n+            LOG.debug(\"Cluster {}-{}: cluster is balanced.\", clusterName, medium);\n+        } else {\n+            LOG.info(\"Cluster {}-{}: get {} moves, actually select {} alternative tablets to move. Tablets detail: {}\",\n+                    clusterName, medium, moves.size(), alternativeTablets.size(),\n+                    alternativeTablets.stream().mapToLong(TabletSchedCtx::getTabletId).toArray());\n+        }\n+        return alternativeTablets;\n+    }\n+\n+    private boolean buildClusterInfo(ClusterLoadStatistic clusterStat, TStorageMedium medium,\n+                                     List<TabletMove> movesInProgress, ClusterBalanceInfo info, List<Long> toDeleteKeys) {\n+        Preconditions.checkState(info.beByTotalReplicaCount.isEmpty() && info.partitionInfoBySkew.isEmpty(), \"\");\n+\n+        // If we wanna modify the PartitionBalanceInfo in info.beByTotalReplicaCount, deep-copy it\n+        info.beByTotalReplicaCount.putAll(clusterStat.getBeByTotalReplicaMap(medium));\n+        info.partitionInfoBySkew.putAll(clusterStat.getSkewMap(medium));\n+\n+        // Skip the toDeleteKeys\n+        List<TabletMove> filteredMoves = movesInProgress.stream().filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+\n+        for (TabletMove move : filteredMoves) {\n+            TabletMeta meta = invertedIndex.getTabletMeta(move.tabletId);\n+            if (meta == null) {\n+                // Move's tablet is invalid, need delete it\n+                toDeleteKeys.add(move.tabletId);\n+                continue;\n+            }\n+\n+            TwoDimensionalGreedyRebalanceAlgo.PartitionMove partitionMove = new TwoDimensionalGreedyRebalanceAlgo.PartitionMove(meta.getPartitionId(), meta.getIndexId(), move.fromBe, move.toBe);\n+            boolean st = TwoDimensionalGreedyRebalanceAlgo.applyMove(partitionMove, info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (!st) {\n+                // Can't apply this move, mark it failed, continue to apply the next.\n+                toDeleteKeys.add(move.tabletId);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void checkMovesCompleted(List<TabletMove> moves, List<Long> toDeleteKeys) {\n+        boolean move_is_complete;\n+        for (TabletMove move : moves) {\n+            move_is_complete = checkMoveCompleted(move);\n+            // If the move was completed, remove it\n+            if (move_is_complete) {\n+                toDeleteKeys.add(move.tabletId);\n+                LOG.debug(\"Move {} is completed. The cur dist: {}\", move,\n+                        invertedIndex.getReplicasByTabletId(move.tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList()));\n+                counterBalanceMoveSucceeded.incrementAndGet();\n+            }\n+        }\n+    }\n+\n+    // Move completed: fromBe doesn't have a replica and toBe has a replica\n+    private boolean checkMoveCompleted(TabletMove move) {", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTA5NA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549561094", "bodyText": "It's hard to define, but when !bes.contains(move.fromBe) && bes.contains(move.toBe), the move is useless. So why not to treat it as completed.", "author": "vagetablechicken", "createdAt": "2020-12-29T04:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NDIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\nindex 03d4843bd..d4cd812a5 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java\n\n@@ -195,11 +195,11 @@ public class PartitionRebalancer extends Rebalancer {\n     }\n \n     private void checkMovesCompleted(List<TabletMove> moves, List<Long> toDeleteKeys) {\n-        boolean move_is_complete;\n+        boolean moveIsComplete;\n         for (TabletMove move : moves) {\n-            move_is_complete = checkMoveCompleted(move);\n+            moveIsComplete = checkMoveCompleted(move);\n             // If the move was completed, remove it\n-            if (move_is_complete) {\n+            if (moveIsComplete) {\n                 toDeleteKeys.add(move.tabletId);\n                 LOG.debug(\"Move {} is completed. The cur dist: {}\", move,\n                         invertedIndex.getReplicasByTabletId(move.tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1Mzk1Nw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549553957", "bodyText": "debug is better?", "author": "morningman", "createdAt": "2020-12-29T03:21:48Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {\n+            return null;\n+        }\n+\n+        // Among the partitions with maximum skew, attempt to pick a partition where there is\n+        // a move that improves the partition skew and the cluster skew, if possible. If\n+        // not, attempt to pick a move that improves the partition skew. If all partitions\n+        // are balanced, attempt to pick a move that preserves partition balance and\n+        // improves cluster skew.\n+        NavigableSet<PartitionBalanceInfo> maxSet = skewMap.get(maxPartitionSkew);\n+        for (PartitionBalanceInfo pbi : maxSet) {\n+            Preconditions.checkArgument(!pbi.beByReplicaCount.isEmpty(), \"no information on replicas of \" +\n+                    \"partition \" + pbi.partitionId + \"-\" + pbi.indexId);\n+\n+            Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n+            Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n+            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\nindex 162765160..cabb5afe1 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n\n@@ -178,7 +178,7 @@ public class TwoDimensionalGreedyRebalanceAlgo {\n \n             Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n             Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n-            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+            LOG.debug(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n                     pbi.partitionId, pbi.indexId, maxPartitionSkew,\n                     minReplicaCount, maxReplicaCount);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NDIxMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549554212", "bodyText": "debug", "author": "morningman", "createdAt": "2020-12-29T03:23:40Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {\n+            return null;\n+        }\n+\n+        // Among the partitions with maximum skew, attempt to pick a partition where there is\n+        // a move that improves the partition skew and the cluster skew, if possible. If\n+        // not, attempt to pick a move that improves the partition skew. If all partitions\n+        // are balanced, attempt to pick a move that preserves partition balance and\n+        // improves cluster skew.\n+        NavigableSet<PartitionBalanceInfo> maxSet = skewMap.get(maxPartitionSkew);\n+        for (PartitionBalanceInfo pbi : maxSet) {\n+            Preconditions.checkArgument(!pbi.beByReplicaCount.isEmpty(), \"no information on replicas of \" +\n+                    \"partition \" + pbi.partitionId + \"-\" + pbi.indexId);\n+\n+            Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n+            Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n+            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+                    pbi.partitionId, pbi.indexId, maxPartitionSkew,\n+                    minReplicaCount, maxReplicaCount);\n+\n+            // Compute the intersection of the bes most loaded for the table\n+            // with the bes most loaded overall, and likewise for least loaded.\n+            // These are our ideal candidates for moving from and to, respectively.\n+            IntersectionResult maxLoaded = getIntersection(ExtremumType.MAX, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            IntersectionResult minLoaded = getIntersection(ExtremumType.MIN, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            LOG.info(\"partition-wise: min_count: {}, max_count: {}\", minLoaded.replicaCountPartition, maxLoaded.replicaCountPartition);", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\nindex 162765160..cabb5afe1 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n\n@@ -178,7 +178,7 @@ public class TwoDimensionalGreedyRebalanceAlgo {\n \n             Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n             Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n-            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+            LOG.debug(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n                     pbi.partitionId, pbi.indexId, maxPartitionSkew,\n                     minReplicaCount, maxReplicaCount);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NDgxNQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549554815", "bodyText": "If we use PICK_FIRST, in the case of fewer candidate sets, will there be a high probability of the same?", "author": "morningman", "createdAt": "2020-12-29T03:27:17Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {\n+            return null;\n+        }\n+\n+        // Among the partitions with maximum skew, attempt to pick a partition where there is\n+        // a move that improves the partition skew and the cluster skew, if possible. If\n+        // not, attempt to pick a move that improves the partition skew. If all partitions\n+        // are balanced, attempt to pick a move that preserves partition balance and\n+        // improves cluster skew.\n+        NavigableSet<PartitionBalanceInfo> maxSet = skewMap.get(maxPartitionSkew);\n+        for (PartitionBalanceInfo pbi : maxSet) {\n+            Preconditions.checkArgument(!pbi.beByReplicaCount.isEmpty(), \"no information on replicas of \" +\n+                    \"partition \" + pbi.partitionId + \"-\" + pbi.indexId);\n+\n+            Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n+            Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n+            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+                    pbi.partitionId, pbi.indexId, maxPartitionSkew,\n+                    minReplicaCount, maxReplicaCount);\n+\n+            // Compute the intersection of the bes most loaded for the table\n+            // with the bes most loaded overall, and likewise for least loaded.\n+            // These are our ideal candidates for moving from and to, respectively.\n+            IntersectionResult maxLoaded = getIntersection(ExtremumType.MAX, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            IntersectionResult minLoaded = getIntersection(ExtremumType.MIN, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            LOG.info(\"partition-wise: min_count: {}, max_count: {}\", minLoaded.replicaCountPartition, maxLoaded.replicaCountPartition);\n+            LOG.info(\"cluster-wise: min_count: {}, max_count: {}\", minLoaded.replicaCountTotal, maxLoaded.replicaCountTotal);\n+            LOG.debug(\"min_loaded_intersection: {}, max_loaded_intersection: {}\", minLoaded.intersection.toString(), maxLoaded.intersection.toString());\n+\n+            // Do not move replicas of a balanced table if the least (most) loaded\n+            // servers overall do not intersect the servers hosting the least (most)\n+            // replicas of the table. Moving a replica in that case might keep the\n+            // cluster skew the same or make it worse while keeping the table balanced.\n+            if ((maxLoaded.replicaCountPartition <= minLoaded.replicaCountPartition + 1)\n+                    && (minLoaded.intersection.isEmpty() || maxLoaded.intersection.isEmpty())) {\n+                continue;\n+            }\n+\n+            Long minLoadedBe, maxLoadedBe;\n+            if (equalSkewOption == EqualSkewOption.PICK_FIRST) {\n+                // beWithExtremumCount lists & intersection lists are natural ordering\n+                minLoadedBe = minLoaded.intersection.isEmpty() ? minLoaded.beWithExtremumCount.get(0) : minLoaded.intersection.get(0);\n+                maxLoadedBe = maxLoaded.intersection.isEmpty() ? maxLoaded.beWithExtremumCount.get(0) : maxLoaded.intersection.get(0);\n+            } else {\n+                minLoadedBe = minLoaded.intersection.isEmpty() ? getRandomListElement(minLoaded.beWithExtremumCount)\n+                        : getRandomListElement(minLoaded.intersection);\n+                maxLoadedBe = maxLoaded.intersection.isEmpty() ? getRandomListElement(maxLoaded.beWithExtremumCount)\n+                        : getRandomListElement(maxLoaded.intersection);\n+            }\n+\n+            LOG.debug(\"min_loaded_be: {}, max_loaded_be: {}\", minLoadedBe, maxLoadedBe);\n+            if (minLoadedBe.equals(maxLoadedBe)) {", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTI4Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549561282", "bodyText": "Now, we only use PICK_FIRST in UTs, to get the results that can be expected.", "author": "vagetablechicken", "createdAt": "2020-12-29T04:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NDgxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "29e790c06c46566f6c36730f6a536b4d165a07f3", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\nindex 162765160..cabb5afe1 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java\n\n@@ -178,7 +178,7 @@ public class TwoDimensionalGreedyRebalanceAlgo {\n \n             Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n             Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n-            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+            LOG.debug(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n                     pbi.partitionId, pbi.indexId, maxPartitionSkew,\n                     minReplicaCount, maxReplicaCount);\n \n"}}, {"oid": "29e790c06c46566f6c36730f6a536b4d165a07f3", "url": "https://github.com/apache/incubator-doris/commit/29e790c06c46566f6c36730f6a536b4d165a07f3", "message": "[] fix by review", "committedDate": "2020-12-29T04:13:06Z", "type": "commit"}]}