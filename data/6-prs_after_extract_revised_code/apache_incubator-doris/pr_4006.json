{"pr_number": 4006, "pr_title": "[Feature] Support InPredicate in delete statement", "pr_createdAt": "2020-07-02T14:09:30Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4006", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg5MTI1NA==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r449891254", "bodyText": "Why skipping the base index?\nIf there is no rollup index, the entire check will be skipped.", "author": "morningman", "createdAt": "2020-07-05T15:46:22Z", "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -516,25 +537,22 @@ private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate>\n         }\n         Map<Long, List<Column>> indexIdToSchema = table.getIndexIdToSchema();\n         for (MaterializedIndex index : partition.getMaterializedIndices(MaterializedIndex.IndexExtState.VISIBLE)) {\n+            if (table.getBaseIndexId() == index.getId()) {\n+                continue;", "originalCommit": "b5dcece74379ed808ac4083a9612e0e684c30e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyMjg1MQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450222851", "bodyText": "I find here double check, because base schema is equal to  table schema? pre code has check table schema column 479 ~ 537", "author": "caiconghui", "createdAt": "2020-07-06T13:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg5MTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI4MDYyOQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450280629", "bodyText": "Oh I see.", "author": "morningman", "createdAt": "2020-07-06T14:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg5MTI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "chunk": "diff --git a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java b/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\ndeleted file mode 100644\nindex a7c01b530..000000000\n--- a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\n+++ /dev/null\n\n@@ -1,691 +0,0 @@\n-// Licensed to the Apache Software Foundation (ASF) under one\n-// or more contributor license agreements.  See the NOTICE file\n-// distributed with this work for additional information\n-// regarding copyright ownership.  The ASF licenses this file\n-// to you under the Apache License, Version 2.0 (the\n-// \"License\"); you may not use this file except in compliance\n-// with the License.  You may obtain a copy of the License at\n-//\n-//   http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing,\n-// software distributed under the License is distributed on an\n-// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-// KIND, either express or implied.  See the License for the\n-// specific language governing permissions and limitations\n-// under the License.\n-\n-package org.apache.doris.load;\n-\n-import org.apache.doris.analysis.BinaryPredicate;\n-import org.apache.doris.analysis.DeleteStmt;\n-import org.apache.doris.analysis.InPredicate;\n-import org.apache.doris.analysis.IsNullPredicate;\n-import org.apache.doris.analysis.LiteralExpr;\n-import org.apache.doris.analysis.Predicate;\n-import org.apache.doris.analysis.SlotRef;\n-import org.apache.doris.catalog.Catalog;\n-import org.apache.doris.catalog.Column;\n-import org.apache.doris.catalog.Database;\n-import org.apache.doris.catalog.KeysType;\n-import org.apache.doris.catalog.MaterializedIndex;\n-import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n-import org.apache.doris.catalog.MaterializedIndexMeta;\n-import org.apache.doris.catalog.OlapTable;\n-import org.apache.doris.catalog.Partition;\n-import org.apache.doris.catalog.PartitionType;\n-import org.apache.doris.catalog.PrimitiveType;\n-import org.apache.doris.catalog.Replica;\n-import org.apache.doris.catalog.Table;\n-import org.apache.doris.catalog.Tablet;\n-import org.apache.doris.catalog.TabletInvertedIndex;\n-import org.apache.doris.catalog.Type;\n-import org.apache.doris.common.AnalysisException;\n-import org.apache.doris.common.Config;\n-import org.apache.doris.common.DdlException;\n-import org.apache.doris.common.ErrorCode;\n-import org.apache.doris.common.ErrorReport;\n-import org.apache.doris.common.FeConstants;\n-import org.apache.doris.common.MarkedCountDownLatch;\n-import org.apache.doris.common.MetaNotFoundException;\n-import org.apache.doris.common.UserException;\n-import org.apache.doris.common.io.Text;\n-import org.apache.doris.common.io.Writable;\n-import org.apache.doris.common.util.ListComparator;\n-import org.apache.doris.common.util.TimeUtils;\n-import org.apache.doris.load.DeleteJob.DeleteState;\n-import org.apache.doris.mysql.privilege.PrivPredicate;\n-import org.apache.doris.persist.gson.GsonUtils;\n-import org.apache.doris.qe.ConnectContext;\n-import org.apache.doris.qe.QueryState.MysqlStateType;\n-import org.apache.doris.qe.QueryStateException;\n-import org.apache.doris.service.FrontendOptions;\n-import org.apache.doris.task.AgentBatchTask;\n-import org.apache.doris.task.AgentTaskExecutor;\n-import org.apache.doris.task.AgentTaskQueue;\n-import org.apache.doris.task.PushTask;\n-import org.apache.doris.thrift.TPriority;\n-import org.apache.doris.thrift.TPushType;\n-import org.apache.doris.thrift.TTaskType;\n-import org.apache.doris.transaction.GlobalTransactionMgr;\n-import org.apache.doris.transaction.TabletCommitInfo;\n-import org.apache.doris.transaction.TransactionState;\n-import org.apache.doris.transaction.TransactionState.TxnCoordinator;\n-import org.apache.doris.transaction.TransactionState.TxnSourceType;\n-import org.apache.doris.transaction.TransactionStatus;\n-\n-import com.google.common.base.Joiner;\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import com.google.gson.annotations.SerializedName;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n-\n-public class DeleteHandler implements Writable {\n-    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n-\n-    // TransactionId -> DeleteJob\n-    private Map<Long, DeleteJob> idToDeleteJob;\n-\n-    // Db -> DeleteInfo list\n-    @SerializedName(value = \"dbToDeleteInfos\")\n-    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n-\n-    public DeleteHandler() {\n-        idToDeleteJob = Maps.newConcurrentMap();\n-        dbToDeleteInfos = Maps.newConcurrentMap();\n-    }\n-\n-    private enum CancelType {\n-        METADATA_MISSING,\n-        TIMEOUT,\n-        COMMIT_FAIL,\n-        UNKNOWN\n-    }\n-\n-    public void process(DeleteStmt stmt) throws DdlException, QueryStateException {\n-        String dbName = stmt.getDbName();\n-        String tableName = stmt.getTableName();\n-        String partitionName = stmt.getPartitionName();\n-        List<Predicate> conditions = stmt.getDeleteConditions();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbName);\n-        if (db == null) {\n-            throw new DdlException(\"Db does not exist. name: \" + dbName);\n-        }\n-\n-        DeleteJob deleteJob = null;\n-        try {\n-            MarkedCountDownLatch<Long, Long> countDownLatch;\n-            long transactionId = -1;\n-            db.readLock();\n-            try {\n-                Table table = db.getTable(tableName);\n-                if (table == null) {\n-                    throw new DdlException(\"Table does not exist. name: \" + tableName);\n-                }\n-\n-                if (table.getType() != Table.TableType.OLAP) {\n-                    throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n-                }\n-                OlapTable olapTable = (OlapTable) table;\n-\n-                if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n-                    throw new DdlException(\"Table's state is not normal: \" + tableName);\n-                }\n-\n-                if (partitionName == null) {\n-                    if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n-                        throw new DdlException(\"This is a range partitioned table.\"\n-                                + \" You should specify partition in delete stmt\");\n-                    } else {\n-                        // this is a unpartitioned table, use table name as partition name\n-                        partitionName = olapTable.getName();\n-                    }\n-                }\n-\n-                Partition partition = olapTable.getPartition(partitionName);\n-                if (partition == null) {\n-                    throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n-                }\n-\n-                List<String> deleteConditions = Lists.newArrayList();\n-\n-                // pre check\n-                checkDeleteV2(olapTable, partition, conditions, deleteConditions);\n-\n-                // generate label\n-                String label = \"delete_\" + UUID.randomUUID();\n-                //generate jobId\n-                long jobId = Catalog.getCurrentCatalog().getNextId();\n-                // begin txn here and generate txn id\n-                transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n-                        Lists.newArrayList(table.getId()), label, null,\n-                        new TxnCoordinator(TxnSourceType.FE, FrontendOptions.getLocalHostAddress()),\n-                        TransactionState.LoadJobSourceType.FRONTEND, jobId, Config.stream_load_default_timeout_second);\n-\n-                DeleteInfo deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n-                        partition.getId(), partitionName,\n-                        -1, 0, deleteConditions);\n-                deleteJob = new DeleteJob(jobId, transactionId, label, deleteInfo);\n-                idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n-\n-                Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n-                // task sent to be\n-                AgentBatchTask batchTask = new AgentBatchTask();\n-                // count total replica num\n-                int totalReplicaNum = 0;\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    for (Tablet tablet : index.getTablets()) {\n-                        totalReplicaNum += tablet.getReplicas().size();\n-                    }\n-                }\n-                countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n-\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    long indexId = index.getId();\n-                    int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n-\n-                    for (Tablet tablet : index.getTablets()) {\n-                        long tabletId = tablet.getId();\n-\n-                        // set push type\n-                        TPushType type = TPushType.DELETE;\n-\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            long replicaId = replica.getId();\n-                            long backendId = replica.getBackendId();\n-                            countDownLatch.addMark(backendId, tabletId);\n-\n-                            // create push task for each replica\n-                            PushTask pushTask = new PushTask(null,\n-                                    replica.getBackendId(), db.getId(), olapTable.getId(),\n-                                    partition.getId(), indexId,\n-                                    tabletId, replicaId, schemaHash,\n-                                    -1, 0, \"\", -1, 0,\n-                                    -1, type, conditions,\n-                                    true, TPriority.NORMAL,\n-                                    TTaskType.REALTIME_PUSH,\n-                                    transactionId,\n-                                    Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n-                            pushTask.setIsSchemaChanging(false);\n-                            pushTask.setCountDownLatch(countDownLatch);\n-\n-                            if (AgentTaskQueue.addTask(pushTask)) {\n-                                batchTask.addTask(pushTask);\n-                                deleteJob.addPushTask(pushTask);\n-                                deleteJob.addTablet(tabletId);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // submit push tasks\n-                if (batchTask.getTaskNum() > 0) {\n-                    AgentTaskExecutor.submit(batchTask);\n-                }\n-\n-            } catch (Throwable t) {\n-                LOG.warn(\"error occurred during delete process\", t);\n-                // if transaction has been begun, need to abort it\n-                if (Catalog.getCurrentGlobalTransactionMgr().getTransactionState(db.getId(), transactionId) != null) {\n-                    cancelJob(deleteJob, CancelType.UNKNOWN, t.getMessage());\n-                }\n-                throw new DdlException(t.getMessage(), t);\n-            } finally {\n-                db.readUnlock();\n-            }\n-\n-            long timeoutMs = deleteJob.getTimeoutMs();\n-            LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n-            boolean ok = false;\n-            try {\n-                ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n-            } catch (InterruptedException e) {\n-                LOG.warn(\"InterruptedException: \", e);\n-                ok = false;\n-            }\n-\n-            if (!ok) {\n-                String errMsg = \"\";\n-                List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n-                // only show at most 5 results\n-                List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n-                if (!subList.isEmpty()) {\n-                    errMsg = \"unfinished replicas: \" + Joiner.on(\", \").join(subList);\n-                }\n-                LOG.warn(errMsg);\n-\n-                try {\n-                    deleteJob.checkAndUpdateQuorum();\n-                } catch (MetaNotFoundException e) {\n-                    cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                    throw new DdlException(e.getMessage(), e);\n-                }\n-                DeleteState state = deleteJob.getState();\n-                switch (state) {\n-                    case UN_QUORUM:\n-                        LOG.warn(\"delete job timeout: transactionId {}, timeout {}, {}\", transactionId, timeoutMs, errMsg);\n-                        cancelJob(deleteJob, CancelType.TIMEOUT, \"delete job timeout\");\n-                        throw new DdlException(\"failed to execute delete. transaction id \" + transactionId +\n-                                \", timeout(ms) \" + timeoutMs + \", \" + errMsg);\n-                    case QUORUM_FINISHED:\n-                    case FINISHED:\n-                        try {\n-                            long nowQuorumTimeMs = System.currentTimeMillis();\n-                            long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n-                            // if job's state is quorum_finished then wait for a period of time and commit it.\n-                            while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n-                                deleteJob.checkAndUpdateQuorum();\n-                                Thread.sleep(1000);\n-                                nowQuorumTimeMs = System.currentTimeMillis();\n-                                LOG.debug(\"wait for quorum finished delete job: {}, txn id: {}\" + deleteJob.getId(), transactionId);\n-                            }\n-                        } catch (MetaNotFoundException e) {\n-                            cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        } catch (InterruptedException e) {\n-                            cancelJob(deleteJob, CancelType.UNKNOWN, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        }\n-                        commitJob(deleteJob, db, timeoutMs);\n-                        break;\n-                    default:\n-                        Preconditions.checkState(false, \"wrong delete job state: \" + state.name());\n-                        break;\n-                }\n-            } else {\n-                commitJob(deleteJob, db, timeoutMs);\n-            }\n-        } finally {\n-            if (!FeConstants.runningUnitTest) {\n-                clearJob(deleteJob);\n-            }\n-        }\n-    }\n-\n-    private void commitJob(DeleteJob job, Database db, long timeoutMs) throws DdlException, QueryStateException {\n-        TransactionStatus status = null;\n-        try {\n-            unprotectedCommitJob(job, db, timeoutMs);\n-            status = Catalog.getCurrentGlobalTransactionMgr().\n-                    getTransactionState(db.getId(), job.getTransactionId()).getTransactionStatus();\n-        } catch (UserException e) {\n-            if (cancelJob(job, CancelType.COMMIT_FAIL, e.getMessage())) {\n-                throw new DdlException(e.getMessage(), e);\n-            }\n-        }\n-\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"{'label':'\").append(job.getLabel()).append(\"', 'status':'\").append(status.name());\n-        sb.append(\"', 'txnId':'\").append(job.getTransactionId()).append(\"'\");\n-\n-        switch (status) {\n-            case COMMITTED: {\n-                // Although publish is unfinished we should tell user that commit already success.\n-                String errMsg = \"delete job is committed but may be taking effect later\";\n-                sb.append(\", 'err':'\").append(errMsg).append(\"'\");\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            case VISIBLE: {\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            default:\n-                Preconditions.checkState(false, \"wrong transaction status: \" + status.name());\n-                break;\n-        }\n-    }\n-\n-    /**\n-     * unprotected commit delete job\n-     * return true when successfully commit and publish\n-     * return false when successfully commit but publish unfinished.\n-     * A UserException thrown if both commit and publish failed.\n-     * @param job\n-     * @param db\n-     * @param timeoutMs\n-     * @return\n-     * @throws UserException\n-     */\n-    private boolean unprotectedCommitJob(DeleteJob job, Database db, long timeoutMs) throws UserException {\n-        long transactionId = job.getTransactionId();\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n-        TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n-        for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n-            for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n-                // the inverted index contains rolling up replica\n-                Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n-                if (tabletId == null) {\n-                    LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n-                    continue;\n-                }\n-                tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n-            }\n-        }\n-        return globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeoutMs);\n-    }\n-\n-    /**\n-     * This method should always be called in the end of the delete process to clean the job.\n-     * Better put it in finally block.\n-     * @param job\n-     */\n-    private void clearJob(DeleteJob job) {\n-        if (job != null) {\n-            long signature = job.getTransactionId();\n-            if (idToDeleteJob.containsKey(signature)) {\n-                idToDeleteJob.remove(signature);\n-            }\n-            for (PushTask pushTask : job.getPushTasks()) {\n-                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n-                        pushTask.getVersion(), pushTask.getVersionHash(),\n-                        pushTask.getPushType(), pushTask.getTaskType());\n-            }\n-\n-            // NOT remove callback from GlobalTransactionMgr's callback factory here.\n-            // the callback will be removed after transaction is aborted of visible.\n-        }\n-    }\n-\n-    public void recordFinishedJob(DeleteJob job) {\n-        if (job != null) {\n-            long dbId = job.getDeleteInfo().getDbId();\n-            LOG.info(\"record finished deleteJob, transactionId {}, dbId {}\",\n-                    job.getTransactionId(), dbId);\n-            dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-            List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-            synchronized (deleteInfoList) {\n-                deleteInfoList.add(job.getDeleteInfo());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * abort delete job\n-     * return true when successfully abort.\n-     * return true when some unknown error happened, just ignore it.\n-     * return false when the job is already committed\n-     * @param job\n-     * @param cancelType\n-     * @param reason\n-     * @return\n-     */\n-    public boolean cancelJob(DeleteJob job, CancelType cancelType, String reason) {\n-        LOG.info(\"start to cancel delete job, transactionId: {}, cancelType: {}\", job.getTransactionId(), cancelType.name());\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        try {\n-            if (job != null) {\n-                globalTransactionMgr.abortTransaction(job.getDeleteInfo().getDbId(), job.getTransactionId(), reason);\n-            }\n-        } catch (Exception e) {\n-            TransactionState state = globalTransactionMgr.getTransactionState(job.getDeleteInfo().getDbId(), job.getTransactionId());\n-            if (state == null) {\n-                LOG.warn(\"cancel delete job failed because txn not found, transactionId: {}\", job.getTransactionId());\n-            } else if (state.getTransactionStatus() == TransactionStatus.COMMITTED || state.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.warn(\"cancel delete job {} failed because it has been committed, transactionId: {}\", job.getTransactionId());\n-                return false;\n-            } else {\n-                LOG.warn(\"errors while abort transaction\", e);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public DeleteJob getDeleteJob(long transactionId) {\n-        return idToDeleteJob.get(transactionId);\n-    }\n-\n-    private SlotRef getSlotRef(Predicate condition) {\n-        SlotRef slotRef = null;\n-        if (condition instanceof BinaryPredicate) {\n-            BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-            slotRef = (SlotRef) binaryPredicate.getChild(0);\n-        } else if (condition instanceof IsNullPredicate) {\n-            IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-            slotRef = (SlotRef) isNullPredicate.getChild(0);\n-        } else if (condition instanceof InPredicate) {\n-            InPredicate inPredicate = (InPredicate) condition;\n-            slotRef = (SlotRef) inPredicate.getChild(0);\n-        }\n-        return slotRef;\n-    }\n-\n-    private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate> conditions, List<String> deleteConditions)\n-            throws DdlException {\n-\n-        // check partition state\n-        Partition.PartitionState state = partition.getState();\n-        if (state != Partition.PartitionState.NORMAL) {\n-            // ErrorReport.reportDdlException(ErrorCode.ERR_BAD_PARTITION_STATE, partition.getName(), state.name());\n-            throw new DdlException(\"Partition[\" + partition.getName() + \"]' state is not NORMAL: \" + state.name());\n-        }\n-\n-        // check condition column is key column and condition value\n-        Map<String, Column> nameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-        for (Column column : table.getBaseSchema()) {\n-            nameToColumn.put(column.getName(), column);\n-        }\n-        for (Predicate condition : conditions) {\n-            SlotRef slotRef = getSlotRef(condition);\n-            String columnName = slotRef.getColumnName();\n-            if (!nameToColumn.containsKey(columnName)) {\n-                ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, table.getName());\n-            }\n-\n-            Column column = nameToColumn.get(columnName);\n-            // Due to rounding errors, most floating-point numbers end up being slightly imprecise,\n-            // it also means that numbers expected to be equal often differ slightly, so we do not allow compare with\n-            // floating-point numbers, floating-point number not allowed in where clause\n-            if (!column.isKey() && table.getKeysType() != KeysType.DUP_KEYS\n-                    || column.getDataType().isFloatingPointType()) {\n-                // ErrorReport.reportDdlException(ErrorCode.ERR_NOT_KEY_COLUMN, columnName);\n-                throw new DdlException(\"Column[\" + columnName + \"] is not key column or storage model \" +\n-                        \"is not duplicate or column type is float or double.\");\n-            }\n-\n-            if (condition instanceof BinaryPredicate) {\n-                String value = null;\n-                try {\n-                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                    // if a bool cond passed to be, be's zone_map cannot handle bool correctly,\n-                    // change it to a tinyint type here;\n-                    value = ((LiteralExpr) binaryPredicate.getChild(1)).getStringValue();\n-                    if (column.getDataType() == PrimitiveType.BOOLEAN ) {\n-                        if (value.toLowerCase().equals(\"true\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"1\", Type.TINYINT));\n-                        } else if (value.toLowerCase().equals(\"false\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"0\", Type.TINYINT));\n-                        }\n-                    }\n-                    LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            } else if (condition instanceof InPredicate) {\n-                String value = null;\n-                try {\n-                    InPredicate inPredicate = (InPredicate) condition;\n-                    for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n-                        value = ((LiteralExpr) inPredicate.getChild(i)).getStringValue();\n-                        LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                    }\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            }\n-\n-            // set schema column name\n-            slotRef.setCol(column.getName());\n-        }\n-        Map<Long, List<Column>> indexIdToSchema = table.getIndexIdToSchema();\n-        for (MaterializedIndex index : partition.getMaterializedIndices(MaterializedIndex.IndexExtState.VISIBLE)) {\n-            if (table.getBaseIndexId() == index.getId()) {\n-                continue;\n-            }\n-\n-            // check table has condition column\n-            Map<String, Column> indexColNameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-            for (Column column : indexIdToSchema.get(index.getId())) {\n-                indexColNameToColumn.put(column.getName(), column);\n-            }\n-            String indexName = table.getIndexNameById(index.getId());\n-            for (Predicate condition : conditions) {\n-                SlotRef slotRef = getSlotRef(condition);\n-                String columnName = slotRef.getColumnName();\n-                Column column = indexColNameToColumn.get(columnName);\n-                if (column == null) {\n-                    ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, \"index[\" + indexName +\"]\");\n-                }\n-                MaterializedIndexMeta indexMeta = table.getIndexIdToMeta().get(index.getId());\n-                if (indexMeta.getKeysType() != KeysType.DUP_KEYS && !column.isKey()) {\n-                    throw new DdlException(\"Column[\" + columnName + \"] is not key column in index[\" + indexName + \"]\");\n-                }\n-            }\n-        }\n-\n-        if (deleteConditions == null) {\n-            return;\n-        }\n-\n-        // save delete conditions\n-        for (Predicate condition : conditions) {\n-            if (condition instanceof BinaryPredicate) {\n-                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                SlotRef slotRef = (SlotRef) binaryPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName).append(\" \").append(binaryPredicate.getOp().name()).append(\" \\\"\")\n-                        .append(((LiteralExpr) binaryPredicate.getChild(1)).getStringValue()).append(\"\\\"\");\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof IsNullPredicate) {\n-                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-                SlotRef slotRef = (SlotRef) isNullPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName);\n-                if (isNullPredicate.isNotNull()) {\n-                    sb.append(\" IS NOT NULL\");\n-                } else {\n-                    sb.append(\" IS NULL\");\n-                }\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof InPredicate) {\n-                InPredicate inPredicate = (InPredicate) condition;\n-                SlotRef slotRef = (SlotRef) inPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder strBuilder = new StringBuilder();\n-                String notStr = inPredicate.isNotIn() ? \"NOT \" : \"\";\n-                strBuilder.append(columnName).append(\" \" + notStr + \"IN (\");\n-                for (int i = 1; i <= inPredicate.getInElementNum(); ++i) {\n-                    strBuilder.append(inPredicate.getChild(i).toSql());\n-                    strBuilder.append((i + 1 != inPredicate.getInElementNum()) ? \", \" : \"\");\n-                }\n-                strBuilder.append(\")\");\n-                deleteConditions.add(strBuilder.toString());\n-            }\n-        }\n-    }\n-\n-    // show delete stmt\n-    public List<List<Comparable>> getDeleteInfosByDb(long dbId, boolean forUser) {\n-        LinkedList<List<Comparable>> infos = new LinkedList<List<Comparable>>();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n-        if (db == null) {\n-            return infos;\n-        }\n-\n-        String dbName = db.getFullName();\n-        List<DeleteInfo> deleteInfos = dbToDeleteInfos.get(dbId);\n-        if (deleteInfos == null) {\n-            return infos;\n-        }\n-\n-        for (DeleteInfo deleteInfo : deleteInfos) {\n-\n-            if (!Catalog.getCurrentCatalog().getAuth().checkTblPriv(ConnectContext.get(), dbName,\n-                    deleteInfo.getTableName(),\n-                    PrivPredicate.LOAD)) {\n-                continue;\n-            }\n-\n-\n-            List<Comparable> info = Lists.newArrayList();\n-            if (!forUser) {\n-                info.add(-1L);\n-                info.add(deleteInfo.getTableId());\n-            }\n-            info.add(deleteInfo.getTableName());\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionId());\n-            }\n-            info.add(deleteInfo.getPartitionName());\n-\n-            info.add(TimeUtils.longToTimeString(deleteInfo.getCreateTimeMs()));\n-            String conds = Joiner.on(\", \").join(deleteInfo.getDeleteConditions());\n-            info.add(conds);\n-\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionVersion());\n-                info.add(deleteInfo.getPartitionVersionHash());\n-            }\n-            // for loading state, should not display loading, show deleting instead\n-//                if (loadJob.getState() == LoadJob.JobState.LOADING) {\n-//                    info.add(\"DELETING\");\n-//                } else {\n-//                    info.add(loadJob.getState().name());\n-//                }\n-            info.add(\"FINISHED\");\n-            infos.add(info);\n-        }\n-        // sort by createTimeMs\n-        int sortIndex;\n-        if (!forUser) {\n-            sortIndex = 5;\n-        } else {\n-            sortIndex = 2;\n-        }\n-        ListComparator<List<Comparable>> comparator = new ListComparator<List<Comparable>>(sortIndex);\n-        Collections.sort(infos, comparator);\n-        return infos;\n-    }\n-\n-    public void replayDelete(DeleteInfo deleteInfo, Catalog catalog) {\n-        // add to deleteInfos\n-        long dbId = deleteInfo.getDbId();\n-        LOG.info(\"replay delete, dbId {}\", dbId);\n-        dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-        List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-        synchronized (deleteInfoList) {\n-            deleteInfoList.add(deleteInfo);\n-        }\n-    }\n-\n-    // for delete handler, we only persist those delete already finished.\n-    @Override\n-    public void write(DataOutput out) throws IOException {\n-        Text.writeString(out, GsonUtils.GSON.toJson(this));\n-    }\n-\n-    public static DeleteHandler read(DataInput in) throws IOException {\n-        String json = Text.readString(in);\n-        return GsonUtils.GSON.fromJson(json, DeleteHandler.class);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg5MTY1NA==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r449891654", "bodyText": "Is it better be a FE's config instead of a session variable?\nI think this should be a system-level restriction to prevent users from writing too many conditions, resulting in a reduction in the efficiency of reading and writing the underlying data in storage system.", "author": "morningman", "createdAt": "2020-07-05T15:50:48Z", "path": "fe/src/main/java/org/apache/doris/qe/SessionVariable.java", "diffHunk": "@@ -248,6 +249,8 @@\n     private int maxScanKeyNum = -1;\n     @VariableMgr.VarAttr(name = MAX_PUSHDOWN_CONDITIONS_PER_COLUMN)\n     private int maxPushdownConditionsPerColumn = -1;\n+    @VariableMgr.VarAttr(name = MAX_ALLOWED_IN_ELEMENT_NUM_OF_DELETE)\n+    private int maxAllowedInElementNumOfDelete = 1024;", "originalCommit": "b5dcece74379ed808ac4083a9612e0e684c30e6b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "105777771afca6e9ae09974f2520bf33339d31ad", "chunk": "diff --git a/fe/src/main/java/org/apache/doris/qe/SessionVariable.java b/fe/src/main/java/org/apache/doris/qe/SessionVariable.java\nindex 628105c27..393cdb02c 100644\n--- a/fe/src/main/java/org/apache/doris/qe/SessionVariable.java\n+++ b/fe/src/main/java/org/apache/doris/qe/SessionVariable.java\n\n@@ -249,8 +248,6 @@ public class SessionVariable implements Serializable, Writable {\n     private int maxScanKeyNum = -1;\n     @VariableMgr.VarAttr(name = MAX_PUSHDOWN_CONDITIONS_PER_COLUMN)\n     private int maxPushdownConditionsPerColumn = -1;\n-    @VariableMgr.VarAttr(name = MAX_ALLOWED_IN_ELEMENT_NUM_OF_DELETE)\n-    private int maxAllowedInElementNumOfDelete = 1024;\n \n     public long getMaxExecMemByte() {\n         return maxExecMemByte;\n"}}, {"oid": "105777771afca6e9ae09974f2520bf33339d31ad", "url": "https://github.com/apache/incubator-doris/commit/105777771afca6e9ae09974f2520bf33339d31ad", "message": "remove unused content from docs", "committedDate": "2020-07-06T15:50:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNzQwNw==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450627407", "bodyText": "the last loop is \u201c i == inPredicate.getInElementNum()\u201d, should \" i + 1 != inPredicate.getInElementNum()\" modify \"i != inPredicate.getInElementNum()\"?", "author": "wutiangan", "createdAt": "2020-07-07T05:57:34Z", "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -569,6 +587,19 @@ private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate>\n                     sb.append(\" IS NULL\");\n                 }\n                 deleteConditions.add(sb.toString());\n+            } else if (condition instanceof InPredicate) {\n+                InPredicate inPredicate = (InPredicate) condition;\n+                SlotRef slotRef = (SlotRef) inPredicate.getChild(0);\n+                String columnName = slotRef.getColumnName();\n+                StringBuilder strBuilder = new StringBuilder();\n+                String notStr = inPredicate.isNotIn() ? \"NOT \" : \"\";\n+                strBuilder.append(columnName).append(\" \" + notStr + \"IN (\");\n+                for (int i = 1; i <= inPredicate.getInElementNum(); ++i) {\n+                    strBuilder.append(inPredicate.getChild(i).toSql());\n+                    strBuilder.append((i + 1 != inPredicate.getInElementNum()) ? \", \" : \"\");", "originalCommit": "105777771afca6e9ae09974f2520bf33339d31ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NjUxOQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450646519", "bodyText": "oh\uff0c my bad\uff0cthanks\uff0cI will fix it", "author": "caiconghui", "createdAt": "2020-07-07T06:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNzQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "chunk": "diff --git a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java b/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\ndeleted file mode 100644\nindex a7c01b530..000000000\n--- a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\n+++ /dev/null\n\n@@ -1,691 +0,0 @@\n-// Licensed to the Apache Software Foundation (ASF) under one\n-// or more contributor license agreements.  See the NOTICE file\n-// distributed with this work for additional information\n-// regarding copyright ownership.  The ASF licenses this file\n-// to you under the Apache License, Version 2.0 (the\n-// \"License\"); you may not use this file except in compliance\n-// with the License.  You may obtain a copy of the License at\n-//\n-//   http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing,\n-// software distributed under the License is distributed on an\n-// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-// KIND, either express or implied.  See the License for the\n-// specific language governing permissions and limitations\n-// under the License.\n-\n-package org.apache.doris.load;\n-\n-import org.apache.doris.analysis.BinaryPredicate;\n-import org.apache.doris.analysis.DeleteStmt;\n-import org.apache.doris.analysis.InPredicate;\n-import org.apache.doris.analysis.IsNullPredicate;\n-import org.apache.doris.analysis.LiteralExpr;\n-import org.apache.doris.analysis.Predicate;\n-import org.apache.doris.analysis.SlotRef;\n-import org.apache.doris.catalog.Catalog;\n-import org.apache.doris.catalog.Column;\n-import org.apache.doris.catalog.Database;\n-import org.apache.doris.catalog.KeysType;\n-import org.apache.doris.catalog.MaterializedIndex;\n-import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n-import org.apache.doris.catalog.MaterializedIndexMeta;\n-import org.apache.doris.catalog.OlapTable;\n-import org.apache.doris.catalog.Partition;\n-import org.apache.doris.catalog.PartitionType;\n-import org.apache.doris.catalog.PrimitiveType;\n-import org.apache.doris.catalog.Replica;\n-import org.apache.doris.catalog.Table;\n-import org.apache.doris.catalog.Tablet;\n-import org.apache.doris.catalog.TabletInvertedIndex;\n-import org.apache.doris.catalog.Type;\n-import org.apache.doris.common.AnalysisException;\n-import org.apache.doris.common.Config;\n-import org.apache.doris.common.DdlException;\n-import org.apache.doris.common.ErrorCode;\n-import org.apache.doris.common.ErrorReport;\n-import org.apache.doris.common.FeConstants;\n-import org.apache.doris.common.MarkedCountDownLatch;\n-import org.apache.doris.common.MetaNotFoundException;\n-import org.apache.doris.common.UserException;\n-import org.apache.doris.common.io.Text;\n-import org.apache.doris.common.io.Writable;\n-import org.apache.doris.common.util.ListComparator;\n-import org.apache.doris.common.util.TimeUtils;\n-import org.apache.doris.load.DeleteJob.DeleteState;\n-import org.apache.doris.mysql.privilege.PrivPredicate;\n-import org.apache.doris.persist.gson.GsonUtils;\n-import org.apache.doris.qe.ConnectContext;\n-import org.apache.doris.qe.QueryState.MysqlStateType;\n-import org.apache.doris.qe.QueryStateException;\n-import org.apache.doris.service.FrontendOptions;\n-import org.apache.doris.task.AgentBatchTask;\n-import org.apache.doris.task.AgentTaskExecutor;\n-import org.apache.doris.task.AgentTaskQueue;\n-import org.apache.doris.task.PushTask;\n-import org.apache.doris.thrift.TPriority;\n-import org.apache.doris.thrift.TPushType;\n-import org.apache.doris.thrift.TTaskType;\n-import org.apache.doris.transaction.GlobalTransactionMgr;\n-import org.apache.doris.transaction.TabletCommitInfo;\n-import org.apache.doris.transaction.TransactionState;\n-import org.apache.doris.transaction.TransactionState.TxnCoordinator;\n-import org.apache.doris.transaction.TransactionState.TxnSourceType;\n-import org.apache.doris.transaction.TransactionStatus;\n-\n-import com.google.common.base.Joiner;\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import com.google.gson.annotations.SerializedName;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n-\n-public class DeleteHandler implements Writable {\n-    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n-\n-    // TransactionId -> DeleteJob\n-    private Map<Long, DeleteJob> idToDeleteJob;\n-\n-    // Db -> DeleteInfo list\n-    @SerializedName(value = \"dbToDeleteInfos\")\n-    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n-\n-    public DeleteHandler() {\n-        idToDeleteJob = Maps.newConcurrentMap();\n-        dbToDeleteInfos = Maps.newConcurrentMap();\n-    }\n-\n-    private enum CancelType {\n-        METADATA_MISSING,\n-        TIMEOUT,\n-        COMMIT_FAIL,\n-        UNKNOWN\n-    }\n-\n-    public void process(DeleteStmt stmt) throws DdlException, QueryStateException {\n-        String dbName = stmt.getDbName();\n-        String tableName = stmt.getTableName();\n-        String partitionName = stmt.getPartitionName();\n-        List<Predicate> conditions = stmt.getDeleteConditions();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbName);\n-        if (db == null) {\n-            throw new DdlException(\"Db does not exist. name: \" + dbName);\n-        }\n-\n-        DeleteJob deleteJob = null;\n-        try {\n-            MarkedCountDownLatch<Long, Long> countDownLatch;\n-            long transactionId = -1;\n-            db.readLock();\n-            try {\n-                Table table = db.getTable(tableName);\n-                if (table == null) {\n-                    throw new DdlException(\"Table does not exist. name: \" + tableName);\n-                }\n-\n-                if (table.getType() != Table.TableType.OLAP) {\n-                    throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n-                }\n-                OlapTable olapTable = (OlapTable) table;\n-\n-                if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n-                    throw new DdlException(\"Table's state is not normal: \" + tableName);\n-                }\n-\n-                if (partitionName == null) {\n-                    if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n-                        throw new DdlException(\"This is a range partitioned table.\"\n-                                + \" You should specify partition in delete stmt\");\n-                    } else {\n-                        // this is a unpartitioned table, use table name as partition name\n-                        partitionName = olapTable.getName();\n-                    }\n-                }\n-\n-                Partition partition = olapTable.getPartition(partitionName);\n-                if (partition == null) {\n-                    throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n-                }\n-\n-                List<String> deleteConditions = Lists.newArrayList();\n-\n-                // pre check\n-                checkDeleteV2(olapTable, partition, conditions, deleteConditions);\n-\n-                // generate label\n-                String label = \"delete_\" + UUID.randomUUID();\n-                //generate jobId\n-                long jobId = Catalog.getCurrentCatalog().getNextId();\n-                // begin txn here and generate txn id\n-                transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n-                        Lists.newArrayList(table.getId()), label, null,\n-                        new TxnCoordinator(TxnSourceType.FE, FrontendOptions.getLocalHostAddress()),\n-                        TransactionState.LoadJobSourceType.FRONTEND, jobId, Config.stream_load_default_timeout_second);\n-\n-                DeleteInfo deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n-                        partition.getId(), partitionName,\n-                        -1, 0, deleteConditions);\n-                deleteJob = new DeleteJob(jobId, transactionId, label, deleteInfo);\n-                idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n-\n-                Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n-                // task sent to be\n-                AgentBatchTask batchTask = new AgentBatchTask();\n-                // count total replica num\n-                int totalReplicaNum = 0;\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    for (Tablet tablet : index.getTablets()) {\n-                        totalReplicaNum += tablet.getReplicas().size();\n-                    }\n-                }\n-                countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n-\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    long indexId = index.getId();\n-                    int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n-\n-                    for (Tablet tablet : index.getTablets()) {\n-                        long tabletId = tablet.getId();\n-\n-                        // set push type\n-                        TPushType type = TPushType.DELETE;\n-\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            long replicaId = replica.getId();\n-                            long backendId = replica.getBackendId();\n-                            countDownLatch.addMark(backendId, tabletId);\n-\n-                            // create push task for each replica\n-                            PushTask pushTask = new PushTask(null,\n-                                    replica.getBackendId(), db.getId(), olapTable.getId(),\n-                                    partition.getId(), indexId,\n-                                    tabletId, replicaId, schemaHash,\n-                                    -1, 0, \"\", -1, 0,\n-                                    -1, type, conditions,\n-                                    true, TPriority.NORMAL,\n-                                    TTaskType.REALTIME_PUSH,\n-                                    transactionId,\n-                                    Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n-                            pushTask.setIsSchemaChanging(false);\n-                            pushTask.setCountDownLatch(countDownLatch);\n-\n-                            if (AgentTaskQueue.addTask(pushTask)) {\n-                                batchTask.addTask(pushTask);\n-                                deleteJob.addPushTask(pushTask);\n-                                deleteJob.addTablet(tabletId);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // submit push tasks\n-                if (batchTask.getTaskNum() > 0) {\n-                    AgentTaskExecutor.submit(batchTask);\n-                }\n-\n-            } catch (Throwable t) {\n-                LOG.warn(\"error occurred during delete process\", t);\n-                // if transaction has been begun, need to abort it\n-                if (Catalog.getCurrentGlobalTransactionMgr().getTransactionState(db.getId(), transactionId) != null) {\n-                    cancelJob(deleteJob, CancelType.UNKNOWN, t.getMessage());\n-                }\n-                throw new DdlException(t.getMessage(), t);\n-            } finally {\n-                db.readUnlock();\n-            }\n-\n-            long timeoutMs = deleteJob.getTimeoutMs();\n-            LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n-            boolean ok = false;\n-            try {\n-                ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n-            } catch (InterruptedException e) {\n-                LOG.warn(\"InterruptedException: \", e);\n-                ok = false;\n-            }\n-\n-            if (!ok) {\n-                String errMsg = \"\";\n-                List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n-                // only show at most 5 results\n-                List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n-                if (!subList.isEmpty()) {\n-                    errMsg = \"unfinished replicas: \" + Joiner.on(\", \").join(subList);\n-                }\n-                LOG.warn(errMsg);\n-\n-                try {\n-                    deleteJob.checkAndUpdateQuorum();\n-                } catch (MetaNotFoundException e) {\n-                    cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                    throw new DdlException(e.getMessage(), e);\n-                }\n-                DeleteState state = deleteJob.getState();\n-                switch (state) {\n-                    case UN_QUORUM:\n-                        LOG.warn(\"delete job timeout: transactionId {}, timeout {}, {}\", transactionId, timeoutMs, errMsg);\n-                        cancelJob(deleteJob, CancelType.TIMEOUT, \"delete job timeout\");\n-                        throw new DdlException(\"failed to execute delete. transaction id \" + transactionId +\n-                                \", timeout(ms) \" + timeoutMs + \", \" + errMsg);\n-                    case QUORUM_FINISHED:\n-                    case FINISHED:\n-                        try {\n-                            long nowQuorumTimeMs = System.currentTimeMillis();\n-                            long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n-                            // if job's state is quorum_finished then wait for a period of time and commit it.\n-                            while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n-                                deleteJob.checkAndUpdateQuorum();\n-                                Thread.sleep(1000);\n-                                nowQuorumTimeMs = System.currentTimeMillis();\n-                                LOG.debug(\"wait for quorum finished delete job: {}, txn id: {}\" + deleteJob.getId(), transactionId);\n-                            }\n-                        } catch (MetaNotFoundException e) {\n-                            cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        } catch (InterruptedException e) {\n-                            cancelJob(deleteJob, CancelType.UNKNOWN, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        }\n-                        commitJob(deleteJob, db, timeoutMs);\n-                        break;\n-                    default:\n-                        Preconditions.checkState(false, \"wrong delete job state: \" + state.name());\n-                        break;\n-                }\n-            } else {\n-                commitJob(deleteJob, db, timeoutMs);\n-            }\n-        } finally {\n-            if (!FeConstants.runningUnitTest) {\n-                clearJob(deleteJob);\n-            }\n-        }\n-    }\n-\n-    private void commitJob(DeleteJob job, Database db, long timeoutMs) throws DdlException, QueryStateException {\n-        TransactionStatus status = null;\n-        try {\n-            unprotectedCommitJob(job, db, timeoutMs);\n-            status = Catalog.getCurrentGlobalTransactionMgr().\n-                    getTransactionState(db.getId(), job.getTransactionId()).getTransactionStatus();\n-        } catch (UserException e) {\n-            if (cancelJob(job, CancelType.COMMIT_FAIL, e.getMessage())) {\n-                throw new DdlException(e.getMessage(), e);\n-            }\n-        }\n-\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"{'label':'\").append(job.getLabel()).append(\"', 'status':'\").append(status.name());\n-        sb.append(\"', 'txnId':'\").append(job.getTransactionId()).append(\"'\");\n-\n-        switch (status) {\n-            case COMMITTED: {\n-                // Although publish is unfinished we should tell user that commit already success.\n-                String errMsg = \"delete job is committed but may be taking effect later\";\n-                sb.append(\", 'err':'\").append(errMsg).append(\"'\");\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            case VISIBLE: {\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            default:\n-                Preconditions.checkState(false, \"wrong transaction status: \" + status.name());\n-                break;\n-        }\n-    }\n-\n-    /**\n-     * unprotected commit delete job\n-     * return true when successfully commit and publish\n-     * return false when successfully commit but publish unfinished.\n-     * A UserException thrown if both commit and publish failed.\n-     * @param job\n-     * @param db\n-     * @param timeoutMs\n-     * @return\n-     * @throws UserException\n-     */\n-    private boolean unprotectedCommitJob(DeleteJob job, Database db, long timeoutMs) throws UserException {\n-        long transactionId = job.getTransactionId();\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n-        TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n-        for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n-            for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n-                // the inverted index contains rolling up replica\n-                Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n-                if (tabletId == null) {\n-                    LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n-                    continue;\n-                }\n-                tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n-            }\n-        }\n-        return globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeoutMs);\n-    }\n-\n-    /**\n-     * This method should always be called in the end of the delete process to clean the job.\n-     * Better put it in finally block.\n-     * @param job\n-     */\n-    private void clearJob(DeleteJob job) {\n-        if (job != null) {\n-            long signature = job.getTransactionId();\n-            if (idToDeleteJob.containsKey(signature)) {\n-                idToDeleteJob.remove(signature);\n-            }\n-            for (PushTask pushTask : job.getPushTasks()) {\n-                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n-                        pushTask.getVersion(), pushTask.getVersionHash(),\n-                        pushTask.getPushType(), pushTask.getTaskType());\n-            }\n-\n-            // NOT remove callback from GlobalTransactionMgr's callback factory here.\n-            // the callback will be removed after transaction is aborted of visible.\n-        }\n-    }\n-\n-    public void recordFinishedJob(DeleteJob job) {\n-        if (job != null) {\n-            long dbId = job.getDeleteInfo().getDbId();\n-            LOG.info(\"record finished deleteJob, transactionId {}, dbId {}\",\n-                    job.getTransactionId(), dbId);\n-            dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-            List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-            synchronized (deleteInfoList) {\n-                deleteInfoList.add(job.getDeleteInfo());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * abort delete job\n-     * return true when successfully abort.\n-     * return true when some unknown error happened, just ignore it.\n-     * return false when the job is already committed\n-     * @param job\n-     * @param cancelType\n-     * @param reason\n-     * @return\n-     */\n-    public boolean cancelJob(DeleteJob job, CancelType cancelType, String reason) {\n-        LOG.info(\"start to cancel delete job, transactionId: {}, cancelType: {}\", job.getTransactionId(), cancelType.name());\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        try {\n-            if (job != null) {\n-                globalTransactionMgr.abortTransaction(job.getDeleteInfo().getDbId(), job.getTransactionId(), reason);\n-            }\n-        } catch (Exception e) {\n-            TransactionState state = globalTransactionMgr.getTransactionState(job.getDeleteInfo().getDbId(), job.getTransactionId());\n-            if (state == null) {\n-                LOG.warn(\"cancel delete job failed because txn not found, transactionId: {}\", job.getTransactionId());\n-            } else if (state.getTransactionStatus() == TransactionStatus.COMMITTED || state.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.warn(\"cancel delete job {} failed because it has been committed, transactionId: {}\", job.getTransactionId());\n-                return false;\n-            } else {\n-                LOG.warn(\"errors while abort transaction\", e);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public DeleteJob getDeleteJob(long transactionId) {\n-        return idToDeleteJob.get(transactionId);\n-    }\n-\n-    private SlotRef getSlotRef(Predicate condition) {\n-        SlotRef slotRef = null;\n-        if (condition instanceof BinaryPredicate) {\n-            BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-            slotRef = (SlotRef) binaryPredicate.getChild(0);\n-        } else if (condition instanceof IsNullPredicate) {\n-            IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-            slotRef = (SlotRef) isNullPredicate.getChild(0);\n-        } else if (condition instanceof InPredicate) {\n-            InPredicate inPredicate = (InPredicate) condition;\n-            slotRef = (SlotRef) inPredicate.getChild(0);\n-        }\n-        return slotRef;\n-    }\n-\n-    private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate> conditions, List<String> deleteConditions)\n-            throws DdlException {\n-\n-        // check partition state\n-        Partition.PartitionState state = partition.getState();\n-        if (state != Partition.PartitionState.NORMAL) {\n-            // ErrorReport.reportDdlException(ErrorCode.ERR_BAD_PARTITION_STATE, partition.getName(), state.name());\n-            throw new DdlException(\"Partition[\" + partition.getName() + \"]' state is not NORMAL: \" + state.name());\n-        }\n-\n-        // check condition column is key column and condition value\n-        Map<String, Column> nameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-        for (Column column : table.getBaseSchema()) {\n-            nameToColumn.put(column.getName(), column);\n-        }\n-        for (Predicate condition : conditions) {\n-            SlotRef slotRef = getSlotRef(condition);\n-            String columnName = slotRef.getColumnName();\n-            if (!nameToColumn.containsKey(columnName)) {\n-                ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, table.getName());\n-            }\n-\n-            Column column = nameToColumn.get(columnName);\n-            // Due to rounding errors, most floating-point numbers end up being slightly imprecise,\n-            // it also means that numbers expected to be equal often differ slightly, so we do not allow compare with\n-            // floating-point numbers, floating-point number not allowed in where clause\n-            if (!column.isKey() && table.getKeysType() != KeysType.DUP_KEYS\n-                    || column.getDataType().isFloatingPointType()) {\n-                // ErrorReport.reportDdlException(ErrorCode.ERR_NOT_KEY_COLUMN, columnName);\n-                throw new DdlException(\"Column[\" + columnName + \"] is not key column or storage model \" +\n-                        \"is not duplicate or column type is float or double.\");\n-            }\n-\n-            if (condition instanceof BinaryPredicate) {\n-                String value = null;\n-                try {\n-                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                    // if a bool cond passed to be, be's zone_map cannot handle bool correctly,\n-                    // change it to a tinyint type here;\n-                    value = ((LiteralExpr) binaryPredicate.getChild(1)).getStringValue();\n-                    if (column.getDataType() == PrimitiveType.BOOLEAN ) {\n-                        if (value.toLowerCase().equals(\"true\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"1\", Type.TINYINT));\n-                        } else if (value.toLowerCase().equals(\"false\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"0\", Type.TINYINT));\n-                        }\n-                    }\n-                    LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            } else if (condition instanceof InPredicate) {\n-                String value = null;\n-                try {\n-                    InPredicate inPredicate = (InPredicate) condition;\n-                    for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n-                        value = ((LiteralExpr) inPredicate.getChild(i)).getStringValue();\n-                        LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                    }\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            }\n-\n-            // set schema column name\n-            slotRef.setCol(column.getName());\n-        }\n-        Map<Long, List<Column>> indexIdToSchema = table.getIndexIdToSchema();\n-        for (MaterializedIndex index : partition.getMaterializedIndices(MaterializedIndex.IndexExtState.VISIBLE)) {\n-            if (table.getBaseIndexId() == index.getId()) {\n-                continue;\n-            }\n-\n-            // check table has condition column\n-            Map<String, Column> indexColNameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-            for (Column column : indexIdToSchema.get(index.getId())) {\n-                indexColNameToColumn.put(column.getName(), column);\n-            }\n-            String indexName = table.getIndexNameById(index.getId());\n-            for (Predicate condition : conditions) {\n-                SlotRef slotRef = getSlotRef(condition);\n-                String columnName = slotRef.getColumnName();\n-                Column column = indexColNameToColumn.get(columnName);\n-                if (column == null) {\n-                    ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, \"index[\" + indexName +\"]\");\n-                }\n-                MaterializedIndexMeta indexMeta = table.getIndexIdToMeta().get(index.getId());\n-                if (indexMeta.getKeysType() != KeysType.DUP_KEYS && !column.isKey()) {\n-                    throw new DdlException(\"Column[\" + columnName + \"] is not key column in index[\" + indexName + \"]\");\n-                }\n-            }\n-        }\n-\n-        if (deleteConditions == null) {\n-            return;\n-        }\n-\n-        // save delete conditions\n-        for (Predicate condition : conditions) {\n-            if (condition instanceof BinaryPredicate) {\n-                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                SlotRef slotRef = (SlotRef) binaryPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName).append(\" \").append(binaryPredicate.getOp().name()).append(\" \\\"\")\n-                        .append(((LiteralExpr) binaryPredicate.getChild(1)).getStringValue()).append(\"\\\"\");\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof IsNullPredicate) {\n-                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-                SlotRef slotRef = (SlotRef) isNullPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName);\n-                if (isNullPredicate.isNotNull()) {\n-                    sb.append(\" IS NOT NULL\");\n-                } else {\n-                    sb.append(\" IS NULL\");\n-                }\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof InPredicate) {\n-                InPredicate inPredicate = (InPredicate) condition;\n-                SlotRef slotRef = (SlotRef) inPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder strBuilder = new StringBuilder();\n-                String notStr = inPredicate.isNotIn() ? \"NOT \" : \"\";\n-                strBuilder.append(columnName).append(\" \" + notStr + \"IN (\");\n-                for (int i = 1; i <= inPredicate.getInElementNum(); ++i) {\n-                    strBuilder.append(inPredicate.getChild(i).toSql());\n-                    strBuilder.append((i + 1 != inPredicate.getInElementNum()) ? \", \" : \"\");\n-                }\n-                strBuilder.append(\")\");\n-                deleteConditions.add(strBuilder.toString());\n-            }\n-        }\n-    }\n-\n-    // show delete stmt\n-    public List<List<Comparable>> getDeleteInfosByDb(long dbId, boolean forUser) {\n-        LinkedList<List<Comparable>> infos = new LinkedList<List<Comparable>>();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n-        if (db == null) {\n-            return infos;\n-        }\n-\n-        String dbName = db.getFullName();\n-        List<DeleteInfo> deleteInfos = dbToDeleteInfos.get(dbId);\n-        if (deleteInfos == null) {\n-            return infos;\n-        }\n-\n-        for (DeleteInfo deleteInfo : deleteInfos) {\n-\n-            if (!Catalog.getCurrentCatalog().getAuth().checkTblPriv(ConnectContext.get(), dbName,\n-                    deleteInfo.getTableName(),\n-                    PrivPredicate.LOAD)) {\n-                continue;\n-            }\n-\n-\n-            List<Comparable> info = Lists.newArrayList();\n-            if (!forUser) {\n-                info.add(-1L);\n-                info.add(deleteInfo.getTableId());\n-            }\n-            info.add(deleteInfo.getTableName());\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionId());\n-            }\n-            info.add(deleteInfo.getPartitionName());\n-\n-            info.add(TimeUtils.longToTimeString(deleteInfo.getCreateTimeMs()));\n-            String conds = Joiner.on(\", \").join(deleteInfo.getDeleteConditions());\n-            info.add(conds);\n-\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionVersion());\n-                info.add(deleteInfo.getPartitionVersionHash());\n-            }\n-            // for loading state, should not display loading, show deleting instead\n-//                if (loadJob.getState() == LoadJob.JobState.LOADING) {\n-//                    info.add(\"DELETING\");\n-//                } else {\n-//                    info.add(loadJob.getState().name());\n-//                }\n-            info.add(\"FINISHED\");\n-            infos.add(info);\n-        }\n-        // sort by createTimeMs\n-        int sortIndex;\n-        if (!forUser) {\n-            sortIndex = 5;\n-        } else {\n-            sortIndex = 2;\n-        }\n-        ListComparator<List<Comparable>> comparator = new ListComparator<List<Comparable>>(sortIndex);\n-        Collections.sort(infos, comparator);\n-        return infos;\n-    }\n-\n-    public void replayDelete(DeleteInfo deleteInfo, Catalog catalog) {\n-        // add to deleteInfos\n-        long dbId = deleteInfo.getDbId();\n-        LOG.info(\"replay delete, dbId {}\", dbId);\n-        dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-        List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-        synchronized (deleteInfoList) {\n-            deleteInfoList.add(deleteInfo);\n-        }\n-    }\n-\n-    // for delete handler, we only persist those delete already finished.\n-    @Override\n-    public void write(DataOutput out) throws IOException {\n-        Text.writeString(out, GsonUtils.GSON.toJson(this));\n-    }\n-\n-    public static DeleteHandler read(DataInput in) throws IOException {\n-        String json = Text.readString(in);\n-        return GsonUtils.GSON.fromJson(json, DeleteHandler.class);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyODQyMQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450628421", "bodyText": "can slotRef be the second child of binaryPreidicate?", "author": "wutiangan", "createdAt": "2020-07-07T06:01:00Z", "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -450,7 +451,22 @@ public DeleteJob getDeleteJob(long transactionId) {\n         return idToDeleteJob.get(transactionId);\n     }\n \n-    private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate> conditions, List<String> deleteConditions, boolean preCheck)\n+    private SlotRef getSlotRef(Predicate condition) {\n+        SlotRef slotRef = null;\n+        if (condition instanceof BinaryPredicate) {\n+            BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n+            slotRef = (SlotRef) binaryPredicate.getChild(0);", "originalCommit": "105777771afca6e9ae09974f2520bf33339d31ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzODcwMA==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450638700", "bodyText": "not allowed", "author": "caiconghui", "createdAt": "2020-07-07T06:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyODQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "chunk": "diff --git a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java b/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\ndeleted file mode 100644\nindex a7c01b530..000000000\n--- a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\n+++ /dev/null\n\n@@ -1,691 +0,0 @@\n-// Licensed to the Apache Software Foundation (ASF) under one\n-// or more contributor license agreements.  See the NOTICE file\n-// distributed with this work for additional information\n-// regarding copyright ownership.  The ASF licenses this file\n-// to you under the Apache License, Version 2.0 (the\n-// \"License\"); you may not use this file except in compliance\n-// with the License.  You may obtain a copy of the License at\n-//\n-//   http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing,\n-// software distributed under the License is distributed on an\n-// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-// KIND, either express or implied.  See the License for the\n-// specific language governing permissions and limitations\n-// under the License.\n-\n-package org.apache.doris.load;\n-\n-import org.apache.doris.analysis.BinaryPredicate;\n-import org.apache.doris.analysis.DeleteStmt;\n-import org.apache.doris.analysis.InPredicate;\n-import org.apache.doris.analysis.IsNullPredicate;\n-import org.apache.doris.analysis.LiteralExpr;\n-import org.apache.doris.analysis.Predicate;\n-import org.apache.doris.analysis.SlotRef;\n-import org.apache.doris.catalog.Catalog;\n-import org.apache.doris.catalog.Column;\n-import org.apache.doris.catalog.Database;\n-import org.apache.doris.catalog.KeysType;\n-import org.apache.doris.catalog.MaterializedIndex;\n-import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n-import org.apache.doris.catalog.MaterializedIndexMeta;\n-import org.apache.doris.catalog.OlapTable;\n-import org.apache.doris.catalog.Partition;\n-import org.apache.doris.catalog.PartitionType;\n-import org.apache.doris.catalog.PrimitiveType;\n-import org.apache.doris.catalog.Replica;\n-import org.apache.doris.catalog.Table;\n-import org.apache.doris.catalog.Tablet;\n-import org.apache.doris.catalog.TabletInvertedIndex;\n-import org.apache.doris.catalog.Type;\n-import org.apache.doris.common.AnalysisException;\n-import org.apache.doris.common.Config;\n-import org.apache.doris.common.DdlException;\n-import org.apache.doris.common.ErrorCode;\n-import org.apache.doris.common.ErrorReport;\n-import org.apache.doris.common.FeConstants;\n-import org.apache.doris.common.MarkedCountDownLatch;\n-import org.apache.doris.common.MetaNotFoundException;\n-import org.apache.doris.common.UserException;\n-import org.apache.doris.common.io.Text;\n-import org.apache.doris.common.io.Writable;\n-import org.apache.doris.common.util.ListComparator;\n-import org.apache.doris.common.util.TimeUtils;\n-import org.apache.doris.load.DeleteJob.DeleteState;\n-import org.apache.doris.mysql.privilege.PrivPredicate;\n-import org.apache.doris.persist.gson.GsonUtils;\n-import org.apache.doris.qe.ConnectContext;\n-import org.apache.doris.qe.QueryState.MysqlStateType;\n-import org.apache.doris.qe.QueryStateException;\n-import org.apache.doris.service.FrontendOptions;\n-import org.apache.doris.task.AgentBatchTask;\n-import org.apache.doris.task.AgentTaskExecutor;\n-import org.apache.doris.task.AgentTaskQueue;\n-import org.apache.doris.task.PushTask;\n-import org.apache.doris.thrift.TPriority;\n-import org.apache.doris.thrift.TPushType;\n-import org.apache.doris.thrift.TTaskType;\n-import org.apache.doris.transaction.GlobalTransactionMgr;\n-import org.apache.doris.transaction.TabletCommitInfo;\n-import org.apache.doris.transaction.TransactionState;\n-import org.apache.doris.transaction.TransactionState.TxnCoordinator;\n-import org.apache.doris.transaction.TransactionState.TxnSourceType;\n-import org.apache.doris.transaction.TransactionStatus;\n-\n-import com.google.common.base.Joiner;\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import com.google.gson.annotations.SerializedName;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n-\n-public class DeleteHandler implements Writable {\n-    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n-\n-    // TransactionId -> DeleteJob\n-    private Map<Long, DeleteJob> idToDeleteJob;\n-\n-    // Db -> DeleteInfo list\n-    @SerializedName(value = \"dbToDeleteInfos\")\n-    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n-\n-    public DeleteHandler() {\n-        idToDeleteJob = Maps.newConcurrentMap();\n-        dbToDeleteInfos = Maps.newConcurrentMap();\n-    }\n-\n-    private enum CancelType {\n-        METADATA_MISSING,\n-        TIMEOUT,\n-        COMMIT_FAIL,\n-        UNKNOWN\n-    }\n-\n-    public void process(DeleteStmt stmt) throws DdlException, QueryStateException {\n-        String dbName = stmt.getDbName();\n-        String tableName = stmt.getTableName();\n-        String partitionName = stmt.getPartitionName();\n-        List<Predicate> conditions = stmt.getDeleteConditions();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbName);\n-        if (db == null) {\n-            throw new DdlException(\"Db does not exist. name: \" + dbName);\n-        }\n-\n-        DeleteJob deleteJob = null;\n-        try {\n-            MarkedCountDownLatch<Long, Long> countDownLatch;\n-            long transactionId = -1;\n-            db.readLock();\n-            try {\n-                Table table = db.getTable(tableName);\n-                if (table == null) {\n-                    throw new DdlException(\"Table does not exist. name: \" + tableName);\n-                }\n-\n-                if (table.getType() != Table.TableType.OLAP) {\n-                    throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n-                }\n-                OlapTable olapTable = (OlapTable) table;\n-\n-                if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n-                    throw new DdlException(\"Table's state is not normal: \" + tableName);\n-                }\n-\n-                if (partitionName == null) {\n-                    if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n-                        throw new DdlException(\"This is a range partitioned table.\"\n-                                + \" You should specify partition in delete stmt\");\n-                    } else {\n-                        // this is a unpartitioned table, use table name as partition name\n-                        partitionName = olapTable.getName();\n-                    }\n-                }\n-\n-                Partition partition = olapTable.getPartition(partitionName);\n-                if (partition == null) {\n-                    throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n-                }\n-\n-                List<String> deleteConditions = Lists.newArrayList();\n-\n-                // pre check\n-                checkDeleteV2(olapTable, partition, conditions, deleteConditions);\n-\n-                // generate label\n-                String label = \"delete_\" + UUID.randomUUID();\n-                //generate jobId\n-                long jobId = Catalog.getCurrentCatalog().getNextId();\n-                // begin txn here and generate txn id\n-                transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n-                        Lists.newArrayList(table.getId()), label, null,\n-                        new TxnCoordinator(TxnSourceType.FE, FrontendOptions.getLocalHostAddress()),\n-                        TransactionState.LoadJobSourceType.FRONTEND, jobId, Config.stream_load_default_timeout_second);\n-\n-                DeleteInfo deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n-                        partition.getId(), partitionName,\n-                        -1, 0, deleteConditions);\n-                deleteJob = new DeleteJob(jobId, transactionId, label, deleteInfo);\n-                idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n-\n-                Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n-                // task sent to be\n-                AgentBatchTask batchTask = new AgentBatchTask();\n-                // count total replica num\n-                int totalReplicaNum = 0;\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    for (Tablet tablet : index.getTablets()) {\n-                        totalReplicaNum += tablet.getReplicas().size();\n-                    }\n-                }\n-                countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n-\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    long indexId = index.getId();\n-                    int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n-\n-                    for (Tablet tablet : index.getTablets()) {\n-                        long tabletId = tablet.getId();\n-\n-                        // set push type\n-                        TPushType type = TPushType.DELETE;\n-\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            long replicaId = replica.getId();\n-                            long backendId = replica.getBackendId();\n-                            countDownLatch.addMark(backendId, tabletId);\n-\n-                            // create push task for each replica\n-                            PushTask pushTask = new PushTask(null,\n-                                    replica.getBackendId(), db.getId(), olapTable.getId(),\n-                                    partition.getId(), indexId,\n-                                    tabletId, replicaId, schemaHash,\n-                                    -1, 0, \"\", -1, 0,\n-                                    -1, type, conditions,\n-                                    true, TPriority.NORMAL,\n-                                    TTaskType.REALTIME_PUSH,\n-                                    transactionId,\n-                                    Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n-                            pushTask.setIsSchemaChanging(false);\n-                            pushTask.setCountDownLatch(countDownLatch);\n-\n-                            if (AgentTaskQueue.addTask(pushTask)) {\n-                                batchTask.addTask(pushTask);\n-                                deleteJob.addPushTask(pushTask);\n-                                deleteJob.addTablet(tabletId);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // submit push tasks\n-                if (batchTask.getTaskNum() > 0) {\n-                    AgentTaskExecutor.submit(batchTask);\n-                }\n-\n-            } catch (Throwable t) {\n-                LOG.warn(\"error occurred during delete process\", t);\n-                // if transaction has been begun, need to abort it\n-                if (Catalog.getCurrentGlobalTransactionMgr().getTransactionState(db.getId(), transactionId) != null) {\n-                    cancelJob(deleteJob, CancelType.UNKNOWN, t.getMessage());\n-                }\n-                throw new DdlException(t.getMessage(), t);\n-            } finally {\n-                db.readUnlock();\n-            }\n-\n-            long timeoutMs = deleteJob.getTimeoutMs();\n-            LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n-            boolean ok = false;\n-            try {\n-                ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n-            } catch (InterruptedException e) {\n-                LOG.warn(\"InterruptedException: \", e);\n-                ok = false;\n-            }\n-\n-            if (!ok) {\n-                String errMsg = \"\";\n-                List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n-                // only show at most 5 results\n-                List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n-                if (!subList.isEmpty()) {\n-                    errMsg = \"unfinished replicas: \" + Joiner.on(\", \").join(subList);\n-                }\n-                LOG.warn(errMsg);\n-\n-                try {\n-                    deleteJob.checkAndUpdateQuorum();\n-                } catch (MetaNotFoundException e) {\n-                    cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                    throw new DdlException(e.getMessage(), e);\n-                }\n-                DeleteState state = deleteJob.getState();\n-                switch (state) {\n-                    case UN_QUORUM:\n-                        LOG.warn(\"delete job timeout: transactionId {}, timeout {}, {}\", transactionId, timeoutMs, errMsg);\n-                        cancelJob(deleteJob, CancelType.TIMEOUT, \"delete job timeout\");\n-                        throw new DdlException(\"failed to execute delete. transaction id \" + transactionId +\n-                                \", timeout(ms) \" + timeoutMs + \", \" + errMsg);\n-                    case QUORUM_FINISHED:\n-                    case FINISHED:\n-                        try {\n-                            long nowQuorumTimeMs = System.currentTimeMillis();\n-                            long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n-                            // if job's state is quorum_finished then wait for a period of time and commit it.\n-                            while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n-                                deleteJob.checkAndUpdateQuorum();\n-                                Thread.sleep(1000);\n-                                nowQuorumTimeMs = System.currentTimeMillis();\n-                                LOG.debug(\"wait for quorum finished delete job: {}, txn id: {}\" + deleteJob.getId(), transactionId);\n-                            }\n-                        } catch (MetaNotFoundException e) {\n-                            cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        } catch (InterruptedException e) {\n-                            cancelJob(deleteJob, CancelType.UNKNOWN, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        }\n-                        commitJob(deleteJob, db, timeoutMs);\n-                        break;\n-                    default:\n-                        Preconditions.checkState(false, \"wrong delete job state: \" + state.name());\n-                        break;\n-                }\n-            } else {\n-                commitJob(deleteJob, db, timeoutMs);\n-            }\n-        } finally {\n-            if (!FeConstants.runningUnitTest) {\n-                clearJob(deleteJob);\n-            }\n-        }\n-    }\n-\n-    private void commitJob(DeleteJob job, Database db, long timeoutMs) throws DdlException, QueryStateException {\n-        TransactionStatus status = null;\n-        try {\n-            unprotectedCommitJob(job, db, timeoutMs);\n-            status = Catalog.getCurrentGlobalTransactionMgr().\n-                    getTransactionState(db.getId(), job.getTransactionId()).getTransactionStatus();\n-        } catch (UserException e) {\n-            if (cancelJob(job, CancelType.COMMIT_FAIL, e.getMessage())) {\n-                throw new DdlException(e.getMessage(), e);\n-            }\n-        }\n-\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"{'label':'\").append(job.getLabel()).append(\"', 'status':'\").append(status.name());\n-        sb.append(\"', 'txnId':'\").append(job.getTransactionId()).append(\"'\");\n-\n-        switch (status) {\n-            case COMMITTED: {\n-                // Although publish is unfinished we should tell user that commit already success.\n-                String errMsg = \"delete job is committed but may be taking effect later\";\n-                sb.append(\", 'err':'\").append(errMsg).append(\"'\");\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            case VISIBLE: {\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            default:\n-                Preconditions.checkState(false, \"wrong transaction status: \" + status.name());\n-                break;\n-        }\n-    }\n-\n-    /**\n-     * unprotected commit delete job\n-     * return true when successfully commit and publish\n-     * return false when successfully commit but publish unfinished.\n-     * A UserException thrown if both commit and publish failed.\n-     * @param job\n-     * @param db\n-     * @param timeoutMs\n-     * @return\n-     * @throws UserException\n-     */\n-    private boolean unprotectedCommitJob(DeleteJob job, Database db, long timeoutMs) throws UserException {\n-        long transactionId = job.getTransactionId();\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n-        TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n-        for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n-            for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n-                // the inverted index contains rolling up replica\n-                Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n-                if (tabletId == null) {\n-                    LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n-                    continue;\n-                }\n-                tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n-            }\n-        }\n-        return globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeoutMs);\n-    }\n-\n-    /**\n-     * This method should always be called in the end of the delete process to clean the job.\n-     * Better put it in finally block.\n-     * @param job\n-     */\n-    private void clearJob(DeleteJob job) {\n-        if (job != null) {\n-            long signature = job.getTransactionId();\n-            if (idToDeleteJob.containsKey(signature)) {\n-                idToDeleteJob.remove(signature);\n-            }\n-            for (PushTask pushTask : job.getPushTasks()) {\n-                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n-                        pushTask.getVersion(), pushTask.getVersionHash(),\n-                        pushTask.getPushType(), pushTask.getTaskType());\n-            }\n-\n-            // NOT remove callback from GlobalTransactionMgr's callback factory here.\n-            // the callback will be removed after transaction is aborted of visible.\n-        }\n-    }\n-\n-    public void recordFinishedJob(DeleteJob job) {\n-        if (job != null) {\n-            long dbId = job.getDeleteInfo().getDbId();\n-            LOG.info(\"record finished deleteJob, transactionId {}, dbId {}\",\n-                    job.getTransactionId(), dbId);\n-            dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-            List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-            synchronized (deleteInfoList) {\n-                deleteInfoList.add(job.getDeleteInfo());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * abort delete job\n-     * return true when successfully abort.\n-     * return true when some unknown error happened, just ignore it.\n-     * return false when the job is already committed\n-     * @param job\n-     * @param cancelType\n-     * @param reason\n-     * @return\n-     */\n-    public boolean cancelJob(DeleteJob job, CancelType cancelType, String reason) {\n-        LOG.info(\"start to cancel delete job, transactionId: {}, cancelType: {}\", job.getTransactionId(), cancelType.name());\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        try {\n-            if (job != null) {\n-                globalTransactionMgr.abortTransaction(job.getDeleteInfo().getDbId(), job.getTransactionId(), reason);\n-            }\n-        } catch (Exception e) {\n-            TransactionState state = globalTransactionMgr.getTransactionState(job.getDeleteInfo().getDbId(), job.getTransactionId());\n-            if (state == null) {\n-                LOG.warn(\"cancel delete job failed because txn not found, transactionId: {}\", job.getTransactionId());\n-            } else if (state.getTransactionStatus() == TransactionStatus.COMMITTED || state.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.warn(\"cancel delete job {} failed because it has been committed, transactionId: {}\", job.getTransactionId());\n-                return false;\n-            } else {\n-                LOG.warn(\"errors while abort transaction\", e);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public DeleteJob getDeleteJob(long transactionId) {\n-        return idToDeleteJob.get(transactionId);\n-    }\n-\n-    private SlotRef getSlotRef(Predicate condition) {\n-        SlotRef slotRef = null;\n-        if (condition instanceof BinaryPredicate) {\n-            BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-            slotRef = (SlotRef) binaryPredicate.getChild(0);\n-        } else if (condition instanceof IsNullPredicate) {\n-            IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-            slotRef = (SlotRef) isNullPredicate.getChild(0);\n-        } else if (condition instanceof InPredicate) {\n-            InPredicate inPredicate = (InPredicate) condition;\n-            slotRef = (SlotRef) inPredicate.getChild(0);\n-        }\n-        return slotRef;\n-    }\n-\n-    private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate> conditions, List<String> deleteConditions)\n-            throws DdlException {\n-\n-        // check partition state\n-        Partition.PartitionState state = partition.getState();\n-        if (state != Partition.PartitionState.NORMAL) {\n-            // ErrorReport.reportDdlException(ErrorCode.ERR_BAD_PARTITION_STATE, partition.getName(), state.name());\n-            throw new DdlException(\"Partition[\" + partition.getName() + \"]' state is not NORMAL: \" + state.name());\n-        }\n-\n-        // check condition column is key column and condition value\n-        Map<String, Column> nameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-        for (Column column : table.getBaseSchema()) {\n-            nameToColumn.put(column.getName(), column);\n-        }\n-        for (Predicate condition : conditions) {\n-            SlotRef slotRef = getSlotRef(condition);\n-            String columnName = slotRef.getColumnName();\n-            if (!nameToColumn.containsKey(columnName)) {\n-                ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, table.getName());\n-            }\n-\n-            Column column = nameToColumn.get(columnName);\n-            // Due to rounding errors, most floating-point numbers end up being slightly imprecise,\n-            // it also means that numbers expected to be equal often differ slightly, so we do not allow compare with\n-            // floating-point numbers, floating-point number not allowed in where clause\n-            if (!column.isKey() && table.getKeysType() != KeysType.DUP_KEYS\n-                    || column.getDataType().isFloatingPointType()) {\n-                // ErrorReport.reportDdlException(ErrorCode.ERR_NOT_KEY_COLUMN, columnName);\n-                throw new DdlException(\"Column[\" + columnName + \"] is not key column or storage model \" +\n-                        \"is not duplicate or column type is float or double.\");\n-            }\n-\n-            if (condition instanceof BinaryPredicate) {\n-                String value = null;\n-                try {\n-                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                    // if a bool cond passed to be, be's zone_map cannot handle bool correctly,\n-                    // change it to a tinyint type here;\n-                    value = ((LiteralExpr) binaryPredicate.getChild(1)).getStringValue();\n-                    if (column.getDataType() == PrimitiveType.BOOLEAN ) {\n-                        if (value.toLowerCase().equals(\"true\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"1\", Type.TINYINT));\n-                        } else if (value.toLowerCase().equals(\"false\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"0\", Type.TINYINT));\n-                        }\n-                    }\n-                    LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            } else if (condition instanceof InPredicate) {\n-                String value = null;\n-                try {\n-                    InPredicate inPredicate = (InPredicate) condition;\n-                    for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n-                        value = ((LiteralExpr) inPredicate.getChild(i)).getStringValue();\n-                        LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                    }\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            }\n-\n-            // set schema column name\n-            slotRef.setCol(column.getName());\n-        }\n-        Map<Long, List<Column>> indexIdToSchema = table.getIndexIdToSchema();\n-        for (MaterializedIndex index : partition.getMaterializedIndices(MaterializedIndex.IndexExtState.VISIBLE)) {\n-            if (table.getBaseIndexId() == index.getId()) {\n-                continue;\n-            }\n-\n-            // check table has condition column\n-            Map<String, Column> indexColNameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-            for (Column column : indexIdToSchema.get(index.getId())) {\n-                indexColNameToColumn.put(column.getName(), column);\n-            }\n-            String indexName = table.getIndexNameById(index.getId());\n-            for (Predicate condition : conditions) {\n-                SlotRef slotRef = getSlotRef(condition);\n-                String columnName = slotRef.getColumnName();\n-                Column column = indexColNameToColumn.get(columnName);\n-                if (column == null) {\n-                    ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, \"index[\" + indexName +\"]\");\n-                }\n-                MaterializedIndexMeta indexMeta = table.getIndexIdToMeta().get(index.getId());\n-                if (indexMeta.getKeysType() != KeysType.DUP_KEYS && !column.isKey()) {\n-                    throw new DdlException(\"Column[\" + columnName + \"] is not key column in index[\" + indexName + \"]\");\n-                }\n-            }\n-        }\n-\n-        if (deleteConditions == null) {\n-            return;\n-        }\n-\n-        // save delete conditions\n-        for (Predicate condition : conditions) {\n-            if (condition instanceof BinaryPredicate) {\n-                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                SlotRef slotRef = (SlotRef) binaryPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName).append(\" \").append(binaryPredicate.getOp().name()).append(\" \\\"\")\n-                        .append(((LiteralExpr) binaryPredicate.getChild(1)).getStringValue()).append(\"\\\"\");\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof IsNullPredicate) {\n-                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-                SlotRef slotRef = (SlotRef) isNullPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName);\n-                if (isNullPredicate.isNotNull()) {\n-                    sb.append(\" IS NOT NULL\");\n-                } else {\n-                    sb.append(\" IS NULL\");\n-                }\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof InPredicate) {\n-                InPredicate inPredicate = (InPredicate) condition;\n-                SlotRef slotRef = (SlotRef) inPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder strBuilder = new StringBuilder();\n-                String notStr = inPredicate.isNotIn() ? \"NOT \" : \"\";\n-                strBuilder.append(columnName).append(\" \" + notStr + \"IN (\");\n-                for (int i = 1; i <= inPredicate.getInElementNum(); ++i) {\n-                    strBuilder.append(inPredicate.getChild(i).toSql());\n-                    strBuilder.append((i + 1 != inPredicate.getInElementNum()) ? \", \" : \"\");\n-                }\n-                strBuilder.append(\")\");\n-                deleteConditions.add(strBuilder.toString());\n-            }\n-        }\n-    }\n-\n-    // show delete stmt\n-    public List<List<Comparable>> getDeleteInfosByDb(long dbId, boolean forUser) {\n-        LinkedList<List<Comparable>> infos = new LinkedList<List<Comparable>>();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n-        if (db == null) {\n-            return infos;\n-        }\n-\n-        String dbName = db.getFullName();\n-        List<DeleteInfo> deleteInfos = dbToDeleteInfos.get(dbId);\n-        if (deleteInfos == null) {\n-            return infos;\n-        }\n-\n-        for (DeleteInfo deleteInfo : deleteInfos) {\n-\n-            if (!Catalog.getCurrentCatalog().getAuth().checkTblPriv(ConnectContext.get(), dbName,\n-                    deleteInfo.getTableName(),\n-                    PrivPredicate.LOAD)) {\n-                continue;\n-            }\n-\n-\n-            List<Comparable> info = Lists.newArrayList();\n-            if (!forUser) {\n-                info.add(-1L);\n-                info.add(deleteInfo.getTableId());\n-            }\n-            info.add(deleteInfo.getTableName());\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionId());\n-            }\n-            info.add(deleteInfo.getPartitionName());\n-\n-            info.add(TimeUtils.longToTimeString(deleteInfo.getCreateTimeMs()));\n-            String conds = Joiner.on(\", \").join(deleteInfo.getDeleteConditions());\n-            info.add(conds);\n-\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionVersion());\n-                info.add(deleteInfo.getPartitionVersionHash());\n-            }\n-            // for loading state, should not display loading, show deleting instead\n-//                if (loadJob.getState() == LoadJob.JobState.LOADING) {\n-//                    info.add(\"DELETING\");\n-//                } else {\n-//                    info.add(loadJob.getState().name());\n-//                }\n-            info.add(\"FINISHED\");\n-            infos.add(info);\n-        }\n-        // sort by createTimeMs\n-        int sortIndex;\n-        if (!forUser) {\n-            sortIndex = 5;\n-        } else {\n-            sortIndex = 2;\n-        }\n-        ListComparator<List<Comparable>> comparator = new ListComparator<List<Comparable>>(sortIndex);\n-        Collections.sort(infos, comparator);\n-        return infos;\n-    }\n-\n-    public void replayDelete(DeleteInfo deleteInfo, Catalog catalog) {\n-        // add to deleteInfos\n-        long dbId = deleteInfo.getDbId();\n-        LOG.info(\"replay delete, dbId {}\", dbId);\n-        dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-        List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-        synchronized (deleteInfoList) {\n-            deleteInfoList.add(deleteInfo);\n-        }\n-    }\n-\n-    // for delete handler, we only persist those delete already finished.\n-    @Override\n-    public void write(DataOutput out) throws IOException {\n-        Text.writeString(out, GsonUtils.GSON.toJson(this));\n-    }\n-\n-    public static DeleteHandler read(DataInput in) throws IOException {\n-        String json = Text.readString(in);\n-        return GsonUtils.GSON.fromJson(json, DeleteHandler.class);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMjE0MQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450632141", "bodyText": "what does the for loop do? LiteralExpr.create has no return value?", "author": "wutiangan", "createdAt": "2020-07-07T06:12:50Z", "path": "fe/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -507,7 +516,19 @@ private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate>\n                     LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n                 } catch (AnalysisException e) {\n                     // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"]\");\n+                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n+                }\n+            } else if (condition instanceof InPredicate) {\n+                String value = null;\n+                try {\n+                    InPredicate inPredicate = (InPredicate) condition;\n+                    for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n+                        value = ((LiteralExpr) inPredicate.getChild(i)).getStringValue();\n+                        LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n+                    }", "originalCommit": "105777771afca6e9ae09974f2520bf33339d31ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzNzAxNg==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r450637016", "bodyText": "check valid or throw exception", "author": "caiconghui", "createdAt": "2020-07-07T06:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMjE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "chunk": "diff --git a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java b/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\ndeleted file mode 100644\nindex a7c01b530..000000000\n--- a/fe/src/main/java/org/apache/doris/load/DeleteHandler.java\n+++ /dev/null\n\n@@ -1,691 +0,0 @@\n-// Licensed to the Apache Software Foundation (ASF) under one\n-// or more contributor license agreements.  See the NOTICE file\n-// distributed with this work for additional information\n-// regarding copyright ownership.  The ASF licenses this file\n-// to you under the Apache License, Version 2.0 (the\n-// \"License\"); you may not use this file except in compliance\n-// with the License.  You may obtain a copy of the License at\n-//\n-//   http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing,\n-// software distributed under the License is distributed on an\n-// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-// KIND, either express or implied.  See the License for the\n-// specific language governing permissions and limitations\n-// under the License.\n-\n-package org.apache.doris.load;\n-\n-import org.apache.doris.analysis.BinaryPredicate;\n-import org.apache.doris.analysis.DeleteStmt;\n-import org.apache.doris.analysis.InPredicate;\n-import org.apache.doris.analysis.IsNullPredicate;\n-import org.apache.doris.analysis.LiteralExpr;\n-import org.apache.doris.analysis.Predicate;\n-import org.apache.doris.analysis.SlotRef;\n-import org.apache.doris.catalog.Catalog;\n-import org.apache.doris.catalog.Column;\n-import org.apache.doris.catalog.Database;\n-import org.apache.doris.catalog.KeysType;\n-import org.apache.doris.catalog.MaterializedIndex;\n-import org.apache.doris.catalog.MaterializedIndex.IndexExtState;\n-import org.apache.doris.catalog.MaterializedIndexMeta;\n-import org.apache.doris.catalog.OlapTable;\n-import org.apache.doris.catalog.Partition;\n-import org.apache.doris.catalog.PartitionType;\n-import org.apache.doris.catalog.PrimitiveType;\n-import org.apache.doris.catalog.Replica;\n-import org.apache.doris.catalog.Table;\n-import org.apache.doris.catalog.Tablet;\n-import org.apache.doris.catalog.TabletInvertedIndex;\n-import org.apache.doris.catalog.Type;\n-import org.apache.doris.common.AnalysisException;\n-import org.apache.doris.common.Config;\n-import org.apache.doris.common.DdlException;\n-import org.apache.doris.common.ErrorCode;\n-import org.apache.doris.common.ErrorReport;\n-import org.apache.doris.common.FeConstants;\n-import org.apache.doris.common.MarkedCountDownLatch;\n-import org.apache.doris.common.MetaNotFoundException;\n-import org.apache.doris.common.UserException;\n-import org.apache.doris.common.io.Text;\n-import org.apache.doris.common.io.Writable;\n-import org.apache.doris.common.util.ListComparator;\n-import org.apache.doris.common.util.TimeUtils;\n-import org.apache.doris.load.DeleteJob.DeleteState;\n-import org.apache.doris.mysql.privilege.PrivPredicate;\n-import org.apache.doris.persist.gson.GsonUtils;\n-import org.apache.doris.qe.ConnectContext;\n-import org.apache.doris.qe.QueryState.MysqlStateType;\n-import org.apache.doris.qe.QueryStateException;\n-import org.apache.doris.service.FrontendOptions;\n-import org.apache.doris.task.AgentBatchTask;\n-import org.apache.doris.task.AgentTaskExecutor;\n-import org.apache.doris.task.AgentTaskQueue;\n-import org.apache.doris.task.PushTask;\n-import org.apache.doris.thrift.TPriority;\n-import org.apache.doris.thrift.TPushType;\n-import org.apache.doris.thrift.TTaskType;\n-import org.apache.doris.transaction.GlobalTransactionMgr;\n-import org.apache.doris.transaction.TabletCommitInfo;\n-import org.apache.doris.transaction.TransactionState;\n-import org.apache.doris.transaction.TransactionState.TxnCoordinator;\n-import org.apache.doris.transaction.TransactionState.TxnSourceType;\n-import org.apache.doris.transaction.TransactionStatus;\n-\n-import com.google.common.base.Joiner;\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import com.google.gson.annotations.SerializedName;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n-\n-public class DeleteHandler implements Writable {\n-    private static final Logger LOG = LogManager.getLogger(DeleteHandler.class);\n-\n-    // TransactionId -> DeleteJob\n-    private Map<Long, DeleteJob> idToDeleteJob;\n-\n-    // Db -> DeleteInfo list\n-    @SerializedName(value = \"dbToDeleteInfos\")\n-    private Map<Long, List<DeleteInfo>> dbToDeleteInfos;\n-\n-    public DeleteHandler() {\n-        idToDeleteJob = Maps.newConcurrentMap();\n-        dbToDeleteInfos = Maps.newConcurrentMap();\n-    }\n-\n-    private enum CancelType {\n-        METADATA_MISSING,\n-        TIMEOUT,\n-        COMMIT_FAIL,\n-        UNKNOWN\n-    }\n-\n-    public void process(DeleteStmt stmt) throws DdlException, QueryStateException {\n-        String dbName = stmt.getDbName();\n-        String tableName = stmt.getTableName();\n-        String partitionName = stmt.getPartitionName();\n-        List<Predicate> conditions = stmt.getDeleteConditions();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbName);\n-        if (db == null) {\n-            throw new DdlException(\"Db does not exist. name: \" + dbName);\n-        }\n-\n-        DeleteJob deleteJob = null;\n-        try {\n-            MarkedCountDownLatch<Long, Long> countDownLatch;\n-            long transactionId = -1;\n-            db.readLock();\n-            try {\n-                Table table = db.getTable(tableName);\n-                if (table == null) {\n-                    throw new DdlException(\"Table does not exist. name: \" + tableName);\n-                }\n-\n-                if (table.getType() != Table.TableType.OLAP) {\n-                    throw new DdlException(\"Not olap type table. type: \" + table.getType().name());\n-                }\n-                OlapTable olapTable = (OlapTable) table;\n-\n-                if (olapTable.getState() != OlapTable.OlapTableState.NORMAL) {\n-                    throw new DdlException(\"Table's state is not normal: \" + tableName);\n-                }\n-\n-                if (partitionName == null) {\n-                    if (olapTable.getPartitionInfo().getType() == PartitionType.RANGE) {\n-                        throw new DdlException(\"This is a range partitioned table.\"\n-                                + \" You should specify partition in delete stmt\");\n-                    } else {\n-                        // this is a unpartitioned table, use table name as partition name\n-                        partitionName = olapTable.getName();\n-                    }\n-                }\n-\n-                Partition partition = olapTable.getPartition(partitionName);\n-                if (partition == null) {\n-                    throw new DdlException(\"Partition does not exist. name: \" + partitionName);\n-                }\n-\n-                List<String> deleteConditions = Lists.newArrayList();\n-\n-                // pre check\n-                checkDeleteV2(olapTable, partition, conditions, deleteConditions);\n-\n-                // generate label\n-                String label = \"delete_\" + UUID.randomUUID();\n-                //generate jobId\n-                long jobId = Catalog.getCurrentCatalog().getNextId();\n-                // begin txn here and generate txn id\n-                transactionId = Catalog.getCurrentGlobalTransactionMgr().beginTransaction(db.getId(),\n-                        Lists.newArrayList(table.getId()), label, null,\n-                        new TxnCoordinator(TxnSourceType.FE, FrontendOptions.getLocalHostAddress()),\n-                        TransactionState.LoadJobSourceType.FRONTEND, jobId, Config.stream_load_default_timeout_second);\n-\n-                DeleteInfo deleteInfo = new DeleteInfo(db.getId(), olapTable.getId(), tableName,\n-                        partition.getId(), partitionName,\n-                        -1, 0, deleteConditions);\n-                deleteJob = new DeleteJob(jobId, transactionId, label, deleteInfo);\n-                idToDeleteJob.put(deleteJob.getTransactionId(), deleteJob);\n-\n-                Catalog.getCurrentGlobalTransactionMgr().getCallbackFactory().addCallback(deleteJob);\n-                // task sent to be\n-                AgentBatchTask batchTask = new AgentBatchTask();\n-                // count total replica num\n-                int totalReplicaNum = 0;\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    for (Tablet tablet : index.getTablets()) {\n-                        totalReplicaNum += tablet.getReplicas().size();\n-                    }\n-                }\n-                countDownLatch = new MarkedCountDownLatch<Long, Long>(totalReplicaNum);\n-\n-                for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n-                    long indexId = index.getId();\n-                    int schemaHash = olapTable.getSchemaHashByIndexId(indexId);\n-\n-                    for (Tablet tablet : index.getTablets()) {\n-                        long tabletId = tablet.getId();\n-\n-                        // set push type\n-                        TPushType type = TPushType.DELETE;\n-\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            long replicaId = replica.getId();\n-                            long backendId = replica.getBackendId();\n-                            countDownLatch.addMark(backendId, tabletId);\n-\n-                            // create push task for each replica\n-                            PushTask pushTask = new PushTask(null,\n-                                    replica.getBackendId(), db.getId(), olapTable.getId(),\n-                                    partition.getId(), indexId,\n-                                    tabletId, replicaId, schemaHash,\n-                                    -1, 0, \"\", -1, 0,\n-                                    -1, type, conditions,\n-                                    true, TPriority.NORMAL,\n-                                    TTaskType.REALTIME_PUSH,\n-                                    transactionId,\n-                                    Catalog.getCurrentGlobalTransactionMgr().getTransactionIDGenerator().getNextTransactionId());\n-                            pushTask.setIsSchemaChanging(false);\n-                            pushTask.setCountDownLatch(countDownLatch);\n-\n-                            if (AgentTaskQueue.addTask(pushTask)) {\n-                                batchTask.addTask(pushTask);\n-                                deleteJob.addPushTask(pushTask);\n-                                deleteJob.addTablet(tabletId);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // submit push tasks\n-                if (batchTask.getTaskNum() > 0) {\n-                    AgentTaskExecutor.submit(batchTask);\n-                }\n-\n-            } catch (Throwable t) {\n-                LOG.warn(\"error occurred during delete process\", t);\n-                // if transaction has been begun, need to abort it\n-                if (Catalog.getCurrentGlobalTransactionMgr().getTransactionState(db.getId(), transactionId) != null) {\n-                    cancelJob(deleteJob, CancelType.UNKNOWN, t.getMessage());\n-                }\n-                throw new DdlException(t.getMessage(), t);\n-            } finally {\n-                db.readUnlock();\n-            }\n-\n-            long timeoutMs = deleteJob.getTimeoutMs();\n-            LOG.info(\"waiting delete Job finish, signature: {}, timeout: {}\", transactionId, timeoutMs);\n-            boolean ok = false;\n-            try {\n-                ok = countDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n-            } catch (InterruptedException e) {\n-                LOG.warn(\"InterruptedException: \", e);\n-                ok = false;\n-            }\n-\n-            if (!ok) {\n-                String errMsg = \"\";\n-                List<Entry<Long, Long>> unfinishedMarks = countDownLatch.getLeftMarks();\n-                // only show at most 5 results\n-                List<Entry<Long, Long>> subList = unfinishedMarks.subList(0, Math.min(unfinishedMarks.size(), 5));\n-                if (!subList.isEmpty()) {\n-                    errMsg = \"unfinished replicas: \" + Joiner.on(\", \").join(subList);\n-                }\n-                LOG.warn(errMsg);\n-\n-                try {\n-                    deleteJob.checkAndUpdateQuorum();\n-                } catch (MetaNotFoundException e) {\n-                    cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                    throw new DdlException(e.getMessage(), e);\n-                }\n-                DeleteState state = deleteJob.getState();\n-                switch (state) {\n-                    case UN_QUORUM:\n-                        LOG.warn(\"delete job timeout: transactionId {}, timeout {}, {}\", transactionId, timeoutMs, errMsg);\n-                        cancelJob(deleteJob, CancelType.TIMEOUT, \"delete job timeout\");\n-                        throw new DdlException(\"failed to execute delete. transaction id \" + transactionId +\n-                                \", timeout(ms) \" + timeoutMs + \", \" + errMsg);\n-                    case QUORUM_FINISHED:\n-                    case FINISHED:\n-                        try {\n-                            long nowQuorumTimeMs = System.currentTimeMillis();\n-                            long endQuorumTimeoutMs = nowQuorumTimeMs + timeoutMs / 2;\n-                            // if job's state is quorum_finished then wait for a period of time and commit it.\n-                            while (deleteJob.getState() == DeleteState.QUORUM_FINISHED && endQuorumTimeoutMs > nowQuorumTimeMs) {\n-                                deleteJob.checkAndUpdateQuorum();\n-                                Thread.sleep(1000);\n-                                nowQuorumTimeMs = System.currentTimeMillis();\n-                                LOG.debug(\"wait for quorum finished delete job: {}, txn id: {}\" + deleteJob.getId(), transactionId);\n-                            }\n-                        } catch (MetaNotFoundException e) {\n-                            cancelJob(deleteJob, CancelType.METADATA_MISSING, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        } catch (InterruptedException e) {\n-                            cancelJob(deleteJob, CancelType.UNKNOWN, e.getMessage());\n-                            throw new DdlException(e.getMessage(), e);\n-                        }\n-                        commitJob(deleteJob, db, timeoutMs);\n-                        break;\n-                    default:\n-                        Preconditions.checkState(false, \"wrong delete job state: \" + state.name());\n-                        break;\n-                }\n-            } else {\n-                commitJob(deleteJob, db, timeoutMs);\n-            }\n-        } finally {\n-            if (!FeConstants.runningUnitTest) {\n-                clearJob(deleteJob);\n-            }\n-        }\n-    }\n-\n-    private void commitJob(DeleteJob job, Database db, long timeoutMs) throws DdlException, QueryStateException {\n-        TransactionStatus status = null;\n-        try {\n-            unprotectedCommitJob(job, db, timeoutMs);\n-            status = Catalog.getCurrentGlobalTransactionMgr().\n-                    getTransactionState(db.getId(), job.getTransactionId()).getTransactionStatus();\n-        } catch (UserException e) {\n-            if (cancelJob(job, CancelType.COMMIT_FAIL, e.getMessage())) {\n-                throw new DdlException(e.getMessage(), e);\n-            }\n-        }\n-\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"{'label':'\").append(job.getLabel()).append(\"', 'status':'\").append(status.name());\n-        sb.append(\"', 'txnId':'\").append(job.getTransactionId()).append(\"'\");\n-\n-        switch (status) {\n-            case COMMITTED: {\n-                // Although publish is unfinished we should tell user that commit already success.\n-                String errMsg = \"delete job is committed but may be taking effect later\";\n-                sb.append(\", 'err':'\").append(errMsg).append(\"'\");\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            case VISIBLE: {\n-                sb.append(\"}\");\n-                throw new QueryStateException(MysqlStateType.OK, sb.toString());\n-            }\n-            default:\n-                Preconditions.checkState(false, \"wrong transaction status: \" + status.name());\n-                break;\n-        }\n-    }\n-\n-    /**\n-     * unprotected commit delete job\n-     * return true when successfully commit and publish\n-     * return false when successfully commit but publish unfinished.\n-     * A UserException thrown if both commit and publish failed.\n-     * @param job\n-     * @param db\n-     * @param timeoutMs\n-     * @return\n-     * @throws UserException\n-     */\n-    private boolean unprotectedCommitJob(DeleteJob job, Database db, long timeoutMs) throws UserException {\n-        long transactionId = job.getTransactionId();\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        List<TabletCommitInfo> tabletCommitInfos = new ArrayList<TabletCommitInfo>();\n-        TabletInvertedIndex invertedIndex = Catalog.getCurrentInvertedIndex();\n-        for (TabletDeleteInfo tDeleteInfo : job.getTabletDeleteInfo()) {\n-            for (Replica replica : tDeleteInfo.getFinishedReplicas()) {\n-                // the inverted index contains rolling up replica\n-                Long tabletId = invertedIndex.getTabletIdByReplica(replica.getId());\n-                if (tabletId == null) {\n-                    LOG.warn(\"could not find tablet id for replica {}, the tablet maybe dropped\", replica);\n-                    continue;\n-                }\n-                tabletCommitInfos.add(new TabletCommitInfo(tabletId, replica.getBackendId()));\n-            }\n-        }\n-        return globalTransactionMgr.commitAndPublishTransaction(db, transactionId, tabletCommitInfos, timeoutMs);\n-    }\n-\n-    /**\n-     * This method should always be called in the end of the delete process to clean the job.\n-     * Better put it in finally block.\n-     * @param job\n-     */\n-    private void clearJob(DeleteJob job) {\n-        if (job != null) {\n-            long signature = job.getTransactionId();\n-            if (idToDeleteJob.containsKey(signature)) {\n-                idToDeleteJob.remove(signature);\n-            }\n-            for (PushTask pushTask : job.getPushTasks()) {\n-                AgentTaskQueue.removePushTask(pushTask.getBackendId(), pushTask.getSignature(),\n-                        pushTask.getVersion(), pushTask.getVersionHash(),\n-                        pushTask.getPushType(), pushTask.getTaskType());\n-            }\n-\n-            // NOT remove callback from GlobalTransactionMgr's callback factory here.\n-            // the callback will be removed after transaction is aborted of visible.\n-        }\n-    }\n-\n-    public void recordFinishedJob(DeleteJob job) {\n-        if (job != null) {\n-            long dbId = job.getDeleteInfo().getDbId();\n-            LOG.info(\"record finished deleteJob, transactionId {}, dbId {}\",\n-                    job.getTransactionId(), dbId);\n-            dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-            List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-            synchronized (deleteInfoList) {\n-                deleteInfoList.add(job.getDeleteInfo());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * abort delete job\n-     * return true when successfully abort.\n-     * return true when some unknown error happened, just ignore it.\n-     * return false when the job is already committed\n-     * @param job\n-     * @param cancelType\n-     * @param reason\n-     * @return\n-     */\n-    public boolean cancelJob(DeleteJob job, CancelType cancelType, String reason) {\n-        LOG.info(\"start to cancel delete job, transactionId: {}, cancelType: {}\", job.getTransactionId(), cancelType.name());\n-        GlobalTransactionMgr globalTransactionMgr = Catalog.getCurrentGlobalTransactionMgr();\n-        try {\n-            if (job != null) {\n-                globalTransactionMgr.abortTransaction(job.getDeleteInfo().getDbId(), job.getTransactionId(), reason);\n-            }\n-        } catch (Exception e) {\n-            TransactionState state = globalTransactionMgr.getTransactionState(job.getDeleteInfo().getDbId(), job.getTransactionId());\n-            if (state == null) {\n-                LOG.warn(\"cancel delete job failed because txn not found, transactionId: {}\", job.getTransactionId());\n-            } else if (state.getTransactionStatus() == TransactionStatus.COMMITTED || state.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.warn(\"cancel delete job {} failed because it has been committed, transactionId: {}\", job.getTransactionId());\n-                return false;\n-            } else {\n-                LOG.warn(\"errors while abort transaction\", e);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public DeleteJob getDeleteJob(long transactionId) {\n-        return idToDeleteJob.get(transactionId);\n-    }\n-\n-    private SlotRef getSlotRef(Predicate condition) {\n-        SlotRef slotRef = null;\n-        if (condition instanceof BinaryPredicate) {\n-            BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-            slotRef = (SlotRef) binaryPredicate.getChild(0);\n-        } else if (condition instanceof IsNullPredicate) {\n-            IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-            slotRef = (SlotRef) isNullPredicate.getChild(0);\n-        } else if (condition instanceof InPredicate) {\n-            InPredicate inPredicate = (InPredicate) condition;\n-            slotRef = (SlotRef) inPredicate.getChild(0);\n-        }\n-        return slotRef;\n-    }\n-\n-    private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate> conditions, List<String> deleteConditions)\n-            throws DdlException {\n-\n-        // check partition state\n-        Partition.PartitionState state = partition.getState();\n-        if (state != Partition.PartitionState.NORMAL) {\n-            // ErrorReport.reportDdlException(ErrorCode.ERR_BAD_PARTITION_STATE, partition.getName(), state.name());\n-            throw new DdlException(\"Partition[\" + partition.getName() + \"]' state is not NORMAL: \" + state.name());\n-        }\n-\n-        // check condition column is key column and condition value\n-        Map<String, Column> nameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-        for (Column column : table.getBaseSchema()) {\n-            nameToColumn.put(column.getName(), column);\n-        }\n-        for (Predicate condition : conditions) {\n-            SlotRef slotRef = getSlotRef(condition);\n-            String columnName = slotRef.getColumnName();\n-            if (!nameToColumn.containsKey(columnName)) {\n-                ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, table.getName());\n-            }\n-\n-            Column column = nameToColumn.get(columnName);\n-            // Due to rounding errors, most floating-point numbers end up being slightly imprecise,\n-            // it also means that numbers expected to be equal often differ slightly, so we do not allow compare with\n-            // floating-point numbers, floating-point number not allowed in where clause\n-            if (!column.isKey() && table.getKeysType() != KeysType.DUP_KEYS\n-                    || column.getDataType().isFloatingPointType()) {\n-                // ErrorReport.reportDdlException(ErrorCode.ERR_NOT_KEY_COLUMN, columnName);\n-                throw new DdlException(\"Column[\" + columnName + \"] is not key column or storage model \" +\n-                        \"is not duplicate or column type is float or double.\");\n-            }\n-\n-            if (condition instanceof BinaryPredicate) {\n-                String value = null;\n-                try {\n-                    BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                    // if a bool cond passed to be, be's zone_map cannot handle bool correctly,\n-                    // change it to a tinyint type here;\n-                    value = ((LiteralExpr) binaryPredicate.getChild(1)).getStringValue();\n-                    if (column.getDataType() == PrimitiveType.BOOLEAN ) {\n-                        if (value.toLowerCase().equals(\"true\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"1\", Type.TINYINT));\n-                        } else if (value.toLowerCase().equals(\"false\")) {\n-                            binaryPredicate.setChild(1, LiteralExpr.create(\"0\", Type.TINYINT));\n-                        }\n-                    }\n-                    LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            } else if (condition instanceof InPredicate) {\n-                String value = null;\n-                try {\n-                    InPredicate inPredicate = (InPredicate) condition;\n-                    for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n-                        value = ((LiteralExpr) inPredicate.getChild(i)).getStringValue();\n-                        LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n-                    }\n-                } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n-                }\n-            }\n-\n-            // set schema column name\n-            slotRef.setCol(column.getName());\n-        }\n-        Map<Long, List<Column>> indexIdToSchema = table.getIndexIdToSchema();\n-        for (MaterializedIndex index : partition.getMaterializedIndices(MaterializedIndex.IndexExtState.VISIBLE)) {\n-            if (table.getBaseIndexId() == index.getId()) {\n-                continue;\n-            }\n-\n-            // check table has condition column\n-            Map<String, Column> indexColNameToColumn = Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);\n-            for (Column column : indexIdToSchema.get(index.getId())) {\n-                indexColNameToColumn.put(column.getName(), column);\n-            }\n-            String indexName = table.getIndexNameById(index.getId());\n-            for (Predicate condition : conditions) {\n-                SlotRef slotRef = getSlotRef(condition);\n-                String columnName = slotRef.getColumnName();\n-                Column column = indexColNameToColumn.get(columnName);\n-                if (column == null) {\n-                    ErrorReport.reportDdlException(ErrorCode.ERR_BAD_FIELD_ERROR, columnName, \"index[\" + indexName +\"]\");\n-                }\n-                MaterializedIndexMeta indexMeta = table.getIndexIdToMeta().get(index.getId());\n-                if (indexMeta.getKeysType() != KeysType.DUP_KEYS && !column.isKey()) {\n-                    throw new DdlException(\"Column[\" + columnName + \"] is not key column in index[\" + indexName + \"]\");\n-                }\n-            }\n-        }\n-\n-        if (deleteConditions == null) {\n-            return;\n-        }\n-\n-        // save delete conditions\n-        for (Predicate condition : conditions) {\n-            if (condition instanceof BinaryPredicate) {\n-                BinaryPredicate binaryPredicate = (BinaryPredicate) condition;\n-                SlotRef slotRef = (SlotRef) binaryPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName).append(\" \").append(binaryPredicate.getOp().name()).append(\" \\\"\")\n-                        .append(((LiteralExpr) binaryPredicate.getChild(1)).getStringValue()).append(\"\\\"\");\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof IsNullPredicate) {\n-                IsNullPredicate isNullPredicate = (IsNullPredicate) condition;\n-                SlotRef slotRef = (SlotRef) isNullPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(columnName);\n-                if (isNullPredicate.isNotNull()) {\n-                    sb.append(\" IS NOT NULL\");\n-                } else {\n-                    sb.append(\" IS NULL\");\n-                }\n-                deleteConditions.add(sb.toString());\n-            } else if (condition instanceof InPredicate) {\n-                InPredicate inPredicate = (InPredicate) condition;\n-                SlotRef slotRef = (SlotRef) inPredicate.getChild(0);\n-                String columnName = slotRef.getColumnName();\n-                StringBuilder strBuilder = new StringBuilder();\n-                String notStr = inPredicate.isNotIn() ? \"NOT \" : \"\";\n-                strBuilder.append(columnName).append(\" \" + notStr + \"IN (\");\n-                for (int i = 1; i <= inPredicate.getInElementNum(); ++i) {\n-                    strBuilder.append(inPredicate.getChild(i).toSql());\n-                    strBuilder.append((i + 1 != inPredicate.getInElementNum()) ? \", \" : \"\");\n-                }\n-                strBuilder.append(\")\");\n-                deleteConditions.add(strBuilder.toString());\n-            }\n-        }\n-    }\n-\n-    // show delete stmt\n-    public List<List<Comparable>> getDeleteInfosByDb(long dbId, boolean forUser) {\n-        LinkedList<List<Comparable>> infos = new LinkedList<List<Comparable>>();\n-        Database db = Catalog.getCurrentCatalog().getDb(dbId);\n-        if (db == null) {\n-            return infos;\n-        }\n-\n-        String dbName = db.getFullName();\n-        List<DeleteInfo> deleteInfos = dbToDeleteInfos.get(dbId);\n-        if (deleteInfos == null) {\n-            return infos;\n-        }\n-\n-        for (DeleteInfo deleteInfo : deleteInfos) {\n-\n-            if (!Catalog.getCurrentCatalog().getAuth().checkTblPriv(ConnectContext.get(), dbName,\n-                    deleteInfo.getTableName(),\n-                    PrivPredicate.LOAD)) {\n-                continue;\n-            }\n-\n-\n-            List<Comparable> info = Lists.newArrayList();\n-            if (!forUser) {\n-                info.add(-1L);\n-                info.add(deleteInfo.getTableId());\n-            }\n-            info.add(deleteInfo.getTableName());\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionId());\n-            }\n-            info.add(deleteInfo.getPartitionName());\n-\n-            info.add(TimeUtils.longToTimeString(deleteInfo.getCreateTimeMs()));\n-            String conds = Joiner.on(\", \").join(deleteInfo.getDeleteConditions());\n-            info.add(conds);\n-\n-            if (!forUser) {\n-                info.add(deleteInfo.getPartitionVersion());\n-                info.add(deleteInfo.getPartitionVersionHash());\n-            }\n-            // for loading state, should not display loading, show deleting instead\n-//                if (loadJob.getState() == LoadJob.JobState.LOADING) {\n-//                    info.add(\"DELETING\");\n-//                } else {\n-//                    info.add(loadJob.getState().name());\n-//                }\n-            info.add(\"FINISHED\");\n-            infos.add(info);\n-        }\n-        // sort by createTimeMs\n-        int sortIndex;\n-        if (!forUser) {\n-            sortIndex = 5;\n-        } else {\n-            sortIndex = 2;\n-        }\n-        ListComparator<List<Comparable>> comparator = new ListComparator<List<Comparable>>(sortIndex);\n-        Collections.sort(infos, comparator);\n-        return infos;\n-    }\n-\n-    public void replayDelete(DeleteInfo deleteInfo, Catalog catalog) {\n-        // add to deleteInfos\n-        long dbId = deleteInfo.getDbId();\n-        LOG.info(\"replay delete, dbId {}\", dbId);\n-        dbToDeleteInfos.putIfAbsent(dbId, Lists.newArrayList());\n-        List<DeleteInfo> deleteInfoList = dbToDeleteInfos.get(dbId);\n-        synchronized (deleteInfoList) {\n-            deleteInfoList.add(deleteInfo);\n-        }\n-    }\n-\n-    // for delete handler, we only persist those delete already finished.\n-    @Override\n-    public void write(DataOutput out) throws IOException {\n-        Text.writeString(out, GsonUtils.GSON.toJson(this));\n-    }\n-\n-    public static DeleteHandler read(DataInput in) throws IOException {\n-        String json = Text.readString(in);\n-        return GsonUtils.GSON.fromJson(json, DeleteHandler.class);\n-    }\n-}\n"}}, {"oid": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "url": "https://github.com/apache/incubator-doris/commit/ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "message": "fix in predicate str error", "committedDate": "2020-07-28T06:02:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMxOTk4MQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r462319981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new AnalysisException(\"Right expr of binary predicate should be value\");\n          \n          \n            \n                                throw new AnalysisException(\"Child of in predicate should be value\");", "author": "morningman", "createdAt": "2020-07-29T13:58:45Z", "path": "fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java", "diffHunk": "@@ -119,11 +120,29 @@ private void analyzePredicate(Expr predicate) throws AnalysisException {\n             IsNullPredicate isNullPredicate = (IsNullPredicate) predicate;\n             Expr leftExpr = isNullPredicate.getChild(0);\n             if (!(leftExpr instanceof SlotRef)) {\n-                throw new AnalysisException(\"Left expr should be column name\");\n+                throw new AnalysisException(\"Left expr of is_null predicate should be column name\");\n             }\n             deleteConditions.add(isNullPredicate);\n+        } else if (predicate instanceof InPredicate) {\n+            InPredicate inPredicate = (InPredicate) predicate;\n+            Expr leftExpr = inPredicate.getChild(0);\n+            if (!(leftExpr instanceof SlotRef)) {\n+                throw new AnalysisException(\"Left expr of in predicate should be column name\");\n+            }\n+            int inElementNum = inPredicate.getInElementNum();\n+            int maxAllowedInElementNumOfDelete = Config.max_allowed_in_element_num_of_delete;\n+            if (inElementNum > maxAllowedInElementNumOfDelete) {\n+                throw new AnalysisException(\"Element num of in predicate should not be more than \" + maxAllowedInElementNumOfDelete);\n+            }\n+            for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n+                Expr expr = inPredicate.getChild(i);\n+                if (!(expr instanceof LiteralExpr)) {\n+                    throw new AnalysisException(\"Right expr of binary predicate should be value\");", "originalCommit": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28df3a3101c268c703510283fcf090df8355eb5", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java b/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java\nindex fbf320430..6d80c0766 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java\n\n@@ -137,12 +137,12 @@ public class DeleteStmt extends DdlStmt {\n             for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n                 Expr expr = inPredicate.getChild(i);\n                 if (!(expr instanceof LiteralExpr)) {\n-                    throw new AnalysisException(\"Right expr of binary predicate should be value\");\n+                    throw new AnalysisException(\"Child of in predicate should be value\");\n                 }\n             }\n             deleteConditions.add(inPredicate);\n         } else {\n-            throw new AnalysisException(\"Where clause should be compound or binary predicate or is_null predicate or in predicate\");\n+            throw new AnalysisException(\"Where clause only supports compound predicate, binary predicate, is_null predicate or in predicate\");\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyMDQwMw==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r462320403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new AnalysisException(\"Where clause should be compound or binary predicate or is_null predicate or in predicate\");\n          \n          \n            \n                        throw new AnalysisException(\"Where clause only supports compound predicate, binary predicate, is_null predicate or in predicate\");", "author": "morningman", "createdAt": "2020-07-29T13:59:22Z", "path": "fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java", "diffHunk": "@@ -119,11 +120,29 @@ private void analyzePredicate(Expr predicate) throws AnalysisException {\n             IsNullPredicate isNullPredicate = (IsNullPredicate) predicate;\n             Expr leftExpr = isNullPredicate.getChild(0);\n             if (!(leftExpr instanceof SlotRef)) {\n-                throw new AnalysisException(\"Left expr should be column name\");\n+                throw new AnalysisException(\"Left expr of is_null predicate should be column name\");\n             }\n             deleteConditions.add(isNullPredicate);\n+        } else if (predicate instanceof InPredicate) {\n+            InPredicate inPredicate = (InPredicate) predicate;\n+            Expr leftExpr = inPredicate.getChild(0);\n+            if (!(leftExpr instanceof SlotRef)) {\n+                throw new AnalysisException(\"Left expr of in predicate should be column name\");\n+            }\n+            int inElementNum = inPredicate.getInElementNum();\n+            int maxAllowedInElementNumOfDelete = Config.max_allowed_in_element_num_of_delete;\n+            if (inElementNum > maxAllowedInElementNumOfDelete) {\n+                throw new AnalysisException(\"Element num of in predicate should not be more than \" + maxAllowedInElementNumOfDelete);\n+            }\n+            for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n+                Expr expr = inPredicate.getChild(i);\n+                if (!(expr instanceof LiteralExpr)) {\n+                    throw new AnalysisException(\"Right expr of binary predicate should be value\");\n+                }\n+            }\n+            deleteConditions.add(inPredicate);\n         } else {\n-            throw new AnalysisException(\"Where clause should be compound or binary predicate\");\n+            throw new AnalysisException(\"Where clause should be compound or binary predicate or is_null predicate or in predicate\");", "originalCommit": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28df3a3101c268c703510283fcf090df8355eb5", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java b/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java\nindex fbf320430..6d80c0766 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/analysis/DeleteStmt.java\n\n@@ -137,12 +137,12 @@ public class DeleteStmt extends DdlStmt {\n             for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n                 Expr expr = inPredicate.getChild(i);\n                 if (!(expr instanceof LiteralExpr)) {\n-                    throw new AnalysisException(\"Right expr of binary predicate should be value\");\n+                    throw new AnalysisException(\"Child of in predicate should be value\");\n                 }\n             }\n             deleteConditions.add(inPredicate);\n         } else {\n-            throw new AnalysisException(\"Where clause should be compound or binary predicate or is_null predicate or in predicate\");\n+            throw new AnalysisException(\"Where clause only supports compound predicate, binary predicate, is_null predicate or in predicate\");\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyMjQ4NQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r462322485", "bodyText": "Remove unused code", "author": "morningman", "createdAt": "2020-07-29T14:02:13Z", "path": "fe/fe-core/src/main/java/org/apache/doris/load/DeleteHandler.java", "diffHunk": "@@ -507,7 +516,19 @@ private void checkDeleteV2(OlapTable table, Partition partition, List<Predicate>\n                     LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n                 } catch (AnalysisException e) {\n                     // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n-                    throw new DdlException(\"Invalid column value[\" + value + \"]\");\n+                    throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n+                }\n+            } else if (condition instanceof InPredicate) {\n+                String value = null;\n+                try {\n+                    InPredicate inPredicate = (InPredicate) condition;\n+                    for (int i = 1; i <= inPredicate.getInElementNum(); i++) {\n+                        value = ((LiteralExpr) inPredicate.getChild(i)).getStringValue();\n+                        LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n+                    }\n+                } catch (AnalysisException e) {\n+                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);", "originalCommit": "ae4c78fd2841986e5e4d52e2d3040e3cd23d0cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQyMDI4Nw==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r462420287", "bodyText": "done", "author": "caiconghui", "createdAt": "2020-07-29T16:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyMjQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28df3a3101c268c703510283fcf090df8355eb5", "chunk": "diff --git a/fe/fe-core/src/main/java/org/apache/doris/load/DeleteHandler.java b/fe/fe-core/src/main/java/org/apache/doris/load/DeleteHandler.java\nindex a70c7e579..91a8006e0 100644\n--- a/fe/fe-core/src/main/java/org/apache/doris/load/DeleteHandler.java\n+++ b/fe/fe-core/src/main/java/org/apache/doris/load/DeleteHandler.java\n\n@@ -527,7 +527,6 @@ public class DeleteHandler implements Writable {\n                         LiteralExpr.create(value, Type.fromPrimitiveType(column.getDataType()));\n                     }\n                 } catch (AnalysisException e) {\n-                    // ErrorReport.reportDdlException(ErrorCode.ERR_INVALID_VALUE, value);\n                     throw new DdlException(\"Invalid column value[\" + value + \"] for column \" + columnName);\n                 }\n             }\n"}}, {"oid": "c28df3a3101c268c703510283fcf090df8355eb5", "url": "https://github.com/apache/incubator-doris/commit/c28df3a3101c268c703510283fcf090df8355eb5", "message": "small fix", "committedDate": "2020-07-30T02:42:41Z", "type": "forcePushed"}, {"oid": "28085aed599fed7e21cc11883d98f71afbeb086d", "url": "https://github.com/apache/incubator-doris/commit/28085aed599fed7e21cc11883d98f71afbeb086d", "message": "support in predicate in delete", "committedDate": "2020-07-30T05:04:54Z", "type": "commit"}, {"oid": "2b73213d1716c0faa219d065bfa7dcecc6b5c5bb", "url": "https://github.com/apache/incubator-doris/commit/2b73213d1716c0faa219d065bfa7dcecc6b5c5bb", "message": "support in predicate in delete stmt", "committedDate": "2020-07-30T05:04:54Z", "type": "commit"}, {"oid": "e1c81a9cca14a238cd1da30ba5f26d2e017e1454", "url": "https://github.com/apache/incubator-doris/commit/e1c81a9cca14a238cd1da30ba5f26d2e017e1454", "message": "Support in and not in predicate in be delete handler", "committedDate": "2020-07-30T05:04:54Z", "type": "commit"}, {"oid": "4cfbde55339a7da01d9496b1d93da6e88a5cf02f", "url": "https://github.com/apache/incubator-doris/commit/4cfbde55339a7da01d9496b1d93da6e88a5cf02f", "message": "Support delete with in predicate", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "dd90e851340e7247ea636a5c169e9740b9c74cd9", "url": "https://github.com/apache/incubator-doris/commit/dd90e851340e7247ea636a5c169e9740b9c74cd9", "message": "remove some unused function and log", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "1d98a7f9b79648b222c17f7e7618e952d54eeeed", "url": "https://github.com/apache/incubator-doris/commit/1d98a7f9b79648b222c17f7e7618e952d54eeeed", "message": "Add max_allowed_in_element_num_of_delete variable", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "e8739b622918c099a00b995cb3f23ffb29c30b38", "url": "https://github.com/apache/incubator-doris/commit/e8739b622918c099a00b995cb3f23ffb29c30b38", "message": "Add doc content for max_allowed_in_element_num_of_delete variable", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "a7387ab5174a60a53d7dd3d8d49c25e936c5a41a", "url": "https://github.com/apache/incubator-doris/commit/a7387ab5174a60a53d7dd3d8d49c25e936c5a41a", "message": "Improve performance of in predicate", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "ad93769e2be04b28658b583540f2a117fe9ae240", "url": "https://github.com/apache/incubator-doris/commit/ad93769e2be04b28658b583540f2a117fe9ae240", "message": "Fix bug for in predicate", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "b9a1e0dff3f109430ffff7b888be3b655d895509", "url": "https://github.com/apache/incubator-doris/commit/b9a1e0dff3f109430ffff7b888be3b655d895509", "message": "support fast delete filter with in predicate", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "8773704a01c3fc6df28252df319a29f23323642e", "url": "https://github.com/apache/incubator-doris/commit/8773704a01c3fc6df28252df319a29f23323642e", "message": "fix", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "27108afdbaeb39d2b93b03bb336de3e7b763ffa3", "url": "https://github.com/apache/incubator-doris/commit/27108afdbaeb39d2b93b03bb336de3e7b763ffa3", "message": "fix deletehandler unit test", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "722737199ab4addedcada5e968f585b763c7c9bd", "url": "https://github.com/apache/incubator-doris/commit/722737199ab4addedcada5e968f585b763c7c9bd", "message": "add unit test for delete_handler", "committedDate": "2020-07-30T05:04:55Z", "type": "commit"}, {"oid": "e049558e622ed7aff9ef3d2d496ee5ac05982da8", "url": "https://github.com/apache/incubator-doris/commit/e049558e622ed7aff9ef3d2d496ee5ac05982da8", "message": "fix by review", "committedDate": "2020-07-30T05:07:54Z", "type": "commit"}, {"oid": "cafcb4170fa7e6f026219431627f2d31b223ddda", "url": "https://github.com/apache/incubator-doris/commit/cafcb4170fa7e6f026219431627f2d31b223ddda", "message": "remove unused content from docs", "committedDate": "2020-07-30T05:07:54Z", "type": "commit"}, {"oid": "1e7e2a9a167233628750f9e55ecd8fba35c2ff62", "url": "https://github.com/apache/incubator-doris/commit/1e7e2a9a167233628750f9e55ecd8fba35c2ff62", "message": "fix in predicate str error", "committedDate": "2020-07-30T05:07:54Z", "type": "commit"}, {"oid": "4d1c423d5d7872213c3bfe8cf19b8537a67fda85", "url": "https://github.com/apache/incubator-doris/commit/4d1c423d5d7872213c3bfe8cf19b8537a67fda85", "message": "fix by review", "committedDate": "2020-07-30T05:07:54Z", "type": "commit"}, {"oid": "ad3dc45050ba362f0fe971d66ae6312d55ac49ec", "url": "https://github.com/apache/incubator-doris/commit/ad3dc45050ba362f0fe971d66ae6312d55ac49ec", "message": "Add doc content about delete", "committedDate": "2020-07-30T05:07:54Z", "type": "commit"}, {"oid": "7fc8ae429810ced14cc6c084b912749681d5d340", "url": "https://github.com/apache/incubator-doris/commit/7fc8ae429810ced14cc6c084b912749681d5d340", "message": "small fix", "committedDate": "2020-07-30T05:07:54Z", "type": "commit"}, {"oid": "7fc8ae429810ced14cc6c084b912749681d5d340", "url": "https://github.com/apache/incubator-doris/commit/7fc8ae429810ced14cc6c084b912749681d5d340", "message": "small fix", "committedDate": "2020-07-30T05:07:54Z", "type": "forcePushed"}, {"oid": "2777547694b5cfb78149aaf96ed4660ca3eb0bea", "url": "https://github.com/apache/incubator-doris/commit/2777547694b5cfb78149aaf96ed4660ca3eb0bea", "message": "fix unit test failed", "committedDate": "2020-08-01T10:49:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2MDAzMQ==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r463960031", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @ConfField(mutable = true, masterOnly = true)\n          \n          \n            \n                @ConfField(mutable = true)\n          \n      \n    \n    \n  \n\nThis is not a \"master only\" config.", "author": "morningman", "createdAt": "2020-08-01T13:00:28Z", "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -1192,4 +1191,11 @@\n      */\n     @ConfField(mutable = true, masterOnly = false)\n     public static int cache_result_max_row_count = 3000;\n+    \n+    /**\n+     * Used to limit element num of InPredicate in delete statement.\n+     */\n+    @ConfField(mutable = true, masterOnly = true)", "originalCommit": "7fc8ae429810ced14cc6c084b912749681d5d340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2OTQ1NA==", "url": "https://github.com/apache/incubator-doris/pull/4006#discussion_r463969454", "bodyText": "delete operation need a txn which only master can execute ?", "author": "caiconghui", "createdAt": "2020-08-01T14:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2MDAzMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "1858a94b0fcbe72748109f5e09134cde21655e5d", "url": "https://github.com/apache/incubator-doris/commit/1858a94b0fcbe72748109f5e09134cde21655e5d", "message": "Change all required to optional for InPredicatePB", "committedDate": "2020-08-03T07:20:20Z", "type": "commit"}, {"oid": "d090f678c34b49bdee76a6c62110139dc2796468", "url": "https://github.com/apache/incubator-doris/commit/d090f678c34b49bdee76a6c62110139dc2796468", "message": "fix be ut failed", "committedDate": "2020-08-03T11:18:52Z", "type": "commit"}]}