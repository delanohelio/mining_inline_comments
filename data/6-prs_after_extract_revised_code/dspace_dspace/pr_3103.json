{"pr_number": 3103, "pr_title": "Enable Customized CSRF Protection in Spring Security for Server Webapp", "pr_createdAt": "2020-12-22T22:53:49Z", "pr_url": "https://github.com/DSpace/DSpace/pull/3103", "timeline": [{"oid": "de58a6ca0367f2992c30d7237c338336c624c235", "url": "https://github.com/DSpace/DSpace/commit/de58a6ca0367f2992c30d7237c338336c624c235", "message": "Reenable CSRF projection with recommended Angular settings", "committedDate": "2021-01-06T16:24:10Z", "type": "commit"}, {"oid": "55c47194f4ae411852397efe66b0b6edb4910902", "url": "https://github.com/DSpace/DSpace/commit/55c47194f4ae411852397efe66b0b6edb4910902", "message": "Cleanup WebSecurityConfiguration via reorg, adding comments & removing duplicative or unneeded default configs.", "committedDate": "2021-01-06T16:24:10Z", "type": "commit"}, {"oid": "b6bf9a2fb35456c4f8f11d85bddde33feb0059ab", "url": "https://github.com/DSpace/DSpace/commit/b6bf9a2fb35456c4f8f11d85bddde33feb0059ab", "message": "Add in missing Builders to enable automated cleanup for these builders", "committedDate": "2021-01-06T16:24:10Z", "type": "commit"}, {"oid": "901cf6e285339425f554d40e1e11469498bb4058", "url": "https://github.com/DSpace/DSpace/commit/901cf6e285339425f554d40e1e11469498bb4058", "message": "Fix possible XSS issue in Hal Browser. See https://github.com/mikekelly/hal-browser/pull/97", "committedDate": "2021-01-06T16:24:11Z", "type": "commit"}, {"oid": "d15e603d43f6fb0901d5e0a645ed9992c6fa9e89", "url": "https://github.com/DSpace/DSpace/commit/d15e603d43f6fb0901d5e0a645ed9992c6fa9e89", "message": "Add (custom) CSRF support to HAL Browser", "committedDate": "2021-01-06T16:24:11Z", "type": "commit"}, {"oid": "f6c095f29651afeae152155d8621149bcd4e7802", "url": "https://github.com/DSpace/DSpace/commit/f6c095f29651afeae152155d8621149bcd4e7802", "message": "Add comments to dspace.cfg describing Spring Boot proxy settings which may be applicable to sites using a proxy. I found this useful when testing SameSite cookies behind a HTTPS proxy.", "committedDate": "2021-01-06T16:24:11Z", "type": "commit"}, {"oid": "30451676abd0151fa850314762f66beaf0530cfb", "url": "https://github.com/DSpace/DSpace/commit/30451676abd0151fa850314762f66beaf0530cfb", "message": "Ensure allowed origins never end in a slash. Otherwise, you can get CORS errors even if the URL is correct.", "committedDate": "2021-01-06T16:24:12Z", "type": "commit"}, {"oid": "d084358e70779748c02ad350da3ce9ac5d4dece4", "url": "https://github.com/DSpace/DSpace/commit/d084358e70779748c02ad350da3ce9ac5d4dece4", "message": "Customize CsrfTokenRepository and CsrfAuthenticationStrategy to support cross domain CSRF protection.", "committedDate": "2021-01-06T16:24:13Z", "type": "commit"}, {"oid": "126775c665f017aed6b5db0e0953b61c309de16a", "url": "https://github.com/DSpace/DSpace/commit/126775c665f017aed6b5db0e0953b61c309de16a", "message": "Update dspace-shibboleth docker settings to no longer overwrite Access-Control-Expose-Headers. Instead we'll use the ones from Tomcat.", "committedDate": "2021-01-06T16:24:13Z", "type": "commit"}, {"oid": "acaa1dbc64e390a3188ac3a4cbe36e6a9711492a", "url": "https://github.com/DSpace/DSpace/commit/acaa1dbc64e390a3188ac3a4cbe36e6a9711492a", "message": "Require POST for logout. Update CSRFTokenRepository to no longer allow server token to be read by Javascript", "committedDate": "2021-01-06T16:24:14Z", "type": "commit"}, {"oid": "b35a3f71be51356b72076baeafb194dfa0ac14cc", "url": "https://github.com/DSpace/DSpace/commit/b35a3f71be51356b72076baeafb194dfa0ac14cc", "message": "Update HAL browser to use DSPACE-XSRF-TOKEN header and store token in custom MyHalBrowserCsrfToken Cookie. Minor comment fixes to TokenRepo", "committedDate": "2021-01-06T16:24:14Z", "type": "commit"}, {"oid": "b35a3f71be51356b72076baeafb194dfa0ac14cc", "url": "https://github.com/DSpace/DSpace/commit/b35a3f71be51356b72076baeafb194dfa0ac14cc", "message": "Update HAL browser to use DSPACE-XSRF-TOKEN header and store token in custom MyHalBrowserCsrfToken Cookie. Minor comment fixes to TokenRepo", "committedDate": "2021-01-06T16:24:14Z", "type": "forcePushed"}, {"oid": "6747bbea92b5abc1758f122f2e3e721c2a1634f9", "url": "https://github.com/DSpace/DSpace/commit/6747bbea92b5abc1758f122f2e3e721c2a1634f9", "message": "Bug Fix: CSRF token should be reset after InvalidCsrfTokenException to allow for resyncing between client & server", "committedDate": "2021-01-08T21:56:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEyMDQxNA==", "url": "https://github.com/DSpace/DSpace/pull/3103#discussion_r566120414", "bodyText": "just a minor thing but I would be happier if we found a way to resolve it at runtime or inject it. We should have a way to get the ExceptionHandlerResolver from spring and pass to it the exception", "author": "abollini", "createdAt": "2021-01-28T14:07:59Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/DSpaceAccessDeniedHandler.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.exception;\n+\n+import java.io.IOException;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.dspace.app.rest.security.WebSecurityConfiguration;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.web.access.AccessDeniedHandler;\n+import org.springframework.security.web.csrf.CsrfToken;\n+import org.springframework.security.web.csrf.CsrfTokenRepository;\n+import org.springframework.security.web.csrf.InvalidCsrfTokenException;\n+import org.springframework.security.web.csrf.MissingCsrfTokenException;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * This Handler customizes behavior of AccessDeniedException errors thrown by Spring Security/Boot.\n+ * <P>\n+ * More specifically, we use this Handler to ensure exceptions related to CSRF Tokens are also sent to our\n+ * DSpaceApiExceptionControllerAdvice class, which manages all exceptions for the DSpace backend. Without this\n+ * handler, those CSRF exceptions are managed by Spring Security/Boot *before* DSpaceApiExceptionControllerAdvice\n+ * is triggered.\n+ * <P>\n+ * Additionally, this Handler is customized to refresh the CSRF Token whenever an InvalidCsrfTokenException occurs.\n+ * This helps ensure our DSpace server-side token (stored in a server-side cookie) remains \"synced\" with the token\n+ * on the client side. If they ever get out of sync, the next request will throw an InvalidCsrfTokenException.\n+ *\n+ * @see DSpaceApiExceptionControllerAdvice\n+ */\n+@Component\n+public class DSpaceAccessDeniedHandler implements AccessDeniedHandler {\n+\n+    @Autowired\n+    private WebSecurityConfiguration webSecurityConfiguration;\n+\n+    /**\n+     * Override handle() to pass these exceptions over to our DSpaceApiExceptionControllerAdvice handler\n+     * @param request request\n+     * @param response response\n+     * @param ex AccessDeniedException\n+     * @throws IOException\n+     * @throws ServletException\n+     */\n+    @Override\n+    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException ex)\n+        throws IOException, ServletException {\n+\n+        // Do nothing if response is already committed\n+        if (response.isCommitted()) {\n+            return;\n+        }\n+\n+        // If we had an InvalidCsrfTokenException, this means the client sent a CSRF token which did *not* match the\n+        // token on the server. In this scenario, we trigger a refresh of the CSRF token...as it's possible the user\n+        // switched clients (from HAL Browser to UI or visa versa) and has an out-of-sync token.\n+        if (ex instanceof InvalidCsrfTokenException) {\n+            // Get access to our enabled CSRF token repository\n+            CsrfTokenRepository csrfTokenRepository = webSecurityConfiguration.getCsrfTokenRepository();\n+\n+            // Remove current token & generate a new one\n+            csrfTokenRepository.saveToken(null, request, response);\n+            CsrfToken newToken = csrfTokenRepository.generateToken(request);\n+            csrfTokenRepository.saveToken(newToken, request, response);\n+        }\n+\n+        // Get access to our general exception handler\n+        DSpaceApiExceptionControllerAdvice handler = new DSpaceApiExceptionControllerAdvice();", "originalCommit": "6747bbea92b5abc1758f122f2e3e721c2a1634f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQwOTE3Mw==", "url": "https://github.com/DSpace/DSpace/pull/3103#discussion_r566409173", "bodyText": "@abollini : I'm not sure this is very easy.  Spring Security is what manages AccessDeniedExceptions, and it catches them & responds before anything gets to Spring MVC.  I've yet to figure out a way to do this at runtime simply because the exception is handled so early in the request.\nSo, your question is similar to the one answered here: https://stackoverflow.com/questions/41140669/handle-security-exceptions-in-spring-boot-resource-server  (and the first response is that you cannot manage this sort of exception in the MVC layer).\nIf you see another option here, I'm willing to try something else.  I just couldn't figure out an easy way around this. The only other option I thought of is to remove the calls to DSpaceApiExceptionControllerAdvice entirely & move the two methods used into DSpaceAccessDeniedHandler (but then we'd have some exceptions handled in DSpaceApiExceptionControllerAdvice and others in DSpaceAccessDeniedHandler, which I thought might be confusing)", "author": "tdonohue", "createdAt": "2021-01-28T21:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEyMDQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjkyNjQ4NA==", "url": "https://github.com/DSpace/DSpace/pull/3103#discussion_r566926484", "bodyText": "@abollini : Please disregard my previous response. Turns out, there is a way to do this more dynamically.  I stumbled on an idea here that led me down the right path...and it seems to be exactly what you were implying.  So, see the latest commit: 70253bc  (includes a small test to ensure our custom error message is coming back -- I also tested it manually and it works)", "author": "tdonohue", "createdAt": "2021-01-29T16:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEyMDQxNA=="}], "type": "inlineReview", "revised_code": {"commit": "70253bc1bf16ce6b612e5bbf3cc876407e05636a", "chunk": "diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/DSpaceAccessDeniedHandler.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/DSpaceAccessDeniedHandler.java\nindex 677737a6e..9e20eca4c 100644\n--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/DSpaceAccessDeniedHandler.java\n+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/DSpaceAccessDeniedHandler.java\n\n@@ -14,13 +14,14 @@ import javax.servlet.http.HttpServletResponse;\n \n import org.dspace.app.rest.security.WebSecurityConfiguration;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.security.access.AccessDeniedException;\n import org.springframework.security.web.access.AccessDeniedHandler;\n import org.springframework.security.web.csrf.CsrfToken;\n import org.springframework.security.web.csrf.CsrfTokenRepository;\n import org.springframework.security.web.csrf.InvalidCsrfTokenException;\n-import org.springframework.security.web.csrf.MissingCsrfTokenException;\n import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerExceptionResolver;\n \n /**\n  * This Handler customizes behavior of AccessDeniedException errors thrown by Spring Security/Boot.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEyODE5Ng==", "url": "https://github.com/DSpace/DSpace/pull/3103#discussion_r566128196", "bodyText": "I don't see any real flow in the proposed solution but if we need to identify one area where we could have hidden problem it is probable the use of a cookie for the csrf check. I'm not sure if having such cookie in place could for instance lead to false positive report by security tool. I'm just curious to know if you have investigated the use of a CSRF JWT based repository see for instance\nhttps://stormpath.com/blog/csrf-protection-jwt-spring-security\nspring-projects/spring-security#5300", "author": "abollini", "createdAt": "2021-01-28T14:18:21Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/DSpaceCsrfAuthenticationStrategy.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.security;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.web.authentication.session.SessionAuthenticationException;\n+import org.springframework.security.web.authentication.session.SessionAuthenticationStrategy;\n+import org.springframework.security.web.csrf.CsrfToken;\n+import org.springframework.security.web.csrf.CsrfTokenRepository;\n+import org.springframework.util.Assert;\n+import org.springframework.util.StringUtils;\n+\n+/**\n+ * Custom SessionAuthenticationStrategy to be used alongside DSpaceCsrfTokenRepository.\n+ * <P>\n+ * Because DSpace is Stateless, this class only resets the CSRF Token if the client has attempted to use it (either\n+ * successfully or unsuccessfully). This ensures that the Token is not changed on every request (since we are stateless\n+ * every request creates a new Authentication object).\n+ * <P>\n+ * Based on Spring Security's CsrfAuthenticationStrategy:\n+ * https://github.com/spring-projects/spring-security/blob/5.2.x/web/src/main/java/org/springframework/security/web/csrf/CsrfAuthenticationStrategy.java\n+ */\n+public class DSpaceCsrfAuthenticationStrategy implements SessionAuthenticationStrategy {", "originalCommit": "6747bbea92b5abc1758f122f2e3e721c2a1634f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjIzNjE2MA==", "url": "https://github.com/DSpace/DSpace/pull/3103#discussion_r566236160", "bodyText": "@abollini : Just to clarify, yes, I had reviewed both those approaches previously, and found they didn't quite work as expected in a Stateless app where the client might be on a different domain than the server (i.e. cross domain requests).\nTo try to explain it simply:\n\nI could have used a JWT for the CSRF token, but it's not recommended to use the Auth token as the CSRF token, so we'd need to generate a separate JWT (plus, unauthenticated users are given a CSRF Token to validate their login, whereas they don't get a JWT until after authenticating).  Rather than doing something much more custom, I went with the approach suggested by OWASP of \"Check if your framework has built-in CSRF protection & use it\".  So, in this PR, I'm letting Spring Security generate the CSRF token for us (it does so by generating a random UUID)\nWhile in this PR, the CSRF token does get stored in a Cookie, this is also the default behavior of Spring Security's CSRF Protection.\n\nBy default, Spring Security sends the CSRF token in a Cookie (named XSRF-TOKEN) to the client, and expects the token to be sent back both in the XSRF-TOKEN cookie and in a X-XSRF-TOKEN Http Header. So, by default, Spring security verifies the Cookie & Header match.  This is stateless, but it doesn't work cross-domain as the client won't be able to read the XSRF-TOKEN cookie in order to send it back in a header.\nMy approach is similarly stateless, but gets around the cross-domain issue by sending the CSRF token to the client both in a cookie (DSPACE-XSRF-COOKIE) and in an Http Header (DSPACE-XSRF-TOKEN).  This ensures that a client on a different domain can read the token from the Http Header and send it back in a different Http Header (X-XSRF-TOKEN).  Then, Spring Security can still do the same validation -- comparing the value in the cookie (in this case DSPACE-XSRF-COOKIE) to that in the X-XSRF-TOKEN header.", "author": "tdonohue", "createdAt": "2021-01-28T16:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEyODE5Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "70253bc1bf16ce6b612e5bbf3cc876407e05636a", "url": "https://github.com/DSpace/DSpace/commit/70253bc1bf16ce6b612e5bbf3cc876407e05636a", "message": "Resolve feedback - Ensure DSpaceAccessDeniedHandler passes exception response handling to DSpaceApiExceptionControllerAdvice dynamically.", "committedDate": "2021-01-29T16:02:21Z", "type": "commit"}]}