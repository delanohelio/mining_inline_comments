{"pr_number": 2980, "pr_title": "chore: added comment on try/catch block", "pr_createdAt": "2020-05-27T19:11:53Z", "pr_url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2980", "timeline": [{"oid": "34479ac70a53304ca30792f2d9b139e772dfd10b", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/34479ac70a53304ca30792f2d9b139e772dfd10b", "message": "chore: added comment on try/catch block", "committedDate": "2020-05-27T19:09:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5ODQ2Mg==", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2980#discussion_r431398462", "bodyText": "Ok, but this is no longer the standard we use.", "author": "lesv", "createdAt": "2020-05-27T19:40:10Z", "path": "vision/cloud-client/src/main/java/com/example/vision/Detect.java", "diffHunk": "@@ -95,19 +95,19 @@ public static void main(String[] args) throws Exception, IOException {\n   public static void argsHelper(String[] args, PrintStream out) throws Exception, IOException {\n     if (args.length < 1) {\n       out.println(\"Usage:\");\n-      out.printf(\n-          \"\\tmvn exec:java -DDetect -Dexec.args=\\\"<command> <path-to-image>\\\"\\n\"\n+      out.format(\n+          \"\\tmvn exec:java -DDetect -Dexec.args=\\\"<command> <path-to-image>\\\"%n\"\n               + \"\\tmvn exec:java -DDetect -Dexec.args=\\\"ocr <path-to-file> <path-to-destination>\\\"\"\n-              + \"\\n\"\n-              + \"Commands:\\n\"\n+              + \"%n\"\n+              + \"Commands:%n\"\n               + \"\\tfaces | labels | landmarks | logos | text | safe-search | properties\"\n-              + \"| web | web-entities | web-entities-include-geo | crop | ocr \\n\"\n-              + \"| object-localization \\n\"\n-              + \"Path:\\n\\tA file path (ex: ./resources/wakeupcat.jpg) or a URI for a Cloud Storage \"\n-              + \"resource (gs://...)\\n\"\n-              + \"Path to File:\\n\\tA path to the remote file on Cloud Storage (gs://...)\\n\"\n-              + \"Path to Destination\\n\\tA path to the remote destination on Cloud Storage for the\"\n-              + \" file to be saved. (gs://BUCKET_NAME/PREFIX/)\\n\");\n+              + \"| web | web-entities | web-entities-include-geo | crop | ocr %n\"\n+              + \"| object-localization %n\"\n+              + \"Path:%n\\tA file path (ex: ./resources/wakeupcat.jpg) or a URI for a Cloud Storage \"\n+              + \"resource (gs://...)%n\"\n+              + \"Path to File:%n\\tA path to the remote file on Cloud Storage (gs://...)%n\"\n+              + \"Path to Destination%n\\tA path to the remote destination on Cloud Storage for the\"\n+              + \" file to be saved. (gs://BUCKET_NAME/PREFIX/)%n\");", "originalCommit": "34479ac70a53304ca30792f2d9b139e772dfd10b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de46cb13e23499b6c8d6038c4285fde62a19fd2f", "chunk": "diff --git a/vision/cloud-client/src/main/java/com/example/vision/Detect.java b/vision/cloud-client/src/main/java/com/example/vision/Detect.java\nindex 7b9308b52..f1da41642 100644\n--- a/vision/cloud-client/src/main/java/com/example/vision/Detect.java\n+++ b/vision/cloud-client/src/main/java/com/example/vision/Detect.java\n\n@@ -76,319 +74,15 @@ import java.util.regex.Pattern;\n \n public class Detect {\n \n-  /**\n-   * Detects entities, sentiment, and syntax in a document using the Vision API.\n-   *\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  public static void main(String[] args) throws Exception, IOException {\n-    argsHelper(args, System.out);\n-  }\n-\n-  /**\n-   * Helper that handles the input passed to the program.\n-   *\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  public static void argsHelper(String[] args, PrintStream out) throws Exception, IOException {\n-    if (args.length < 1) {\n-      out.println(\"Usage:\");\n-      out.format(\n-          \"\\tmvn exec:java -DDetect -Dexec.args=\\\"<command> <path-to-image>\\\"%n\"\n-              + \"\\tmvn exec:java -DDetect -Dexec.args=\\\"ocr <path-to-file> <path-to-destination>\\\"\"\n-              + \"%n\"\n-              + \"Commands:%n\"\n-              + \"\\tfaces | labels | landmarks | logos | text | safe-search | properties\"\n-              + \"| web | web-entities | web-entities-include-geo | crop | ocr %n\"\n-              + \"| object-localization %n\"\n-              + \"Path:%n\\tA file path (ex: ./resources/wakeupcat.jpg) or a URI for a Cloud Storage \"\n-              + \"resource (gs://...)%n\"\n-              + \"Path to File:%n\\tA path to the remote file on Cloud Storage (gs://...)%n\"\n-              + \"Path to Destination%n\\tA path to the remote destination on Cloud Storage for the\"\n-              + \" file to be saved. (gs://BUCKET_NAME/PREFIX/)%n\");\n-      return;\n-    }\n-    String command = args[0];\n-    String path = args.length > 1 ? args[1] : \"\";\n-\n-    if (command.equals(\"faces\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectFacesGcs(path, out);\n-      } else {\n-        detectFaces(path, out);\n-      }\n-    } else if (command.equals(\"labels\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectLabelsGcs(path, out);\n-      } else {\n-        detectLabels(path, out);\n-      }\n-    } else if (command.equals(\"landmarks\")) {\n-      if (path.startsWith(\"http\")) {\n-        detectLandmarksUrl(path, out);\n-      } else if (path.startsWith(\"gs://\")) {\n-        detectLandmarksGcs(path, out);\n-      } else {\n-        detectLandmarks(path, out);\n-      }\n-    } else if (command.equals(\"logos\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectLogosGcs(path, out);\n-      } else {\n-        detectLogos(path, out);\n-      }\n-    } else if (command.equals(\"text\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectTextGcs(path, out);\n-      } else {\n-        detectText(path, out);\n-      }\n-    } else if (command.equals(\"properties\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectPropertiesGcs(path, out);\n-      } else {\n-        detectProperties(path, out);\n-      }\n-    } else if (command.equals(\"safe-search\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectSafeSearchGcs(path, out);\n-      } else {\n-        detectSafeSearch(path, out);\n-      }\n-    } else if (command.equals(\"web\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectWebDetectionsGcs(path, out);\n-      } else {\n-        detectWebDetections(path, out);\n-      }\n-    } else if (command.equals(\"web-entities\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectWebEntitiesGcs(path, out);\n-      } else {\n-        detectWebEntities(path, out);\n-      }\n-    } else if (command.equals(\"web-entities-include-geo\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectWebEntitiesIncludeGeoResultsGcs(path, out);\n-      } else {\n-        detectWebEntitiesIncludeGeoResults(path, out);\n-      }\n-    } else if (command.equals(\"crop\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectCropHintsGcs(path, out);\n-      } else {\n-        detectCropHints(path, out);\n-      }\n-    } else if (command.equals(\"fulltext\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectDocumentTextGcs(path, out);\n-      } else {\n-        detectDocumentText(path, out);\n-      }\n-    } else if (command.equals(\"ocr\")) {\n-      String destPath = args.length > 2 ? args[2] : \"\";\n-      detectDocumentsGcs(path, destPath);\n-    } else if (command.equals(\"object-localization\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectLocalizedObjectsGcs(path, out);\n-      } else {\n-        detectLocalizedObjects(path, out);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Detects faces in the specified local image.\n-   *\n-   * @param filePath The path to the file to perform face detection on.\n-   * @param out A {@link PrintStream} to write detected features to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_face_detection]\n-  public static void detectFaces(String filePath, PrintStream out) throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ByteString imgBytes = ByteString.readFrom(new FileInputStream(filePath));\n-\n-    Image img = Image.newBuilder().setContent(imgBytes).build();\n-    Feature feat = Feature.newBuilder().setType(Type.FACE_DETECTION).build();\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (FaceAnnotation annotation : res.getFaceAnnotationsList()) {\n-          out.format(\n-              \"anger: %s%njoy: %s%nsurprise: %s%nposition: %s\",\n-              annotation.getAngerLikelihood(),\n-              annotation.getJoyLikelihood(),\n-              annotation.getSurpriseLikelihood(),\n-              annotation.getBoundingPoly());\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_face_detection]\n-\n-  /**\n-   * Detects faces in the specified remote image on Google Cloud Storage.\n-   *\n-   * @param gcsPath The path to the remote file on Google Cloud Storage to perform face detection\n-   *     on.\n-   * @param out A {@link PrintStream} to write detected features to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_face_detection_gcs]\n-  public static void detectFacesGcs(String gcsPath, PrintStream out) throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ImageSource imgSource = ImageSource.newBuilder().setGcsImageUri(gcsPath).build();\n-    Image img = Image.newBuilder().setSource(imgSource).build();\n-    Feature feat = Feature.newBuilder().setType(Type.FACE_DETECTION).build();\n-\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (FaceAnnotation annotation : res.getFaceAnnotationsList()) {\n-          out.format(\n-              \"anger: %s%njoy: %s%nsurprise: %s%nposition: %s\",\n-              annotation.getAngerLikelihood(),\n-              annotation.getJoyLikelihood(),\n-              annotation.getSurpriseLikelihood(),\n-              annotation.getBoundingPoly());\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_face_detection_gcs]\n-\n-  /**\n-   * Detects labels in the specified local image.\n-   *\n-   * @param filePath The path to the file to perform label detection on.\n-   * @param out A {@link PrintStream} to write detected labels to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_label_detection]\n-  public static void detectLabels(String filePath, PrintStream out) throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ByteString imgBytes = ByteString.readFrom(new FileInputStream(filePath));\n-\n-    Image img = Image.newBuilder().setContent(imgBytes).build();\n-    Feature feat = Feature.newBuilder().setType(Type.LABEL_DETECTION).build();\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (EntityAnnotation annotation : res.getLabelAnnotationsList()) {\n-          annotation.getAllFields().forEach((k, v) -> out.format(\"%s : %s%n\", k, v.toString()));\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_label_detection]\n-\n-  /**\n-   * Detects labels in the specified remote image on Google Cloud Storage.\n-   *\n-   * @param gcsPath The path to the remote file on Google Cloud Storage to perform label detection\n-   *     on.\n-   * @param out A {@link PrintStream} to write detected features to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_label_detection_gcs]\n-  public static void detectLabelsGcs(String gcsPath, PrintStream out)\n-      throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ImageSource imgSource = ImageSource.newBuilder().setGcsImageUri(gcsPath).build();\n-    Image img = Image.newBuilder().setSource(imgSource).build();\n-    Feature feat = Feature.newBuilder().setType(Type.LABEL_DETECTION).build();\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (EntityAnnotation annotation : res.getLabelAnnotationsList()) {\n-          annotation.getAllFields().forEach((k, v) -> out.format(\"%s : %s%n\", k, v.toString()));\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_label_detection_gcs]\n-\n   /**\n    * Detects landmarks in the specified local image.\n    *\n    * @param filePath The path to the file to perform landmark detection on.\n-   * @param out A {@link PrintStream} to write detected landmarks to.\n    * @throws Exception on errors while closing the client.\n    * @throws IOException on Input/Output errors.\n    */\n   // [START vision_landmark_detection]\n-  public static void detectLandmarks(String filePath, PrintStream out)\n+  public static void detectLandmarks(String filePath)\n       throws Exception, IOException {\n     List<AnnotateImageRequest> requests = new ArrayList<>();\n     ByteString imgBytes = ByteString.readFrom(new FileInputStream(filePath));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5OTI5NA==", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2980#discussion_r431399294", "bodyText": "Why isn't this just a bunch of out.println(...);  ??", "author": "lesv", "createdAt": "2020-05-27T19:41:55Z", "path": "vision/cloud-client/src/main/java/com/example/vision/Detect.java", "diffHunk": "@@ -95,19 +95,19 @@ public static void main(String[] args) throws Exception, IOException {\n   public static void argsHelper(String[] args, PrintStream out) throws Exception, IOException {\n     if (args.length < 1) {\n       out.println(\"Usage:\");\n-      out.printf(\n-          \"\\tmvn exec:java -DDetect -Dexec.args=\\\"<command> <path-to-image>\\\"\\n\"\n+      out.format(\n+          \"\\tmvn exec:java -DDetect -Dexec.args=\\\"<command> <path-to-image>\\\"%n\"\n               + \"\\tmvn exec:java -DDetect -Dexec.args=\\\"ocr <path-to-file> <path-to-destination>\\\"\"\n-              + \"\\n\"\n-              + \"Commands:\\n\"\n+              + \"%n\"\n+              + \"Commands:%n\"\n               + \"\\tfaces | labels | landmarks | logos | text | safe-search | properties\"\n-              + \"| web | web-entities | web-entities-include-geo | crop | ocr \\n\"\n-              + \"| object-localization \\n\"\n-              + \"Path:\\n\\tA file path (ex: ./resources/wakeupcat.jpg) or a URI for a Cloud Storage \"\n-              + \"resource (gs://...)\\n\"\n-              + \"Path to File:\\n\\tA path to the remote file on Cloud Storage (gs://...)\\n\"\n-              + \"Path to Destination\\n\\tA path to the remote destination on Cloud Storage for the\"\n-              + \" file to be saved. (gs://BUCKET_NAME/PREFIX/)\\n\");\n+              + \"| web | web-entities | web-entities-include-geo | crop | ocr %n\"\n+              + \"| object-localization %n\"\n+              + \"Path:%n\\tA file path (ex: ./resources/wakeupcat.jpg) or a URI for a Cloud Storage \"\n+              + \"resource (gs://...)%n\"\n+              + \"Path to File:%n\\tA path to the remote file on Cloud Storage (gs://...)%n\"\n+              + \"Path to Destination%n\\tA path to the remote destination on Cloud Storage for the\"\n+              + \" file to be saved. (gs://BUCKET_NAME/PREFIX/)%n\");", "originalCommit": "34479ac70a53304ca30792f2d9b139e772dfd10b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwOTQwNw==", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/pull/2980#discussion_r431509407", "bodyText": "I will just remove this argsHelper method", "author": "munkhuushmgl", "createdAt": "2020-05-28T00:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5OTI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "de46cb13e23499b6c8d6038c4285fde62a19fd2f", "chunk": "diff --git a/vision/cloud-client/src/main/java/com/example/vision/Detect.java b/vision/cloud-client/src/main/java/com/example/vision/Detect.java\nindex 7b9308b52..f1da41642 100644\n--- a/vision/cloud-client/src/main/java/com/example/vision/Detect.java\n+++ b/vision/cloud-client/src/main/java/com/example/vision/Detect.java\n\n@@ -76,319 +74,15 @@ import java.util.regex.Pattern;\n \n public class Detect {\n \n-  /**\n-   * Detects entities, sentiment, and syntax in a document using the Vision API.\n-   *\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  public static void main(String[] args) throws Exception, IOException {\n-    argsHelper(args, System.out);\n-  }\n-\n-  /**\n-   * Helper that handles the input passed to the program.\n-   *\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  public static void argsHelper(String[] args, PrintStream out) throws Exception, IOException {\n-    if (args.length < 1) {\n-      out.println(\"Usage:\");\n-      out.format(\n-          \"\\tmvn exec:java -DDetect -Dexec.args=\\\"<command> <path-to-image>\\\"%n\"\n-              + \"\\tmvn exec:java -DDetect -Dexec.args=\\\"ocr <path-to-file> <path-to-destination>\\\"\"\n-              + \"%n\"\n-              + \"Commands:%n\"\n-              + \"\\tfaces | labels | landmarks | logos | text | safe-search | properties\"\n-              + \"| web | web-entities | web-entities-include-geo | crop | ocr %n\"\n-              + \"| object-localization %n\"\n-              + \"Path:%n\\tA file path (ex: ./resources/wakeupcat.jpg) or a URI for a Cloud Storage \"\n-              + \"resource (gs://...)%n\"\n-              + \"Path to File:%n\\tA path to the remote file on Cloud Storage (gs://...)%n\"\n-              + \"Path to Destination%n\\tA path to the remote destination on Cloud Storage for the\"\n-              + \" file to be saved. (gs://BUCKET_NAME/PREFIX/)%n\");\n-      return;\n-    }\n-    String command = args[0];\n-    String path = args.length > 1 ? args[1] : \"\";\n-\n-    if (command.equals(\"faces\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectFacesGcs(path, out);\n-      } else {\n-        detectFaces(path, out);\n-      }\n-    } else if (command.equals(\"labels\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectLabelsGcs(path, out);\n-      } else {\n-        detectLabels(path, out);\n-      }\n-    } else if (command.equals(\"landmarks\")) {\n-      if (path.startsWith(\"http\")) {\n-        detectLandmarksUrl(path, out);\n-      } else if (path.startsWith(\"gs://\")) {\n-        detectLandmarksGcs(path, out);\n-      } else {\n-        detectLandmarks(path, out);\n-      }\n-    } else if (command.equals(\"logos\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectLogosGcs(path, out);\n-      } else {\n-        detectLogos(path, out);\n-      }\n-    } else if (command.equals(\"text\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectTextGcs(path, out);\n-      } else {\n-        detectText(path, out);\n-      }\n-    } else if (command.equals(\"properties\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectPropertiesGcs(path, out);\n-      } else {\n-        detectProperties(path, out);\n-      }\n-    } else if (command.equals(\"safe-search\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectSafeSearchGcs(path, out);\n-      } else {\n-        detectSafeSearch(path, out);\n-      }\n-    } else if (command.equals(\"web\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectWebDetectionsGcs(path, out);\n-      } else {\n-        detectWebDetections(path, out);\n-      }\n-    } else if (command.equals(\"web-entities\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectWebEntitiesGcs(path, out);\n-      } else {\n-        detectWebEntities(path, out);\n-      }\n-    } else if (command.equals(\"web-entities-include-geo\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectWebEntitiesIncludeGeoResultsGcs(path, out);\n-      } else {\n-        detectWebEntitiesIncludeGeoResults(path, out);\n-      }\n-    } else if (command.equals(\"crop\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectCropHintsGcs(path, out);\n-      } else {\n-        detectCropHints(path, out);\n-      }\n-    } else if (command.equals(\"fulltext\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectDocumentTextGcs(path, out);\n-      } else {\n-        detectDocumentText(path, out);\n-      }\n-    } else if (command.equals(\"ocr\")) {\n-      String destPath = args.length > 2 ? args[2] : \"\";\n-      detectDocumentsGcs(path, destPath);\n-    } else if (command.equals(\"object-localization\")) {\n-      if (path.startsWith(\"gs://\")) {\n-        detectLocalizedObjectsGcs(path, out);\n-      } else {\n-        detectLocalizedObjects(path, out);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Detects faces in the specified local image.\n-   *\n-   * @param filePath The path to the file to perform face detection on.\n-   * @param out A {@link PrintStream} to write detected features to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_face_detection]\n-  public static void detectFaces(String filePath, PrintStream out) throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ByteString imgBytes = ByteString.readFrom(new FileInputStream(filePath));\n-\n-    Image img = Image.newBuilder().setContent(imgBytes).build();\n-    Feature feat = Feature.newBuilder().setType(Type.FACE_DETECTION).build();\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (FaceAnnotation annotation : res.getFaceAnnotationsList()) {\n-          out.format(\n-              \"anger: %s%njoy: %s%nsurprise: %s%nposition: %s\",\n-              annotation.getAngerLikelihood(),\n-              annotation.getJoyLikelihood(),\n-              annotation.getSurpriseLikelihood(),\n-              annotation.getBoundingPoly());\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_face_detection]\n-\n-  /**\n-   * Detects faces in the specified remote image on Google Cloud Storage.\n-   *\n-   * @param gcsPath The path to the remote file on Google Cloud Storage to perform face detection\n-   *     on.\n-   * @param out A {@link PrintStream} to write detected features to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_face_detection_gcs]\n-  public static void detectFacesGcs(String gcsPath, PrintStream out) throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ImageSource imgSource = ImageSource.newBuilder().setGcsImageUri(gcsPath).build();\n-    Image img = Image.newBuilder().setSource(imgSource).build();\n-    Feature feat = Feature.newBuilder().setType(Type.FACE_DETECTION).build();\n-\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (FaceAnnotation annotation : res.getFaceAnnotationsList()) {\n-          out.format(\n-              \"anger: %s%njoy: %s%nsurprise: %s%nposition: %s\",\n-              annotation.getAngerLikelihood(),\n-              annotation.getJoyLikelihood(),\n-              annotation.getSurpriseLikelihood(),\n-              annotation.getBoundingPoly());\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_face_detection_gcs]\n-\n-  /**\n-   * Detects labels in the specified local image.\n-   *\n-   * @param filePath The path to the file to perform label detection on.\n-   * @param out A {@link PrintStream} to write detected labels to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_label_detection]\n-  public static void detectLabels(String filePath, PrintStream out) throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ByteString imgBytes = ByteString.readFrom(new FileInputStream(filePath));\n-\n-    Image img = Image.newBuilder().setContent(imgBytes).build();\n-    Feature feat = Feature.newBuilder().setType(Type.LABEL_DETECTION).build();\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (EntityAnnotation annotation : res.getLabelAnnotationsList()) {\n-          annotation.getAllFields().forEach((k, v) -> out.format(\"%s : %s%n\", k, v.toString()));\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_label_detection]\n-\n-  /**\n-   * Detects labels in the specified remote image on Google Cloud Storage.\n-   *\n-   * @param gcsPath The path to the remote file on Google Cloud Storage to perform label detection\n-   *     on.\n-   * @param out A {@link PrintStream} to write detected features to.\n-   * @throws Exception on errors while closing the client.\n-   * @throws IOException on Input/Output errors.\n-   */\n-  // [START vision_label_detection_gcs]\n-  public static void detectLabelsGcs(String gcsPath, PrintStream out)\n-      throws Exception, IOException {\n-    List<AnnotateImageRequest> requests = new ArrayList<>();\n-\n-    ImageSource imgSource = ImageSource.newBuilder().setGcsImageUri(gcsPath).build();\n-    Image img = Image.newBuilder().setSource(imgSource).build();\n-    Feature feat = Feature.newBuilder().setType(Type.LABEL_DETECTION).build();\n-    AnnotateImageRequest request =\n-        AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).build();\n-    requests.add(request);\n-\n-    // Initialize client that will be used to send requests. This client only needs to be created\n-    // once, and can be reused for multiple requests. After completing all of your requests, call\n-    // the \"close\" method on the client to safely clean up any remaining background resources.\n-    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\n-      BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\n-      List<AnnotateImageResponse> responses = response.getResponsesList();\n-\n-      for (AnnotateImageResponse res : responses) {\n-        if (res.hasError()) {\n-          out.format(\"Error: %s%n\", res.getError().getMessage());\n-          return;\n-        }\n-\n-        // For full list of available annotations, see http://g.co/cloud/vision/docs\n-        for (EntityAnnotation annotation : res.getLabelAnnotationsList()) {\n-          annotation.getAllFields().forEach((k, v) -> out.format(\"%s : %s%n\", k, v.toString()));\n-        }\n-      }\n-    }\n-  }\n-  // [END vision_label_detection_gcs]\n-\n   /**\n    * Detects landmarks in the specified local image.\n    *\n    * @param filePath The path to the file to perform landmark detection on.\n-   * @param out A {@link PrintStream} to write detected landmarks to.\n    * @throws Exception on errors while closing the client.\n    * @throws IOException on Input/Output errors.\n    */\n   // [START vision_landmark_detection]\n-  public static void detectLandmarks(String filePath, PrintStream out)\n+  public static void detectLandmarks(String filePath)\n       throws Exception, IOException {\n     List<AnnotateImageRequest> requests = new ArrayList<>();\n     ByteString imgBytes = ByteString.readFrom(new FileInputStream(filePath));\n"}}, {"oid": "de46cb13e23499b6c8d6038c4285fde62a19fd2f", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/de46cb13e23499b6c8d6038c4285fde62a19fd2f", "message": "started breaking down detect file", "committedDate": "2020-05-28T01:14:02Z", "type": "commit"}, {"oid": "4998e311f478161f62dddd57e6860176257acf51", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/4998e311f478161f62dddd57e6860176257acf51", "message": "nits", "committedDate": "2020-05-28T01:19:19Z", "type": "commit"}, {"oid": "970aa006ff252b80e86b8df9fc08518464a81a23", "url": "https://github.com/GoogleCloudPlatform/java-docs-samples/commit/970aa006ff252b80e86b8df9fc08518464a81a23", "message": "formatted new files", "committedDate": "2020-05-28T18:17:20Z", "type": "commit"}]}