{"pr_number": 2105, "pr_title": "Optimize KVCMutation construct for deletions in CacheTransaction", "pr_createdAt": "2020-05-02T07:32:42Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2105", "timeline": [{"oid": "2cd04f8ce8d2f00c5b0292bf4c817eec1f2d645c", "url": "https://github.com/JanusGraph/janusgraph/commit/2cd04f8ce8d2f00c5b0292bf4c817eec1f2d645c", "message": "Optimize KVCMutation construct for deletions in CacheTransaction\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-05-02T07:46:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MjU5NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419292594", "bodyText": "Why not use a Supplier<List<E>> instead of CopyArrayListFunction<E>?", "author": "rngcntr", "createdAt": "2020-05-04T08:48:37Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java", "diffHunk": "@@ -35,10 +36,27 @@\n     public Mutation(List<E> additions, List<K> deletions) {\n         Preconditions.checkNotNull(additions);\n         Preconditions.checkNotNull(deletions);\n-        if (additions.isEmpty()) this.additions=null;\n-        else this.additions = new ArrayList<>(additions);\n-        if (deletions.isEmpty()) this.deletions=null;\n-        else this.deletions = new ArrayList<>(deletions);\n+        if (additions.isEmpty()){\n+            this.additions=null;\n+        } else {\n+            this.additions = new ArrayList<>(additions);\n+        }\n+        if (deletions.isEmpty()){\n+            this.deletions=null;\n+        } else {\n+            this.deletions = new ArrayList<>(deletions);\n+        }\n+    }\n+\n+    public Mutation(CopyArrayListFunction<E> additionsCopyFunction, CopyArrayListFunction<K> deletionsCopyFunction) {", "originalCommit": "2cd04f8ce8d2f00c5b0292bf4c817eec1f2d645c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4NTA2Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419585063", "bodyText": "This is very good suggestion. Changed to Supplier", "author": "porunov", "createdAt": "2020-05-04T17:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MjU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "5dbba151a5fe83dec87b9f0ba1155620ab3e08d8", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java b/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java\nindex 65b85c84b..f4eec4488 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java\n\n@@ -48,9 +48,9 @@ public abstract class Mutation<E,K> {\n         }\n     }\n \n-    public Mutation(CopyArrayListFunction<E> additionsCopyFunction, CopyArrayListFunction<K> deletionsCopyFunction) {\n-        additions = Preconditions.checkNotNull(additionsCopyFunction.copy());\n-        deletions = Preconditions.checkNotNull(deletionsCopyFunction.copy());\n+    public Mutation(Supplier<List<E>> additionsSupplier, Supplier<List<K>> deletionsSupplier) {\n+        additions = Preconditions.checkNotNull(additionsSupplier.get());\n+        deletions = Preconditions.checkNotNull(deletionsSupplier.get());\n         if (additions.isEmpty()){\n             additions=null;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419294624", "bodyText": "nitpick: You can redirect calls of this constructor to the new constructor:\npublic Mutation(List<E> additions, List<K> deletions) {\n    this(() -> new ArrayList<E>(additions), () -> new ArrayList<E>(deletions));\n}\nSaves lines and reduces potential for future mistakes ;)", "author": "rngcntr", "createdAt": "2020-05-04T08:52:12Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java", "diffHunk": "@@ -35,10 +36,27 @@\n     public Mutation(List<E> additions, List<K> deletions) {", "originalCommit": "2cd04f8ce8d2f00c5b0292bf4c817eec1f2d645c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyNTc4OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419525788", "bodyText": "I am not sure I get it here. Where do you get converted deletions here?", "author": "porunov", "createdAt": "2020-05-04T15:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5MDUyNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419590524", "bodyText": "Ah, got it. I didn't check the code", "author": "porunov", "createdAt": "2020-05-04T17:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYwMjgxOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419602819", "bodyText": "I'm in doubt of it because we used to check Preconditions.checkNotNull(additions) before starting working with the instance. If we change to above code, we may get NPE in ArrayList construction logic. If we move checkNotNull it means we add duplicate checkNotNull call.\nFrom another hand checkNotNull throws NPE if the instance is null. Which is a little bit strange to me. I'm not sure why we really need this check here at all. If an instance is null -> we will get the same NPE because of additions.isEmpty() call. From another hand, we won't get NPE here because we never pass null here. So, I guess, this check was added here just for readability to help other developers that they should not pass null here.\nIf so, I guess we can remove checkNotNull from this place at all and use either assert additions!=null; or just add javadoc to these constructors and mention there that passed parameters should not be null.\nWhat do you think about it?", "author": "porunov", "createdAt": "2020-05-04T17:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NTMyMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419865321", "bodyText": "I think assertions are a clean way of handling this. Also, I don't mind having duplicate assertions as much as having duplicate business logic", "author": "rngcntr", "createdAt": "2020-05-05T05:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4Njc3Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419886777", "bodyText": "I will change checkNotNull checks here to:\nassert additions!=null;\nassert deletions!=null;\n\nAs they are not enabled by default and thus will be used for testing only. And they will clearly show developers that they should not pass null here.", "author": "porunov", "createdAt": "2020-05-05T06:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxNTc2NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419915764", "bodyText": "Hm. Not sure now. The code looks strange if we are using this logic:\npublic Mutation(List<E> additions, List<K> deletions) {\n    this(() -> {\n        assert additions!=null;\n        return new ArrayList<E>(additions);\n    }, () -> {\n        assert deletions!=null;\n        return new ArrayList<K>(deletions);\n    });\n}\n\nI think the below code is cleaner and also doesn't create an unnecessary suppliers:\npublic Mutation(List<E> additions, List<K> deletions) {\n    assert additions!=null;\n    assert deletions!=null;\n    this.additions = additions.isEmpty()? null : new ArrayList<>(additions);\n    this.deletions = deletions.isEmpty()? null : new ArrayList<>(deletions);\n}\n\nOverall, I see that the whole Mutation and usages of Mutation should be refracted but I guess in other PRs.", "author": "porunov", "createdAt": "2020-05-05T07:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxNjg5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419916890", "bodyText": "What do you think about the updated implementation?", "author": "porunov", "createdAt": "2020-05-05T07:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0NTAwOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419945008", "bodyText": "I'd prefer to have the logic only once, either in the old constructor or in the new one. Maybe you could replace the new constructor to only do\nthis(additionsCopySupplier.get(), deletionsCopySupplier.get());\nBut this solution would not check if the suppliers themselves are null. On the other hand, the current solution doesn't do this either...\nThis is just a nitpick. I'm also ok with the current implementation but it would be nicer to keep it as clean as possible.", "author": "rngcntr", "createdAt": "2020-05-05T08:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIyOTEzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r420229137", "bodyText": "The problem with this solution:\nthis(additionsCopySupplier.get(), deletionsCopySupplier.get()); is that it will cause a copy of supplier's returned ArrayList to a new ArrayList which makes suppliers redundant and removes this optimization.\nI think it would be better to leave current optimization as is and make re-factoring of Mutation and usages of Mutation in other PRs", "author": "porunov", "createdAt": "2020-05-05T16:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYxNDczNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r420614734", "bodyText": "I see", "author": "rngcntr", "createdAt": "2020-05-06T08:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5NDYyNA=="}], "type": "inlineReview", "revised_code": {"commit": "5dbba151a5fe83dec87b9f0ba1155620ab3e08d8", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java b/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java\nindex 65b85c84b..f4eec4488 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java\n\n@@ -48,9 +48,9 @@ public abstract class Mutation<E,K> {\n         }\n     }\n \n-    public Mutation(CopyArrayListFunction<E> additionsCopyFunction, CopyArrayListFunction<K> deletionsCopyFunction) {\n-        additions = Preconditions.checkNotNull(additionsCopyFunction.copy());\n-        deletions = Preconditions.checkNotNull(deletionsCopyFunction.copy());\n+    public Mutation(Supplier<List<E>> additionsSupplier, Supplier<List<K>> deletionsSupplier) {\n+        additions = Preconditions.checkNotNull(additionsSupplier.get());\n+        deletions = Preconditions.checkNotNull(deletionsSupplier.get());\n         if (additions.isEmpty()){\n             additions=null;\n         }\n"}}, {"oid": "5dbba151a5fe83dec87b9f0ba1155620ab3e08d8", "url": "https://github.com/JanusGraph/janusgraph/commit/5dbba151a5fe83dec87b9f0ba1155620ab3e08d8", "message": "Optimize KVCMutation construct for deletions in CacheTransaction\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-05-04T16:59:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NzY4NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419867685", "bodyText": "Wouldn't it be more readable if we do:\nreturn mutations.getDeletions()\n    .stream()\n    .map(KCVEntryMutation.ENTRY2COLUMN_FCT::apply)\n    .collect(Collectors.toList());", "author": "rngcntr", "createdAt": "2020-05-05T05:14:59Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/keycolumnvalue/cache/CacheTransaction.java", "diffHunk": "@@ -105,10 +103,19 @@ public String toString() {\n \n     private KCVMutation convert(KCVEntryMutation mutation) {\n         assert !mutation.isEmpty();\n-        if (!mutation.hasDeletions())\n-            return new KCVMutation(mutation.getAdditions(), KeyColumnValueStore.NO_DELETIONS);\n-        else\n-            return new KCVMutation(mutation.getAdditions(), mutation.getDeletions().stream().map(KCVEntryMutation.ENTRY2COLUMN_FCT).collect(Collectors.toList()));\n+        if (mutation.hasDeletions()) {\n+            return new KCVMutation(\n+                () -> new ArrayList<>(mutation.getAdditions()),\n+                () -> {\n+                    List<Entry> deletions = mutation.getDeletions();\n+                    ArrayList<StaticBuffer> convertedDeletions = new ArrayList<>(deletions.size());\n+                    for(Entry entry : deletions){\n+                        convertedDeletions.add(KCVEntryMutation.ENTRY2COLUMN_FCT.apply(entry));\n+                    }\n+                    return convertedDeletions;", "originalCommit": "5dbba151a5fe83dec87b9f0ba1155620ab3e08d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2Nzk1Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419867952", "bodyText": "Oh this way we can even omit the code block and the return statement", "author": "rngcntr", "createdAt": "2020-05-05T05:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NzY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4MzkxNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419883915", "bodyText": "As noted and benchmarked by @mad , vanilla java is faster than stream api (#2098 (comment)) and thus it is recommended to use vanilla java in performance critical sections (like mutations).\nPersonally, I didn't compare ArrayList transformation performance for vanilla java and stream API. Also, I'm not sure if StreamAPI is using initial ArrayList length to construct an array of needed size without resizing an array during additions.\nI think that StreamAPI is a cleaner version here, but I didn't check benchmarks. If you can confirm that Stream API uses new ArrayList<>(initialArrayListSize) instead of new ArrayList<>() for Collectors.toList() for stream from ArrayList and you checked performance and it is the same as vanilla java, I am more than happy to apply this suggestion. Otherwise, I think it would be better to use vanilla java code in this section.", "author": "porunov", "createdAt": "2020-05-05T06:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NzY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4OTc5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419889791", "bodyText": "As far as I know, one can initialize a custom list to be used by collect(). But I have no benchmarks. Will do one if I have some time later today.", "author": "rngcntr", "createdAt": "2020-05-05T06:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NzY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwMDAzNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419900034", "bodyText": "@rngcntr indeed we could do .collect(Collectors.toCollection(() -> new ArrayList<>(data.size()))).\nIt would be good to check performance for this scenario. If it has the same performance, then we could use Steam API here.", "author": "porunov", "createdAt": "2020-05-05T06:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NzY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3MzU1NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r419973555", "bodyText": "Using ArrayList with the stream API brings a slight improvement, but nothing beats vanilla:\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@BenchmarkMode(Mode.AverageTime)\n@OperationsPerInvocation(StreamVsVanilla.N)\n@Warmup(iterations = 3, time = 2, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 3, time = 2, timeUnit = TimeUnit.SECONDS)\npublic class StreamVsVanilla {\n    public static final int N = 100_000;\n\n    static List<String> sourceList = new ArrayList<>(N);\n    static Function<String, String> identity = Function.identity();\n\n    static {\n        for (int i = 0; i < N; i++) {\n            sourceList.add(\"hello\");\n        }\n    }\n\n    @Benchmark\n    public List<String> vanilla() {\n        List<String> adds = new ArrayList<>(N);\n        for (final String s : sourceList) {\n            adds.add(identity.apply(s));\n        }\n        return adds;\n    }\n\n    @Benchmark\n    public List<String> stream() {\n        List<String> adds = sourceList.stream()\n            .map(identity)\n            .collect(Collectors.toCollection(() -> new ArrayList<>(sourceList.size())));\n        return adds;\n    }\n\n    @Benchmark\n    public List<String> naiveStream() {\n        List<String> adds = sourceList.stream()\n            .map(identity)\n            .collect(Collectors.toList());\n        return adds;\n    }\n}\nResults:\nBenchmark                    Mode  Cnt   Score   Error  Units\nStreamVsVanilla.naiveStream  avgt   15  11.339 \u00b1 0.461  ns/op\nStreamVsVanilla.stream       avgt   15  10.594 \u00b1 0.548  ns/op\nStreamVsVanilla.vanilla      avgt   15   6.362 \u00b1 0.088  ns/op", "author": "rngcntr", "createdAt": "2020-05-05T09:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NzY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNTMzNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2105#discussion_r420235334", "bodyText": "@rngcntr Thank you for these benchmarks. If so, we need to use vanilla code in performance critical sections. Also, I have created an issue here #2110 to move code to Vanilla Java in other performance critical sections.", "author": "porunov", "createdAt": "2020-05-05T16:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg2NzY4NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "55aca41ccbc8c6ec9d48d18ebba36c766f237e2a", "url": "https://github.com/JanusGraph/janusgraph/commit/55aca41ccbc8c6ec9d48d18ebba36c766f237e2a", "message": "Optimize KVCMutation construct for deletions in CacheTransaction\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-05-05T07:35:02Z", "type": "commit"}, {"oid": "55aca41ccbc8c6ec9d48d18ebba36c766f237e2a", "url": "https://github.com/JanusGraph/janusgraph/commit/55aca41ccbc8c6ec9d48d18ebba36c766f237e2a", "message": "Optimize KVCMutation construct for deletions in CacheTransaction\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-05-05T07:35:02Z", "type": "forcePushed"}]}