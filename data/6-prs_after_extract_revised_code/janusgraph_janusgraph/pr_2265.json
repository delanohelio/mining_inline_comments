{"pr_number": 2265, "pr_title": "Fix neq and null condition query behavior", "pr_createdAt": "2020-12-06T15:02:21Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2265", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDEwNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537120107", "bodyText": "Why this test was removed from JanusGraphTest.java? Tests in JanusGraphTest.java are executed against different storages backends. I guess, it would be better to just fix this test instead of removing it.\nI.e. we could change this method to something like:\n@Test\npublic void testHasNot() {\n    graph.addVertex();\n    assertTrue(graph.query().hasNot(\"abcd\").vertices().iterator().hasNext());\n    assertFalse(graph.query().hasNot(\"abcd\", true).vertices().iterator().hasNext());\n}", "author": "porunov", "createdAt": "2020-12-06T20:46:51Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -5792,18 +5792,6 @@ private static void assertElementOrderForWithoutIndex(StandardJanusGraph graph)\n \n     //................................................\n \n-\n-    @Test\n-    public void testHasNot() {\n-        JanusGraphVertex v1, v2;\n-        v1 = graph.addVertex();\n-\n-        v2 = graph.query().hasNot(\"abcd\").vertices().iterator().next();\n-        assertEquals(v1, v2);\n-        v2 = graph.query().hasNot(\"abcd\", true).vertices().iterator().next();\n-        assertEquals(v1, v2);\n-    }", "originalCommit": "ffc0768f35fab586b926843ab59f15ee691f573b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NDEyMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537184120", "bodyText": "It is moved to JanusGraphIndexTest because I want to enforce the existence of indexes does not alter the behavior. Example: #1868 (comment)", "author": "li-boxuan", "createdAt": "2020-12-07T02:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI5ODY4Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537298687", "bodyText": "What about behaviour without any index? As I understand, this logic was tested with use cases when there is no necessary indices", "author": "porunov", "createdAt": "2020-12-07T07:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMxMTkxMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537311910", "bodyText": "That is also tested. See testHasNot in JanusGraphIndexTest.", "author": "li-boxuan", "createdAt": "2020-12-07T08:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1OTAyOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537359029", "bodyText": "I don't have strong opinion here. testHasNot which you removed was tested against different storage backends (CQL, BerkleyDB, HBase, InMemory). In the new testHasNot method we test it with several combinations CQL or BerkleyDB as a storage backend and Lucene / Solr / ElasticSearch as index backend. Thus, now the test is executed with less storage backends.\nAs I said, I don't have strong opinion here. If you think it's better to keep all that test logic in one place (JanusGraphIndexTest) and don't test against InMemory and HBase I'm fine with it. I thought, maybe it's better to split that test logic between JanusGraphTest and JanusGraphIndexTest. For example, test cases property not registered in schema, property registered in schema and property registered in schema and has composite index can easily be moved to JanusGraphTest where they will be executed against a bigger number of Storage backends whereas property registered in schema and has mixed index can be in JanusGraphIndexTest where it will be executed against different mixed index backends.", "author": "porunov", "createdAt": "2020-12-07T09:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQyMzI2Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537423263", "bodyText": "That's fair. The initial thought was to avoid having similar tests in both classes, but you made a valid point. I'll move some back to JanusGraphTest.", "author": "li-boxuan", "createdAt": "2020-12-07T11:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "7d9757343257121a3f69dcd5b16d4eeb5685818c", "chunk": "diff --git a/janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java b/janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java\nindex 7fd9c0385..58ac1be5e 100644\n--- a/janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java\n+++ b/janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java\n\n@@ -5792,6 +5792,102 @@ public abstract class JanusGraphTest extends JanusGraphBaseTest {\n \n     //................................................\n \n+    @Test\n+    public void testNeqQuery() {\n+        makeKey(\"p2\", String.class);\n+        PropertyKey p3 = makeKey(\"p3\", String.class);\n+        mgmt.buildIndex(\"composite\", Vertex.class).addKey(p3).buildCompositeIndex();\n+        finishSchema();\n+\n+        tx.addVertex();\n+        tx.commit();\n+        newTx();\n+\n+        // property not registered in schema\n+        assertFalse(tx.traversal().V().has(\"p1\", P.neq(\"v\")).hasNext());\n+        assertFalse(tx.traversal().V().has(\"p1\", P.neq(null)).hasNext());\n+        // property registered in schema\n+        assertFalse(tx.traversal().V().has(\"p2\", P.neq(\"v\")).hasNext());\n+        assertFalse(tx.traversal().V().has(\"p2\", P.neq(null)).hasNext());\n+        // property registered in schema and has composite index\n+        assertFalse(tx.traversal().V().has(\"p3\", P.neq(\"v\")).hasNext());\n+        assertFalse(tx.traversal().V().has(\"p3\", P.neq(null)).hasNext());\n+    }\n+\n+    /**\n+     * The behaviour of has(p, null) deviates from TinkerGraph. Since JanusGraph does not support null values,\n+     * has(p, null) indicates hasNot(p). In other words, an absent property implicitly implies null value for that property.\n+     */\n+    @Test\n+    public void testHasNullQuery() {\n+        makeKey(\"p2\", String.class);\n+        PropertyKey p3 = makeKey(\"p3\", String.class);\n+        mgmt.buildIndex(\"composite\", Vertex.class).addKey(p3).buildCompositeIndex();\n+        finishSchema();\n+\n+        tx.addVertex();\n+        tx.commit();\n+        newTx();\n+\n+        // property not registered in schema\n+        assertTrue(tx.traversal().V().has(\"p1\", (Object) null).hasNext());\n+        // property registered in schema\n+        assertTrue(tx.traversal().V().has(\"p2\", (Object) null).hasNext());\n+        // property registered in schema and has composite index\n+        assertTrue(tx.traversal().V().has(\"p3\", (Object) null).hasNext());\n+    }\n+\n+    /**\n+     * The behaviour of hasNot(p) is straight-forward: hasNot(p) means it does not have such property p.\n+     * Note that hasNot(p, value) (which is a JanusGraph API rather than gremlin API) is a bit tricky and it is equivalent\n+     * to has(p, neq(value)). Therefore, hasNot(p, null) means has(p, neq(null)) which is equivalent to has(p).\n+     */\n+    @Test\n+    public void testHasNot() {\n+        makeKey(\"p2\", String.class);\n+        PropertyKey p3 = makeKey(\"p3\", String.class);\n+        mgmt.buildIndex(\"composite\", Vertex.class).addKey(p3).buildCompositeIndex();\n+\n+        tx.addVertex();\n+        tx.commit();\n+        newTx();\n+\n+        // property not registered in schema\n+        assertTrue(tx.traversal().V().hasNot(\"p1\").hasNext());\n+        assertTrue(tx.query().hasNot(\"p1\").vertices().iterator().hasNext());\n+        assertFalse(tx.query().hasNot(\"p1\", null).vertices().iterator().hasNext());\n+        assertFalse(tx.query().hasNot(\"p1\", \"value\").vertices().iterator().hasNext());\n+        // property registered in schema\n+        assertTrue(tx.traversal().V().hasNot(\"p2\").hasNext());\n+        assertTrue(tx.query().hasNot(\"p2\").vertices().iterator().hasNext());\n+        assertFalse(tx.query().hasNot(\"p2\", null).vertices().iterator().hasNext());\n+        assertFalse(tx.query().hasNot(\"p2\", \"value\").vertices().iterator().hasNext());\n+        // property registered in schema and has composite index\n+        assertTrue(tx.traversal().V().hasNot(\"p3\").hasNext());\n+        assertTrue(tx.query().hasNot(\"p3\").vertices().iterator().hasNext());\n+        assertFalse(tx.query().hasNot(\"p3\", null).vertices().iterator().hasNext());\n+        assertFalse(tx.query().hasNot(\"p3\", \"value\").vertices().iterator().hasNext());\n+    }\n+\n+    @Test\n+    public void testNotHas() {\n+        makeKey(\"p2\", String.class);\n+        PropertyKey p3 = makeKey(\"p3\", String.class);\n+        mgmt.buildIndex(\"composite\", Vertex.class).addKey(p3).buildCompositeIndex();\n+        finishSchema();\n+\n+        tx.addVertex();\n+        tx.commit();\n+        newTx();\n+\n+        // property not registered in schema\n+        assertTrue(tx.traversal().V().not(__.has(\"p1\")).hasNext());\n+        // property registered in schema\n+        assertTrue(tx.traversal().V().not(__.has(\"p2\")).hasNext());\n+        // property registered in schema and has composite index\n+        assertTrue(tx.traversal().V().not(__.has(\"p3\")).hasNext());\n+    }\n+\n     @Test\n     public void testVertexCentricIndexWithNull() {\n         EdgeLabel bought = makeLabel(\"bought\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMjE4OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537122189", "bodyText": "I guess, slightly simplified version would be:\n@Override\npublic boolean test(Object value, Object condition) {\n    // To align with TinkerPop behaviour, if an element does not have property p, then has(p, neq(anything))\n    // should always evaluate to false. Note that JanusGraph does not support null value, so the \"value == null\"\n    // here implies the element does not have such property.\n    return value != null && !value.equals(condition);\n}", "author": "porunov", "createdAt": "2020-12-06T20:59:10Z", "path": "janusgraph-driver/src/main/java/org/janusgraph/core/attribute/Cmp.java", "diffHunk": "@@ -73,10 +73,13 @@ public boolean isValidCondition(Object condition) {\n \n         @Override\n         public boolean test(Object value, Object condition) {\n-            if (condition==null) {\n-                return value!=null;\n+            if (value == null) {\n+                // To align with TinkerPop behaviour, if an element does not have property p, then has(p, neq(anything))\n+                // should always evaluate to false. Note that JanusGraph does not support null value, so the \"value == null\"\n+                // here implies the element does not have such property.\n+                return false;\n             } else {\n-                return !condition.equals(value);\n+                return !value.equals(condition);\n             }\n         }", "originalCommit": "ffc0768f35fab586b926843ab59f15ee691f573b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d9757343257121a3f69dcd5b16d4eeb5685818c", "chunk": "diff --git a/janusgraph-driver/src/main/java/org/janusgraph/core/attribute/Cmp.java b/janusgraph-driver/src/main/java/org/janusgraph/core/attribute/Cmp.java\nindex f16fdeea8..39de74779 100644\n--- a/janusgraph-driver/src/main/java/org/janusgraph/core/attribute/Cmp.java\n+++ b/janusgraph-driver/src/main/java/org/janusgraph/core/attribute/Cmp.java\n\n@@ -73,14 +73,10 @@ public enum Cmp implements JanusGraphPredicate {\n \n         @Override\n         public boolean test(Object value, Object condition) {\n-            if (value == null) {\n-                // To align with TinkerPop behaviour, if an element does not have property p, then has(p, neq(anything))\n-                // should always evaluate to false. Note that JanusGraph does not support null value, so the \"value == null\"\n-                // here implies the element does not have such property.\n-                return false;\n-            } else {\n-                return !value.equals(condition);\n-            }\n+            // To align with TinkerPop behaviour, if an element does not have property p, then has(p, neq(anything))\n+            // should always evaluate to false. Note that JanusGraph does not support null value, so the \"value == null\"\n+            // here implies the element does not have such property.\n+            return value != null && !value.equals(condition);\n         }\n \n         @Override\n"}}, {"oid": "7d9757343257121a3f69dcd5b16d4eeb5685818c", "url": "https://github.com/JanusGraph/janusgraph/commit/7d9757343257121a3f69dcd5b16d4eeb5685818c", "message": "Fix neq and null condition query behavior\n\nFixes #2205\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-12-07T12:29:59Z", "type": "commit"}, {"oid": "7d9757343257121a3f69dcd5b16d4eeb5685818c", "url": "https://github.com/JanusGraph/janusgraph/commit/7d9757343257121a3f69dcd5b16d4eeb5685818c", "message": "Fix neq and null condition query behavior\n\nFixes #2205\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-12-07T12:29:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4NDI1Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537484257", "bodyText": "Doesn't hasNot is Gremlin API?\nhttps://tinkerpop.apache.org/javadocs/3.4.8/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasNot-java.lang.String-", "author": "porunov", "createdAt": "2020-12-07T12:54:47Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -5792,16 +5792,100 @@ private static void assertElementOrderForWithoutIndex(StandardJanusGraph graph)\n \n     //................................................\n \n+    @Test\n+    public void testNeqQuery() {\n+        makeKey(\"p2\", String.class);\n+        PropertyKey p3 = makeKey(\"p3\", String.class);\n+        mgmt.buildIndex(\"composite\", Vertex.class).addKey(p3).buildCompositeIndex();\n+        finishSchema();\n+\n+        tx.addVertex();\n+        tx.commit();\n+        newTx();\n+\n+        // property not registered in schema\n+        assertFalse(tx.traversal().V().has(\"p1\", P.neq(\"v\")).hasNext());\n+        assertFalse(tx.traversal().V().has(\"p1\", P.neq(null)).hasNext());\n+        // property registered in schema\n+        assertFalse(tx.traversal().V().has(\"p2\", P.neq(\"v\")).hasNext());\n+        assertFalse(tx.traversal().V().has(\"p2\", P.neq(null)).hasNext());\n+        // property registered in schema and has composite index\n+        assertFalse(tx.traversal().V().has(\"p3\", P.neq(\"v\")).hasNext());\n+        assertFalse(tx.traversal().V().has(\"p3\", P.neq(null)).hasNext());\n+    }\n+\n+    /**\n+     * The behaviour of has(p, null) deviates from TinkerGraph. Since JanusGraph does not support null values,\n+     * has(p, null) indicates hasNot(p). In other words, an absent property implicitly implies null value for that property.\n+     */\n+    @Test\n+    public void testHasNullQuery() {\n+        makeKey(\"p2\", String.class);\n+        PropertyKey p3 = makeKey(\"p3\", String.class);\n+        mgmt.buildIndex(\"composite\", Vertex.class).addKey(p3).buildCompositeIndex();\n+        finishSchema();\n+\n+        tx.addVertex();\n+        tx.commit();\n+        newTx();\n+\n+        // property not registered in schema\n+        assertTrue(tx.traversal().V().has(\"p1\", (Object) null).hasNext());\n+        // property registered in schema\n+        assertTrue(tx.traversal().V().has(\"p2\", (Object) null).hasNext());\n+        // property registered in schema and has composite index\n+        assertTrue(tx.traversal().V().has(\"p3\", (Object) null).hasNext());\n+    }\n \n+    /**\n+     * The behaviour of hasNot(p) is straight-forward: hasNot(p) means it does not have such property p.\n+     * Note that hasNot(p, value) (which is a JanusGraph API rather than gremlin API) is a bit tricky and it is equivalent\n+     * to has(p, neq(value)). Therefore, hasNot(p, null) means has(p, neq(null)) which is equivalent to has(p).\n+     */", "originalCommit": "7d9757343257121a3f69dcd5b16d4eeb5685818c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4NDkwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2265#discussion_r537484905", "bodyText": "Ah sorry, missed second parameter", "author": "porunov", "createdAt": "2020-12-07T12:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4NDI1Nw=="}], "type": "inlineReview", "revised_code": null}]}