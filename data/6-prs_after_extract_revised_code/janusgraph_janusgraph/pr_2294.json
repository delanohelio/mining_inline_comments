{"pr_number": 2294, "pr_title": "issue #2273 - implement variable length \"valuePosition\" in page storage", "pr_createdAt": "2020-12-21T16:20:24Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2294", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNDA4OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r548824088", "bodyText": "Just a nitpick: we could use ByteBuffer.wrap(rawData, offset, Integer.BYTES).order(ByteOrder.BIG_ENDIAN) to explicitly set the endianness, or we could add an assertion to make sure order() is equivalent to BIG_ENDIAN.", "author": "li-boxuan", "createdAt": "2020-12-25T07:35:47Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java", "diffHunk": "@@ -92,6 +93,30 @@ public static SharedEntryBuffer readFrom(DataInputStream in) throws IOException\n         }\n     }\n \n+    static int computeValPosSize(Entry e)\n+    {\n+        //this assumes that the key size will almost never be > 127 bytes,\n+        // thus most of the time saving 3 out of 4 bytes to store the value position within the buffer\n+        return e.getValuePosition() > 127 ? Integer.BYTES : 1;\n+    }\n+\n+    static int writeValPos(Entry e, byte[] rawData, int offset)\n+    {\n+        if (e.getValuePosition() <= 127) //\"column\" name length fits into one byte - should be 99.99% of cases\n+        {\n+            final byte entryValPos = (byte) e.getValuePosition();\n+            rawData[offset] = entryValPos;\n+            return 1;\n+        }\n+        else //doesn't fit in 1 byte - use full integer\n+        {\n+            //ByteBuffer is in BigENdian mode by default, so if we write -valuePosition,\n+            // 1st byte should have a negative value, indicating full int\n+            ByteBuffer.wrap(rawData, offset, Integer.BYTES).asIntBuffer().put(-e.getValuePosition());", "originalCommit": "a3674776e68e5eca45dd238c3bdbe350afe36757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0ODMzOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549148338", "bodyText": "done", "author": "dk-github", "createdAt": "2020-12-27T18:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNDA4OA=="}], "type": "inlineReview", "revised_code": {"commit": "010179f72dce076b5015dbcd85ac9c3c82403150", "chunk": "diff --git a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java\nindex 079ed041e..f8af4d21f 100644\n--- a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java\n+++ b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java\n\n@@ -110,9 +111,8 @@ public final class BufferPageUtils {\n         }\n         else //doesn't fit in 1 byte - use full integer\n         {\n-            //ByteBuffer is in BigENdian mode by default, so if we write -valuePosition,\n-            // 1st byte should have a negative value, indicating full int\n-            ByteBuffer.wrap(rawData, offset, Integer.BYTES).asIntBuffer().put(-e.getValuePosition());\n+            // if we write -valuePosition in big-endian order, 1st byte should have a negative value, indicating full int\n+            ByteBuffer.wrap(rawData, offset, Integer.BYTES).order(ByteOrder.BIG_ENDIAN).asIntBuffer().put(-e.getValuePosition());\n             return Integer.BYTES;\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r548826348", "bodyText": "I think if you can change the signature of this method into\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static int computeValPosSize(Entry e)\n          \n          \n            \n                static int computeValPosSize(int valPos)\n          \n      \n    \n    \n  \n\nthen it could be reused in BufferPage.java.", "author": "li-boxuan", "createdAt": "2020-12-25T07:49:37Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java", "diffHunk": "@@ -92,6 +93,30 @@ public static SharedEntryBuffer readFrom(DataInputStream in) throws IOException\n         }\n     }\n \n+    static int computeValPosSize(Entry e)", "originalCommit": "a3674776e68e5eca45dd238c3bdbe350afe36757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0NzgwNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549147806", "bodyText": "I could change it here, but not sure how it could help reuse it in BufferPage - here we have an \"unpacked\" entry and decide how we are going to pack, there we get the packed entry and need to find out how it WAS packed - so it needs to take the byte array etc...", "author": "dk-github", "createdAt": "2020-12-27T18:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5NzgxNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549197817", "bodyText": "What I noticed is, in BufferPage.java, you always retrieve valPos before retrieving valPosSize. Since you have valPos available, you could call BufferPageUtils::computeValPosSize(int valPos) to retrieve valPosSize.\nThe caller in this class should then call computeValPosSize((array[start+i]).getValuePosition()) to retrieve valPosSize.", "author": "li-boxuan", "createdAt": "2020-12-28T02:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MDc4Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549780782", "bodyText": "ok, got you now - done", "author": "dk-github", "createdAt": "2020-12-29T17:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "010179f72dce076b5015dbcd85ac9c3c82403150", "chunk": "diff --git a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java\nindex 079ed041e..f8af4d21f 100644\n--- a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java\n+++ b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java\n\n@@ -110,9 +111,8 @@ public final class BufferPageUtils {\n         }\n         else //doesn't fit in 1 byte - use full integer\n         {\n-            //ByteBuffer is in BigENdian mode by default, so if we write -valuePosition,\n-            // 1st byte should have a negative value, indicating full int\n-            ByteBuffer.wrap(rawData, offset, Integer.BYTES).asIntBuffer().put(-e.getValuePosition());\n+            // if we write -valuePosition in big-endian order, 1st byte should have a negative value, indicating full int\n+            ByteBuffer.wrap(rawData, offset, Integer.BYTES).order(ByteOrder.BIG_ENDIAN).asIntBuffer().put(-e.getValuePosition());\n             return Integer.BYTES;\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgzMDU4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r548830586", "bodyText": "It took me some time to understand this method thoroughly. I think the usage of entryBuffer here is not straight-forward to understand, since you are kind of mixing the two use cases (reading and moving cursor v.s. purely reading) together in one method. Would be helpful if you can add some javadoc.", "author": "li-boxuan", "createdAt": "2020-12-25T08:16:18Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java", "diffHunk": "@@ -111,24 +113,64 @@ private int getEntryEndOffset(final int index) {\n         }\n     }\n \n+    static int readValPos(byte[] rawData, int entryOffset, ByteBuffer entryBuffer)", "originalCommit": "a3674776e68e5eca45dd238c3bdbe350afe36757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0ODM3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549148370", "bodyText": "done", "author": "dk-github", "createdAt": "2020-12-27T18:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgzMDU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "010179f72dce076b5015dbcd85ac9c3c82403150", "chunk": "diff --git a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java\nindex 0b95095bb..e3e2a9713 100644\n--- a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java\n+++ b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java\n\n@@ -113,6 +113,10 @@ class BufferPage {\n         }\n     }\n \n+    /**\n+     * This figures out how the \"valuePosition\" was stored (i.e. 1 byte or 4), reads it correctly,\n+     * and leaves the byte buffer (if given) at the beginning of the key value\n+     */\n     static int readValPos(byte[] rawData, int entryOffset, ByteBuffer entryBuffer)\n     {\n         final byte firstByte = rawData[entryOffset];\n"}}, {"oid": "010179f72dce076b5015dbcd85ac9c3c82403150", "url": "https://github.com/JanusGraph/janusgraph/commit/010179f72dce076b5015dbcd85ac9c3c82403150", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2020-12-27T18:27:11Z", "type": "forcePushed"}, {"oid": "b2c46e3b346d781e04e4dcc6e28c7ad531c4e6dd", "url": "https://github.com/JanusGraph/janusgraph/commit/b2c46e3b346d781e04e4dcc6e28c7ad531c4e6dd", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2020-12-29T17:07:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkxNTAyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549915023", "bodyText": "nitpick: don't put the curly brace on a new line, to be consistent with the convention used in the codebase.", "author": "li-boxuan", "createdAt": "2020-12-30T02:31:43Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java", "diffHunk": "@@ -111,24 +113,62 @@ private int getEntryEndOffset(final int index) {\n         }\n     }\n \n+    /**\n+     * This figures out how the \"valuePosition\" was stored (i.e. 1 byte or 4), reads it correctly,\n+     * and leaves the byte buffer (if given) at the beginning of the key value\n+     */\n+    static int readValPos(byte[] rawData, int entryOffset, ByteBuffer entryBuffer)\n+    {", "originalCommit": "b2c46e3b346d781e04e4dcc6e28c7ad531c4e6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b4431939055237b3e280ea7873bd53232731bd", "chunk": "diff --git a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java\nindex f5e439f86..a214c9319 100644\n--- a/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java\n+++ b/janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java\n\n@@ -117,8 +117,7 @@ class BufferPage {\n      * This figures out how the \"valuePosition\" was stored (i.e. 1 byte or 4), reads it correctly,\n      * and leaves the byte buffer (if given) at the beginning of the key value\n      */\n-    static int readValPos(byte[] rawData, int entryOffset, ByteBuffer entryBuffer)\n-    {\n+    static int readValPos(byte[] rawData, int entryOffset, ByteBuffer entryBuffer) {\n         final byte firstByte = rawData[entryOffset];\n         if (firstByte > 0) //this entry has a short \"column\" key whose length fit in 1 byte\n         {\n"}}, {"oid": "d936872df4c815ef524a4c78013d90f45a886af8", "url": "https://github.com/JanusGraph/janusgraph/commit/d936872df4c815ef524a4c78013d90f45a886af8", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2021-01-07T22:46:10Z", "type": "forcePushed"}, {"oid": "f2b4431939055237b3e280ea7873bd53232731bd", "url": "https://github.com/JanusGraph/janusgraph/commit/f2b4431939055237b3e280ea7873bd53232731bd", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2021-01-08T11:04:07Z", "type": "commit"}, {"oid": "f2b4431939055237b3e280ea7873bd53232731bd", "url": "https://github.com/JanusGraph/janusgraph/commit/f2b4431939055237b3e280ea7873bd53232731bd", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2021-01-08T11:04:07Z", "type": "forcePushed"}]}