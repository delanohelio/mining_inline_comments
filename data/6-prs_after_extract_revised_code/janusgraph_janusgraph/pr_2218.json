{"pr_number": 2218, "pr_title": "Make iterators auto-closeable and fix SubqueryIterator close bug", "pr_createdAt": "2020-09-20T12:44:25Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2218", "timeline": [{"oid": "4bf4c6a377f3c59ebd851f6da2a374ceca5a34eb", "url": "https://github.com/JanusGraph/janusgraph/commit/4bf4c6a377f3c59ebd851f6da2a374ceca5a34eb", "message": "Fix SubqueryIterator close bug\n\nThis makes SubqueryIterator, LimitAdjustingIterator, and\nResultSetIterator implement CloseableIterator, and makes\nsure SubqueryIterator finishes properly.\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-20T14:34:24Z", "type": "forcePushed"}, {"oid": "db73fa612f471b3fbfcad137ea54e84fd5baf6ac", "url": "https://github.com/JanusGraph/janusgraph/commit/db73fa612f471b3fbfcad137ea54e84fd5baf6ac", "message": "Fix SubqueryIterator close bug\n\nThis makes SubqueryIterator, LimitAdjustingIterator, and\nResultSetIterator implement CloseableIterator, and makes\nsure SubqueryIterator finishes properly.\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-20T14:38:42Z", "type": "forcePushed"}, {"oid": "70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "url": "https://github.com/JanusGraph/janusgraph/commit/70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "message": "Fix SubqueryIterator close bug\n\nThis makes SubqueryIterator, LimitAdjustingIterator, and\nResultSetIterator implement CloseableIterator, and makes\nsure SubqueryIterator finishes properly.\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-21T01:09:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5NzQ1MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r491797450", "bodyText": "What happened to the currentIds != null check here? Before your change, the SubQueryIterator was also stopped if currentIds was null, even if the elementIterator had a next element.", "author": "rngcntr", "createdAt": "2020-09-21T05:17:27Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java", "diffHunk": "@@ -73,11 +74,8 @@ public SubqueryIterator(JointIndexQuery.Subquery subQuery, IndexSerializer index\n \n     @Override\n     public boolean hasNext() {\n-        if (!elementIterator.hasNext() && currentIds != null) {", "originalCommit": "70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyNDQ5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r492024491", "bodyText": "I didn't get you here. Can you elaborate a bit?", "author": "li-boxuan", "createdAt": "2020-09-21T12:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5NzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3Mzk3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r492473970", "bodyText": "You moved the lines inside this if statement to a separate function named close and now call this function instead of executing the lines directly. But the condition inside the if has changed. It was\nif (!elementIterator.hasNext() && currentIds != null) {\n   ...\n}\nbefore and now it is\nif (!elementIterator.hasNext()) {\n   ...\n}\nYou removed the && currentIds != null part.", "author": "rngcntr", "createdAt": "2020-09-22T04:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5NzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY5MTMzNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r492691335", "bodyText": "Got your question. What confused me was the sentence:\n\nBefore your change, the SubQueryIterator was also stopped if currentIds was null, even if the elementIterator had a next element.\n\nAnyway, I removed this currentIds != null condition because it is not needed anymore. In the old logic, it is needed, because currentIds == null means cached response is used, in which case there is no timer running & no results fetched from backend.\nAfter my changes, I moved the logic into the close() method. In that method, nothing would be done if isTimerRunning evaluates to false (note that isTimerRunning == true and currentIds != null are equivalent), so the effect remains the same.", "author": "li-boxuan", "createdAt": "2020-09-22T12:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5NzQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "1973676c48d0d37ac42fd0bd317bf3c4edfc66bf", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\nindex fc1847778..305860ed7 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n\n@@ -74,22 +75,34 @@ public class SubqueryIterator implements CloseableIterator<JanusGraphElement> {\n \n     @Override\n     public boolean hasNext() {\n-        if (!elementIterator.hasNext()) {\n+        final boolean hasNext = elementIterator.hasNext();\n+        if (!hasNext) {\n+            if (currentIds != null) {\n+                indexCache.put(subQuery, currentIds);\n+            }\n             close();\n         }\n-        return elementIterator.hasNext();\n+        return hasNext;\n     }\n \n     @Override\n     public JanusGraphElement next() {\n-        return this.elementIterator.next();\n+        if (!hasNext()) {\n+            throw new NoSuchElementException();\n+        }\n+        return elementIterator.next();\n     }\n \n+    /**\n+     * Close the iterator, stop timer and update profiler.\n+     *\n+     * Results shall not be put into cache because close() can be invoked before underlying\n+     * elementIterator is exhausted.\n+     */\n     @Override\n     public void close() {\n         if (isTimerRunning) {\n             assert currentIds != null;\n-            indexCache.put(subQuery, currentIds);\n             profiler.setResultSize(currentIds.size());\n             profiler.stopTimer();\n             isTimerRunning = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5ODI4NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r491798285", "bodyText": "Not sure: The encapsulation of all the code within an if (isTimerRunning) suggests that calling close() with an already stopped timer is also a valid operation. Does it make sense to restrict the cache update to the case where the timer is still running?\nFrom my understanding, there should be no real difference since after the timer has stopped, currentIds should not be altered anymore. But still I would be more comfortable if the if block only encapsulates operations that are invalid if the timer is stopped.", "author": "rngcntr", "createdAt": "2020-09-21T05:21:46Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java", "diffHunk": "@@ -88,9 +86,13 @@ public JanusGraphElement next() {\n     }\n \n     @Override\n-    public void close() throws Exception {\n+    public void close() {\n         if (isTimerRunning) {\n+            assert currentIds != null;\n+            indexCache.put(subQuery, currentIds);", "originalCommit": "70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyMzk4NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r492023985", "bodyText": "In this class, isTimerRunning is not only an indicator for 'timer is running', but also for 'results are being fetched from backend in a stream'. There is no way for the situation 'timer stops but currentIds not put into cache yet' to happen. Let me know if you have a better way to handle this.", "author": "li-boxuan", "createdAt": "2020-09-21T12:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5ODI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1973676c48d0d37ac42fd0bd317bf3c4edfc66bf", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\nindex fc1847778..305860ed7 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n\n@@ -74,22 +75,34 @@ public class SubqueryIterator implements CloseableIterator<JanusGraphElement> {\n \n     @Override\n     public boolean hasNext() {\n-        if (!elementIterator.hasNext()) {\n+        final boolean hasNext = elementIterator.hasNext();\n+        if (!hasNext) {\n+            if (currentIds != null) {\n+                indexCache.put(subQuery, currentIds);\n+            }\n             close();\n         }\n-        return elementIterator.hasNext();\n+        return hasNext;\n     }\n \n     @Override\n     public JanusGraphElement next() {\n-        return this.elementIterator.next();\n+        if (!hasNext()) {\n+            throw new NoSuchElementException();\n+        }\n+        return elementIterator.next();\n     }\n \n+    /**\n+     * Close the iterator, stop timer and update profiler.\n+     *\n+     * Results shall not be put into cache because close() can be invoked before underlying\n+     * elementIterator is exhausted.\n+     */\n     @Override\n     public void close() {\n         if (isTimerRunning) {\n             assert currentIds != null;\n-            indexCache.put(subQuery, currentIds);\n             profiler.setResultSize(currentIds.size());\n             profiler.stopTimer();\n             isTimerRunning = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMDk2MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r491800960", "bodyText": "I don't have a strong opinion on this but if the ResultSetIterator itself is a CloseableIterator, would it make sense to enforce it's inner iterator to be closeable, too?", "author": "rngcntr", "createdAt": "2020-09-21T05:34:29Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/ResultSetIterator.java", "diffHunk": "@@ -36,7 +37,7 @@\n \n \n     public ResultSetIterator(Iterator<R> inner, int limit) {", "originalCommit": "70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyNjUxMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r492026513", "bodyText": "I actually indeed tried that at first, but I ended up changing a lot more classes, and then I gave up and kept it like this. Not because that is undoable, but because I want to keep initial changes simple. If people think that is the better way to go, I'll do that and amend this commit.", "author": "li-boxuan", "createdAt": "2020-09-21T13:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMDk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3NDM5Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r492474396", "bodyText": "Understood. As I said, I'm also happy with your solution but if someone has a different oppinion, please tell \ud83d\ude04", "author": "rngcntr", "createdAt": "2020-09-22T04:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMDk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIwNTQ3Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r499205472", "bodyText": "I made them auto-closeable as well. To correctly delegate Traversal.close(), I ended up refactoring/modifying many iterator classes.", "author": "li-boxuan", "createdAt": "2020-10-04T04:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMDk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzExNzgwMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r537117801", "bodyText": "@rngcntr Could be great if you could describe your thoughts a little bit, why should we force to accept CloseableIterator and not just Iterator. I'm still trying to review this PR, I guess I may miss some ideas / code style / patterns / etc. begind this logic. Also, I posted my thoughts here: #2218 (comment) . I may totally be wrong because I didn't research it and didn't spend much time reviewing this PR but for some reason, I feel that we can achieve better results if we don't enforce CloseableIterator to be an input and just force CloseableIterator to be be automatically closed when the last element is read.\nGoing in Javadoc to java.io.Closeable, it says:\n\nCloses this stream and releases any system resources associated with it. If the stream is already closed then invoking this method has no effect.\n\nWe do implement safe close method in SubqueryIterator and this method is automatically called when we read last element from elementIterator, so, I'm not sure why we are forcing CloseableIterator to be used everywhere even so it should be used just in a couple of places.\nCould be great to hear some thoughts about it.", "author": "porunov", "createdAt": "2020-12-06T20:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMDk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "a364ccbb704172326c38b2001e9c60720890bc61", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/ResultSetIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/ResultSetIterator.java\nindex f8f05ba70..d0356ab12 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/ResultSetIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/ResultSetIterator.java\n\n@@ -36,8 +35,8 @@ public class ResultSetIterator<R extends JanusGraphElement> implements Closeable\n     private int count;\n \n \n-    public ResultSetIterator(Iterator<R> inner, int limit) {\n-        this.iterator = CloseableIterator.asCloseable(inner);\n+    public ResultSetIterator(CloseableIterator<R> inner, int limit) {\n+        this.iterator = inner;\n         this.limit = limit;\n         count = 0;\n \n"}}, {"oid": "50251d59fbde80624b23168fa86391609559e7a7", "url": "https://github.com/JanusGraph/janusgraph/commit/50251d59fbde80624b23168fa86391609559e7a7", "message": "Fix SubqueryIterator close bug\n\nThis makes SubqueryIterator, LimitAdjustingIterator, and\nResultSetIterator implement CloseableIterator, and makes\nsure SubqueryIterator finishes properly.\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-26T07:11:33Z", "type": "forcePushed"}, {"oid": "70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "url": "https://github.com/JanusGraph/janusgraph/commit/70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "message": "Fix SubqueryIterator close bug\n\nThis makes SubqueryIterator, LimitAdjustingIterator, and\nResultSetIterator implement CloseableIterator, and makes\nsure SubqueryIterator finishes properly.\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-21T01:09:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk3MjY0Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r495972643", "bodyText": "I didn't spend much time checking the logic behind this class but from the first glance both solutions look error prone to me.\nThe first solution binds the logic to hasNext to add new elements to the cache (no one said that hasNext should always be executed before next or close methods, thus the solution is error prone).\nA new solution binds logic to close method which might be a little bit better but still looks error prone to me (if we don't call close method at all).\nI think it would be more correct to bind that logic to next method because only next method is responsible for retrieving new elements. Without calling next we can't collect necessary elements for our cache.\nI didn't had much time to think about another solution but what if we use a separate method, something like:\nprivate void cacheQueryIfNoMoreElementsAvailable(){\n    if (!elementIterator.hasNext() && currentIds != null) {\n        indexCache.put(subQuery, currentIds);\n        profiler.setResultSize(currentIds.size());\n        profiler.stopTimer();\n        isTimerRunning = false;\n    }\n}\n\nThan our next method could look like:\npublic JanusGraphElement next() {\n    JanusGraphElement element = this.elementIterator.next();\n    cacheQueryIfNoMoreElementsAvailable();\n    return element;\n}\n\nIn addition we can execute this method in the end of SubqueryIterator constructor just for cases when an index contains 0 elements.\nThat said, I didn't check the above soltuion and didn't think too much about it, thus I may missed something. Nevertheless, I would like to hear some opinions regarding it.", "author": "porunov", "createdAt": "2020-09-28T14:15:09Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java", "diffHunk": "@@ -88,9 +86,13 @@ public JanusGraphElement next() {\n     }\n \n     @Override\n-    public void close() throws Exception {\n+    public void close() {", "originalCommit": "70a4da19f659d4e319d4d4d9f1d8cb0f5f8b06d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwNjk2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r496006965", "bodyText": "Nice idea. I think stopping the timer in the close() method still would be useful in the try-with-resources statement, or when the user quits the iteration (although I cannot think of such a case where profiling is used). I think I might let next() method call hasNext() method, which in turn calls close() method when results are exhausted.\nIt also comes into my mind that the current solution has a bug: when the iteration is closed before iterating is over, we shouldn't put results into the cache, since the results are probably incomplete.", "author": "li-boxuan", "createdAt": "2020-09-28T14:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk3MjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NDI3NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r496064275", "bodyText": "Agree, so I assume the resulting code could look something like:\npublic class SubqueryIterator implements CloseableIterator<JanusGraphElement> {\n\n    private final JointIndexQuery.Subquery subQuery;\n\n    private final Cache<JointIndexQuery.Subquery, List<Object>> indexCache;\n\n    private final Iterator<? extends JanusGraphElement> elementIterator;\n\n    private List<Object> currentIds;\n\n    private QueryProfiler profiler;\n\n    private boolean isTimerRunning;\n\n    public SubqueryIterator(JointIndexQuery.Subquery subQuery, IndexSerializer indexSerializer, BackendTransaction tx,\n            Cache<JointIndexQuery.Subquery, List<Object>> indexCache, int limit,\n            Function<Object, ? extends JanusGraphElement> function, List<Object> otherResults) {\n        this.subQuery = subQuery;\n        this.indexCache = indexCache;\n        final List<Object> cacheResponse = indexCache.getIfPresent(subQuery);\n        final Stream<?> stream;\n        if (cacheResponse != null) {\n            stream = cacheResponse.stream();\n        } else {\n            try {\n                currentIds = new ArrayList<>();\n                profiler = QueryProfiler.startProfile(subQuery.getProfiler(), subQuery);\n                isTimerRunning = true;\n                stream = indexSerializer.query(subQuery, tx).peek(r -> currentIds.add(r));\n            } catch (final Exception e) {\n                throw new JanusGraphException(\"Could not call index\", e.getCause());\n            }\n        }\n        elementIterator = stream.filter(e -> otherResults == null || otherResults.contains(e)).limit(limit).map(function).map(r -> (JanusGraphElement) r).iterator();\n        cacheQueryIfNoMoreElementsAvailable();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return elementIterator.hasNext();\n    }\n\n    @Override\n    public JanusGraphElement next() {\n        JanusGraphElement element = this.elementIterator.next();\n        cacheQueryIfNoMoreElementsAvailable();\n        return element;\n    }\n\n    @Override\n    public void close() {\n        if (isTimerRunning) {\n            profiler.stopTimer();\n        }\n    }\n\n    private void cacheQueryIfNoMoreElementsAvailable(){\n        if (!elementIterator.hasNext() && currentIds != null) {\n            indexCache.put(subQuery, currentIds);\n            profiler.setResultSize(currentIds.size());\n            profiler.stopTimer();\n            isTimerRunning = false;\n        }\n    }\n}", "author": "porunov", "createdAt": "2020-09-28T16:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk3MjY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1973676c48d0d37ac42fd0bd317bf3c4edfc66bf", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\nindex fc1847778..305860ed7 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n\n@@ -74,22 +75,34 @@ public class SubqueryIterator implements CloseableIterator<JanusGraphElement> {\n \n     @Override\n     public boolean hasNext() {\n-        if (!elementIterator.hasNext()) {\n+        final boolean hasNext = elementIterator.hasNext();\n+        if (!hasNext) {\n+            if (currentIds != null) {\n+                indexCache.put(subQuery, currentIds);\n+            }\n             close();\n         }\n-        return elementIterator.hasNext();\n+        return hasNext;\n     }\n \n     @Override\n     public JanusGraphElement next() {\n-        return this.elementIterator.next();\n+        if (!hasNext()) {\n+            throw new NoSuchElementException();\n+        }\n+        return elementIterator.next();\n     }\n \n+    /**\n+     * Close the iterator, stop timer and update profiler.\n+     *\n+     * Results shall not be put into cache because close() can be invoked before underlying\n+     * elementIterator is exhausted.\n+     */\n     @Override\n     public void close() {\n         if (isTimerRunning) {\n             assert currentIds != null;\n-            indexCache.put(subQuery, currentIds);\n             profiler.setResultSize(currentIds.size());\n             profiler.stopTimer();\n             isTimerRunning = false;\n"}}, {"oid": "1973676c48d0d37ac42fd0bd317bf3c4edfc66bf", "url": "https://github.com/JanusGraph/janusgraph/commit/1973676c48d0d37ac42fd0bd317bf3c4edfc66bf", "message": "Fix SubqueryIterator close bug\n\nThis makes SubqueryIterator, LimitAdjustingIterator, and\nResultSetIterator implement CloseableIterator, and makes\nsure SubqueryIterator finishes properly.\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-01T02:46:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA1NDg3MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r498054871", "bodyText": "Don't forget to cache a query when the result is empty and nobody calls hasNext or next or close.", "author": "porunov", "createdAt": "2020-10-01T07:59:59Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java", "diffHunk": "@@ -73,24 +75,37 @@ public SubqueryIterator(JointIndexQuery.Subquery subQuery, IndexSerializer index\n \n     @Override\n     public boolean hasNext() {\n-        if (!elementIterator.hasNext() && currentIds != null) {\n-            indexCache.put(subQuery, currentIds);\n-            profiler.stopTimer();\n-            isTimerRunning = false;\n-            profiler.setResultSize(currentIds.size());\n+        final boolean hasNext = elementIterator.hasNext();\n+        if (!hasNext) {\n+            if (currentIds != null) {\n+                indexCache.put(subQuery, currentIds);\n+            }\n+            close();\n         }\n-        return elementIterator.hasNext();\n+        return hasNext;", "originalCommit": "1973676c48d0d37ac42fd0bd317bf3c4edfc66bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIwNDY5Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r499204697", "bodyText": "I am a bit against doing so because generally, I want to avoid running the real (and maybe costly) computation in the constructor itself, especially when nobody calls hasNext or next afterward. In this class, the iterator comes from an unfiltered iterator which intersects with otherResults. The intersection can be expensive. Thus, if nobody uses this iterator afterward, the \"pre-computation\" will be wasted.\nThat being said, in this class, we know the underlying stream is not lazy, which means in the constructor, the underlying index query already happens. Probably we want to cache all results in the constructor even if nobody uses iterator, or the iterator is used but not exhausted... However, if we don't consider the internal implementation of stream = indexSerializer.query(subQuery, tx).peek(r -> currentIds.add(r));, we should consider it as lazy and avoid eager fetching if no one calls hasNext or next IMO.", "author": "li-boxuan", "createdAt": "2020-10-04T04:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA1NDg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NDM2Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r499244367", "bodyText": "Great points! Totally makes sense.", "author": "porunov", "createdAt": "2020-10-04T13:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA1NDg3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a364ccbb704172326c38b2001e9c60720890bc61", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\nindex 305860ed7..556265913 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/SubqueryIterator.java\n\n@@ -74,35 +72,25 @@ public class SubqueryIterator implements CloseableIterator<JanusGraphElement> {\n     }\n \n     @Override\n-    public boolean hasNext() {\n-        final boolean hasNext = elementIterator.hasNext();\n-        if (!hasNext) {\n-            if (currentIds != null) {\n-                indexCache.put(subQuery, currentIds);\n-            }\n-            close();\n-        }\n-        return hasNext;\n-    }\n-\n-    @Override\n-    public JanusGraphElement next() {\n-        if (!hasNext()) {\n-            throw new NoSuchElementException();\n+    protected JanusGraphElement computeNext() {\n+        if (elementIterator.hasNext()) {\n+            return elementIterator.next();\n         }\n-        return elementIterator.next();\n+        close();\n+        return endOfData();\n     }\n \n     /**\n      * Close the iterator, stop timer and update profiler.\n-     *\n-     * Results shall not be put into cache because close() can be invoked before underlying\n-     * elementIterator is exhausted.\n+     * Put results into cache if the underlying elementIterator is exhausted.\n      */\n     @Override\n     public void close() {\n         if (isTimerRunning) {\n             assert currentIds != null;\n+            if (!elementIterator.hasNext()) {\n+                indexCache.put(subQuery, currentIds);\n+            }\n             profiler.setResultSize(currentIds.size());\n             profiler.stopTimer();\n             isTimerRunning = false;\n"}}, {"oid": "a364ccbb704172326c38b2001e9c60720890bc61", "url": "https://github.com/JanusGraph/janusgraph/commit/a364ccbb704172326c38b2001e9c60720890bc61", "message": "Make iterators auto-closeable and fix SubqueryIterator close bug\n\nThis makes a few iterators implement CloseableIterator, and makes\nsure SubqueryIterator finishes properly.\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-04T04:04:15Z", "type": "forcePushed"}, {"oid": "1c6c9e503a70d511f6b71c34519e2e57e52cdcd1", "url": "https://github.com/JanusGraph/janusgraph/commit/1c6c9e503a70d511f6b71c34519e2e57e52cdcd1", "message": "Make iterators auto-closeable and fix SubqueryIterator close bug\n\nChanges:\n\n1. Make a few iterators auto-closeable. Now traversal.close() can\nbe delegated to SubqueryIterator.\n2. Extract some logic from MultiDistinctOrderedIterator and use new\nMultiDistinctUnorderedIterator when orders are not given. This\nmakes the code cleaner and reduces the overhead of creating &\nmaintaining complex data structures.\n3. Make a few iterators extend CloseableAbstractIterator which in\nturn leverages Guava Iterator's computeNext method. Now, these\niterators don't need to explicitly write hasNext and next.\n4. Fix SubqueryIterator bug so that profiler is correctly stopped\nand results can be cached appropriately.\n\nThis commit does not:\n\n1. Make all iterators auto-closeable. It only refactors iterators on\nthe traversal -> SubqueryIterator chain so that traversal.close()\ncan be delegated.\n2. Refactor all iterators using computeNext method. Some iterators have\ncomplex internal logic thus I would like to leave them as they are\nin this commit. Generally, all iterators using nextInternal method\ncould be rewritten using computeNext which is much cleaner and\navoids eager-computing (fetches the first result in the constructor).\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-04T12:39:20Z", "type": "forcePushed"}, {"oid": "106f0c84c99e7fe2851a372b0917086d469dc1d2", "url": "https://github.com/JanusGraph/janusgraph/commit/106f0c84c99e7fe2851a372b0917086d469dc1d2", "message": "Make iterators auto-closeable and fix SubqueryIterator close bug\n\nChanges:\n\n1. Make a few iterators auto-closeable. Now traversal.close() can\nbe delegated to SubqueryIterator.\n2. Extract some logic from MultiDistinctOrderedIterator and use new\nMultiDistinctUnorderedIterator when orders are not given. This\nmakes the code cleaner and reduces the overhead of creating &\nmaintaining complex data structures.\n3. Make a few iterators extend CloseableAbstractIterator which in\nturn leverages Guava Iterator's computeNext method. Now, these\niterators don't need to explicitly write hasNext and next.\n4. Fix SubqueryIterator bug so that profiler is correctly stopped\nand results can be cached appropriately.\n\nThis commit does not:\n\n1. Make all iterators auto-closeable. It only refactors iterators on\nthe traversal -> SubqueryIterator chain so that traversal.close()\ncan be delegated.\n2. Refactor all iterators using computeNext method. Some iterators have\ncomplex internal logic thus I would like to leave them as they are\nin this commit. Generally, all iterators using nextInternal method\ncould be rewritten using computeNext which is much cleaner and\navoids eager-computing (fetches the first result in the constructor).\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-05T15:26:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjEzMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533106131", "bodyText": "Nit: One should avoid calling get(index) on plain lists. My suggestion is to use an iterator, which iterates over the iterators \ud83d\ude01", "author": "rngcntr", "createdAt": "2020-12-01T06:45:38Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class MultiIterator<E> extends CloseableAbstractIterator<E> {\n+\n+    private List<CloseableIterator<E>> iterators;\n+    private int current;\n+\n+    public MultiIterator(final List<CloseableIterator<E>> iterators) {\n+        Objects.requireNonNull(iterators);\n+        this.iterators = iterators;\n+    }\n+\n+    @Override\n+    protected E computeNext() {\n+        while (current < iterators.size()) {\n+            CloseableIterator<E> iterator = iterators.get(current);", "originalCommit": "106f0c84c99e7fe2851a372b0917086d469dc1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5Mjk3Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533392977", "bodyText": "That would be a bit more complicated because it requires two instance variables: a current iterator and an iterator of iterators (now we just have one int type instance variable). May I know why you think one should avoid calling get(index) on List?", "author": "li-boxuan", "createdAt": "2020-12-01T13:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQwMTQzMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533401432", "bodyText": "I guess that's because List isn't guaranteed to be ArrayList which supports Random Access in O(1) time. Thus, someone may for some reason pass LinkedList to the constructor of this class. If so, get operation will cost O(n) time instead of O(1) time. Making this loop to be O(n^2) time. That said, it depends on List implementation which is used here", "author": "porunov", "createdAt": "2020-12-01T13:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQwMjE5OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533402199", "bodyText": "I think that using a current iterator and an iterator of iterators is a more safer approach here or we can force to use ArrayList here. If we use ArrayList and not List in the constructor, the rest implementation can be the same", "author": "porunov", "createdAt": "2020-12-01T13:22:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQwMzU2OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533403568", "bodyText": "Thanks @porunov, that's exactly what I wanted to point out", "author": "rngcntr", "createdAt": "2020-12-01T13:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQwNDg0Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533404843", "bodyText": "However, I would prefer not to enforce ArrayList. Using an iterator over an arbitrary list should be equally es fast but maintains more flexibility. Especially in case we decide to switch back to List for some reason in the future.", "author": "rngcntr", "createdAt": "2020-12-01T13:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQwNjkwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533406905", "bodyText": "@rngcntr Agree with your points. Using iterator will have more sense here.", "author": "porunov", "createdAt": "2020-12-01T13:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjEzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c4a0ac68034e4c67d0d789b9673047e18560a572", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\nindex 6cbbbdeef..9101b84bf 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\n\n@@ -16,28 +16,30 @@ package org.janusgraph.graphdb.util;\n \n import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n \n+import java.util.Iterator;\n import java.util.List;\n import java.util.Objects;\n \n public class MultiIterator<E> extends CloseableAbstractIterator<E> {\n \n-    private List<CloseableIterator<E>> iterators;\n-    private int current;\n+    private Iterator<CloseableIterator<E>> listIterator;\n+    private CloseableIterator<E> currentIterator;\n \n     public MultiIterator(final List<CloseableIterator<E>> iterators) {\n         Objects.requireNonNull(iterators);\n-        this.iterators = iterators;\n+        listIterator = iterators.iterator();\n     }\n \n     @Override\n     protected E computeNext() {\n-        while (current < iterators.size()) {\n-            CloseableIterator<E> iterator = iterators.get(current);\n-            if (iterator.hasNext()) {\n-                return iterator.next();\n+        while (currentIterator != null || listIterator.hasNext()) {\n+            if (currentIterator == null) {\n+                currentIterator = listIterator.next();\n+            } else if (currentIterator.hasNext()) {\n+                return currentIterator.next();\n             } else {\n-                iterator.close();\n-                current++;\n+                currentIterator.close();\n+                currentIterator = null;\n             }\n         }\n         return endOfData();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNjk0Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533106946", "bodyText": "same", "author": "rngcntr", "createdAt": "2020-12-01T06:48:01Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class MultiIterator<E> extends CloseableAbstractIterator<E> {\n+\n+    private List<CloseableIterator<E>> iterators;\n+    private int current;\n+\n+    public MultiIterator(final List<CloseableIterator<E>> iterators) {\n+        Objects.requireNonNull(iterators);\n+        this.iterators = iterators;\n+    }\n+\n+    @Override\n+    protected E computeNext() {\n+        while (current < iterators.size()) {\n+            CloseableIterator<E> iterator = iterators.get(current);\n+            if (iterator.hasNext()) {\n+                return iterator.next();\n+            } else {\n+                iterator.close();\n+                current++;\n+            }\n+        }\n+        return endOfData();\n+    }\n+\n+    @Override\n+    public void close() {\n+        for (int i = current; i < iterators.size(); i++) {\n+            iterators.get(i).close();", "originalCommit": "106f0c84c99e7fe2851a372b0917086d469dc1d2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c4a0ac68034e4c67d0d789b9673047e18560a572", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\nindex 6cbbbdeef..9101b84bf 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\n\n@@ -16,28 +16,30 @@ package org.janusgraph.graphdb.util;\n \n import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n \n+import java.util.Iterator;\n import java.util.List;\n import java.util.Objects;\n \n public class MultiIterator<E> extends CloseableAbstractIterator<E> {\n \n-    private List<CloseableIterator<E>> iterators;\n-    private int current;\n+    private Iterator<CloseableIterator<E>> listIterator;\n+    private CloseableIterator<E> currentIterator;\n \n     public MultiIterator(final List<CloseableIterator<E>> iterators) {\n         Objects.requireNonNull(iterators);\n-        this.iterators = iterators;\n+        listIterator = iterators.iterator();\n     }\n \n     @Override\n     protected E computeNext() {\n-        while (current < iterators.size()) {\n-            CloseableIterator<E> iterator = iterators.get(current);\n-            if (iterator.hasNext()) {\n-                return iterator.next();\n+        while (currentIterator != null || listIterator.hasNext()) {\n+            if (currentIterator == null) {\n+                currentIterator = listIterator.next();\n+            } else if (currentIterator.hasNext()) {\n+                return currentIterator.next();\n             } else {\n-                iterator.close();\n-                current++;\n+                currentIterator.close();\n+                currentIterator = null;\n             }\n         }\n         return endOfData();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyMDMyMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r533120321", "bodyText": "Just an idea: For large sets it can be quite inefficient to perform this check, because hash sets are not cache friendly at all. So before this check, one could query a bloom filter. If the filter says that this element is new, the check can be skipped.\nOn the downside, we would still need to collect the elements in allElements so insertions would still consume as much time as before. Therefore I'm not sure how significant a change like this would be.\nThis is just a general consideration and has nothing to do with your PR. So feel free to dismiss it \ud83d\ude04", "author": "rngcntr", "createdAt": "2020-12-01T07:24:06Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiDistinctUnorderedIterator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class MultiDistinctUnorderedIterator<E> extends CloseableAbstractIterator<E> {\n+\n+    private final Set<E> allElements = new HashSet<E>();\n+    private final CloseableIterator<E> iterator;\n+    private final int limit;\n+    private long count;\n+\n+    public MultiDistinctUnorderedIterator(final int lowLimit, final int highLimit, final List<CloseableIterator<E>> iterators) {\n+        Objects.requireNonNull(iterators);\n+        iterator = IteratorUtils.concat(iterators);\n+        limit = highLimit;\n+\n+        long i = 0;\n+        while (i < lowLimit && hasNext()) {\n+            next();\n+            i++;\n+        }\n+    }\n+\n+    @Override\n+    protected E computeNext() {\n+        if (count < limit) {\n+            while (iterator.hasNext()) {\n+                E elem = iterator.next();\n+                if (!allElements.contains(elem)) {", "originalCommit": "106f0c84c99e7fe2851a372b0917086d469dc1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI0NzYyNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r534247627", "bodyText": "Sounds interesting. My intuition is that would be even slower, but worth giving it a try. If I got some time I'll do some experiments and probably open up a new issue.", "author": "li-boxuan", "createdAt": "2020-12-02T15:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyMDMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2NDg0Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r534264846", "bodyText": "Also, a small nitpick, why not to add elem to the set instead of checking for its existence and then adding it to the set?\nI.e. the next code is 1 line shorted and doesn't call contains operation:\nif(allElements.add(elem)){\n  count++;\n  return elem;\n}\n\nThat said, I didn't check if bloom filter is actually faster for this logic or not. Not sure about that", "author": "porunov", "createdAt": "2020-12-02T15:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyMDMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDcxNzkxNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r534717915", "bodyText": "@porunov With your idea implemented, I'm now pretty sure a bloom filter would just cause overhead here. Even with one, either contains or add would be called anyway, so I don't see an improvement there anymore.", "author": "rngcntr", "createdAt": "2020-12-03T06:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyMDMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b2a4781db5a3a17a370e8d855d1b692ee1774a05", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiDistinctUnorderedIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiDistinctUnorderedIterator.java\nindex 4fec6f257..276503e9f 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiDistinctUnorderedIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiDistinctUnorderedIterator.java\n\n@@ -45,8 +45,7 @@ public class MultiDistinctUnorderedIterator<E> extends CloseableAbstractIterator\n         if (count < limit) {\n             while (iterator.hasNext()) {\n                 E elem = iterator.next();\n-                if (!allElements.contains(elem)) {\n-                    allElements.add(elem);\n+                if (allElements.add(elem)) {\n                     count++;\n                     return elem;\n                 }\n"}}, {"oid": "c4a0ac68034e4c67d0d789b9673047e18560a572", "url": "https://github.com/JanusGraph/janusgraph/commit/c4a0ac68034e4c67d0d789b9673047e18560a572", "message": "Make iterators auto-closeable and fix SubqueryIterator close bug\n\nChanges:\n\n1. Make a few iterators auto-closeable. Now traversal.close() can\nbe delegated to SubqueryIterator.\n2. Extract some logic from MultiDistinctOrderedIterator and use new\nMultiDistinctUnorderedIterator when orders are not given. This\nmakes the code cleaner and reduces the overhead of creating &\nmaintaining complex data structures.\n3. Make a few iterators extend CloseableAbstractIterator which in\nturn leverages Guava Iterator's computeNext method. Now, these\niterators don't need to explicitly write hasNext and next.\n4. Fix SubqueryIterator bug so that profiler is correctly stopped\nand results can be cached appropriately.\n\nThis commit does not:\n\n1. Make all iterators auto-closeable. It only refactors iterators on\nthe traversal -> SubqueryIterator chain so that traversal.close()\ncan be delegated.\n2. Refactor all iterators using computeNext method. Some iterators have\ncomplex internal logic thus I would like to leave them as they are\nin this commit. Generally, all iterators using nextInternal method\ncould be rewritten using computeNext which is much cleaner and\navoids eager-computing (fetches the first result in the constructor).\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-12-02T15:11:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDc5Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r534274796", "bodyText": "I've seen you used IteratorUtils.concat(iterators);. Will it be easier to manage MultiIterator with IteratorUtils.concat(iterators); or did you create it for some other purposes (like better performance, less overhead or something like that)?", "author": "porunov", "createdAt": "2020-12-02T15:50:12Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java", "diffHunk": "@@ -0,0 +1,59 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class MultiIterator<E> extends CloseableAbstractIterator<E> {\n+\n+    private Iterator<CloseableIterator<E>> listIterator;\n+    private CloseableIterator<E> currentIterator;\n+\n+    public MultiIterator(final List<CloseableIterator<E>> iterators) {\n+        Objects.requireNonNull(iterators);\n+        listIterator = iterators.iterator();", "originalCommit": "c4a0ac68034e4c67d0d789b9673047e18560a572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYwNjg2OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r534606869", "bodyText": "In fact that is the reason why MultiIterator was created at the first place:\npublic static <T> CloseableIterator<T> concat(final List<CloseableIterator<T>> iterators) {\n    return new MultiIterator<T>(iterators);\n}", "author": "li-boxuan", "createdAt": "2020-12-03T01:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzExMTI1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2218#discussion_r537111253", "bodyText": "Yap, I missed that. Now I see the purpose of this class. I'm just thinking if we can somehow reuse already existent general functionality instead of introducing our own implementation and then support it.\nI know we have #2033 but I don't see it to be resolved anytime soon. Thus, I think, in case we don't have better alternatives for some functionality, it's okay to use that functionality from Guava.\nFor example, Guava already has this concat functionality in Iterators. So, basically you would be able to do something like this:\npublic static <T> CloseableIterator<T> concat(final List<CloseableIterator<T>> iterators) {\n    return Iterators.concat(iterators.iterator());\n}\n\nInstead of supporting this MultiIterator, but I see that MultiIterator not just concat iterators as Iterators.concat does, but also closes iterators which don't have any value anymore.\nSo, I was thinking, if it is right. I'm not sure yet. Maybe it is a correct implementation but for me it's a little bit confusing.\nMy confusion is that it's not clear, when exactly we trigger close for CloseableIterator. Looking in this PR I see that some Iterators automatically trigger close after the last element they read but some Iterators don't trigger this logic and expect external logic to trigger close for them (like LimitAdjustingIterator).\nI need to look at this PR a little bit more deeply. I have a small feeling that we can remove our concat implementation and if each Iterator which implements CloseableIterator would close itself automatically, then we don't need to pass CloseableIterator iterator everywhere and we don't need to wrap Iterator as CloseableIterator when it doesn't have anything to close. That said, I could be completely wrong, I just didn't check the full PR yet.", "author": "porunov", "createdAt": "2020-12-06T19:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "fe145a5576ebcc844b70ca182d719f19fc05e7b6", "chunk": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\nindex 9101b84bf..69fe58c58 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/MultiIterator.java\n\n@@ -22,10 +22,10 @@ import java.util.Objects;\n \n public class MultiIterator<E> extends CloseableAbstractIterator<E> {\n \n-    private Iterator<CloseableIterator<E>> listIterator;\n-    private CloseableIterator<E> currentIterator;\n+    private Iterator<Iterator<E>> listIterator;\n+    private Iterator<E> currentIterator;\n \n-    public MultiIterator(final List<CloseableIterator<E>> iterators) {\n+    public MultiIterator(final List<Iterator<E>> iterators) {\n         Objects.requireNonNull(iterators);\n         listIterator = iterators.iterator();\n     }\n"}}, {"oid": "b2a4781db5a3a17a370e8d855d1b692ee1774a05", "url": "https://github.com/JanusGraph/janusgraph/commit/b2a4781db5a3a17a370e8d855d1b692ee1774a05", "message": "Make iterators auto-closeable and fix SubqueryIterator close bug\n\nChanges:\n\n1. Make a few iterators auto-closeable. Now traversal.close() can\nbe delegated to SubqueryIterator.\n2. Extract some logic from MultiDistinctOrderedIterator and use new\nMultiDistinctUnorderedIterator when orders are not given. This\nmakes the code cleaner and reduces the overhead of creating &\nmaintaining complex data structures.\n3. Make a few iterators extend CloseableAbstractIterator which in\nturn leverages Guava Iterator's computeNext method. Now, these\niterators don't need to explicitly write hasNext and next.\n4. Fix SubqueryIterator bug so that profiler is correctly stopped\nand results can be cached appropriately.\n\nThis commit does not:\n\n1. Make all iterators auto-closeable. It only refactors iterators on\nthe traversal -> SubqueryIterator chain so that traversal.close()\ncan be delegated.\n2. Refactor all iterators using computeNext method. Some iterators have\ncomplex internal logic thus I would like to leave them as they are\nin this commit. Generally, all iterators using nextInternal method\ncould be rewritten using computeNext which is much cleaner and\navoids eager-computing (fetches the first result in the constructor).\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-12-03T01:59:45Z", "type": "commit"}, {"oid": "b2a4781db5a3a17a370e8d855d1b692ee1774a05", "url": "https://github.com/JanusGraph/janusgraph/commit/b2a4781db5a3a17a370e8d855d1b692ee1774a05", "message": "Make iterators auto-closeable and fix SubqueryIterator close bug\n\nChanges:\n\n1. Make a few iterators auto-closeable. Now traversal.close() can\nbe delegated to SubqueryIterator.\n2. Extract some logic from MultiDistinctOrderedIterator and use new\nMultiDistinctUnorderedIterator when orders are not given. This\nmakes the code cleaner and reduces the overhead of creating &\nmaintaining complex data structures.\n3. Make a few iterators extend CloseableAbstractIterator which in\nturn leverages Guava Iterator's computeNext method. Now, these\niterators don't need to explicitly write hasNext and next.\n4. Fix SubqueryIterator bug so that profiler is correctly stopped\nand results can be cached appropriately.\n\nThis commit does not:\n\n1. Make all iterators auto-closeable. It only refactors iterators on\nthe traversal -> SubqueryIterator chain so that traversal.close()\ncan be delegated.\n2. Refactor all iterators using computeNext method. Some iterators have\ncomplex internal logic thus I would like to leave them as they are\nin this commit. Generally, all iterators using nextInternal method\ncould be rewritten using computeNext which is much cleaner and\navoids eager-computing (fetches the first result in the constructor).\n\nFixes #2217\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-12-03T01:59:45Z", "type": "forcePushed"}, {"oid": "fe145a5576ebcc844b70ca182d719f19fc05e7b6", "url": "https://github.com/JanusGraph/janusgraph/commit/fe145a5576ebcc844b70ca182d719f19fc05e7b6", "message": "Reduce wrappings of iterators to closable iterators\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-12-20T21:27:41Z", "type": "forcePushed"}, {"oid": "267f18987b2b4605fe21572451e3e7854e492056", "url": "https://github.com/JanusGraph/janusgraph/commit/267f18987b2b4605fe21572451e3e7854e492056", "message": "Reduce wrappings of iterators to closable iterators\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-12-20T21:34:12Z", "type": "forcePushed"}, {"oid": "4a7db78cdbe9cea61966ff98a716d67249218877", "url": "https://github.com/JanusGraph/janusgraph/commit/4a7db78cdbe9cea61966ff98a716d67249218877", "message": "Reduce wrappings of iterators to closable iterators\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-12-20T21:37:55Z", "type": "forcePushed"}, {"oid": "166c22ba97ebf5589aa87baa642b035e7d846ec8", "url": "https://github.com/JanusGraph/janusgraph/commit/166c22ba97ebf5589aa87baa642b035e7d846ec8", "message": "Reduce wrappings of iterators to closable iterators\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-12-20T21:57:31Z", "type": "commit"}, {"oid": "166c22ba97ebf5589aa87baa642b035e7d846ec8", "url": "https://github.com/JanusGraph/janusgraph/commit/166c22ba97ebf5589aa87baa642b035e7d846ec8", "message": "Reduce wrappings of iterators to closable iterators\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-12-20T21:57:31Z", "type": "forcePushed"}]}