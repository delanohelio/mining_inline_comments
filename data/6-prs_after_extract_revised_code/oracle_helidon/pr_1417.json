{"pr_number": 1417, "pr_title": "Config change support refactoring", "pr_createdAt": "2020-02-20T16:57:07Z", "pr_url": "https://github.com/oracle/helidon/pull/1417", "timeline": [{"oid": "45081c1047d4c0ba7d7361e862bad77825e5941b", "url": "https://github.com/oracle/helidon/commit/45081c1047d4c0ba7d7361e862bad77825e5941b", "message": "Checkstyle fixed.", "committedDate": "2020-02-20T17:00:51Z", "type": "forcePushed"}, {"oid": "9c23c216fb8af2ff8933246060731c8eb0d11daa", "url": "https://github.com/oracle/helidon/commit/9c23c216fb8af2ff8933246060731c8eb0d11daa", "message": "Documentation + javadoc fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T13:40:55Z", "type": "forcePushed"}, {"oid": "fc748ee5d8d50e19e10fa2e4ef679d5ea7f3bb03", "url": "https://github.com/oracle/helidon/commit/fc748ee5d8d50e19e10fa2e4ef679d5ea7f3bb03", "message": "Removal of project Reactor.", "committedDate": "2020-02-26T18:03:38Z", "type": "commit"}, {"oid": "4371352b89cfa17393913d7ba0bf178c8ca83675", "url": "https://github.com/oracle/helidon/commit/4371352b89cfa17393913d7ba0bf178c8ca83675", "message": "Change support refactoring.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:03:38Z", "type": "commit"}, {"oid": "92b8ae69dabc68f13ee79574de97d958375ab227", "url": "https://github.com/oracle/helidon/commit/92b8ae69dabc68f13ee79574de97d958375ab227", "message": "Big change polling + changes + lazy etc.", "committedDate": "2020-02-26T18:03:39Z", "type": "commit"}, {"oid": "3992111265dee49533c943c0289f025852d21695", "url": "https://github.com/oracle/helidon/commit/3992111265dee49533c943c0289f025852d21695", "message": "Big change polling + changes + lazy etc.", "committedDate": "2020-02-26T18:03:40Z", "type": "commit"}, {"oid": "f2456646a1ba92bafd3206c646a3870067910d89", "url": "https://github.com/oracle/helidon/commit/f2456646a1ba92bafd3206c646a3870067910d89", "message": "File and map sources.", "committedDate": "2020-02-26T18:03:41Z", "type": "commit"}, {"oid": "bd1476ac2b460f69d4ecd130679ee21e5bd5b5b8", "url": "https://github.com/oracle/helidon/commit/bd1476ac2b460f69d4ecd130679ee21e5bd5b5b8", "message": "All config source types", "committedDate": "2020-02-26T18:03:42Z", "type": "commit"}, {"oid": "64af0409503120e3b46e59150d128ad149287f35", "url": "https://github.com/oracle/helidon/commit/64af0409503120e3b46e59150d128ad149287f35", "message": "moving...", "committedDate": "2020-02-26T18:03:43Z", "type": "commit"}, {"oid": "fcf3bad4feb4e506717825fe0bea4626978dfc3a", "url": "https://github.com/oracle/helidon/commit/fcf3bad4feb4e506717825fe0bea4626978dfc3a", "message": "another one", "committedDate": "2020-02-26T18:03:43Z", "type": "commit"}, {"oid": "623be09ffaf8417827c5fdd7a0b020f0e1745a0c", "url": "https://github.com/oracle/helidon/commit/623be09ffaf8417827c5fdd7a0b020f0e1745a0c", "message": "fff\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:03:44Z", "type": "commit"}, {"oid": "7ac6656309092e0af25fcce349cb122aeb9f6cff", "url": "https://github.com/oracle/helidon/commit/7ac6656309092e0af25fcce349cb122aeb9f6cff", "message": "ggg\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:03:45Z", "type": "commit"}, {"oid": "f24730bf321cd9aaf03bb6a7150bbf43342dc783", "url": "https://github.com/oracle/helidon/commit/f24730bf321cd9aaf03bb6a7150bbf43342dc783", "message": "aaa", "committedDate": "2020-02-26T18:03:45Z", "type": "commit"}, {"oid": "e9508dfca8449f9c36e48b03321ae3ca7843189e", "url": "https://github.com/oracle/helidon/commit/e9508dfca8449f9c36e48b03321ae3ca7843189e", "message": "bbb\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:03:46Z", "type": "commit"}, {"oid": "0baaecf719b7ddea83580d4a5d22fd7b793cda84", "url": "https://github.com/oracle/helidon/commit/0baaecf719b7ddea83580d4a5d22fd7b793cda84", "message": "uuu", "committedDate": "2020-02-26T18:03:47Z", "type": "commit"}, {"oid": "f1d0b6f7c31bda5a302bac7d7905e9d51e1a48da", "url": "https://github.com/oracle/helidon/commit/f1d0b6f7c31bda5a302bac7d7905e9d51e1a48da", "message": "ccc\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:03:48Z", "type": "commit"}, {"oid": "f5c1b6704a94023a83e1b6299cdf3f9f3d259ba5", "url": "https://github.com/oracle/helidon/commit/f5c1b6704a94023a83e1b6299cdf3f9f3d259ba5", "message": "vvv", "committedDate": "2020-02-26T18:03:49Z", "type": "commit"}, {"oid": "b4161e40e743cca6d09ea3db05456c1645ff6a57", "url": "https://github.com/oracle/helidon/commit/b4161e40e743cca6d09ea3db05456c1645ff6a57", "message": "www", "committedDate": "2020-02-26T18:04:02Z", "type": "commit"}, {"oid": "c374cda802f9973de971de372beb731772b8ec2b", "url": "https://github.com/oracle/helidon/commit/c374cda802f9973de971de372beb731772b8ec2b", "message": "ddd\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:04:02Z", "type": "commit"}, {"oid": "4d8445371dd47beceea5975c0edbf30176061dcd", "url": "https://github.com/oracle/helidon/commit/4d8445371dd47beceea5975c0edbf30176061dcd", "message": "eee\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:04:03Z", "type": "commit"}, {"oid": "6ba007f766cc041261eebdf630c107d727bbbe64", "url": "https://github.com/oracle/helidon/commit/6ba007f766cc041261eebdf630c107d727bbbe64", "message": "xxx", "committedDate": "2020-02-26T18:04:03Z", "type": "commit"}, {"oid": "b6180c143d7aae356c7df1a5a950067ae369401c", "url": "https://github.com/oracle/helidon/commit/b6180c143d7aae356c7df1a5a950067ae369401c", "message": "Config core works.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:04:04Z", "type": "commit"}, {"oid": "199f757860e24f46303b9ddfda3eaa8f0bf3a41b", "url": "https://github.com/oracle/helidon/commit/199f757860e24f46303b9ddfda3eaa8f0bf3a41b", "message": "yyy", "committedDate": "2020-02-26T18:04:05Z", "type": "commit"}, {"oid": "f2caaab1967a9a70289d6cd4697eb0bc1cdea6b7", "url": "https://github.com/oracle/helidon/commit/f2caaab1967a9a70289d6cd4697eb0bc1cdea6b7", "message": "Everything but checkstyle and copyright.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:04:05Z", "type": "commit"}, {"oid": "2476b30225db9f1f4b642923bf6bb7ebcdee6447", "url": "https://github.com/oracle/helidon/commit/2476b30225db9f1f4b642923bf6bb7ebcdee6447", "message": "Checkstyle fixed.", "committedDate": "2020-02-26T18:04:05Z", "type": "commit"}, {"oid": "8938e772b4252fa98fc9d12b33267a3b590e226c", "url": "https://github.com/oracle/helidon/commit/8938e772b4252fa98fc9d12b33267a3b590e226c", "message": "Copyright fixes.", "committedDate": "2020-02-26T18:04:06Z", "type": "commit"}, {"oid": "1f34b723672c93850ac9eb490d5c87af576e57f8", "url": "https://github.com/oracle/helidon/commit/1f34b723672c93850ac9eb490d5c87af576e57f8", "message": "Copyright fixes.", "committedDate": "2020-02-26T18:04:06Z", "type": "commit"}, {"oid": "6869b6e2124481b27c6b615c4f556c24e0f4054e", "url": "https://github.com/oracle/helidon/commit/6869b6e2124481b27c6b615c4f556c24e0f4054e", "message": "Documentation + javadoc fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:04:07Z", "type": "commit"}, {"oid": "53d52349696f5b7ec4004e49065f4c32a8429399", "url": "https://github.com/oracle/helidon/commit/53d52349696f5b7ec4004e49065f4c32a8429399", "message": "Better failure if timeout.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-26T18:04:08Z", "type": "commit"}, {"oid": "5b3328d390ff7e4fe0c464a36d21fcb86cffec89", "url": "https://github.com/oracle/helidon/commit/5b3328d390ff7e4fe0c464a36d21fcb86cffec89", "message": "Rebased, cleaned disabled tests.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-27T09:47:55Z", "type": "forcePushed"}, {"oid": "23e8d221d71445f12913435739fef10eb8cc4617", "url": "https://github.com/oracle/helidon/commit/23e8d221d71445f12913435739fef10eb8cc4617", "message": "Rebased, cleaned disabled tests.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-27T10:00:42Z", "type": "commit"}, {"oid": "23e8d221d71445f12913435739fef10eb8cc4617", "url": "https://github.com/oracle/helidon/commit/23e8d221d71445f12913435739fef10eb8cc4617", "message": "Rebased, cleaned disabled tests.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-02-27T10:00:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxOTE0MA==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385719140", "bodyText": "Could it be avoided by adding another from method?\n    static ListNodeBuilderImpl from(ListNode elements, Function<String, String> resolveTokenFunction) {\n        ListNodeBuilderImpl builder = new ListNodeBuilderImpl(resolveTokenFunction);\n        elements.forEach(builder::addNode);\n        elements.value().ifPresent(builder::value);\n        return builder;\n    }", "author": "danielkec", "createdAt": "2020-02-28T14:18:19Z", "path": "config/config/src/main/java/io/helidon/config/ListNodeBuilderImpl.java", "diffHunk": "@@ -97,6 +97,13 @@ public ListNodeBuilderImpl value(String value) {\n         return this;\n     }\n \n+    // this is a shortcut method to keep current fluent code\n+    // even though value is now optional\n+    ListNodeBuilderImpl value(Optional<String> value) {\n+        value.ifPresent(this::value);\n+        return this;\n+    }", "originalCommit": "23e8d221d71445f12913435739fef10eb8cc4617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3MjYwOA==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388272608", "bodyText": "This method is called as fluent from multiple places that have different methods called.", "author": "tomas-langer", "createdAt": "2020-03-05T12:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxOTE0MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0NzUwMQ==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385747501", "bodyText": "List<ObjectNode> objectNodes = loadedData.stream()\n                .map(RuntimeWithData::data)\n                .flatMap(Optional::stream)\n                .collect(Collectors.toList());", "author": "danielkec", "createdAt": "2020-02-28T15:09:35Z", "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());", "originalCommit": "23e8d221d71445f12913435739fef10eb8cc4617", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "baa078701de5d30433607e1c4ef9d9baf8a3b1f1", "chunk": "diff --git a/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java b/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\nindex dcfcc4637..cb7704e1c 100644\n--- a/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\n+++ b/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\n\n@@ -129,8 +129,7 @@ final class ConfigSourcesRuntime {\n     synchronized Optional<ObjectNode> latest() {\n         List<ObjectNode> objectNodes = loadedData.stream()\n                 .map(RuntimeWithData::data)\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n+                .flatMap(Optional::stream)\n                 .collect(Collectors.toList());\n \n         return Optional.of(mergingStrategy.merge(objectNodes));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDQ5NA==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385750494", "bodyText": "Optional is such ... \ud83d\ude1e\n.flatMap(Optional::stream)\n.flatMap(this::streamKeys)", "author": "danielkec", "createdAt": "2020-02-28T15:14:47Z", "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+\n+        return Optional.of(mergingStrategy.merge(objectNodes));\n+    }\n+\n+    synchronized Optional<ObjectNode> load() {\n+\n+        for (ConfigSourceRuntimeBase source : allSources) {\n+            if (source.isLazy()) {\n+                loadedData.add(new RuntimeWithData(source, Optional.empty()));\n+            } else {\n+                loadedData.add(new RuntimeWithData(source, source.load()\n+                        .map(ObjectNodeImpl::wrap)\n+                        .map(objectNode -> objectNode.initDescription(source.description()))));\n+            }\n+        }\n+\n+        Set<String> allKeys = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .flatMap(this::streamKeys)\n+                .collect(Collectors.toSet());", "originalCommit": "23e8d221d71445f12913435739fef10eb8cc4617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3MzEzOQ==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388273139", "bodyText": "Fixing.", "author": "tomas-langer", "createdAt": "2020-03-05T12:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDQ5NA=="}], "type": "inlineReview", "revised_code": {"commit": "baa078701de5d30433607e1c4ef9d9baf8a3b1f1", "chunk": "diff --git a/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java b/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\nindex dcfcc4637..cb7704e1c 100644\n--- a/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\n+++ b/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\n\n@@ -129,8 +129,7 @@ final class ConfigSourcesRuntime {\n     synchronized Optional<ObjectNode> latest() {\n         List<ObjectNode> objectNodes = loadedData.stream()\n                 .map(RuntimeWithData::data)\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n+                .flatMap(Optional::stream)\n                 .collect(Collectors.toList());\n \n         return Optional.of(mergingStrategy.merge(objectNodes));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDg1MA==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385750850", "bodyText": "same", "author": "danielkec", "createdAt": "2020-02-28T15:15:24Z", "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+\n+        return Optional.of(mergingStrategy.merge(objectNodes));\n+    }\n+\n+    synchronized Optional<ObjectNode> load() {\n+\n+        for (ConfigSourceRuntimeBase source : allSources) {\n+            if (source.isLazy()) {\n+                loadedData.add(new RuntimeWithData(source, Optional.empty()));\n+            } else {\n+                loadedData.add(new RuntimeWithData(source, source.load()\n+                        .map(ObjectNodeImpl::wrap)\n+                        .map(objectNode -> objectNode.initDescription(source.description()))));\n+            }\n+        }\n+\n+        Set<String> allKeys = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .flatMap(this::streamKeys)\n+                .collect(Collectors.toSet());\n+\n+        if (allKeys.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        // now we have all the keys, let's load them from the lazy sources\n+        for (RuntimeWithData data : loadedData) {\n+            if (data.runtime().isLazy()) {\n+                data.data(loadLazy(data.runtime(), allKeys));\n+            }\n+        }\n+\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)", "originalCommit": "23e8d221d71445f12913435739fef10eb8cc4617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3MzM3Mw==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388273373", "bodyText": "Fixing", "author": "tomas-langer", "createdAt": "2020-03-05T12:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3NDQzNg==", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388274436", "bodyText": "Also fixing in all other classes this was used.", "author": "tomas-langer", "createdAt": "2020-03-05T12:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDg1MA=="}], "type": "inlineReview", "revised_code": {"commit": "baa078701de5d30433607e1c4ef9d9baf8a3b1f1", "chunk": "diff --git a/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java b/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\nindex dcfcc4637..cb7704e1c 100644\n--- a/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\n+++ b/config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java\n\n@@ -129,8 +129,7 @@ final class ConfigSourcesRuntime {\n     synchronized Optional<ObjectNode> latest() {\n         List<ObjectNode> objectNodes = loadedData.stream()\n                 .map(RuntimeWithData::data)\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n+                .flatMap(Optional::stream)\n                 .collect(Collectors.toList());\n \n         return Optional.of(mergingStrategy.merge(objectNodes));\n"}}, {"oid": "71c114b44f9b4d38440dc08d832b5fec6029cfd4", "url": "https://github.com/oracle/helidon/commit/71c114b44f9b4d38440dc08d832b5fec6029cfd4", "message": "Fix SE native image test.", "committedDate": "2020-03-04T16:13:34Z", "type": "commit"}, {"oid": "baa078701de5d30433607e1c4ef9d9baf8a3b1f1", "url": "https://github.com/oracle/helidon/commit/baa078701de5d30433607e1c4ef9d9baf8a3b1f1", "message": "Review comments incorporated.", "committedDate": "2020-03-05T12:56:32Z", "type": "commit"}, {"oid": "73bea275904651d00a4dc43c8b49ced0a0de05aa", "url": "https://github.com/oracle/helidon/commit/73bea275904651d00a4dc43c8b49ced0a0de05aa", "message": "Copyright fix", "committedDate": "2020-03-05T13:04:46Z", "type": "commit"}, {"oid": "10cf7c4d8f92b6eb48d09b8025fd7663f690bead", "url": "https://github.com/oracle/helidon/commit/10cf7c4d8f92b6eb48d09b8025fd7663f690bead", "message": "Intermittent failure fix", "committedDate": "2020-03-05T14:37:51Z", "type": "commit"}, {"oid": "28511b388554b2be7df8fc3d9f5eda79871b66c3", "url": "https://github.com/oracle/helidon/commit/28511b388554b2be7df8fc3d9f5eda79871b66c3", "message": "Changelog update.", "committedDate": "2020-03-05T16:41:06Z", "type": "commit"}, {"oid": "3e0905bcf341ba4d6e36476f954b041f2df7a70f", "url": "https://github.com/oracle/helidon/commit/3e0905bcf341ba4d6e36476f954b041f2df7a70f", "message": "Fixed intermittent test failure - race condition.", "committedDate": "2020-03-05T17:01:49Z", "type": "commit"}]}