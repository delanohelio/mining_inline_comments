{"pr_number": 1574, "pr_title": "[JBTM-3270] tracking persisted REST-AT participant ", "pr_createdAt": "2020-03-27T12:42:50Z", "pr_url": "https://github.com/jbosstm/narayana/pull/1574", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r399363577", "bodyText": "If the remove_committed call throws an exception then since the participantId is still in the map the code inside the if will be executed on every recovery pass and an exception will appear in the log on every pass. How about the following code instead:\n        if (committedParticipants.remove(participantId) != null) {\n            // the key was in the map and it has now been removed\n            try {\n                recoveryStore.remove_committed etc", "author": "mmusgrov", "createdAt": "2020-03-27T15:50:23Z", "path": "rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java", "diffHunk": "@@ -93,12 +101,15 @@ public void removeParticipantInformation(final ParticipantInformation participan\n         }\n \n         final RecoveryStore recoveryStore = StoreManager.getRecoveryStore();\n-        final Uid uid = new Uid(participantInformation.getId());\n+        String participantId = participantInformation.getId();\n \n-        try {\n-            recoveryStore.remove_committed(uid, PARTICIPANT_INFORMATION_RECORD_TYPE);\n-        } catch (ObjectStoreException e) {\n-            LOG.warn(\"Failure while removing participant information from the object store.\", e);\n+        if(committedParticipants.get(participantId) != null) {\n+            try {\n+                recoveryStore.remove_committed(new Uid(participantId), PARTICIPANT_INFORMATION_RECORD_TYPE);\n+                committedParticipants.remove(participantId);\n+            } catch (ObjectStoreException e) {\n+                LOG.warn(\"Failure while removing participant information from the object store.\", e);", "originalCommit": "0f53113255553c019c0461c4c0049a2ef7ab4190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE0Mzk5Mw==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400143993", "bodyText": "I think the record should not be removed from the map if the remove_committed fails. It means that the object store was not updated. It's important to ensure to really cleaning the object store in the next attempt. The warning sounds correct here as it's needed to warn the user that the participant could not be removed because of some internal failure, probably on the storage.", "author": "ochaloup", "createdAt": "2020-03-30T12:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI4OTc4NQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400289785", "bodyText": "The record will not be removed. However subsequent attempts to remove it will not be attempted (if we failed once then it is likely to continually fail). The way you have it coded is that if the remove fails the warning will appear in the log on every recovery pass. A single WARNING in the log should be sufficient for notifying the user about this error.", "author": "mmusgrov", "createdAt": "2020-03-30T15:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc4MzY1Ng==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400783656", "bodyText": "I really don't agree on this strategy. When a record is not removed from the log then it's the Narayana strategy to inform the user about the consistent failure.\nMy idea is to really let the warning being printed on every recovery pass.", "author": "ochaloup", "createdAt": "2020-03-31T09:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkxMzY5OA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400913698", "bodyText": "Normally we only continually report recovery failures when we are expecting recovery to happen and repeating warnings for that purpose is acceptable. But failing to delete file will most likely fail forevermore and the user only needs to be told about it once.", "author": "mmusgrov", "createdAt": "2020-03-31T13:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk4NDg0OQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400984849", "bodyText": "@mmusgrov - is it not possible to have a transient storage problem though? Perhaps we need to understand better why the remove is failing. But that might be better in some object store API change, like a return type that determines if the failure is expected to be transient or not.\nYour proposed change (in the first comment of this thread) does not look to be rendering fully to me (or Ondra already took that in). How do you propose to suppress subsequent warnings? I am not aware of a precedent to do that in Narayana so far. Doesn't the recovery manager report repeated failures to recover things? But if there are other examples of that let's evaluate as repeating the message at WARN at least might not be so useful (perhaps trace) and might be covered by wording the message that the failure will not be re-reported?\nBTW, given the current state of the patch (in that we only put it in the map when write_committed passes or it is recovered/recreated, I can't guess why remove_committed would throw an exception now but maybe there is something in the recover/recreated paths that would do that?", "author": "tomjenkinson", "createdAt": "2020-03-31T15:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAwNTUyMw==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401005523", "bodyText": "@mmusgrov I don't agree that user should be informed about the failure of the storage just once. When the storage is not cleaned the e.g. rollback operation will be retried. Probably with some error. Additional information that there is the trouble with removal is important part of the context.\n@tomjenkinson  the remove_committed is not expected to throw an exception in the current state of the patch. It just logs a warning that there is not a way to remove the record.", "author": "ochaloup", "createdAt": "2020-03-31T15:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA2NDQ2NA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401064464", "bodyText": "@ochaloup I guess Mike was trying to prevent was some outcome a bit like the following (and this is total pseudo log statements and pseudo code):\nwhile true {\n  // rest of the algorithm, then\n  \"Failure while removing participant information from the object store\" with a caused by of some permanent error like \"File does not exist\"\n}\n\nWhat I am not sure of whether that could ever be the case. And if it could, rather than suppressing the logging alone it would perhaps be better to consider what can cause the condition and deal with it in the algorithm to give a break out clause?", "author": "tomjenkinson", "createdAt": "2020-03-31T16:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA2NzI3OA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401067278", "bodyText": "@tomjenkinson the remove_committed is not expected to throw an exception in the current state of the patch. It just logs a warning that there is not a way to remove the record.\n\nResponding to this separate. I was not clear enough, let me rephrase: given the current state of the patch, I can't guess why there would be problem to remove the record but maybe there is something in the recover/recreated paths that would cause there to be a problem to remove it somehow?", "author": "tomjenkinson", "createdAt": "2020-03-31T16:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA3MTA5MQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401071091", "bodyText": "@tomjenkinson ok. maybe I understand, at least partially.\n@tomjenkinson @mmusgrov  First, for the understanding of the changes, please, consult the source code. Where the method is called from and what is the context it's called from.\nIt's quite possible I misunderstand something but if we are talking from start in some semi-real context it's something which I'm not able to follow and which makes my work pretty hard.\n@tomjenkinson the failure during removal is the same from any narayana submodule which uses the object store. There is some IO failure or some internal storage failure that makes impossible to remove the record. It's something which can't be handled by algorithm. And in case there is some adjustment possible then it has to be handled by the ObjectStore API in arjunacore not here in the rts/at module.", "author": "ochaloup", "createdAt": "2020-03-31T17:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA3Mzc2Ng==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401073766", "bodyText": "Thanks for clarifying @ochaloup. If the patch introduces no likelihood of causing the remove_committed to fail then I think changes to dealing with non-recoverable remove_committed errors should be dealt with as an RFE", "author": "tomjenkinson", "createdAt": "2020-03-31T17:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxMTM5MQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401711391", "bodyText": "@mmusgrov - is it not possible to have a transient storage problem though? Perhaps we need to understand better why the remove is failing. But that might be better in some object store API change, like a return type that determines if the failure is expected to be transient or not.\n\nYes it is most likely either a transient because the record has already been removed.\n\nYour proposed change (in the first comment of this thread) does not look to be rendering fully to me (or Ondra already took that in). How do you propose to suppress subsequent warnings? I am not aware of a precedent to do that in Narayana so far.\n\nMy suggested code first removed the participant from the volatile map and then called recoveryStore.remove_committed\nif (committedParticipants.remove(participantId) != null) {\n      // the key was in the map and it has now been removed\n      try {\n         recoveryStore.remove_committed\n         etc\nStandard recovery ought to pick up the record if it was indeed a transient (and if the failure is because the record isn't there then we don't need to keep retrying the remove).\nThere is no precedent since normal recovery is handled by periodic recovery where we do need to keep WARNing the user.\nAs Ondra points out, XTS does the same as what's in the PR. On that basis I could be overruled on this one.\n\nDoesn't the recovery manager report repeated failures to recover things? But if there are other examples of that let's evaluate as repeating the message at WARN at least might not be so useful (perhaps trace) and might be covered by wording the message that the failure will not be re-reported?\n\nThis is not periodic recovery. This is the REST-AT bridge cleaning up after it has finished processing a transaction.\nI would agree the second part of your statement (TRACE + a message that it will not continue reporting the WARNing).\n\nBTW, given the current state of the patch (in that we only put it in the map when write_committed passes or it is recovered/recreated, I can't guess why remove_committed would throw an exception now but maybe there is something in the recover/recreated paths that would do that?\n\nI agree that such a failure is unexpected and most likely would be because something/somebody has already deleted the record, in which case the repeated WARNing is not good. If the cause is a transient storage failure (for example the JDBC store could not be contacted) then perhaps a subsequent attempt at removal might succeed but what is the tradeoff of not deleting the log versus filling the log with duplicate WARNings. Not deleting the log should have no effect (question does this RecoveryManager have any interaction with the InboundBridgeRecoveryModule) until the JVM is restarted (when the local cache of committedParticipants is recreated from what's in the store).\nSo filling up log with repeated information that does not add any further value should be avoided.", "author": "mmusgrov", "createdAt": "2020-04-01T15:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjAyMQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401722021", "bodyText": "I am adding my approval of this PR on the following basis:\n\nXTS does the same as what's in this PR.\nThe error should may only ever occur each time an InboundBridgeManager is created (after a server restart) and after a transaction is finished.\nAs far as I can see this new code is not ran by Periodic Recovery so my concern about filling the logs on each recovery pass is not a valid concern.\n\nBut I'd still argue that my points made in the previous comment are still valid but not sufficient to block this PR.", "author": "mmusgrov", "createdAt": "2020-04-01T15:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MzU3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "44b4a810093d76ebd974b2de5463178295890261", "chunk": "diff --git a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\nindex 45a165d4e..20162880c 100644\n--- a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n+++ b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n\n@@ -107,8 +106,8 @@ public final class RecoveryManager {\n             try {\n                 recoveryStore.remove_committed(new Uid(participantId), PARTICIPANT_INFORMATION_RECORD_TYPE);\n                 committedParticipants.remove(participantId);\n-            } catch (ObjectStoreException e) {\n-                LOG.warn(\"Failure while removing participant information from the object store.\", e);\n+            } catch (ObjectStoreException ose) {\n+                LOG.warn(\"Failure while removing participant information from the object store.\", ose);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MjAwNw==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r399372007", "bodyText": "What does <Participant Id :: Uid> mean. It also starts a new sentence making it more confusing.\nIs it suggesting that the variable is\n* A map of participant ids to Uids for the purpose of keeping track of which participants\n* have been saved to the recovery store.\nAlso if you are going to make changes to this PR I would suggest using the same term for the store throughout (it currently contains three different names: persistent store, object store and recovery store)", "author": "mmusgrov", "createdAt": "2020-03-27T16:02:31Z", "path": "rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java", "diffHunk": "@@ -44,6 +45,11 @@\n \n     private final Map<String, ParticipantDeserializer> deserializers = new ConcurrentHashMap<String, ParticipantDeserializer>();\n \n+    /**\n+     * A map of participants saved in the persistent store. &lt;Participant Id :: Uid&gt;", "originalCommit": "0f53113255553c019c0461c4c0049a2ef7ab4190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE0NDI3MQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400144271", "bodyText": "Agree, thanks for the note. I updated the comments.", "author": "ochaloup", "createdAt": "2020-03-30T12:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MjAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "44b4a810093d76ebd974b2de5463178295890261", "chunk": "diff --git a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\nindex 45a165d4e..20162880c 100644\n--- a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n+++ b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n\n@@ -46,7 +45,7 @@ public final class RecoveryManager {\n     private final Map<String, ParticipantDeserializer> deserializers = new ConcurrentHashMap<String, ParticipantDeserializer>();\n \n     /**\n-     * A map of participants saved in the persistent store. &lt;Participant Id :: Uid&gt;\n+     * A map of participants persisted in the object store, it maps 'Participant Id' to 'Uid'\n      */\n     private final Map<String, Uid> committedParticipants = new ConcurrentHashMap<>();\n \n"}}, {"oid": "44b4a810093d76ebd974b2de5463178295890261", "url": "https://github.com/jbosstm/narayana/commit/44b4a810093d76ebd974b2de5463178295890261", "message": "[JBTM-3270] tracking persisted REST-AT participant for removal not showing warning in the server log", "committedDate": "2020-03-30T12:16:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNDY0Mw==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400814643", "bodyText": "Would persistedParticipants be clearer (though I do accept the store API is calling it committed)? Or are these really committed from a transactional perspective?", "author": "tomjenkinson", "createdAt": "2020-03-31T10:43:44Z", "path": "rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java", "diffHunk": "@@ -44,6 +44,11 @@\n \n     private final Map<String, ParticipantDeserializer> deserializers = new ConcurrentHashMap<String, ParticipantDeserializer>();\n \n+    /**\n+     * A map of participants persisted in the object store, it maps 'Participant Id' to 'Uid'\n+     */\n+    private final Map<String, Uid> committedParticipants = new ConcurrentHashMap<>();", "originalCommit": "44b4a810093d76ebd974b2de5463178295890261", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgyNTY2NQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400825665", "bodyText": "+1", "author": "ochaloup", "createdAt": "2020-03-31T11:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNDY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b2efa02bbe6e6710c5e297150b0253ad6dfda414", "chunk": "diff --git a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\nindex 20162880c..cf1572888 100644\n--- a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n+++ b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n\n@@ -47,7 +47,7 @@ public final class RecoveryManager {\n     /**\n      * A map of participants persisted in the object store, it maps 'Participant Id' to 'Uid'\n      */\n-    private final Map<String, Uid> committedParticipants = new ConcurrentHashMap<>();\n+    private final Map<String, Uid> persistedParticipants = new ConcurrentHashMap<>();\n \n     private RecoveryManager() {\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNDgwMA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400814800", "bodyText": "I note this is going in the map before the store is updated", "author": "tomjenkinson", "createdAt": "2020-03-31T10:44:04Z", "path": "rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java", "diffHunk": "@@ -81,6 +86,8 @@ public void persistParticipantInformation(final ParticipantInformation participa\n             final OutputObjectState state = getParticipantInformationOutputState(participantInformation);\n             final Uid uid = new Uid(participantInformation.getId());\n \n+            // to identify the uid from the participant persisted into the object store in order to delete it later\n+            committedParticipants.put(participantInformation.getId(), uid);", "originalCommit": "44b4a810093d76ebd974b2de5463178295890261", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgyNTY0NA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400825644", "bodyText": "This was intentional originally as I was thinking that it's safer to try to try a remove an non-existing record from the object store than does not try it at all. I was thinking on some issue being thrown after the record was persisted but the call was not yet returned to this point.\nThen the persistedParticipants would not be aware.\nBut when I'm rethinking now it seems to me it's safe to move it after the persistent call.", "author": "ochaloup", "createdAt": "2020-03-31T11:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNDgwMA=="}], "type": "inlineReview", "revised_code": {"commit": "b2efa02bbe6e6710c5e297150b0253ad6dfda414", "chunk": "diff --git a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\nindex 20162880c..cf1572888 100644\n--- a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n+++ b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n\n@@ -86,9 +86,9 @@ public final class RecoveryManager {\n             final OutputObjectState state = getParticipantInformationOutputState(participantInformation);\n             final Uid uid = new Uid(participantInformation.getId());\n \n-            // to identify the uid from the participant persisted into the object store in order to delete it later\n-            committedParticipants.put(participantInformation.getId(), uid);\n             recoveryStore.write_committed(uid, PARTICIPANT_INFORMATION_RECORD_TYPE, state);\n+            // to identify the uid from the participant persisted into the object store in order to delete it later\n+            persistedParticipants.put(participantInformation.getId(), uid);\n         } catch (Exception e) {\n             LOG.warn(\"Failure while persisting participant information.\", e);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNjU1MQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400816551", "bodyText": "A general question, how do we reach removeParticipantInformation if the participant was not property written to disk before. Do we need to differentiate on rollback vs other conditions?", "author": "tomjenkinson", "createdAt": "2020-03-31T10:47:27Z", "path": "rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java", "diffHunk": "@@ -93,12 +100,15 @@ public void removeParticipantInformation(final ParticipantInformation participan\n         }\n \n         final RecoveryStore recoveryStore = StoreManager.getRecoveryStore();\n-        final Uid uid = new Uid(participantInformation.getId());", "originalCommit": "44b4a810093d76ebd974b2de5463178295890261", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgyNzMzMA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400827330", "bodyText": "If I understand correctly what you ask about then the call to removeParticipantInformation is just called on these type of \"actions\" from the ParticipantResource (https://github.com/jbosstm/narayana/blob/5.10.4.Final/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/ParticipantResource.java#L276)\nSo any call on rollback, commit, forget may cause to call here. There is no differentiation from where the method is called from.", "author": "ochaloup", "createdAt": "2020-03-31T11:07:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3ODUwMQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400978501", "bodyText": "It follows a little to the conversation @mmusgrov and you are having. It relates particularly to whether a failure to remove could be transient or not", "author": "tomjenkinson", "createdAt": "2020-03-31T14:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk5OTgxOA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400999818", "bodyText": "I probably don't understand the point. Failure to remove causes there is found the record in the next recovery round and the attempt to rollback/commit will be retried.", "author": "ochaloup", "createdAt": "2020-03-31T15:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA2ODcxNg==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401068716", "bodyText": "I will resolve this as we are discussing something related in the parallel thread", "author": "tomjenkinson", "createdAt": "2020-03-31T16:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNjU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b2efa02bbe6e6710c5e297150b0253ad6dfda414", "chunk": "diff --git a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\nindex 20162880c..cf1572888 100644\n--- a/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n+++ b/rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java\n\n@@ -102,10 +102,10 @@ public final class RecoveryManager {\n         final RecoveryStore recoveryStore = StoreManager.getRecoveryStore();\n         String participantId = participantInformation.getId();\n \n-        if(committedParticipants.get(participantId) != null) {\n+        if(persistedParticipants.get(participantId) != null) {\n             try {\n                 recoveryStore.remove_committed(new Uid(participantId), PARTICIPANT_INFORMATION_RECORD_TYPE);\n-                committedParticipants.remove(participantId);\n+                persistedParticipants.remove(participantId);\n             } catch (ObjectStoreException ose) {\n                 LOG.warn(\"Failure while removing participant information from the object store.\", ose);\n             }\n"}}, {"oid": "b2efa02bbe6e6710c5e297150b0253ad6dfda414", "url": "https://github.com/jbosstm/narayana/commit/b2efa02bbe6e6710c5e297150b0253ad6dfda414", "message": "[JBTM-3270] tracking persisted REST-AT participant for removal not showing warning in the server log", "committedDate": "2020-03-31T11:04:53Z", "type": "commit"}, {"oid": "b2efa02bbe6e6710c5e297150b0253ad6dfda414", "url": "https://github.com/jbosstm/narayana/commit/b2efa02bbe6e6710c5e297150b0253ad6dfda414", "message": "[JBTM-3270] tracking persisted REST-AT participant for removal not showing warning in the server log", "committedDate": "2020-03-31T11:04:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk4NDg5Mg==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r400984892", "bodyText": "@mmusgrov is more handling of this case considered elsewhere or is the failure to write to disk of a participant just logged but algorithmically ignored? Is that safe?", "author": "tomjenkinson", "createdAt": "2020-03-31T15:01:21Z", "path": "rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java", "diffHunk": "@@ -82,6 +87,8 @@ public void persistParticipantInformation(final ParticipantInformation participa\n             final Uid uid = new Uid(participantInformation.getId());\n \n             recoveryStore.write_committed(uid, PARTICIPANT_INFORMATION_RECORD_TYPE, state);\n+            // to identify the uid from the participant persisted into the object store in order to delete it later\n+            persistedParticipants.put(participantInformation.getId(), uid);\n         } catch (Exception e) {\n             LOG.warn(\"Failure while persisting participant information.\", e);", "originalCommit": "b2efa02bbe6e6710c5e297150b0253ad6dfda414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNDk4Ng==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r403904986", "bodyText": "Customers normally log at WARN level. Do you want it logged at ERROR instead or do you expect the code to recover from disk failures by retrying?", "author": "mmusgrov", "createdAt": "2020-04-06T08:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk4NDg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3MzMzNA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r404573334", "bodyText": "I found I missed this comment.\nThe WARN level is considered because of the retrying happens and there is the hope the disk failure will be recovered.", "author": "ochaloup", "createdAt": "2020-04-07T06:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk4NDg5Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA2OTk0MQ==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401069941", "bodyText": "@ochaloup is there any need to synchronise in case a thread doing write_participant and persistedParticipants.put could execute concurrently with a thread checking if something is in the map? I don't know the answer but did you assess that?", "author": "tomjenkinson", "createdAt": "2020-03-31T16:59:01Z", "path": "rts/at/integration/src/main/java/org/jboss/narayana/rest/integration/RecoveryManager.java", "diffHunk": "@@ -93,12 +100,15 @@ public void removeParticipantInformation(final ParticipantInformation participan\n         }\n \n         final RecoveryStore recoveryStore = StoreManager.getRecoveryStore();\n-        final Uid uid = new Uid(participantInformation.getId());\n+        String participantId = participantInformation.getId();\n \n-        try {\n-            recoveryStore.remove_committed(uid, PARTICIPANT_INFORMATION_RECORD_TYPE);\n-        } catch (ObjectStoreException e) {\n-            LOG.warn(\"Failure while removing participant information from the object store.\", e);\n+        if(persistedParticipants.get(participantId) != null) {", "originalCommit": "b2efa02bbe6e6710c5e297150b0253ad6dfda414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA3MzcwNA==", "url": "https://github.com/jbosstm/narayana/pull/1574#discussion_r401073704", "bodyText": "yes, I did. There is used the ConcurrentHashMap. If something is checking (e.g. recovery) if something is in map, it may not find it but it will find it in the next cycle.", "author": "ochaloup", "createdAt": "2020-03-31T17:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA2OTk0MQ=="}], "type": "inlineReview", "revised_code": null}]}