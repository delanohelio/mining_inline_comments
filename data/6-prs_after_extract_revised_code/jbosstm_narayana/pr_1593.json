{"pr_number": 1593, "pr_title": "JBTM-3276 SlotStore implementation.", "pr_createdAt": "2020-04-08T14:53:34Z", "pr_url": "https://github.com/jbosstm/narayana/pull/1593", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2NjI1OQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r407966259", "bodyText": "Can you indicate why so that we can continue with the work if your priorities change?", "author": "mmusgrov", "createdAt": "2020-04-14T08:42:56Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+\n+import java.io.*;\n+import java.util.zip.CRC32;\n+\n+/**\n+ * File backed implementation of the SlotStore backend.\n+ * WARNING: this is currently a test implementation and is NOT SAFE for production use yet.", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MDUyNw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408690527", "bodyText": "The current code shouldn't be too bad, but I'm not going to be really comfortable until we've done a run over the full test suite with a config to use that store as the backend. So far the only test coverage is small subset that I ran locally.\nFor serious production use, the main challenge will be how to deal with changing config values. For example, if you reduce the number of slots whilst the store is non-empty, some records may become inaccessible. Likewise bad things can happen if you change the slot size.  I'm not sure these need code safeguards, it may be sufficient just to update the docs to reflect the potential problems and put a big 'don't do this' notice in.", "author": "jhalliday", "createdAt": "2020-04-15T09:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2NjI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MTI1Nw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408741257", "bodyText": "Thanks", "author": "mmusgrov", "createdAt": "2020-04-15T10:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2NjI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "585c0365de387272684842f1af60e55f51cd4982", "chunk": "diff --git a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\nindex 7aab4ebfd..6d64c19ee 100644\n--- a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n+++ b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n\n@@ -22,7 +22,9 @@ package com.arjuna.ats.internal.arjuna.objectstore.slot;\n \n import com.arjuna.ats.arjuna.logging.tsLogger;\n \n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n import java.util.zip.CRC32;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1MzY2Mw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408253663", "bodyText": "Isn't it possible for parallel threads to safely write to a memory mapped file if they are writing to distinct slots, if so wouldn't you get better performance using a single file.", "author": "mmusgrov", "createdAt": "2020-04-14T16:02:05Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+\n+import java.io.*;\n+import java.util.zip.CRC32;\n+\n+/**\n+ * File backed implementation of the SlotStore backend.\n+ * WARNING: this is currently a test implementation and is NOT SAFE for production use yet.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-04\n+ */\n+public class DiskSlots implements BackingSlots {\n+\n+    private SlotStoreEnvironmentBean config;\n+    private RandomAccessFile[] slots;\n+\n+    @Override\n+    public synchronized void init(SlotStoreEnvironmentBean config) throws IOException {\n+        if (this.config != null) {\n+            throw new IllegalStateException(\"already initialized\");\n+        }\n+\n+        this.config = config;\n+\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        slots = new RandomAccessFile[config.getNumberOfSlots()];", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NzYwMg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408697602", "bodyText": "It's not memory mapped, but your point is still relevant.  The Java API is cursor based - you seek to the location you want to write, then write it. So you'd get lock contention on the shared cursor. The fd.sync is also a problem - it syncs the whole file. The O/S will be dirty tracking at the block level, but will still incur some overhead to find the dirty blocks to flush. So, you'd certain get less resource (RAM) usage, but I don't see a performance improvement as likely. It's more the other way around I think.\nHowever...\nThe pmem backend is designed to use memory mapping over a single file. It's also JDK14 only, because that's the first version that has the pmem support in the JVM. So it can and does use the newer Java API that allows both absolute position writes (no cursor to lock, you specify the offset as a call parameter instead) and region flush - calling the new force(offset, length) instead of force().  Although it's designed for pmem, it should be possible to run almost the same code in non-pmem mode, at which point it's equivalent to the single file version of the store you suggest. So another reason the DiskSlots one is multi-file, is to provide an alternative for comparison.  Finally, the multi-file approach is more robust to slotSize changes, as it can grow files. With a single file, you have to delete and recreate the whole thing if you want to change the slotSize.", "author": "jhalliday", "createdAt": "2020-04-15T09:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1MzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MzA1Nw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408743057", "bodyText": "Good explanation.", "author": "mmusgrov", "createdAt": "2020-04-15T10:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1MzY2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "585c0365de387272684842f1af60e55f51cd4982", "chunk": "diff --git a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\nindex 7aab4ebfd..6d64c19ee 100644\n--- a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n+++ b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n\n@@ -22,7 +22,9 @@ package com.arjuna.ats.internal.arjuna.objectstore.slot;\n \n import com.arjuna.ats.arjuna.logging.tsLogger;\n \n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n import java.util.zip.CRC32;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NTgyOA==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408255828", "bodyText": "Would assert data.length <= SlotStoreEnvironmentBean#bytesPerSlot provide any debug benefit.\nBTW this implementation uses a file per slot and since a files' size is unlimited the bytesPerSlot config should not apply to this particular BackingSlots implementation (in particular in SlotStore#write there is a check that the data size < config.bytesPerSlot).", "author": "mmusgrov", "createdAt": "2020-04-14T16:05:02Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+\n+import java.io.*;\n+import java.util.zip.CRC32;\n+\n+/**\n+ * File backed implementation of the SlotStore backend.\n+ * WARNING: this is currently a test implementation and is NOT SAFE for production use yet.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-04\n+ */\n+public class DiskSlots implements BackingSlots {\n+\n+    private SlotStoreEnvironmentBean config;\n+    private RandomAccessFile[] slots;\n+\n+    @Override\n+    public synchronized void init(SlotStoreEnvironmentBean config) throws IOException {\n+        if (this.config != null) {\n+            throw new IllegalStateException(\"already initialized\");\n+        }\n+\n+        this.config = config;\n+\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        slots = new RandomAccessFile[config.getNumberOfSlots()];\n+        for (int i = 0; i < slots.length; i++) {\n+            File file = new File(storeDir, \"slot.\" + i);\n+            slots[i] = new RandomAccessFile(file, \"rw\");\n+        }\n+    }\n+\n+    @Override\n+    public void write(int slot, byte[] data, boolean sync) throws IOException {\n+        RandomAccessFile randomAccessFile = slots[slot];\n+        synchronized (randomAccessFile) {\n+\n+            randomAccessFile.seek(0);\n+            randomAccessFile.writeInt(data.length);", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5OTA0Mg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408699042", "bodyText": "Right, the size check is in the common SlotStore code, not the backend. To make it apply to only some stores we'd have to move it into each relevant backend, but yes, that's possible.", "author": "jhalliday", "createdAt": "2020-04-15T09:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0NzQzNQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408747435", "bodyText": "So we have a bit of code that may serialize an XAResource into a slot. Will the default slot size be big enough for that or does the user need to be aware that the slot needs configuring properly?", "author": "mmusgrov", "createdAt": "2020-04-15T10:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc1MzIwMg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408753202", "bodyText": "A typical JTA AtomicAction embedding 2 XAResource records and the key metadata weights in at under 1k. The slotSize defaults to 4k, which is a single block on most filesystems i.e. is the smallest size that the storage system handles anyhow. That should be enough headroom for most users. Records for e.g. XTS, JTS, subordinate tx and other more complex cases will vary more in size, but those should be caught early in staging environments. Bump the default to 8 or 16k if you're worried - for the current implementation there is no downsize to over-provisioning in that way.", "author": "jhalliday", "createdAt": "2020-04-15T10:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgyNzk2Nw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408827967", "bodyText": "Well I was asking for input. If, as you say, it is typically 1K per resource then the default is sufficient. And if a user adds a resource that requires more then, since you throw an IOException if the slot is too small, it will be caught during testing and they can tweak the config appropriately. Thanks for the answer.", "author": "mmusgrov", "createdAt": "2020-04-15T13:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NTgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "585c0365de387272684842f1af60e55f51cd4982", "chunk": "diff --git a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\nindex 7aab4ebfd..6d64c19ee 100644\n--- a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n+++ b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n\n@@ -22,7 +22,9 @@ package com.arjuna.ats.internal.arjuna.objectstore.slot;\n \n import com.arjuna.ats.arjuna.logging.tsLogger;\n \n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n import java.util.zip.CRC32;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1ODI1MQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408258251", "bodyText": "What's this, is it for the two ints corresponding to the data length and the checksum?", "author": "mmusgrov", "createdAt": "2020-04-14T16:08:29Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+\n+import java.io.*;\n+import java.util.zip.CRC32;\n+\n+/**\n+ * File backed implementation of the SlotStore backend.\n+ * WARNING: this is currently a test implementation and is NOT SAFE for production use yet.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-04\n+ */\n+public class DiskSlots implements BackingSlots {\n+\n+    private SlotStoreEnvironmentBean config;\n+    private RandomAccessFile[] slots;\n+\n+    @Override\n+    public synchronized void init(SlotStoreEnvironmentBean config) throws IOException {\n+        if (this.config != null) {\n+            throw new IllegalStateException(\"already initialized\");\n+        }\n+\n+        this.config = config;\n+\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        slots = new RandomAccessFile[config.getNumberOfSlots()];\n+        for (int i = 0; i < slots.length; i++) {\n+            File file = new File(storeDir, \"slot.\" + i);\n+            slots[i] = new RandomAccessFile(file, \"rw\");\n+        }\n+    }\n+\n+    @Override\n+    public void write(int slot, byte[] data, boolean sync) throws IOException {\n+        RandomAccessFile randomAccessFile = slots[slot];\n+        synchronized (randomAccessFile) {\n+\n+            randomAccessFile.seek(0);\n+            randomAccessFile.writeInt(data.length);\n+            randomAccessFile.write(data);\n+            randomAccessFile.writeInt(checksum(data));\n+\n+            if (sync) {\n+                randomAccessFile.getFD().sync();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public byte[] read(int slot) throws IOException {\n+        RandomAccessFile randomAccessFile = slots[slot];\n+        synchronized (randomAccessFile) {\n+\n+            if (randomAccessFile.length() < 8) {", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMjE3NQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408702175", "bodyText": "Right. The minimum valid record is one with just the leading size bytes and trailing checksum, with a zero size payload between. So if the file is smaller than that it's invalid regardless of the content, thus no point reading it. That mostly covers the bootstrap case where a slot has never been occupied and the file is zero length. Moving the first readInt into the try/catch and just allowing it to fail would work fine, but it feels a bit ugly to rely on exception handling for something that's actually expected.", "author": "jhalliday", "createdAt": "2020-04-15T09:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1ODI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0Nzk5NA==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408747994", "bodyText": "Agreed, it would be ugly.", "author": "mmusgrov", "createdAt": "2020-04-15T10:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1ODI1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "585c0365de387272684842f1af60e55f51cd4982", "chunk": "diff --git a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\nindex 7aab4ebfd..6d64c19ee 100644\n--- a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n+++ b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n\n@@ -22,7 +22,9 @@ package com.arjuna.ats.internal.arjuna.objectstore.slot;\n \n import com.arjuna.ats.arjuna.logging.tsLogger;\n \n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n import java.util.zip.CRC32;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NjgzOA==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408266838", "bodyText": "Since you are using one file per slot why do you need a random access file, you could read the whole file and validate the data using the final checksum.", "author": "mmusgrov", "createdAt": "2020-04-14T16:20:57Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+\n+import java.io.*;\n+import java.util.zip.CRC32;\n+\n+/**\n+ * File backed implementation of the SlotStore backend.\n+ * WARNING: this is currently a test implementation and is NOT SAFE for production use yet.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-04\n+ */\n+public class DiskSlots implements BackingSlots {\n+\n+    private SlotStoreEnvironmentBean config;\n+    private RandomAccessFile[] slots;\n+\n+    @Override\n+    public synchronized void init(SlotStoreEnvironmentBean config) throws IOException {\n+        if (this.config != null) {\n+            throw new IllegalStateException(\"already initialized\");\n+        }\n+\n+        this.config = config;\n+\n+        File storeDir = new File(config.getStoreDir());\n+        if (!storeDir.exists() && !storeDir.mkdirs()) {\n+            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n+        }\n+        slots = new RandomAccessFile[config.getNumberOfSlots()];\n+        for (int i = 0; i < slots.length; i++) {\n+            File file = new File(storeDir, \"slot.\" + i);\n+            slots[i] = new RandomAccessFile(file, \"rw\");\n+        }\n+    }\n+\n+    @Override\n+    public void write(int slot, byte[] data, boolean sync) throws IOException {\n+        RandomAccessFile randomAccessFile = slots[slot];\n+        synchronized (randomAccessFile) {\n+\n+            randomAccessFile.seek(0);\n+            randomAccessFile.writeInt(data.length);\n+            randomAccessFile.write(data);\n+            randomAccessFile.writeInt(checksum(data));\n+\n+            if (sync) {\n+                randomAccessFile.getFD().sync();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public byte[] read(int slot) throws IOException {\n+        RandomAccessFile randomAccessFile = slots[slot];\n+        synchronized (randomAccessFile) {\n+\n+            if (randomAccessFile.length() < 8) {\n+                return null;\n+            }\n+\n+            randomAccessFile.seek(0);\n+            int dataLength = randomAccessFile.readInt();", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNjc1Mg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408706752", "bodyText": "Sure, but I needed or had the layout code for the pmem backend too, so this way was less work. For that matter if you're willing to trust the filesystem not to tear writes (an assumption the traditional stores makes) then you don't even need the checksum, it's a carry over too.", "author": "jhalliday", "createdAt": "2020-04-15T09:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NjgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0ODM4Nw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408748387", "bodyText": "I don't know what \"tear writes\" are but fair enough.", "author": "mmusgrov", "createdAt": "2020-04-15T10:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NjgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MTc3Mg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408761772", "bodyText": "Write atomicity guarantees are... not straightforward. Where a write that's supposed to be a single atomic change gets split up and is not atomic, it's said to be torn, as in tearing a piece of paper and holding onto only part of it.\nInternally the O/S is holding pages (1k or 4k, depending) in the buffer cache and writing disk blocks (used to be 512bytes, now 4kbytes) to the underlying device driver to send back to the media. Note that neither the O/S nor the media strictly guarantees to handle a single block write atomically, but in practice it's assumed to. Writes that span multiple blocks can theoretically fail such that one block is persisted and the other isn't, but again most systems rely on this not happening. Since tx records usually fit in one block it's not much of an additional concern for us anyhow. In the old days we had to try to squeeze the tx record into 512 bytes, but that's ancient history...\nFor pmem, which doesn't go via the O/S block layer, writes are at cache line granularity i.e. 64bytes rather than 4096bytes. That's a lot more efficient for small records. But it's also a lot harder to program against, because it comes with a twist... Whereas the O/S will flush a dirty block to the backing store only when you tell it to (lazily with close, or immediately with fd.sync), the CPU can evict a cache line back to the persistent memory whenever it likes. You can tell it to when you want, like calling sync, but... you can't stop it doing it at other times. Thus you get torn writes frequently, both because you've got smaller 'blocks', but also because you get unpredictably timed persistence operations. Hence persistence design for pmem storage is more conservative and makes use of checksums or other techniques that can be more or less safely skipped for regular storage if you trust the O/S.", "author": "jhalliday", "createdAt": "2020-04-15T11:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NjgzOA=="}], "type": "inlineReview", "revised_code": {"commit": "585c0365de387272684842f1af60e55f51cd4982", "chunk": "diff --git a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\nindex 7aab4ebfd..6d64c19ee 100644\n--- a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n+++ b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n\n@@ -22,7 +22,9 @@ package com.arjuna.ats.internal.arjuna.objectstore.slot;\n \n import com.arjuna.ats.arjuna.logging.tsLogger;\n \n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n import java.util.zip.CRC32;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODM4MQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408268381", "bodyText": "or the checksum of the contents of slot failed", "author": "mmusgrov", "createdAt": "2020-04-14T16:23:08Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/BackingSlots.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Interface for pluggable internal implementations of the SlotStore backend.\n+ *\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com), 2020-04\n+ */\n+public interface BackingSlots {\n+\n+    /**\n+     * Initialize the instance from the given configuration.\n+     * This must be called once per instance, before any other method is called.\n+     *\n+     * @param config The configuration to apply.\n+     */\n+    void init(SlotStoreEnvironmentBean config) throws IOException;\n+\n+    /**\n+     * Update the given slot with the provided data, overwriting (non-atomically) any existing data.\n+     * The update may not be immediately persistent, depending on config syncWrites\n+     *\n+     * @param slot the index, from 0 to config numberOfSlots-1\n+     * @param sync true for immediate persistence, false otherwise\n+     * @param data the content.\n+     */\n+    void write(int slot, byte[] data, boolean sync) throws IOException;\n+\n+    /**\n+     * Read the given slot, returning its contents.\n+     *\n+     * @param slot the index, from 0 to config numberOfSlots-1\n+     * @return the content, or null if the slot has not been written or has been cleared.", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwODc0Mg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408708742", "bodyText": "yes, though I'm treating the checksum as an internal implementation detail. It's really validating the write completed and didn't get interrupted by a crash. We could do that a different way without changing the API, so it's not documented behaviour. Broken checksum is just a way of determining the slot has not been written (completely), which is documented API behaviour.", "author": "jhalliday", "createdAt": "2020-04-15T09:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc1NjYxMQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408756611", "bodyText": "So a corrupt slot is equivalent to one that had never been written to in the first place. What if it is written okay, read and updated but the second write corrupted it. The read may have real world consequences (e.g. to tell an XAResource to do something). Since there is no log message (that could usefully be used to correlate with other log messages) about the corrupt slot the information (that the slot was corrupt) is lost.", "author": "mmusgrov", "createdAt": "2020-04-15T10:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDMyNw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408764327", "bodyText": "This is really covered below. I'll copy here:\nA partial write is never exposed, it just behaves as never having happened, so the slot is considered to still be empty. There is nothing useful a user can do about it even if it's made visible to them, so they don't need to know. The mechanism that puts overwrites for the same key into parallel slots is critical here, as if we let data vanish by partially overwriting it then crashing, that would be a user visible data loss that would not be recoverable.\nLogically, you may have a partial update, but also the entire previous state. Recovering that is essentially an internal rollback - the partial update in one slot is considered invalid, freeing the slot, and the original state is restored from the other slot. The index update occurs only after a sucessfull write, so a partially written state can't be seen externally.", "author": "jhalliday", "createdAt": "2020-04-15T11:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0Mzg4Nw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408843887", "bodyText": "The scenario I quoted below was:\n\nSo are you saying that a slot update that goes into the parallel new slot can never become corrupt after it has been written\n\nie the parallel slot was successfully written but later became corrupted. If that circumstance is so improbable as not worth the effort then fair enough. But a log message would detect this situation.", "author": "mmusgrov", "createdAt": "2020-04-15T13:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMxNzU5Mw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r410317593", "bodyText": "So this conversation was resolved by a later comment.", "author": "mmusgrov", "createdAt": "2020-04-17T15:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODM4MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408272049", "bodyText": "We use a checkstyle plugin rule to disallow the use of .*. But since ArjunaCore predates maven and we have a policy of not refactoring historical (but still current) code we avoid failing the compilation. But we do encourage/advise that new files should follow our checkstyle rules by not skipping the plugin in our top level pom.", "author": "mmusgrov", "createdAt": "2020-04-14T16:28:18Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * JBoss, Home of Professional Open Source\n+ * Copyright 2020, Red Hat, Inc. and/or its affiliates,\n+ * and individual contributors as indicated by the @author tags.\n+ * See the copyright.txt in the distribution for a\n+ * full listing of individual contributors.\n+ * This copyrighted material is made available to anyone wishing to use,\n+ * modify, copy, or redistribute it subject to the terms and conditions\n+ * of the GNU Lesser General Public License, v. 2.1.\n+ * This program is distributed in the hope that it will be useful, but WITHOUT A\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n+ * You should have received a copy of the GNU Lesser General Public License,\n+ * v.2.1 along with this distribution; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+ * MA  02110-1301, USA.\n+ *\n+ * (C) 2020,\n+ * @author Jonathan Halliday (jonathan.halliday@redhat.com)\n+ */\n+package com.arjuna.ats.internal.arjuna.objectstore.slot;\n+\n+import com.arjuna.ats.arjuna.logging.tsLogger;\n+\n+import java.io.*;", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMDAxNQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408710015", "bodyText": "Hmm. Should the build scripts be failing the build then? Perhaps using the \"/build.sh -am -pl :narayana-jta\" rather than doing a full \"/build.sh\" is bypassing something it shouldn't be?", "author": "jhalliday", "createdAt": "2020-04-15T09:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MTE0OQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408761149", "bodyText": "Well we caught between the proverbial rock and a hard place. We cannot checkstyle ArjunaCore since it contains very old source files and we want to be able to perform meaningful diffs with the old source (fixing checkstyle errors would mean we could no longer easily diff revisions unless the diff tool ignores whitespace etc). So instead we just ask engineers to follow our rules. But since that may present a barrier for occasional contributors, if you prefer not incur the overhead of having to manually follow these rules then we will not block your PR.", "author": "mmusgrov", "createdAt": "2020-04-15T11:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDk5Mg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408764992", "bodyText": "ok, at least the build scripts aren't broken, they just aren't intended to be warning or enforcing. Is there any tool support, or do I just have to remember to eyeball the code?", "author": "jhalliday", "createdAt": "2020-04-15T11:16:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNjYxMw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408836613", "bodyText": "You have two options:\n\n\nEnable the checkstyle plugin via the pom file, or\n\n\nReference the rule file from your IDE settings (for Intelij that would be Settings -> Other Settings -> Checkstyle) and we use the wildfly rule set.", "author": "mmusgrov", "createdAt": "2020-04-15T13:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0Nzc4Mg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408847782", "bodyText": "Any advise on how we can improve upon that would be useful but I do not see any alternaive.", "author": "mmusgrov", "createdAt": "2020-04-15T13:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1NTU2NQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r412955565", "bodyText": "I did say \"if you prefer not incur the overhead of having to manually follow these rules then we will not block your PR\" so if you do not plan to run checkstyle then you need to resolve this conversation.", "author": "mmusgrov", "createdAt": "2020-04-22T12:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MTczMQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r413691731", "bodyText": "Sorry, got sidetracked doing a memory mapped version of the backend. Should all be sorted now.", "author": "jhalliday", "createdAt": "2020-04-23T10:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "585c0365de387272684842f1af60e55f51cd4982", "chunk": "diff --git a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\nindex 7aab4ebfd..6d64c19ee 100644\n--- a/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n+++ b/ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/DiskSlots.java\n\n@@ -22,7 +22,9 @@ package com.arjuna.ats.internal.arjuna.objectstore.slot;\n \n import com.arjuna.ats.arjuna.logging.tsLogger;\n \n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n import java.util.zip.CRC32;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3ODc1OA==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408278758", "bodyText": "What happens if the config is changed or if the backing slot store is moved to a different system?", "author": "mmusgrov", "createdAt": "2020-04-14T16:38:17Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -65,15 +65,21 @@ public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n \n         // unused for now, but eventually we'll have a disk backend...\n         File storeDir = new File(config.getStoreDir());\n-        if (!storeDir.exists() && !storeDir.mkdirs()) {\n-            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n-        }\n         storeDirCanonicalPath = storeDir.getCanonicalPath();\n \n-        slots = new RAMSlots(config);\n+        slots = config.getBackingSlots();\n+        slots.init(config);\n \n+        // internal recovery to rebuild the slotIdIndex and freeList", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzQ1Nw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408713457", "bodyText": "internal recovery in the case of config changes is complex and the current situation is basically 'don't try it'. The extent to which we want to support and test it is open to discussion. Broadly I don't think it will be common to change the config on a non-empty store, except to grow the number of slots or the slotSize, both of which will work with the current implementation. Relocating the directory should likewise work - it will change the store name, but that's not used anywhere except for debugging output.", "author": "jhalliday", "createdAt": "2020-04-15T09:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3ODc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MjQ2OQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408762469", "bodyText": "So can you add a note to the config bean to say \"don't do XYZ\" if the store is not empty.", "author": "mmusgrov", "createdAt": "2020-04-15T11:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3ODc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1NTk3NQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r412955975", "bodyText": "Once this conversation is resolved we can merge the contribution.", "author": "mmusgrov", "createdAt": "2020-04-22T12:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3ODc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MTk2OA==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r413691968", "bodyText": "Warnings added to javadoc.", "author": "jhalliday", "createdAt": "2020-04-23T10:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3ODc1OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3OTIzNQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408279235", "bodyText": "typo should be it is free for use\nBTW data can be null if the checksum failed in which case you are masking the error without reporting it to the user.", "author": "mmusgrov", "createdAt": "2020-04-14T16:39:03Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStore.java", "diffHunk": "@@ -65,15 +65,21 @@ public SlotStore(SlotStoreEnvironmentBean config) throws IOException {\n \n         // unused for now, but eventually we'll have a disk backend...\n         File storeDir = new File(config.getStoreDir());\n-        if (!storeDir.exists() && !storeDir.mkdirs()) {\n-            throw new IOException(tsLogger.i18NLogger.get_dir_create_failed(storeDir.getCanonicalPath()));\n-        }\n         storeDirCanonicalPath = storeDir.getCanonicalPath();\n \n-        slots = new RAMSlots(config);\n+        slots = config.getBackingSlots();\n+        slots.init(config);\n \n+        // internal recovery to rebuild the slotIdIndex and freeList\n         for (int i = 0; i < config.getNumberOfSlots(); i++) {\n-            freeList.add(i); // TODO recovery, when the backend supports it.\n+            byte[] data = slots.read(i);\n+            if (data == null || data.length == 0) {\n+                freeList.add(i); // slot does not contain a valid entry, is free for use", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzcwOQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408717709", "bodyText": "Right. It's an implementation detail of the write. A partial write is never exposed, it just behaves as never having happened, so the slot is considered to still be empty. There is nothing useful a user can do about it even if it's made visible to them, so they don't need to know. The mechanism that puts overwrites for the same key into parallel slots is critical here, as if we let data vanish by partially overwriting it then crashing, that would be a user visable data loss that would not be recoverable.", "author": "jhalliday", "createdAt": "2020-04-15T09:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTg0Ng==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408769846", "bodyText": "Right. It's an implementation detail of the write. A partial write is never exposed, it just behaves as never having happened, so the slot is considered to still be empty.\n\nSee my earlier comment about a full write, a read followed by a partial rewrite. That sequence has exposed the data to the outside world.\n\nThere is nothing useful a user can do about it even if it's made visible to them, so they don't need to know.\n\nA log message may enable them to correlate it with earlier log messages.\n\nThe mechanism that puts overwrites for the same key into parallel slots is critical here, as if we let data vanish by partially overwriting it then crashing, that would be a user visable data loss that would not be recoverable.\n\nSo are you saying that a slot update that goes into the parallel new slot can never become corrupt after it has been written. If this is an improbable scenario then your counter argument is valid. But should our transaction system strive to deal with improbable scenarios or would you argue that dealing with this particular scenario (of corruption after the fact) would be overkill. Either way a log message to say that a corrupt slot was encountered would deal with the circumstance.", "author": "mmusgrov", "createdAt": "2020-04-15T11:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc5NDQyMA==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408794420", "bodyText": "full write, a read followed by a partial rewrite. That sequence has exposed the data to the outside world.\n\nIt has exposed the full write to the read, which is fine. The partial write is never exposed. A read before will read the previous full state. A read after will likewise read the previous full state, which still exists because it's in a different slot. The state is logically atomically overwritten, but physically never partially overwritten - internally the old and new states exist in parallel.", "author": "jhalliday", "createdAt": "2020-04-15T12:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0MTMzMg==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408841332", "bodyText": "Yes but my point is that the slot was read and real world decisions may have been made, for example XA resources have been contacted. When recovery later tries to read the slot and it is corrupted (I said above that the slot could become corrupted after the write has happened) the implementation quietly ignores it and the resources may be left in limbo.", "author": "mmusgrov", "createdAt": "2020-04-15T13:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMxODQ4Ng==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r410318486", "bodyText": "So this conversation was resolved by a later comment.", "author": "mmusgrov", "createdAt": "2020-04-17T16:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3OTIzNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MjU1Ng==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408292556", "bodyText": "Why not combine the if and else into a single boolean test.", "author": "mmusgrov", "createdAt": "2020-04-14T16:59:07Z", "path": "ArjunaCore/arjuna/classes/com/arjuna/ats/internal/arjuna/objectstore/slot/SlotStoreEnvironmentBean.java", "diffHunk": "@@ -149,4 +153,64 @@ public boolean isSyncDeletes() {\n     public void setSyncDeletes(boolean syncDeletes) {\n         this.syncDeletes = syncDeletes;\n     }\n+\n+    /**\n+     * Returns the class name of the com.arjuna.ats.internal.arjuna.objectstore.slot.BackingSlots implementation\n+     * <p>\n+     * Default: \"com.arjuna.ats.internal.arjuna.objectstore.slot.VolatileSlots\"\n+     *\n+     * @return the name of the class implementing BackingSlots.\n+     */\n+    public String getBackingSlotsClassName() {\n+        return backingSlotsClassName;\n+    }\n+\n+    public void setBackingSlotsClassName(String backingSlotsClassName) {\n+        synchronized (this) {\n+            if (backingSlotsClassName == null) {\n+                this.backingSlots = null;\n+            } else if (!backingSlotsClassName.equals(this.backingSlotsClassName)) {", "originalCommit": "c17259bb149f97d37c67239eb3ecfddc6cab3715", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMDI5Mw==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408720293", "bodyText": "Could do. It's really only for consistency of style with the ones that do different things in the if and else clauses, like setBackingSlots", "author": "jhalliday", "createdAt": "2020-04-15T09:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MjU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc3MDI3NQ==", "url": "https://github.com/jbosstm/narayana/pull/1593#discussion_r408770275", "bodyText": "Okay.", "author": "mmusgrov", "createdAt": "2020-04-15T11:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MjU1Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "da7805f21dd539cef4c6bc2b0edb499cb3b6b850", "url": "https://github.com/jbosstm/narayana/commit/da7805f21dd539cef4c6bc2b0edb499cb3b6b850", "message": "JBTM-3276 SlotStore implementation.\npart two - refactor to add disk backend.", "committedDate": "2020-04-15T10:03:56Z", "type": "forcePushed"}, {"oid": "c9ef545e8ccaa7bd9cabfe259819c9256ab7b5a7", "url": "https://github.com/jbosstm/narayana/commit/c9ef545e8ccaa7bd9cabfe259819c9256ab7b5a7", "message": "JBTM-3276 SlotStore implementation.\npart two - refactor to add disk backend.", "committedDate": "2020-04-15T12:14:33Z", "type": "forcePushed"}, {"oid": "585c0365de387272684842f1af60e55f51cd4982", "url": "https://github.com/jbosstm/narayana/commit/585c0365de387272684842f1af60e55f51cd4982", "message": "JBTM-3276 SlotStore implementation.\npart two - refactor to add disk backend.", "committedDate": "2020-04-23T10:12:23Z", "type": "commit"}, {"oid": "585c0365de387272684842f1af60e55f51cd4982", "url": "https://github.com/jbosstm/narayana/commit/585c0365de387272684842f1af60e55f51cd4982", "message": "JBTM-3276 SlotStore implementation.\npart two - refactor to add disk backend.", "committedDate": "2020-04-23T10:12:23Z", "type": "forcePushed"}]}