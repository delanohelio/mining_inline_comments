{"pr_number": 1637, "pr_title": "[JBTM-3318] tckrecoverytests timeout fixes", "pr_createdAt": "2020-06-17T11:03:55Z", "pr_url": "https://github.com/jbosstm/narayana/pull/1637", "timeline": [{"oid": "ca17805be15fdbf7272fb7144a54d7042e4b8206", "url": "https://github.com/jbosstm/narayana/commit/ca17805be15fdbf7272fb7144a54d7042e4b8206", "message": "[JBTM-3318] Adjusting LRA annotation 'timeLimit' value with factor\n\nThis is a reflection over the LRA annotations to fix timing issues on\nAMS CI which is slow and it may happen that the LRA is\ntimeouted/cancelled before the business method is invoked.\n\nThat's a trouble as the TCK tests are written in way to get the business\nmethod invoke and only after that the timeout should be elapsed\nsometimes later.", "committedDate": "2020-06-17T14:18:10Z", "type": "forcePushed"}, {"oid": "82ebd15bb3b94e6b4b82f4bc6fc71052e74c0a9e", "url": "https://github.com/jbosstm/narayana/commit/82ebd15bb3b94e6b4b82f4bc6fc71052e74c0a9e", "message": "[JBTM-3318] Adjusting LRA annotation 'timeLimit' value with factor\n\nThis is a reflection over the LRA annotations to fix timing issues on\nAMS CI which is slow and it may happen that the LRA is\ntimeouted/cancelled before the business method is invoked.\n\nThat's a trouble as the TCK tests are written in way to get the business\nmethod invoke and only after that the timeout should be elapsed\nsometimes later.", "committedDate": "2020-06-18T08:48:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NTUwOA==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442675508", "bodyText": "My IDE says this is a varargs param so you don't need to use null.", "author": "mmusgrov", "createdAt": "2020-06-19T07:23:10Z", "path": "rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.spi;\n+\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+import org.jboss.logging.Logger;\n+\n+import javax.ws.rs.core.Response;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Helper class to do internal changes of annotations during runtime.\n+ */\n+public class LRAAnnotationAdjuster {\n+    private static final Logger log = Logger.getLogger(LRAAnnotationAdjuster.class);\n+    private static final String ANNOTATIONS_FIELD_NAME = \"annotations\";\n+    private static final String ANNOTATION_DATA_METHOD_NAME = \"annotationData\";\n+\n+    /**\n+     * Take the clazz, check if contains the {@link LRA} annotation.\n+     * The LRA annotation is then replaced by wrapped {@link LRAWrapped}.\n+     */\n+    static void processWithClass(Class<?> clazz) {\n+        LRA lraAnnotation = clazz.getDeclaredAnnotation(LRA.class);\n+        if (lraAnnotation != null) {\n+            LRAAnnotationAdjuster.adjustLRAAnnotation(clazz, lraAnnotation);\n+        }\n+        Arrays.stream(clazz.getMethods()).forEach(method -> {\n+            LRA lraAnnotationMethod = method.getDeclaredAnnotation(LRA.class);\n+            if (lraAnnotationMethod != null) {\n+                LRAAnnotationAdjuster.adjustLRAAnnotation(method, lraAnnotationMethod);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Changing the LRA annotation declared on class by wrapping it with {@link LRAWrapped}.\n+     */\n+    static void adjustLRAAnnotation(Class clazzToLookFor, LRA originalLRAAnnotation) {\n+        if (doesJDKDefineAnnotationsField()) {\n+            // JDK7 has \"annotations\" field\n+            try {\n+                Field annotations = Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n+                annotations.setAccessible(true);\n+                Map<Class<? extends Annotation>, Annotation> map =\n+                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(clazzToLookFor);\n+                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n+            } catch (Exception  e) {\n+                e.printStackTrace();\n+            }\n+        } else {\n+            try {\n+                // JDK8+ has \"annotationData\" private method\n+                // obtaining reference to private class AnnotationData\n+                Method method = Class.class.getDeclaredMethod(ANNOTATION_DATA_METHOD_NAME, null);", "originalCommit": "82ebd15bb3b94e6b4b82f4bc6fc71052e74c0a9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1OTUxMg==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442759512", "bodyText": "+1", "author": "ochaloup", "createdAt": "2020-06-19T10:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NTUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "aa22d9a407cab517f5fad69f070361c2de0b9953", "chunk": "diff --git a/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java b/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java\ndeleted file mode 100644\nindex 6cdbf1828..000000000\n--- a/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java\n+++ /dev/null\n\n@@ -1,206 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2020, Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags. See the copyright.txt file in the\n- * distribution for a full listing of individual contributors.\n- *\n- * This is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as\n- * published by the Free Software Foundation; either version 2.1 of\n- * the License, or (at your option) any later version.\n- *\n- * This software is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this software; if not, write to the Free\n- * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n- * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n- */\n-\n-package io.narayana.lra.arquillian.spi;\n-\n-import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n-import org.jboss.logging.Logger;\n-\n-import javax.ws.rs.core.Response;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Map;\n-\n-/**\n- * Helper class to do internal changes of annotations during runtime.\n- */\n-public class LRAAnnotationAdjuster {\n-    private static final Logger log = Logger.getLogger(LRAAnnotationAdjuster.class);\n-    private static final String ANNOTATIONS_FIELD_NAME = \"annotations\";\n-    private static final String ANNOTATION_DATA_METHOD_NAME = \"annotationData\";\n-\n-    /**\n-     * Take the clazz, check if contains the {@link LRA} annotation.\n-     * The LRA annotation is then replaced by wrapped {@link LRAWrapped}.\n-     */\n-    static void processWithClass(Class<?> clazz) {\n-        LRA lraAnnotation = clazz.getDeclaredAnnotation(LRA.class);\n-        if (lraAnnotation != null) {\n-            LRAAnnotationAdjuster.adjustLRAAnnotation(clazz, lraAnnotation);\n-        }\n-        Arrays.stream(clazz.getMethods()).forEach(method -> {\n-            LRA lraAnnotationMethod = method.getDeclaredAnnotation(LRA.class);\n-            if (lraAnnotationMethod != null) {\n-                LRAAnnotationAdjuster.adjustLRAAnnotation(method, lraAnnotationMethod);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Changing the LRA annotation declared on class by wrapping it with {@link LRAWrapped}.\n-     */\n-    static void adjustLRAAnnotation(Class clazzToLookFor, LRA originalLRAAnnotation) {\n-        if (doesJDKDefineAnnotationsField()) {\n-            // JDK7 has \"annotations\" field\n-            try {\n-                Field annotations = Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n-                annotations.setAccessible(true);\n-                Map<Class<? extends Annotation>, Annotation> map =\n-                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(clazzToLookFor);\n-                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n-            } catch (Exception  e) {\n-                e.printStackTrace();\n-            }\n-        } else {\n-            try {\n-                // JDK8+ has \"annotationData\" private method\n-                // obtaining reference to private class AnnotationData\n-                Method method = Class.class.getDeclaredMethod(ANNOTATION_DATA_METHOD_NAME, null);\n-                method.setAccessible(true);\n-                // AnnotationData is private need to work with Object\n-                Object annotationData = method.invoke(clazzToLookFor);\n-                // AnnotationData works with map annotations\n-                Field annotations = annotationData.getClass().getDeclaredField(ANNOTATIONS_FIELD_NAME);\n-                annotations.setAccessible(true);\n-                Map<Class<? extends Annotation>, Annotation> map =\n-                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(annotationData);\n-                log.debugf(\"Adjusting LRA annotation %s for class %s%n\", originalLRAAnnotation, clazzToLookFor.getName());\n-                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n-            } catch (Exception  e) {\n-                throw new IllegalStateException(\"Cannot change annotation \" + originalLRAAnnotation\n-                        + \" of class \" + clazzToLookFor, e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Changing the LRA annotation declared on method by wrapping it with {@link LRAWrapped}.\n-     */\n-    static void adjustLRAAnnotation(Method method, LRA originalLRAAnnotation) {\n-        Field field = null;\n-        try {\n-            Class<?> executableClass = Class.forName(\"java.lang.reflect.Executable\");\n-            field = executableClass.getDeclaredField(\"declaredAnnotations\");\n-            field.setAccessible(true);\n-        } catch (ClassNotFoundException cnfe) {\n-            throw new IllegalStateException(\"Cannot instantiate class java.lang.reflect.Executable\", cnfe);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new IllegalStateException(\"Cannot find field 'declaredAnnotations' under instantiate class java.lang.reflect.Executable\", nsfe);\n-        }\n-        Map<Class<? extends Annotation>, Annotation> annotations = null;\n-        try {\n-            annotations = (Map<Class<? extends Annotation>, Annotation>) field.get(method);\n-        } catch (IllegalAccessException iae) {\n-            throw new IllegalStateException(\"Cannnot access field 'declaredAnnotations' of the method instance \" + method, iae);\n-        }\n-        log.debugf(\"Adjusting LRA annotation %s for method %s of class %s%n\",\n-                originalLRAAnnotation, method, method.getDeclaringClass().getName());\n-        annotations.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n-    }\n-\n-    /**\n-     * Expected for JDK lower to 7\n-     */\n-    private static boolean doesJDKDefineAnnotationsField() {\n-        boolean jdkLower = true;\n-        try {\n-            Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n-        } catch (NoSuchFieldException ignore) {\n-            jdkLower = false;\n-        }\n-        return jdkLower;\n-    }\n-\n-    private static class LRAWrapped implements LRA {\n-        private static final String TIMEOUT_FACTOR_PROPERTY = \"lra.tck.timeout.factor\";\n-        private final LRA wrapped;\n-\n-        LRAWrapped(LRA lraInstance) {\n-            this.wrapped = lraInstance;\n-        }\n-\n-        @Override\n-        public LRA.Type value() {\n-            return wrapped.value();\n-        }\n-\n-        @Override\n-        public long timeLimit() {\n-            return getTimeout(wrapped.timeLimit());\n-        }\n-\n-        @Override\n-        public ChronoUnit timeUnit() {\n-            return wrapped.timeUnit();\n-        }\n-\n-        @Override\n-        public boolean end() {\n-            return wrapped.end();\n-        }\n-\n-        @Override\n-        public Response.Status.Family[] cancelOnFamily() {\n-            return wrapped.cancelOnFamily();\n-        }\n-\n-        @Override\n-        public Response.Status[] cancelOn() {\n-            return wrapped.cancelOn();\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            return wrapped.equals(obj);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return wrapped.hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return wrapped.toString();\n-        }\n-\n-        @Override\n-        public Class<? extends Annotation> annotationType() {\n-            return wrapped.annotationType();\n-        }\n-\n-        private long getTimeout(long originalTimeout) {\n-            if (originalTimeout <= 0) {\n-                return 0;\n-            }\n-            String timeoutFactorString = System.getProperty(TIMEOUT_FACTOR_PROPERTY, \"1.0\");\n-            Double timeoutFactor = Double.parseDouble(timeoutFactorString);\n-            if (timeoutFactor <= 0) {\n-                return originalTimeout;\n-            }\n-            return (long) Math.ceil(originalTimeout * timeoutFactor);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3ODMzOA==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442678338", "bodyText": "Fiendishly clever.\nAs an aside, we'd need to remember to change this class if the LRA annotation changes in MP-LRA 1.x.", "author": "mmusgrov", "createdAt": "2020-06-19T07:29:19Z", "path": "rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.spi;\n+\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+import org.jboss.logging.Logger;\n+\n+import javax.ws.rs.core.Response;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Helper class to do internal changes of annotations during runtime.\n+ */\n+public class LRAAnnotationAdjuster {\n+    private static final Logger log = Logger.getLogger(LRAAnnotationAdjuster.class);\n+    private static final String ANNOTATIONS_FIELD_NAME = \"annotations\";\n+    private static final String ANNOTATION_DATA_METHOD_NAME = \"annotationData\";\n+\n+    /**\n+     * Take the clazz, check if contains the {@link LRA} annotation.\n+     * The LRA annotation is then replaced by wrapped {@link LRAWrapped}.\n+     */\n+    static void processWithClass(Class<?> clazz) {\n+        LRA lraAnnotation = clazz.getDeclaredAnnotation(LRA.class);\n+        if (lraAnnotation != null) {\n+            LRAAnnotationAdjuster.adjustLRAAnnotation(clazz, lraAnnotation);\n+        }\n+        Arrays.stream(clazz.getMethods()).forEach(method -> {\n+            LRA lraAnnotationMethod = method.getDeclaredAnnotation(LRA.class);\n+            if (lraAnnotationMethod != null) {\n+                LRAAnnotationAdjuster.adjustLRAAnnotation(method, lraAnnotationMethod);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Changing the LRA annotation declared on class by wrapping it with {@link LRAWrapped}.\n+     */\n+    static void adjustLRAAnnotation(Class clazzToLookFor, LRA originalLRAAnnotation) {\n+        if (doesJDKDefineAnnotationsField()) {\n+            // JDK7 has \"annotations\" field\n+            try {\n+                Field annotations = Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n+                annotations.setAccessible(true);\n+                Map<Class<? extends Annotation>, Annotation> map =\n+                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(clazzToLookFor);\n+                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n+            } catch (Exception  e) {\n+                e.printStackTrace();\n+            }\n+        } else {\n+            try {\n+                // JDK8+ has \"annotationData\" private method\n+                // obtaining reference to private class AnnotationData\n+                Method method = Class.class.getDeclaredMethod(ANNOTATION_DATA_METHOD_NAME, null);\n+                method.setAccessible(true);\n+                // AnnotationData is private need to work with Object\n+                Object annotationData = method.invoke(clazzToLookFor);\n+                // AnnotationData works with map annotations\n+                Field annotations = annotationData.getClass().getDeclaredField(ANNOTATIONS_FIELD_NAME);\n+                annotations.setAccessible(true);\n+                Map<Class<? extends Annotation>, Annotation> map =\n+                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(annotationData);\n+                log.debugf(\"Adjusting LRA annotation %s for class %s%n\", originalLRAAnnotation, clazzToLookFor.getName());\n+                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n+            } catch (Exception  e) {\n+                throw new IllegalStateException(\"Cannot change annotation \" + originalLRAAnnotation\n+                        + \" of class \" + clazzToLookFor, e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Changing the LRA annotation declared on method by wrapping it with {@link LRAWrapped}.\n+     */\n+    static void adjustLRAAnnotation(Method method, LRA originalLRAAnnotation) {\n+        Field field = null;\n+        try {\n+            Class<?> executableClass = Class.forName(\"java.lang.reflect.Executable\");\n+            field = executableClass.getDeclaredField(\"declaredAnnotations\");\n+            field.setAccessible(true);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new IllegalStateException(\"Cannot instantiate class java.lang.reflect.Executable\", cnfe);\n+        } catch (NoSuchFieldException nsfe) {\n+            throw new IllegalStateException(\"Cannot find field 'declaredAnnotations' under instantiate class java.lang.reflect.Executable\", nsfe);\n+        }\n+        Map<Class<? extends Annotation>, Annotation> annotations = null;\n+        try {\n+            annotations = (Map<Class<? extends Annotation>, Annotation>) field.get(method);\n+        } catch (IllegalAccessException iae) {\n+            throw new IllegalStateException(\"Cannnot access field 'declaredAnnotations' of the method instance \" + method, iae);\n+        }\n+        log.debugf(\"Adjusting LRA annotation %s for method %s of class %s%n\",\n+                originalLRAAnnotation, method, method.getDeclaringClass().getName());\n+        annotations.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n+    }\n+\n+    /**\n+     * Expected for JDK lower to 7\n+     */\n+    private static boolean doesJDKDefineAnnotationsField() {\n+        boolean jdkLower = true;\n+        try {\n+            Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n+        } catch (NoSuchFieldException ignore) {\n+            jdkLower = false;\n+        }\n+        return jdkLower;\n+    }\n+\n+    private static class LRAWrapped implements LRA {", "originalCommit": "82ebd15bb3b94e6b4b82f4bc6fc71052e74c0a9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc2MDIwNQ==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442760205", "bodyText": "sure. I think that should be fine as this is part of the test which is usually compiled and run. The compilation would fail if the LRAWrapped does not implement some LRA method (or implement a different definition).", "author": "ochaloup", "createdAt": "2020-06-19T10:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3ODMzOA=="}], "type": "inlineReview", "revised_code": {"commit": "aa22d9a407cab517f5fad69f070361c2de0b9953", "chunk": "diff --git a/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java b/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java\ndeleted file mode 100644\nindex 6cdbf1828..000000000\n--- a/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java\n+++ /dev/null\n\n@@ -1,206 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2020, Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags. See the copyright.txt file in the\n- * distribution for a full listing of individual contributors.\n- *\n- * This is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as\n- * published by the Free Software Foundation; either version 2.1 of\n- * the License, or (at your option) any later version.\n- *\n- * This software is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this software; if not, write to the Free\n- * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n- * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n- */\n-\n-package io.narayana.lra.arquillian.spi;\n-\n-import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n-import org.jboss.logging.Logger;\n-\n-import javax.ws.rs.core.Response;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Map;\n-\n-/**\n- * Helper class to do internal changes of annotations during runtime.\n- */\n-public class LRAAnnotationAdjuster {\n-    private static final Logger log = Logger.getLogger(LRAAnnotationAdjuster.class);\n-    private static final String ANNOTATIONS_FIELD_NAME = \"annotations\";\n-    private static final String ANNOTATION_DATA_METHOD_NAME = \"annotationData\";\n-\n-    /**\n-     * Take the clazz, check if contains the {@link LRA} annotation.\n-     * The LRA annotation is then replaced by wrapped {@link LRAWrapped}.\n-     */\n-    static void processWithClass(Class<?> clazz) {\n-        LRA lraAnnotation = clazz.getDeclaredAnnotation(LRA.class);\n-        if (lraAnnotation != null) {\n-            LRAAnnotationAdjuster.adjustLRAAnnotation(clazz, lraAnnotation);\n-        }\n-        Arrays.stream(clazz.getMethods()).forEach(method -> {\n-            LRA lraAnnotationMethod = method.getDeclaredAnnotation(LRA.class);\n-            if (lraAnnotationMethod != null) {\n-                LRAAnnotationAdjuster.adjustLRAAnnotation(method, lraAnnotationMethod);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Changing the LRA annotation declared on class by wrapping it with {@link LRAWrapped}.\n-     */\n-    static void adjustLRAAnnotation(Class clazzToLookFor, LRA originalLRAAnnotation) {\n-        if (doesJDKDefineAnnotationsField()) {\n-            // JDK7 has \"annotations\" field\n-            try {\n-                Field annotations = Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n-                annotations.setAccessible(true);\n-                Map<Class<? extends Annotation>, Annotation> map =\n-                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(clazzToLookFor);\n-                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n-            } catch (Exception  e) {\n-                e.printStackTrace();\n-            }\n-        } else {\n-            try {\n-                // JDK8+ has \"annotationData\" private method\n-                // obtaining reference to private class AnnotationData\n-                Method method = Class.class.getDeclaredMethod(ANNOTATION_DATA_METHOD_NAME, null);\n-                method.setAccessible(true);\n-                // AnnotationData is private need to work with Object\n-                Object annotationData = method.invoke(clazzToLookFor);\n-                // AnnotationData works with map annotations\n-                Field annotations = annotationData.getClass().getDeclaredField(ANNOTATIONS_FIELD_NAME);\n-                annotations.setAccessible(true);\n-                Map<Class<? extends Annotation>, Annotation> map =\n-                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(annotationData);\n-                log.debugf(\"Adjusting LRA annotation %s for class %s%n\", originalLRAAnnotation, clazzToLookFor.getName());\n-                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n-            } catch (Exception  e) {\n-                throw new IllegalStateException(\"Cannot change annotation \" + originalLRAAnnotation\n-                        + \" of class \" + clazzToLookFor, e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Changing the LRA annotation declared on method by wrapping it with {@link LRAWrapped}.\n-     */\n-    static void adjustLRAAnnotation(Method method, LRA originalLRAAnnotation) {\n-        Field field = null;\n-        try {\n-            Class<?> executableClass = Class.forName(\"java.lang.reflect.Executable\");\n-            field = executableClass.getDeclaredField(\"declaredAnnotations\");\n-            field.setAccessible(true);\n-        } catch (ClassNotFoundException cnfe) {\n-            throw new IllegalStateException(\"Cannot instantiate class java.lang.reflect.Executable\", cnfe);\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new IllegalStateException(\"Cannot find field 'declaredAnnotations' under instantiate class java.lang.reflect.Executable\", nsfe);\n-        }\n-        Map<Class<? extends Annotation>, Annotation> annotations = null;\n-        try {\n-            annotations = (Map<Class<? extends Annotation>, Annotation>) field.get(method);\n-        } catch (IllegalAccessException iae) {\n-            throw new IllegalStateException(\"Cannnot access field 'declaredAnnotations' of the method instance \" + method, iae);\n-        }\n-        log.debugf(\"Adjusting LRA annotation %s for method %s of class %s%n\",\n-                originalLRAAnnotation, method, method.getDeclaringClass().getName());\n-        annotations.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n-    }\n-\n-    /**\n-     * Expected for JDK lower to 7\n-     */\n-    private static boolean doesJDKDefineAnnotationsField() {\n-        boolean jdkLower = true;\n-        try {\n-            Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n-        } catch (NoSuchFieldException ignore) {\n-            jdkLower = false;\n-        }\n-        return jdkLower;\n-    }\n-\n-    private static class LRAWrapped implements LRA {\n-        private static final String TIMEOUT_FACTOR_PROPERTY = \"lra.tck.timeout.factor\";\n-        private final LRA wrapped;\n-\n-        LRAWrapped(LRA lraInstance) {\n-            this.wrapped = lraInstance;\n-        }\n-\n-        @Override\n-        public LRA.Type value() {\n-            return wrapped.value();\n-        }\n-\n-        @Override\n-        public long timeLimit() {\n-            return getTimeout(wrapped.timeLimit());\n-        }\n-\n-        @Override\n-        public ChronoUnit timeUnit() {\n-            return wrapped.timeUnit();\n-        }\n-\n-        @Override\n-        public boolean end() {\n-            return wrapped.end();\n-        }\n-\n-        @Override\n-        public Response.Status.Family[] cancelOnFamily() {\n-            return wrapped.cancelOnFamily();\n-        }\n-\n-        @Override\n-        public Response.Status[] cancelOn() {\n-            return wrapped.cancelOn();\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            return wrapped.equals(obj);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return wrapped.hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return wrapped.toString();\n-        }\n-\n-        @Override\n-        public Class<? extends Annotation> annotationType() {\n-            return wrapped.annotationType();\n-        }\n-\n-        private long getTimeout(long originalTimeout) {\n-            if (originalTimeout <= 0) {\n-                return 0;\n-            }\n-            String timeoutFactorString = System.getProperty(TIMEOUT_FACTOR_PROPERTY, \"1.0\");\n-            Double timeoutFactor = Double.parseDouble(timeoutFactorString);\n-            if (timeoutFactor <= 0) {\n-                return originalTimeout;\n-            }\n-            return (long) Math.ceil(originalTimeout * timeoutFactor);\n-        }\n-    }\n-}\n"}}, {"oid": "aa22d9a407cab517f5fad69f070361c2de0b9953", "url": "https://github.com/jbosstm/narayana/commit/aa22d9a407cab517f5fad69f070361c2de0b9953", "message": "[JBTM-3318] enabling TckRecoveryTests#testCancelWhenParticipantIsUnavailable", "committedDate": "2020-06-19T10:13:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODY3NA==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442808674", "bodyText": "I think you prefer logging instead of stack traces.", "author": "xstefank", "createdAt": "2020-06-19T12:23:13Z", "path": "rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.spi;\n+\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+import org.jboss.logging.Logger;\n+\n+import javax.ws.rs.core.Response;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Helper class to do internal changes of annotations during runtime.\n+ */\n+public class LRAAnnotationAdjuster {\n+    private static final Logger log = Logger.getLogger(LRAAnnotationAdjuster.class);\n+    private static final String ANNOTATIONS_FIELD_NAME = \"annotations\";\n+    private static final String ANNOTATION_DATA_METHOD_NAME = \"annotationData\";\n+\n+    /**\n+     * Take the clazz, check if contains the {@link LRA} annotation.\n+     * The LRA annotation is then replaced by wrapped {@link LRAWrapped}.\n+     */\n+    static void processWithClass(Class<?> clazz) {\n+        LRA lraAnnotation = clazz.getDeclaredAnnotation(LRA.class);\n+        if (lraAnnotation != null) {\n+            LRAAnnotationAdjuster.adjustLRAAnnotation(clazz, lraAnnotation);\n+        }\n+        Arrays.stream(clazz.getMethods()).forEach(method -> {\n+            LRA lraAnnotationMethod = method.getDeclaredAnnotation(LRA.class);\n+            if (lraAnnotationMethod != null) {\n+                LRAAnnotationAdjuster.adjustLRAAnnotation(method, lraAnnotationMethod);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Changing the LRA annotation declared on class by wrapping it with {@link LRAWrapped}.\n+     */\n+    static void adjustLRAAnnotation(Class clazzToLookFor, LRA originalLRAAnnotation) {\n+        if (doesJDKDefineAnnotationsField()) {\n+            // JDK7 has \"annotations\" field\n+            try {\n+                Field annotations = Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n+                annotations.setAccessible(true);\n+                Map<Class<? extends Annotation>, Annotation> map =\n+                        (Map<Class<? extends Annotation>, Annotation>) annotations.get(clazzToLookFor);\n+                map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n+            } catch (Exception  e) {\n+                e.printStackTrace();", "originalCommit": "82ebd15bb3b94e6b4b82f4bc6fc71052e74c0a9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNzgwOQ==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442817809", "bodyText": "+1", "author": "ochaloup", "createdAt": "2020-06-19T12:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "58abf647448d7129a2e8a3135b4b0e573cfdf85b", "chunk": "diff --git a/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java b/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java\nindex 6cdbf1828..9df7c79c0 100644\n--- a/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java\n+++ b/rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/LRAAnnotationAdjuster.java\n\n@@ -61,36 +61,39 @@ public class LRAAnnotationAdjuster {\n     /**\n      * Changing the LRA annotation declared on class by wrapping it with {@link LRAWrapped}.\n      */\n-    static void adjustLRAAnnotation(Class clazzToLookFor, LRA originalLRAAnnotation) {\n+    static void adjustLRAAnnotation(Class<?> clazzToLookFor, LRA originalLRAAnnotation) {\n         if (doesJDKDefineAnnotationsField()) {\n             // JDK7 has \"annotations\" field\n             try {\n                 Field annotations = Class.class.getDeclaredField(ANNOTATIONS_FIELD_NAME);\n                 annotations.setAccessible(true);\n+                @SuppressWarnings(\"unchecked\")\n                 Map<Class<? extends Annotation>, Annotation> map =\n                         (Map<Class<? extends Annotation>, Annotation>) annotations.get(clazzToLookFor);\n                 map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n             } catch (Exception  e) {\n-                e.printStackTrace();\n+                throw new IllegalStateException(\"Cannot change annotation \" + originalLRAAnnotation\n+                        + \" of class \" + clazzToLookFor + \" in JDK7 way\", e);\n             }\n         } else {\n             try {\n                 // JDK8+ has \"annotationData\" private method\n                 // obtaining reference to private class AnnotationData\n-                Method method = Class.class.getDeclaredMethod(ANNOTATION_DATA_METHOD_NAME, null);\n+                Method method = Class.class.getDeclaredMethod(ANNOTATION_DATA_METHOD_NAME);\n                 method.setAccessible(true);\n                 // AnnotationData is private need to work with Object\n                 Object annotationData = method.invoke(clazzToLookFor);\n                 // AnnotationData works with map annotations\n                 Field annotations = annotationData.getClass().getDeclaredField(ANNOTATIONS_FIELD_NAME);\n                 annotations.setAccessible(true);\n+                @SuppressWarnings(\"unchecked\")\n                 Map<Class<? extends Annotation>, Annotation> map =\n                         (Map<Class<? extends Annotation>, Annotation>) annotations.get(annotationData);\n                 log.debugf(\"Adjusting LRA annotation %s for class %s%n\", originalLRAAnnotation, clazzToLookFor.getName());\n                 map.put(LRA.class, new LRAWrapped(originalLRAAnnotation));\n             } catch (Exception  e) {\n                 throw new IllegalStateException(\"Cannot change annotation \" + originalLRAAnnotation\n-                        + \" of class \" + clazzToLookFor, e);\n+                        + \" of class \" + clazzToLookFor + \" in JDK8 way\", e);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMjc3Ng==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442812776", "bodyText": "wouldn't be better to use getName() here?", "author": "xstefank", "createdAt": "2020-06-19T12:32:01Z", "path": "rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/NarayanaLRARecovery.java", "diffHunk": "@@ -32,6 +33,25 @@\n import java.net.URI;\n \n public class NarayanaLRARecovery implements LRARecoveryService {\n+    private static final Logger log = Logger.getLogger(NarayanaLRARecovery.class);\n+\n+    /**\n+     * A bit of hacking to change the internals of annotations defined in LRA TCK.\n+     * There is need to adjust timeout defined on the annotation definition.\n+     */\n+    static {\n+        String[] resourceClassNames = new String[]{\n+                \"org.eclipse.microprofile.lra.tck.participant.api.LraResource\",\n+                \"org.eclipse.microprofile.lra.tck.participant.api.RecoveryResource\"};", "originalCommit": "82ebd15bb3b94e6b4b82f4bc6fc71052e74c0a9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2ODk5MQ==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r442968991", "bodyText": "not using the getName() was intentional. If the extension is used for deployments where these resources are not provided then using of the Class.getName() makes the whole NarayanaLRARecoveryfailing as it tries to link a class which is not on classpath.\nIt's the case e.g. for lra-test-basic where those classes are not available.", "author": "ochaloup", "createdAt": "2020-06-19T17:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMjc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0Mjc4MA==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r443142780", "bodyText": "wouldn't it be better than to add LRA TCK dependency to the basic module (or better this module) then to keep track of possible renames in the dependent project? :)", "author": "xstefank", "createdAt": "2020-06-20T16:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMjc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU2OTMyOQ==", "url": "https://github.com/jbosstm/narayana/pull/1637#discussion_r443569329", "bodyText": "I was investigating here a bit about what's needed to do and the TCK dependency would need to be added to any module which is to use the arquillian extension. I don't want to add such requirements on users.\nThis is an enhancement for the TCK behaviour (and I agree it's a bit hacky but without definition of long pause time into TCK our AMS CI is currently in troubles to get running properly the LRA tests) and not any other tests.\nWhen there is a failure on loading class (ie. the TCK tests is renamed) then if the test starts to fail it will be needed to investigate the reasons.\nBy me this loosely coupling of this Arq extenstion to TCK tests is desired here.", "author": "ochaloup", "createdAt": "2020-06-22T13:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMjc3Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "58abf647448d7129a2e8a3135b4b0e573cfdf85b", "url": "https://github.com/jbosstm/narayana/commit/58abf647448d7129a2e8a3135b4b0e573cfdf85b", "message": "[JBTM-3318] Adjusting LRA annotation 'timeLimit' value with factor\n\nThis is a reflection over the LRA annotations to fix timing issues on\nAMS CI which is slow and it may happen that the LRA is\ntimeouted/cancelled before the business method is invoked.\n\nThat's a trouble as the TCK tests are written in way to get the business\nmethod invoke and only after that the timeout should be elapsed\nsometimes later.", "committedDate": "2020-06-19T17:43:56Z", "type": "commit"}, {"oid": "58abf647448d7129a2e8a3135b4b0e573cfdf85b", "url": "https://github.com/jbosstm/narayana/commit/58abf647448d7129a2e8a3135b4b0e573cfdf85b", "message": "[JBTM-3318] Adjusting LRA annotation 'timeLimit' value with factor\n\nThis is a reflection over the LRA annotations to fix timing issues on\nAMS CI which is slow and it may happen that the LRA is\ntimeouted/cancelled before the business method is invoked.\n\nThat's a trouble as the TCK tests are written in way to get the business\nmethod invoke and only after that the timeout should be elapsed\nsometimes later.", "committedDate": "2020-06-19T17:43:56Z", "type": "forcePushed"}]}