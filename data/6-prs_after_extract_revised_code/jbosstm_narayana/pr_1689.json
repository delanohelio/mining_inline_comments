{"pr_number": 1689, "pr_title": "JBTM-3361 recovery for non-unique xids", "pr_createdAt": "2020-10-12T08:33:53Z", "pr_url": "https://github.com/jbosstm/narayana/pull/1689", "timeline": [{"oid": "daddd12330a25edfcbb7309e34a9ad2934c4d06d", "url": "https://github.com/jbosstm/narayana/commit/daddd12330a25edfcbb7309e34a9ad2934c4d06d", "message": "JBTM-3361 recovery for non-unique xids\nimprove name matching", "committedDate": "2020-10-12T08:31:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0NzE1MQ==", "url": "https://github.com/jbosstm/narayana/pull/1689#discussion_r503147151", "bodyText": "Let's hope there are no legacy XTS customers that fall into this category.", "author": "mmusgrov", "createdAt": "2020-10-12T09:04:23Z", "path": "ArjunaJTA/jta/classes/com/arjuna/ats/internal/jta/recovery/arjunacore/XARecoveryModule.java", "diffHunk": "@@ -352,14 +352,63 @@ private XAResource getNewXAResource(Xid xid, String jndiName)\n \t\t\t\t * after the call to periodicWorkFirstPass but before the call to getTheKey\n \t\t\t\t */\n \t\t\t\tperiodicWorkFirstPass(ScanStates.IDLE);\n-\t\t\t\ttoReturn = getTheKey(key);\n+\t\t\t\ttoReturn = getTheKey(key, false);\n+\t\t\t\tif(toReturn == null) {\n+\t\t\t\t\t// last resort, accept a weaker match if there is one\n+\t\t\t\t\ttoReturn = getTheKey(key, true);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn toReturn;\n     }\n \n-    private XAResource getTheKey(NameScopedXid scopedXid) {\n+\t/*\n+\t An Xid value we're looking for, described from the objectstore log record by scopedXid,\n+\t   also appears in the recovery xa scan of theKey.\n+\t However, that does not necessarily mean that theKey's XAResource can be used for recovering it\n+\t   as non-unique (inflowed) xids may appear under multiple, potentially non-interchangeable, keys.\n+\t */\n+\tprivate boolean isReasonableMatch(NameScopedXid scopedXid, NameScopedXAResource theKey, boolean relaxedMatch) {\n+\t\tjtaLogger.logger.trace(\"isReasonableMatch \"+scopedXid+\" \"+theKey+\" \"+relaxedMatch);\n+\n+\t\t// JTA Xids are always unique (see TransactionImple::createXid)\n+\t\t// so can appear in only one place. Just ignore any metadata.\n+\t\tif(scopedXid.getXid().getFormatId() == XATxConverter.FORMAT_ID) {\n+\t\t\tjtaLogger.logger.trace(\"isReasonableMatch true by FORMAT_ID\");\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// all other xids may be non-uniq branches and appear under more than one theKey\n+\t\t// so we need some additional rules to try and get the right one...\n+\n+\t\t// where the jndi name in the log matches the resources name, it's a good bet.\n+\t\t// this covers the ironjacamar integration case for databases in wildfly/EAP\n+\t\tif(!scopedXid.isAnonymous() && scopedXid.isSameName(theKey)) {\n+\t\t\tjtaLogger.logger.trace(\"isReasonableMatch true by exact name\");\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// some integrations, notable HornetQ, provide name metadata in the enlistment side\n+\t\t// (so it winds up in the logs and hence in scopedXid)\n+\t\t// but not on the recovery side (so theKey is unnamed).\n+\t\t// If we've failed to make a stronger match, then that will have to do,\n+\t\t// even though it's potentially wrong.\n+\t\tif(relaxedMatch && !(!scopedXid.isAnonymous() && !theKey.isAnonymous())) {\n+\t\t\tjtaLogger.logger.trace(\"isReasonableMatch true by relaxed name\");\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// at this point there is one remaining valid case... the names on both side are set and don't match", "originalCommit": "daddd12330a25edfcbb7309e34a9ad2934c4d06d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}