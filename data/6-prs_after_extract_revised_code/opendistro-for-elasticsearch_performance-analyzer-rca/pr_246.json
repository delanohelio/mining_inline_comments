{"pr_number": 246, "pr_title": "Add a base class for cluster RCA and derive QueueRejectionClusterRca from it", "pr_createdAt": "2020-06-16T01:08:42Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246", "timeline": [{"oid": "dcc0da6b9a821aab91995a22cb90a175f6459bd2", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/dcc0da6b9a821aab91995a22cb90a175f6459bd2", "message": "WIP", "committedDate": "2020-06-12T22:57:20Z", "type": "commit"}, {"oid": "858c9e0bfc0d996fb1c533ad8b8d9b4a963d83f5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/858c9e0bfc0d996fb1c533ad8b8d9b4a963d83f5", "message": "Merge remote-tracking branch 'origin' into rguo-cluster", "committedDate": "2020-06-15T18:22:55Z", "type": "commit"}, {"oid": "4d914a0840548abf537f84eef6b09a92d9b141ff", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/4d914a0840548abf537f84eef6b09a92d9b141ff", "message": "Add a base class for cluster RCA BaseClusterRca", "committedDate": "2020-06-16T01:01:25Z", "type": "commit"}, {"oid": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d4118d6eb9b0f4cd77960684f97984aa462e6375", "message": "add support for subscribing multiple rca", "committedDate": "2020-06-17T01:58:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MTY5Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445261697", "bodyText": "Can we add documentation around the table dimensions, for example, not sure what does the String denote here.", "author": "khushbr", "createdAt": "2020-06-25T01:40:54Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NzA2Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445747062", "bodyText": "I will addd a comment there for clarity. String here is the name of the node level RCA. This would allow this cluster RCA to subscribe and store flowunits from multiple types of node level RCA(which might not be useful in queue cluster / cache cluster RCA )", "author": "rguo-aws", "createdAt": "2020-06-25T18:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MTY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2NzkyMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445267920", "bodyText": "Execute pollFirst() until the size of linkedList is less than equal to numOfFlowUnitsInMap ?", "author": "khushbr", "createdAt": "2020-06-25T02:06:09Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n+  private final int rcaPeriod;\n+  private int counter;\n+  protected Clock clock;\n+  protected int numOfFlowUnitsInMap;\n+  protected boolean collectFromMasterNode;\n+  protected long expirationTimeWindow;\n+\n+\n+  @SafeVarargs\n+  public <R extends Rca<ResourceFlowUnit<HotNodeSummary>>> BaseClusterRca(final int rcaPeriod,\n+      final R... nodeRca) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    this.counter = 0;\n+    this.clock = Clock.systemUTC();\n+    this.numOfFlowUnitsInMap = DEFAULT_NUM_OF_FLOWUNITS;\n+    this.nodeTable = HashBasedTable.create();\n+    this.collectFromMasterNode = false;\n+    this.expirationTimeWindow = TIMESTAMP_EXPIRATION_IN_MILLIS;\n+    this.nodeRcas = Arrays.asList(nodeRca);\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @VisibleForTesting\n+  public void setCollectFromMasterNode(boolean collectFromMasterNode) {\n+    this.collectFromMasterNode = collectFromMasterNode;\n+  }\n+\n+  //add upstream flowunits collected from different nodes into Table\n+  private void addUpstreamFlowUnits(Rca<ResourceFlowUnit<HotNodeSummary>> nodeRca) {\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnits = nodeRca.getFlowUnits();\n+    for (ResourceFlowUnit<HotNodeSummary> flowUnit : flowUnits) {\n+      if (flowUnit.isEmpty()) {\n+        continue;\n+      }\n+      HotNodeSummary nodeSummary = flowUnit.getSummary();\n+      NodeKey nodeKey = new NodeKey(nodeSummary.getNodeID(), nodeSummary.getHostAddress());\n+\n+      if (nodeTable.get(nodeKey, nodeRca.name()) == null) {\n+        nodeTable.put(nodeKey, nodeRca.name(), new LinkedList<>());\n+      }\n+      LinkedList<ResourceFlowUnit<HotNodeSummary>> linkedList = nodeTable.get(nodeKey, nodeRca.name());\n+      linkedList.addLast(flowUnit);\n+      if (linkedList.size() > numOfFlowUnitsInMap) {\n+        linkedList.pollFirst();", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NTUwMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445745500", "bodyText": "yes, this is to make sure the linked list only contains the last numOfFlowUnitsInMap  flowunits from each node", "author": "rguo-aws", "createdAt": "2020-06-25T18:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2NzkyMA=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2OTAwNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445269007", "bodyText": "Do we need NodeKey here or just  Host IP Address should be enough ?", "author": "khushbr", "createdAt": "2020-06-25T02:10:31Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n+  private final int rcaPeriod;\n+  private int counter;\n+  protected Clock clock;\n+  protected int numOfFlowUnitsInMap;\n+  protected boolean collectFromMasterNode;\n+  protected long expirationTimeWindow;\n+\n+\n+  @SafeVarargs\n+  public <R extends Rca<ResourceFlowUnit<HotNodeSummary>>> BaseClusterRca(final int rcaPeriod,\n+      final R... nodeRca) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    this.counter = 0;\n+    this.clock = Clock.systemUTC();\n+    this.numOfFlowUnitsInMap = DEFAULT_NUM_OF_FLOWUNITS;\n+    this.nodeTable = HashBasedTable.create();\n+    this.collectFromMasterNode = false;\n+    this.expirationTimeWindow = TIMESTAMP_EXPIRATION_IN_MILLIS;\n+    this.nodeRcas = Arrays.asList(nodeRca);\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @VisibleForTesting\n+  public void setCollectFromMasterNode(boolean collectFromMasterNode) {\n+    this.collectFromMasterNode = collectFromMasterNode;\n+  }\n+\n+  //add upstream flowunits collected from different nodes into Table\n+  private void addUpstreamFlowUnits(Rca<ResourceFlowUnit<HotNodeSummary>> nodeRca) {\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnits = nodeRca.getFlowUnits();\n+    for (ResourceFlowUnit<HotNodeSummary> flowUnit : flowUnits) {\n+      if (flowUnit.isEmpty()) {\n+        continue;\n+      }\n+      HotNodeSummary nodeSummary = flowUnit.getSummary();\n+      NodeKey nodeKey = new NodeKey(nodeSummary.getNodeID(), nodeSummary.getHostAddress());", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0ODY1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445748655", "bodyText": "Having a dedicated NodeKey object as the key would make it easier for us to create the output summary.  HotNodeSummary will need both id and address and we have to maintain a separate map here to map node id -> (node id, address ip) if we use node id only as the key.", "author": "rguo-aws", "createdAt": "2020-06-25T18:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2OTAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2OTkwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445269909", "bodyText": "How are we getting this list of nodes within Cluster? Are we polling ES here?\nIf yes, then we should definitely move this to use ClusterDetailsEventProcessor now then later.", "author": "khushbr", "createdAt": "2020-06-25T02:14:21Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n+  private final int rcaPeriod;\n+  private int counter;\n+  protected Clock clock;\n+  protected int numOfFlowUnitsInMap;\n+  protected boolean collectFromMasterNode;\n+  protected long expirationTimeWindow;\n+\n+\n+  @SafeVarargs\n+  public <R extends Rca<ResourceFlowUnit<HotNodeSummary>>> BaseClusterRca(final int rcaPeriod,\n+      final R... nodeRca) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    this.counter = 0;\n+    this.clock = Clock.systemUTC();\n+    this.numOfFlowUnitsInMap = DEFAULT_NUM_OF_FLOWUNITS;\n+    this.nodeTable = HashBasedTable.create();\n+    this.collectFromMasterNode = false;\n+    this.expirationTimeWindow = TIMESTAMP_EXPIRATION_IN_MILLIS;\n+    this.nodeRcas = Arrays.asList(nodeRca);\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @VisibleForTesting\n+  public void setCollectFromMasterNode(boolean collectFromMasterNode) {\n+    this.collectFromMasterNode = collectFromMasterNode;\n+  }\n+\n+  //add upstream flowunits collected from different nodes into Table\n+  private void addUpstreamFlowUnits(Rca<ResourceFlowUnit<HotNodeSummary>> nodeRca) {\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnits = nodeRca.getFlowUnits();\n+    for (ResourceFlowUnit<HotNodeSummary> flowUnit : flowUnits) {\n+      if (flowUnit.isEmpty()) {\n+        continue;\n+      }\n+      HotNodeSummary nodeSummary = flowUnit.getSummary();\n+      NodeKey nodeKey = new NodeKey(nodeSummary.getNodeID(), nodeSummary.getHostAddress());\n+\n+      if (nodeTable.get(nodeKey, nodeRca.name()) == null) {\n+        nodeTable.put(nodeKey, nodeRca.name(), new LinkedList<>());\n+      }\n+      LinkedList<ResourceFlowUnit<HotNodeSummary>> linkedList = nodeTable.get(nodeKey, nodeRca.name());\n+      linkedList.addLast(flowUnit);\n+      if (linkedList.size() > numOfFlowUnitsInMap) {\n+        linkedList.pollFirst();\n+      }\n+    }\n+  }\n+\n+  private List<NodeDetails> getClusterNodesDetails() {\n+    if (collectFromMasterNode) {\n+      return ClusterDetailsEventProcessor.getNodesDetails();\n+    }\n+    else {\n+      return ClusterDetailsEventProcessor.getDataNodesDetails();\n+    }\n+  }\n+\n+  // TODO : we might need to change this function later to use EventListener\n+  // to update the nodeMap whenever the ClusterDetailsEventProcessor is updated\n+  // so we don't have to keep polling the NodeDetails in every time window.\n+  private void removeInactiveNodeFromNodeMap() {\n+    Set<String> nodeIdSet = new HashSet<>();\n+    List<NodeKey> inactiveNodes = new ArrayList<>();\n+    for (NodeDetails nodeDetail : getClusterNodesDetails()) {", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc1MTM3MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445751371", "bodyText": "no, we are not polling ES here. This getClusterNodesDetails() read NodeDetails directly from ClusterDetailsEventProcessor. And the reason why I create a private method getClusterNodesDetails() here is to check whether we want to include master node or not in the final summary report. (some node level RCA might not run on master so we don't want to add the master nodes into the node list)", "author": "rguo-aws", "createdAt": "2020-06-25T18:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2OTkwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3MTMwMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445271302", "bodyText": "We can add a log statement here describing the inactiveNodes and their removal from nodeTable", "author": "khushbr", "createdAt": "2020-06-25T02:20:12Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n+  private final int rcaPeriod;\n+  private int counter;\n+  protected Clock clock;\n+  protected int numOfFlowUnitsInMap;\n+  protected boolean collectFromMasterNode;\n+  protected long expirationTimeWindow;\n+\n+\n+  @SafeVarargs\n+  public <R extends Rca<ResourceFlowUnit<HotNodeSummary>>> BaseClusterRca(final int rcaPeriod,\n+      final R... nodeRca) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    this.counter = 0;\n+    this.clock = Clock.systemUTC();\n+    this.numOfFlowUnitsInMap = DEFAULT_NUM_OF_FLOWUNITS;\n+    this.nodeTable = HashBasedTable.create();\n+    this.collectFromMasterNode = false;\n+    this.expirationTimeWindow = TIMESTAMP_EXPIRATION_IN_MILLIS;\n+    this.nodeRcas = Arrays.asList(nodeRca);\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @VisibleForTesting\n+  public void setCollectFromMasterNode(boolean collectFromMasterNode) {\n+    this.collectFromMasterNode = collectFromMasterNode;\n+  }\n+\n+  //add upstream flowunits collected from different nodes into Table\n+  private void addUpstreamFlowUnits(Rca<ResourceFlowUnit<HotNodeSummary>> nodeRca) {\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnits = nodeRca.getFlowUnits();\n+    for (ResourceFlowUnit<HotNodeSummary> flowUnit : flowUnits) {\n+      if (flowUnit.isEmpty()) {\n+        continue;\n+      }\n+      HotNodeSummary nodeSummary = flowUnit.getSummary();\n+      NodeKey nodeKey = new NodeKey(nodeSummary.getNodeID(), nodeSummary.getHostAddress());\n+\n+      if (nodeTable.get(nodeKey, nodeRca.name()) == null) {\n+        nodeTable.put(nodeKey, nodeRca.name(), new LinkedList<>());\n+      }\n+      LinkedList<ResourceFlowUnit<HotNodeSummary>> linkedList = nodeTable.get(nodeKey, nodeRca.name());\n+      linkedList.addLast(flowUnit);\n+      if (linkedList.size() > numOfFlowUnitsInMap) {\n+        linkedList.pollFirst();\n+      }\n+    }\n+  }\n+\n+  private List<NodeDetails> getClusterNodesDetails() {\n+    if (collectFromMasterNode) {\n+      return ClusterDetailsEventProcessor.getNodesDetails();\n+    }\n+    else {\n+      return ClusterDetailsEventProcessor.getDataNodesDetails();\n+    }\n+  }\n+\n+  // TODO : we might need to change this function later to use EventListener\n+  // to update the nodeMap whenever the ClusterDetailsEventProcessor is updated\n+  // so we don't have to keep polling the NodeDetails in every time window.\n+  private void removeInactiveNodeFromNodeMap() {\n+    Set<String> nodeIdSet = new HashSet<>();\n+    List<NodeKey> inactiveNodes = new ArrayList<>();\n+    for (NodeDetails nodeDetail : getClusterNodesDetails()) {\n+      nodeIdSet.add(nodeDetail.getId());\n+    }\n+    for (NodeKey nodeKey : nodeTable.rowKeySet()) {\n+      if (!nodeIdSet.contains(nodeKey.getNodeId())) {\n+        inactiveNodes.add(nodeKey);\n+      }\n+    }\n+    inactiveNodes.forEach(nodeKey -> nodeTable.row(nodeKey).clear());", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgwOTc3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445809775", "bodyText": "done", "author": "rguo-aws", "createdAt": "2020-06-25T20:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3MTMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3MzE2Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445273162", "bodyText": "generateFlowUnit() is invoked after removeInactiveNodeFromNodeMap(), where we refresh the active node lists.\nWe shouldn't be refreshing the list again here while generating flow units but instead, the consumer(decider) should take care of discarding any flowunits from inactive nodes.", "author": "khushbr", "createdAt": "2020-06-25T02:27:57Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n+  private final int rcaPeriod;\n+  private int counter;\n+  protected Clock clock;\n+  protected int numOfFlowUnitsInMap;\n+  protected boolean collectFromMasterNode;\n+  protected long expirationTimeWindow;\n+\n+\n+  @SafeVarargs\n+  public <R extends Rca<ResourceFlowUnit<HotNodeSummary>>> BaseClusterRca(final int rcaPeriod,\n+      final R... nodeRca) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    this.counter = 0;\n+    this.clock = Clock.systemUTC();\n+    this.numOfFlowUnitsInMap = DEFAULT_NUM_OF_FLOWUNITS;\n+    this.nodeTable = HashBasedTable.create();\n+    this.collectFromMasterNode = false;\n+    this.expirationTimeWindow = TIMESTAMP_EXPIRATION_IN_MILLIS;\n+    this.nodeRcas = Arrays.asList(nodeRca);\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @VisibleForTesting\n+  public void setCollectFromMasterNode(boolean collectFromMasterNode) {\n+    this.collectFromMasterNode = collectFromMasterNode;\n+  }\n+\n+  //add upstream flowunits collected from different nodes into Table\n+  private void addUpstreamFlowUnits(Rca<ResourceFlowUnit<HotNodeSummary>> nodeRca) {\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnits = nodeRca.getFlowUnits();\n+    for (ResourceFlowUnit<HotNodeSummary> flowUnit : flowUnits) {\n+      if (flowUnit.isEmpty()) {\n+        continue;\n+      }\n+      HotNodeSummary nodeSummary = flowUnit.getSummary();\n+      NodeKey nodeKey = new NodeKey(nodeSummary.getNodeID(), nodeSummary.getHostAddress());\n+\n+      if (nodeTable.get(nodeKey, nodeRca.name()) == null) {\n+        nodeTable.put(nodeKey, nodeRca.name(), new LinkedList<>());\n+      }\n+      LinkedList<ResourceFlowUnit<HotNodeSummary>> linkedList = nodeTable.get(nodeKey, nodeRca.name());\n+      linkedList.addLast(flowUnit);\n+      if (linkedList.size() > numOfFlowUnitsInMap) {\n+        linkedList.pollFirst();\n+      }\n+    }\n+  }\n+\n+  private List<NodeDetails> getClusterNodesDetails() {\n+    if (collectFromMasterNode) {\n+      return ClusterDetailsEventProcessor.getNodesDetails();\n+    }\n+    else {\n+      return ClusterDetailsEventProcessor.getDataNodesDetails();\n+    }\n+  }\n+\n+  // TODO : we might need to change this function later to use EventListener\n+  // to update the nodeMap whenever the ClusterDetailsEventProcessor is updated\n+  // so we don't have to keep polling the NodeDetails in every time window.\n+  private void removeInactiveNodeFromNodeMap() {\n+    Set<String> nodeIdSet = new HashSet<>();\n+    List<NodeKey> inactiveNodes = new ArrayList<>();\n+    for (NodeDetails nodeDetail : getClusterNodesDetails()) {\n+      nodeIdSet.add(nodeDetail.getId());\n+    }\n+    for (NodeKey nodeKey : nodeTable.rowKeySet()) {\n+      if (!nodeIdSet.contains(nodeKey.getNodeId())) {\n+        inactiveNodes.add(nodeKey);\n+      }\n+    }\n+    inactiveNodes.forEach(nodeKey -> nodeTable.row(nodeKey).clear());\n+  }\n+\n+  /**\n+   * generate flowunit for downstream based on the flowunits this RCA collects in hashmap\n+   * flowunits with timestamp beyond expirationTimeWindow time frame are  considered\n+   * as stale and ignored by this RCA.\n+   * @return flowunit for downstream vertices\n+   */\n+  private ResourceFlowUnit<HotClusterSummary> generateFlowUnit() {\n+    List<HotNodeSummary> unhealthyNodeSummaries = new ArrayList<>();\n+    long timestamp = clock.millis();\n+    List<NodeDetails> clusterNodesDetails = getClusterNodesDetails();", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk0NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445277944", "bodyText": "Suppose a node went down and came back up, the node will have the same hostAddress but the nodeId would change.\nSo, for such a case, we should ideally not treat this node as a new node and thus, match here based on the hostAddress. Thoughts?", "author": "khushbr", "createdAt": "2020-06-25T02:48:17Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+public class NodeKey {\n+  private final String nodeId;\n+  private final String hostAddress;\n+\n+  public NodeKey(String nodeId, String hostAddress) {\n+    this.nodeId = nodeId;\n+    this.hostAddress = hostAddress;\n+  }\n+\n+  public String getNodeId() {\n+    return nodeId;\n+  }\n+\n+  public String getHostAddress() {\n+    return hostAddress;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (obj instanceof NodeKey) {\n+      NodeKey key = (NodeKey)obj;\n+      return nodeId.equals(key.getNodeId());", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc1MjY2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445752665", "bodyText": "that is a good point. let's discuss with @vigyasharma on this and see what is the best approach", "author": "rguo-aws", "createdAt": "2020-06-25T18:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxMDU1OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445810558", "bodyText": "Had a discussion with Vigya and he said in newer ES versions,  both node ip and es node id are same after es restarts.", "author": "rguo-aws", "createdAt": "2020-06-25T20:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNzIyNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r446327226", "bodyText": "Given that this holds for all versions post ES5, I think we can safely use nodeID here.", "author": "khushbr", "createdAt": "2020-06-26T17:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk0NA=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java\nindex 5b20c411..52dce5c9 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java\n\n@@ -15,6 +15,8 @@\n \n package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n \n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n public class NodeKey {\n   private final String nodeId;\n   private final String hostAddress;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODYyNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445278627", "bodyText": "String based hashCode methods are inconsistent across different process and machines. Can we use something like below :\nHashCodeBuilder(17, 37)\n            .append(nodeId)\n            .toHashCode();", "author": "khushbr", "createdAt": "2020-06-25T02:51:04Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+public class NodeKey {\n+  private final String nodeId;\n+  private final String hostAddress;\n+\n+  public NodeKey(String nodeId, String hostAddress) {\n+    this.nodeId = nodeId;\n+    this.hostAddress = hostAddress;\n+  }\n+\n+  public String getNodeId() {\n+    return nodeId;\n+  }\n+\n+  public String getHostAddress() {\n+    return hostAddress;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (obj instanceof NodeKey) {\n+      NodeKey key = (NodeKey)obj;\n+      return nodeId.equals(key.getNodeId());\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return nodeId.hashCode();", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxMDk1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445810956", "bodyText": "done", "author": "rguo-aws", "createdAt": "2020-06-25T20:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java\nindex 5b20c411..52dce5c9 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java\n\n@@ -15,6 +15,8 @@\n \n package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n \n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n public class NodeKey {\n   private final String nodeId;\n   private final String hostAddress;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5MDc3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445290773", "bodyText": "We can 2 things here:\n\ndeclare the table nodeTable as protected, so in case we want to add other functionality in the sub class, we have access to nodeTable\nInstead of declaring the table in base class, we declare it in subclass and pass it around as a parameter.", "author": "khushbr", "createdAt": "2020-06-25T03:47:19Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc2MzUwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445763509", "bodyText": "Should this class also keep track of the fact that all NodeLevel RCAs are received within a time window or mark the node as unhealthy for missing heartbeat ?", "author": "yojs", "createdAt": "2020-06-25T18:42:28Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MzUwMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445793502", "bodyText": "we store timestamp as part of the flowunits in that 2D table. And it is up to the derived class to decide whether missing heartbeat needs to be considered or not. Any derived class can override the generateNodeSummary() method to re-implement the function to keep track of missing heartbeat. the default method will simple ignore the node if the flowunit is too stale and it does not receive flowunit from that particular node for a certain amount of time (default is set to 10 mins)", "author": "rguo-aws", "createdAt": "2020-06-25T19:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc2MzUwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc2NTEyMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445765120", "bodyText": "If we are building a base class for all RCA types, can we keep the HotClusterSummary part generic so that TemperatureProfile RCAs can make use of it as well ?", "author": "yojs", "createdAt": "2020-06-25T18:44:02Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {", "originalCommit": "d4118d6eb9b0f4cd77960684f97984aa462e6375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyMTQ4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r445921482", "bodyText": "As per out discussion, I will create separate base class for cluster summary and node summary so that we can make the  output flowunit generic. Let me address it in a separate PR. will create a issue for that", "author": "rguo-aws", "createdAt": "2020-06-26T01:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc2NTEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\nindex fe4dd285..b76ba075 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java\n\n@@ -36,22 +36,31 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n /**\n- * This is a generic cluster level RCA which subscripts a single upstream node level RCA.\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n  * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n- * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name). This RCA will\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n  * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n  * <p></p>\n  * A few protected variables that can be overridden by derived class:\n  * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n  * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n  * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n  */\n public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n   private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n   private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n   private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n   private final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n   private final int rcaPeriod;\n   private int counter;\n"}}, {"oid": "8e02f212b22190dcc0b7cc38c8f4cd2d6079ae0e", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/8e02f212b22190dcc0b7cc38c8f4cd2d6079ae0e", "message": "Merge remote-tracking branch 'origin/master' into rguo-cluster", "committedDate": "2020-06-25T21:01:22Z", "type": "commit"}, {"oid": "97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/97a182bc7fff91a9cf26fa2b8c0aff8ee8be3139", "message": "Address PR comments", "committedDate": "2020-06-25T21:59:25Z", "type": "commit"}, {"oid": "4288e7885672ea7e09ded900f3650d85b190b3d5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/4288e7885672ea7e09ded900f3650d85b190b3d5", "message": "Address more PR comments", "committedDate": "2020-06-26T01:16:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxODQ5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r446318492", "bodyText": "Can't this be done inside the above for loop?", "author": "yojs", "createdAt": "2020-06-26T17:33:00Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/BaseClusterRca.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources.State;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor.NodeDetails;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * This is a generic cluster level RCA which subscripts upstream node level RCAs and generate a flowunit\n+ * with cluster level summary that concludes the healthiness of the cluster in terms of those node level RCAs.\n+ * This cluster RCA maintains a Table to keep track of flowunits sending from different nodes across\n+ * the cluster. This table is a two dimensional table indexed by (NodeKey, Rca Name) and each cells stores\n+ * that last numOfFlowUnitsInMap flowunits it receives. This RCA will\n+ * mark the cluster as unhealthy if the flowunits from any data nodes are unhealthy.\n+ * <p></p>\n+ * A few protected variables that can be overridden by derived class:\n+ * numOfFlowUnitsInMap : number of consecutive flowunits stored in hashtable. Default is 1\n+ * collectFromMasterNode : whether this RCA collect flowunit from master nodes.\n+ * expirationTimeWindow : time window to determine whether flowunit in hashmap becomes stale\n+ * method that can be overriden :\n+ * generateNodeSummary(NodeKey) : how do we want to parse the table and generate summary for one node.\n+ */\n+public class BaseClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(BaseClusterRca.class);\n+  private static final int DEFAULT_NUM_OF_FLOWUNITS = 1;\n+  private static final long TIMESTAMP_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(10);\n+  private final List<Rca<ResourceFlowUnit<HotNodeSummary>>> nodeRcas;\n+  // two dimensional table indexed by (NodeKey, Rca Name) => last numOfFlowUnitsInMap flowunits\n+  protected final Table<NodeKey, String, LinkedList<ResourceFlowUnit<HotNodeSummary>>> nodeTable;\n+  private final int rcaPeriod;\n+  private int counter;\n+  protected Clock clock;\n+  protected int numOfFlowUnitsInMap;\n+  protected boolean collectFromMasterNode;\n+  protected long expirationTimeWindow;\n+\n+\n+  @SafeVarargs\n+  public <R extends Rca<ResourceFlowUnit<HotNodeSummary>>> BaseClusterRca(final int rcaPeriod,\n+      final R... nodeRca) {\n+    super(5);\n+    this.rcaPeriod = rcaPeriod;\n+    this.counter = 0;\n+    this.clock = Clock.systemUTC();\n+    this.numOfFlowUnitsInMap = DEFAULT_NUM_OF_FLOWUNITS;\n+    this.nodeTable = HashBasedTable.create();\n+    this.collectFromMasterNode = false;\n+    this.expirationTimeWindow = TIMESTAMP_EXPIRATION_IN_MILLIS;\n+    this.nodeRcas = Arrays.asList(nodeRca);\n+  }\n+\n+  @VisibleForTesting\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n+  }\n+\n+  @VisibleForTesting\n+  public void setCollectFromMasterNode(boolean collectFromMasterNode) {\n+    this.collectFromMasterNode = collectFromMasterNode;\n+  }\n+\n+  //add upstream flowunits collected from different nodes into Table\n+  private void addUpstreamFlowUnits(Rca<ResourceFlowUnit<HotNodeSummary>> nodeRca) {\n+    List<ResourceFlowUnit<HotNodeSummary>> flowUnits = nodeRca.getFlowUnits();\n+    for (ResourceFlowUnit<HotNodeSummary> flowUnit : flowUnits) {\n+      if (flowUnit.isEmpty()) {\n+        continue;\n+      }\n+      HotNodeSummary nodeSummary = flowUnit.getSummary();\n+      NodeKey nodeKey = new NodeKey(nodeSummary.getNodeID(), nodeSummary.getHostAddress());\n+\n+      if (nodeTable.get(nodeKey, nodeRca.name()) == null) {\n+        nodeTable.put(nodeKey, nodeRca.name(), new LinkedList<>());\n+      }\n+      LinkedList<ResourceFlowUnit<HotNodeSummary>> linkedList = nodeTable.get(nodeKey, nodeRca.name());\n+      linkedList.addLast(flowUnit);\n+      if (linkedList.size() > numOfFlowUnitsInMap) {\n+        linkedList.pollFirst();\n+      }\n+    }\n+  }\n+\n+  private List<NodeDetails> getClusterNodesDetails() {\n+    if (collectFromMasterNode) {\n+      return ClusterDetailsEventProcessor.getNodesDetails();\n+    }\n+    else {\n+      return ClusterDetailsEventProcessor.getDataNodesDetails();\n+    }\n+  }\n+\n+  // TODO : we might need to change this function later to use EventListener\n+  // to update the nodeMap whenever the ClusterDetailsEventProcessor is updated\n+  // so we don't have to keep polling the NodeDetails in every time window.\n+  private void removeInactiveNodeFromNodeMap() {\n+    Set<String> nodeIdSet = new HashSet<>();\n+    List<NodeKey> inactiveNodes = new ArrayList<>();\n+    for (NodeDetails nodeDetail : getClusterNodesDetails()) {\n+      nodeIdSet.add(nodeDetail.getId());\n+    }\n+    for (NodeKey nodeKey : nodeTable.rowKeySet()) {\n+      if (!nodeIdSet.contains(nodeKey.getNodeId())) {\n+        inactiveNodes.add(nodeKey);\n+        LOG.info(\"RCA: remove node {} from node map\", nodeKey);\n+      }\n+    }\n+    inactiveNodes.forEach(nodeKey -> nodeTable.row(nodeKey).clear());", "originalCommit": "4288e7885672ea7e09ded900f3650d85b190b3d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyOTU0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/246#discussion_r446329545", "bodyText": "Great that we updated the equals and hashCode method here to include hostAddress", "author": "khushbr", "createdAt": "2020-06-26T17:56:17Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cluster/NodeKey.java", "diffHunk": "@@ -36,13 +38,25 @@ public String getHostAddress() {\n   public boolean equals(Object obj) {\n     if (obj instanceof NodeKey) {\n       NodeKey key = (NodeKey)obj;\n-      return nodeId.equals(key.getNodeId());\n+      return nodeId.equals(key.getNodeId()) && hostAddress.equals(key.getHostAddress());", "originalCommit": "4288e7885672ea7e09ded900f3650d85b190b3d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}