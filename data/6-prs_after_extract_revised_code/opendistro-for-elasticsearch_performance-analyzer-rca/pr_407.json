{"pr_number": 407, "pr_title": "Refactoring the persistence layer to be able to persist any Java Object", "pr_createdAt": "2020-09-01T02:57:48Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407", "timeline": [{"oid": "36755dd63fee732d2aae091b334f3c78a6632f19", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/36755dd63fee732d2aae091b334f3c78a6632f19", "message": "Findbug errors", "committedDate": "2020-09-01T04:05:12Z", "type": "forcePushed"}, {"oid": "edc720593dc9cdcfceee15c2ad46fb295a8a3ce6", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/edc720593dc9cdcfceee15c2ad46fb295a8a3ce6", "message": "Refactoring the Persistence layer\n\nFixes: #399\n\nThe persistence layer takes care of durably storing the RCA results (and in future decisions from deciders) and providing them when asked for it. The layer also takes care of periodic file rotations and cleaning up old DB files.\n\nAlthough, it wasn't intended, the _Persistence_ layer is tightly coupled to the _RCA graph_ today. If you look at the `write()` method in  `Persistable` interface, you will find this signature:\n`<T extends ResourceFlowUnit> void write(Node<?> node, T flowUnit) throws SQLException, IOException;`\n\nSo the Persistable Object knows about the graph node. Therefore, in future as the remediation system evolves and we have components, that are not nodes in the RCA-Graph, we might still want to persist their outputs and this interface can't do that.\n\nTherefore, the goal is to make the methods of Persistable generic, so that it can persist any object given to it and be able to read out any object the caller asks for.\n\nSay we have to persist this class:\n```java\n\nOuter.java\n________________\n\nclass Outer {\n  int x;\n  int y;\n  boolean z;\n  String name;\n  List<T> myList;\n\n B b_obj;\n}\n-------------------------------------------------------\n\nA.java\n_______\n\nclass B {\n  int x;\n  String y;\n}\n```\n\nwhen the above code is annotated as:\n```java\n\nOuter.java\n________________\n\n// This will create a table named \"Outer\"\n@Table\nclass Outer {\n  int x;\n  int y;\n  // Its not annotated as column, therefore, it will not be persisted.\n  boolean z;\n  String name;\n  B b_obj;\n  List<T> myList;\n\n  // Add a column named x to Outer table. The value stored in the row for that column will be the value of x.\n  @Column\n  int getX() { .. }\n\n  @Column\n  int getY() { .. }\n\n  @Column\n   String getName() { .. }\n\n  // For all fields that are not [primitive types](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#isPrimitive()), they will be persisted in their own tables as a new row. The auto-increment ID\nfor this row will be persisted as a value of the column named \"__table__B\", so that we have a link to the nested element/table from this table.\n  @Column\n  B getBObj() {..}\n\n// If the Column annotation exists for a collection type, then they will be written to a table of their own.\n// The name of the table is obtained by calling T.class.getSimpleName(). If all of them evaluates to the same\n// table name, then they get written to the same table as different rows. And the corresponding Outer table's\n// column will have a string [<rowId1]>, <rowId2>].\n// If `T.class.getSimpleName()` evaluates to different names, then they are linked back in Outer table as\n// different columns.\n  @Column\n  List<T> getMyList() { .. }\n}\n-------------------------------------------------------\n\nB.java\n_______\n\n@Table\nclass B {\n  int x;\n  String y;\n}\n```\n\nthis creates these set of tables:\nHere assuming that\n\n`getMyList()` returns a list of three elements where\n\n```java\nfor (T in getMyList) {\n  // T.getClass().getSimpleName() returns `T` for two of the objects and `TT` for the third.\n}\n```\n\nTable Outer\ntimestamp|ID|X|Y|Name|__table__BObj|__table__T|__table__TT\n--|--|--|-|------|--------------|----------------|---\n..|53|1|2|name|34|[23,24]|32\n\nTable B\ntimestamp|ID|X|Y\n--|--|--|--\n..|34|23|y\n\nTable T\ntimestamp|ID| col2| ..\n--|---|-|--------\n..|23|24|..\n..|24|24|..\n\nTable TT\ntimestamp|ID| col2| ..\n--|---|-|--------\n..|32|24|..\n\n- The Java code resembles how the tables and nested tables will be laid out.\n- Because the nested table can be obtained just by reading the column name, someone can write a tool to read the RCAs from the SQLite files. The won't need the java package to figure out the nesting.\n- If new columns or nestings are added, they can also be added in the DB without schema mismatch. This is because, we create a new SQLite file on each restart of the RCA agent process (on top of periodic file rotations).\n- The table name and column names are derived from the classname and getter name (methodName with `get` stripped out). This provides a 1-1 mapping from the persistor class and fields to the table name and column names.\n- Over and above, we are able to persist any Java Object.", "committedDate": "2020-09-01T18:06:06Z", "type": "commit"}, {"oid": "edc720593dc9cdcfceee15c2ad46fb295a8a3ce6", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/edc720593dc9cdcfceee15c2ad46fb295a8a3ce6", "message": "Refactoring the Persistence layer\n\nFixes: #399\n\nThe persistence layer takes care of durably storing the RCA results (and in future decisions from deciders) and providing them when asked for it. The layer also takes care of periodic file rotations and cleaning up old DB files.\n\nAlthough, it wasn't intended, the _Persistence_ layer is tightly coupled to the _RCA graph_ today. If you look at the `write()` method in  `Persistable` interface, you will find this signature:\n`<T extends ResourceFlowUnit> void write(Node<?> node, T flowUnit) throws SQLException, IOException;`\n\nSo the Persistable Object knows about the graph node. Therefore, in future as the remediation system evolves and we have components, that are not nodes in the RCA-Graph, we might still want to persist their outputs and this interface can't do that.\n\nTherefore, the goal is to make the methods of Persistable generic, so that it can persist any object given to it and be able to read out any object the caller asks for.\n\nSay we have to persist this class:\n```java\n\nOuter.java\n________________\n\nclass Outer {\n  int x;\n  int y;\n  boolean z;\n  String name;\n  List<T> myList;\n\n B b_obj;\n}\n-------------------------------------------------------\n\nA.java\n_______\n\nclass B {\n  int x;\n  String y;\n}\n```\n\nwhen the above code is annotated as:\n```java\n\nOuter.java\n________________\n\n// This will create a table named \"Outer\"\n@Table\nclass Outer {\n  int x;\n  int y;\n  // Its not annotated as column, therefore, it will not be persisted.\n  boolean z;\n  String name;\n  B b_obj;\n  List<T> myList;\n\n  // Add a column named x to Outer table. The value stored in the row for that column will be the value of x.\n  @Column\n  int getX() { .. }\n\n  @Column\n  int getY() { .. }\n\n  @Column\n   String getName() { .. }\n\n  // For all fields that are not [primitive types](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#isPrimitive()), they will be persisted in their own tables as a new row. The auto-increment ID\nfor this row will be persisted as a value of the column named \"__table__B\", so that we have a link to the nested element/table from this table.\n  @Column\n  B getBObj() {..}\n\n// If the Column annotation exists for a collection type, then they will be written to a table of their own.\n// The name of the table is obtained by calling T.class.getSimpleName(). If all of them evaluates to the same\n// table name, then they get written to the same table as different rows. And the corresponding Outer table's\n// column will have a string [<rowId1]>, <rowId2>].\n// If `T.class.getSimpleName()` evaluates to different names, then they are linked back in Outer table as\n// different columns.\n  @Column\n  List<T> getMyList() { .. }\n}\n-------------------------------------------------------\n\nB.java\n_______\n\n@Table\nclass B {\n  int x;\n  String y;\n}\n```\n\nthis creates these set of tables:\nHere assuming that\n\n`getMyList()` returns a list of three elements where\n\n```java\nfor (T in getMyList) {\n  // T.getClass().getSimpleName() returns `T` for two of the objects and `TT` for the third.\n}\n```\n\nTable Outer\ntimestamp|ID|X|Y|Name|__table__BObj|__table__T|__table__TT\n--|--|--|-|------|--------------|----------------|---\n..|53|1|2|name|34|[23,24]|32\n\nTable B\ntimestamp|ID|X|Y\n--|--|--|--\n..|34|23|y\n\nTable T\ntimestamp|ID| col2| ..\n--|---|-|--------\n..|23|24|..\n..|24|24|..\n\nTable TT\ntimestamp|ID| col2| ..\n--|---|-|--------\n..|32|24|..\n\n- The Java code resembles how the tables and nested tables will be laid out.\n- Because the nested table can be obtained just by reading the column name, someone can write a tool to read the RCAs from the SQLite files. The won't need the java package to figure out the nesting.\n- If new columns or nestings are added, they can also be added in the DB without schema mismatch. This is because, we create a new SQLite file on each restart of the RCA agent process (on top of periodic file rotations).\n- The table name and column names are derived from the classname and getter name (methodName with `get` stripped out). This provides a 1-1 mapping from the persistor class and fields to the table name and column names.\n- Over and above, we are able to persist any Java Object.", "committedDate": "2020-09-01T18:06:06Z", "type": "forcePushed"}, {"oid": "9fbc9362d307800ba94fc1418a5394296f16a9ac", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9fbc9362d307800ba94fc1418a5394296f16a9ac", "message": "Better comments and error message handling", "committedDate": "2020-09-01T19:10:24Z", "type": "commit"}, {"oid": "7b79151d413397efdeae7475be142302617526f9", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/7b79151d413397efdeae7475be142302617526f9", "message": "Adding some more tests", "committedDate": "2020-09-01T22:41:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTk2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481469966", "bodyText": "This read method is not added in the PersistorBase class.\nThis logic can be moved to the PersistorBase class? It can follow similar structure that write uses. read and readImpl methods. With read implemented in PersistorBase and readImpl in persistors?", "author": "sruti1312", "createdAt": "2020-09-01T22:36:10Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +217,345 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> T read(Class<T> clz)", "originalCommit": "9fbc9362d307800ba94fc1418a5394296f16a9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4MTU4OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481481588", "bodyText": "PersistorBase is supposed to be DB agnostic. So, tomorrow we can have a levelDB persistor instead of SQLite and even then PersistorBase would take care of file rotation and gc etc.", "author": "yojs", "createdAt": "2020-09-01T23:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7b79151d413397efdeae7475be142302617526f9", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\nindex c0fb22c7..d5d8ee06 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n\n@@ -218,12 +221,12 @@ class SQLitePersistor extends PersistorBase {\n   }\n \n   @Override\n-  public synchronized <T> T read(Class<T> clz)\n-      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n     return read(clz, -1 /* To indicate this is the top level call */);\n   }\n \n-  public synchronized <T> T read(Class<T> clz, int rowId)\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n       throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n     String tableName = getTableNameFromClassName(clz);\n     String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3Mzg2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481473863", "bodyText": "Is this more of an warning?", "author": "sruti1312", "createdAt": "2020-09-01T22:47:36Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);", "originalCommit": "7b79151d413397efdeae7475be142302617526f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4MjAxMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481482013", "bodyText": "This is error because we don't have have the chained table to completely fill up the Object. We messed up writing data. That's why it is error", "author": "yojs", "createdAt": "2020-09-01T23:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3Mzg2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2e01e5d840b5ae185e20ea9288547705921a566d", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\nindex d5d8ee06..fc3857e4 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n\n@@ -234,7 +234,6 @@ class SQLitePersistor extends PersistorBase {\n \n     Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n \n-\n     List<Record> recordList;\n     if (rowId == -1) {\n       try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NDUzOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481474539", "bodyText": "Can we add a statement when throwing this. Might be more informative when debugging", "author": "sruti1312", "createdAt": "2020-09-01T22:49:34Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();", "originalCommit": "7b79151d413397efdeae7475be142302617526f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4OTkyMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481489920", "bodyText": "Good point. In the latest revision, this has been removed.", "author": "yojs", "createdAt": "2020-09-01T23:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NDUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2e01e5d840b5ae185e20ea9288547705921a566d", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\nindex d5d8ee06..fc3857e4 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n\n@@ -234,7 +234,6 @@ class SQLitePersistor extends PersistorBase {\n \n     Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n \n-\n     List<Record> recordList;\n     if (rowId == -1) {\n       try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481475516", "bodyText": "Quick check if name is not empty and length is more than 1 character?", "author": "sruti1312", "createdAt": "2020-09-01T22:52:37Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethod(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check method: \" + method.getName());\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);", "originalCommit": "7b79151d413397efdeae7475be142302617526f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MDMyMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481490323", "bodyText": "So what this intends to do is convert x to 'X' or 'camelCaseX' to 'CamelCaseX'. So capitalize the first character. Do you mean I should check for this ?", "author": "yojs", "createdAt": "2020-09-01T23:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1MTA5OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481551098", "bodyText": "Check for length > 1 inorder to avoid IndexOutOfBoundsException", "author": "sruti1312", "createdAt": "2020-09-02T02:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyMjA2OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482222068", "bodyText": "JDk handles it but you are right, we can skip the call to that function for a single-lettered-field.\npublic String substring(int beginIndex) {\n        ..\n        if (beginIndex == 0) {\n            return this;\n        }\n        ...\n    }", "author": "yojs", "createdAt": "2020-09-02T16:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg=="}], "type": "inlineReview", "revised_code": {"commit": "2e01e5d840b5ae185e20ea9288547705921a566d", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\nindex d5d8ee06..fc3857e4 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n\n@@ -234,7 +234,6 @@ class SQLitePersistor extends PersistorBase {\n \n     Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n \n-\n     List<Record> recordList;\n     if (rowId == -1) {\n       try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTg3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481475875", "bodyText": "Any reason why this is static? I might be missing something", "author": "sruti1312", "createdAt": "2020-09-01T22:53:51Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {", "originalCommit": "7b79151d413397efdeae7475be142302617526f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MDk3Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481490977", "bodyText": "This depends on no member of this class and it does not modify any member of the instance. Therefore, I kept it as static.", "author": "yojs", "createdAt": "2020-09-01T23:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2e01e5d840b5ae185e20ea9288547705921a566d", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\nindex d5d8ee06..fc3857e4 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java\n\n@@ -234,7 +234,6 @@ class SQLitePersistor extends PersistorBase {\n \n     Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n \n-\n     List<Record> recordList;\n     if (rowId == -1) {\n       try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3OTM2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481479366", "bodyText": "Can we rename this class as say PersistorTestExample or MockPersistorInput?", "author": "sruti1312", "createdAt": "2020-09-01T23:04:22Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck1.TestPersist;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class SqliteObjectPersistor {\n+  private Path testLocation = null;\n+  private final String baseFilename = \"rca.test.file\";\n+\n+  @Before\n+  public void init() throws IOException {\n+    String cwd = System.getProperty(\"user.dir\");\n+    testLocation = Paths.get(cwd, \"src\", \"test\", \"resources\", \"tmp\", \"file_rotate\");\n+    Files.createDirectories(testLocation);\n+    FileUtils.cleanDirectory(testLocation.toFile());\n+  }\n+\n+  @After\n+  public void cleanup() throws IOException {\n+    FileUtils.cleanDirectory(testLocation.toFile());\n+  }\n+\n+  @Test\n+  public void testWriteObject() throws Exception {\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    Outer outer = new Outer();\n+    sqlite.write(outer);\n+\n+    Outer outerOut = sqlite.read(Outer.class);\n+\n+    Assert.assertEquals(outer.x, outerOut.x);\n+    Assert.assertEquals(outer.name, outerOut.name);\n+    Assert.assertEquals(outer.bObj.x, outerOut.bObj.x, 0.01);\n+  }\n+\n+  /**\n+   * This test checks that we get a null Object in case the Database is created but it does not contain table with the object data we are\n+   * asking for.\n+   */\n+  @Test\n+  public void testNoData()\n+      throws IOException, SQLException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    Assert.assertNull(sqlite.read(Outer.class));\n+  }\n+\n+  @Rule\n+  public ExpectedException exceptionRule = ExpectedException.none();\n+\n+  @Test\n+  public void persistTwoClassesWithSameName() throws Exception {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\"There is already a table in the Database with the same name\");\n+\n+    TestPersist testPersist1 = new TestPersist();\n+    com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck2.TestPersist testPersist2 =\n+        new com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck2.TestPersist();\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(testPersist1);\n+    sqlite.write(testPersist2);\n+  }\n+\n+  @Test\n+  public void testObjectWithNoGetters()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"Could not find 'getter' for the field 'x' of class\");\n+\n+    class NoGetter {\n+      @ValueColumn\n+      int x;\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new NoGetter());\n+  }\n+\n+  @Test\n+  public void testGetterReturnMismatch()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"The return type of the getter 'getX' (class java.lang.Integer) and field 'x' (int) don't match.\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      public Integer getX() {\n+        return x;\n+      }\n+\n+      public void setX(int x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testSetterArgTypeMismatch()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"Could not find 'setter' for the field 'x' of class\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      public int getX() {\n+        return x;\n+      }\n+\n+      public void setX(Integer x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testNonPublicGetterSetter()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\"Found 'getX'. But it is not public\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      int getX() {\n+        return x;\n+      }\n+\n+      public void setX(Integer x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testNoPersistableFields()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\n+        \"NotPersistable was asked to be persisted but there are no fields with annotations: ValueColumn or RefColumn\");\n+    class NotPersistable {\n+      int x;\n+    }\n+    \n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new NotPersistable());\n+  }\n+\n+  static class Outer {", "originalCommit": "7b79151d413397efdeae7475be142302617526f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNzI4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481507280", "bodyText": "done", "author": "yojs", "createdAt": "2020-09-02T00:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3OTM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2e01e5d840b5ae185e20ea9288547705921a566d", "chunk": "diff --git a/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java b/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java\nindex f1eb111d..d79c6cb0 100644\n--- a/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java\n+++ b/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java\n\n@@ -39,14 +39,14 @@ public class SqliteObjectPersistor {\n   public void testWriteObject() throws Exception {\n     SQLitePersistor sqlite = new SQLitePersistor(\n         testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n-    Outer outer = new Outer();\n-    sqlite.write(outer);\n+    PersistorTestExample persistorTestExample = new PersistorTestExample();\n+    sqlite.write(persistorTestExample);\n \n-    Outer outerOut = sqlite.read(Outer.class);\n+    PersistorTestExample persistorTestExampleOut = sqlite.read(PersistorTestExample.class);\n \n-    Assert.assertEquals(outer.x, outerOut.x);\n-    Assert.assertEquals(outer.name, outerOut.name);\n-    Assert.assertEquals(outer.bObj.x, outerOut.bObj.x, 0.01);\n+    Assert.assertEquals(persistorTestExample.x, persistorTestExampleOut.x);\n+    Assert.assertEquals(persistorTestExample.name, persistorTestExampleOut.name);\n+    Assert.assertEquals(persistorTestExample.bObj.x, persistorTestExampleOut.bObj.x, 0.01);\n   }\n \n   /**\n"}}, {"oid": "2e01e5d840b5ae185e20ea9288547705921a566d", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/2e01e5d840b5ae185e20ea9288547705921a566d", "message": "Addressing PR comments", "committedDate": "2020-09-02T00:36:40Z", "type": "commit"}, {"oid": "e43aa1692166d835ba04b65c274df2e0065f3266", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/e43aa1692166d835ba04b65c274df2e0065f3266", "message": "Added test to cover list of ints", "committedDate": "2020-09-02T01:16:38Z", "type": "commit"}, {"oid": "5607a226bdf2c21bfd3807acbfc210844b603ff9", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5607a226bdf2c21bfd3807acbfc210844b603ff9", "message": "Added more comments for readability and addressing PR review comments", "committedDate": "2020-09-02T16:55:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNzU4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482237580", "bodyText": "I still think we should not use class name directly as the table name.\nFor example, if we wants to persist rca flowunit of different types, how are we going to persist them into a same table (i.e. RCA table) ?\nThis also applies to remediation actions, in that case all remediation actions (cache actions, queue actions) will be persisted into a single table\nOr should we create a base class for persister to use in that case ?", "author": "rguo-aws", "createdAt": "2020-09-02T17:17:34Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +221,426 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        // get the row with the provided rowId.\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rowID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        // If the name of the column starts with the prefix, then it is a reference Column. It means that the value contained in this\n+        // column references to a particular RowIDs in the table with name same as this column(with prefix removed).\n+        // There are two forms of this:\n+        // - It can be a reference to another table, in which case the column is an integer type.\n+        // - OR it is a collection of RowIDs from multiple tables, in which case the column type a JsonArray as String. e.g.\n+        //    [{\\\"tableName\\\":\\\"ITestImpl2\\\",\\\"rowIds\\\":[1]},{\\\"tableName\\\":\\\"ITestImpl1\\\",\\\"rowIds\\\":[1,2]}]\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // This references a row in a table.\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          if (setter.getParameterTypes().length != 1) {\n+            throw new IllegalStateException(\"A setter \" + setter.getName() + \" of class \" + clz.getSimpleName()\n+                + \" accepts more than one arguments.\");\n+          }\n+\n+          // This gives the type of the setter parameter.\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+          int nestedRowId = (int)jooqField.getValue(record);\n+\n+          // Now that we have the Type of the parameter and the rowID specifying the data the object\n+          // is to be filled with; we call the read method recursively to create the referenced Object\n+          // and then invoke the setter with it.\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethodReturn(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    return getFirstTypeFromParameterizedTypes(mtype, method.getName());\n+  }\n+\n+  private Class<?> getGenericFieldType(java.lang.reflect.Field field) {\n+    ParameterizedType mtype = (ParameterizedType) field.getGenericType();\n+    return getFirstTypeFromParameterizedTypes(mtype, field.getName());\n+  }\n+\n+  private Class<?> getFirstTypeFromParameterizedTypes(ParameterizedType mtype, String name) {\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check field/method: \" + name);\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    if (name.length() == 1) {\n+      return name.toUpperCase();\n+    }\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);\n+  }\n+\n+  private void checkValidType(java.lang.reflect.Field field, Class<?> clz) {\n+    Type type = field.getGenericType();\n+    Annotation[] annotation = field.getAnnotations();\n+    StringBuilder err = new StringBuilder();\n+    err.append(\"[class: \").append(clz.getSimpleName()).append(\":field:\").append(field.getName()).append(\"]::\");\n+\n+    if (annotation.length != 1) {\n+      err\n+          .append(\"A field can have either \")\n+          .append(ValueColumn.class.getSimpleName())\n+          .append(\" or \")\n+          .append(RefColumn.class.getSimpleName())\n+          .append(\" not both\");\n+      throw new IllegalStateException(err.toString());\n+    }\n+\n+    if (annotation[0].annotationType() == RefColumn.class) {\n+      if (type instanceof ParameterizedType) {\n+        ParameterizedType parameterizedType = (ParameterizedType) type;\n+        Class<?> actualType = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+        if (actualType.isPrimitive() || actualType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      } else {\n+        Class<?> justType = field.getType();\n+        if (justType.isPrimitive() || justType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      }\n+    } else {\n+      if (type instanceof ParameterizedType) {\n+        // TODO: This will be added if use-cases require this.\n+        err.append(\"persisting Primitives or Strings as Parameterized Types is not supported.\");\n+        throw new IllegalStateException(err.toString());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Go over all the fields of the class and then filter out all that are annotated as @AColumn or @ATable. For those fields,\n+   * try to figure out the getter and setters.\n+   * @param clz The class whose field registry is to be created.\n+   * @param <T> The Generic type of the class.\n+   * @throws IllegalStateException When getters and setters are not found for the field that is required to be persisted or they exist but\n+   *     are not public.\n+   */\n+  private <T> void createFieldRegistry(Class<T> clz) throws IllegalStateException, NoSuchMethodException {\n+    fieldGetterSetterPairsMap.putIfAbsent(clz, new HashMap<>());\n+    classFieldNamesToGetterSetterMap.putIfAbsent(clz, new HashMap<>());\n+\n+    Map<java.lang.reflect.Field, GetterSetterPairs> fieldToGetterSetterMap = fieldGetterSetterPairsMap.get(clz);\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    for (java.lang.reflect.Field field : clz.getDeclaredFields()) {\n+      if (field.isAnnotationPresent(ValueColumn.class) || field.isAnnotationPresent(RefColumn.class)) {\n+        checkValidType(field, clz);\n+        // Now we try to find the corresponding Getter and Setter for this field.\n+        GetterSetterPairs pair = new GetterSetterPairs();\n+\n+        String capitalizedFieldName = capitalize(field.getName());\n+        for (String prefix: GETTER_PREFIXES) {\n+          String key = prefix + capitalizedFieldName;\n+          Method method;\n+          try {\n+            method = clz.getDeclaredMethod(key);\n+          } catch (NoSuchMethodException nom) {\n+            continue;\n+          }\n+          if (method.getReturnType() != field.getType()) {\n+            StringBuilder sb = new StringBuilder(\"The return type of the getter '\");\n+            sb.append(key)\n+                .append(\"' (\")\n+                .append(method.getReturnType())\n+                .append(\") and field '\")\n+                .append(field.getName())\n+                .append(\"' (\")\n+                .append(field.getType())\n+                .append(\") don't match.\");\n+            throw new NoSuchMethodException(sb.toString());\n+          }\n+          checkPublic(method);\n+          pair.getter = method;\n+          break;\n+        }\n+        for (String prefix: SETTER_PREFIXES) {\n+          String key = prefix + capitalizedFieldName;\n+          try {\n+            // This line will throw if no method with the name exists or if a method with such name exists\n+            // but the method argument types are not the same. Remember, int and Integer are not the same\n+            // types.\n+            Method method = clz.getDeclaredMethod(key, field.getType());\n+            checkPublic(method);\n+            pair.setter = method;\n+            break;\n+          } catch (NoSuchMethodException e) {\n+          }\n+        }\n+        if (pair.getter == null) {\n+          throw new NoSuchMethodException(getNoGetterSetterExist(clz, field, GetterOrSetter.GETTER));\n+        }\n+        if (pair.setter == null) {\n+          throw new NoSuchMethodException(getNoGetterSetterExist(clz, field, GetterOrSetter.SETTER));\n+        }\n+        fieldToGetterSetterMap.put(field, pair);\n+        fieldNameToGetterSetterMap.put(field.getName(), pair);\n+      }\n+    }\n+  }\n+\n+  private String getNoGetterSetterExist(Class<?> clz, java.lang.reflect.Field field, GetterOrSetter getterOrSetter) {\n+    String type;\n+    switch (getterOrSetter) {\n+      case GETTER:\n+        type = \"getter\";\n+        break;\n+      case SETTER:\n+        type = \"setter\";\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unrecognized type: \" + getterOrSetter);\n+    }\n+\n+    StringBuilder sb = new StringBuilder(\"Could not find '\");\n+    sb.append(type)\n+        .append(\"' for the field '\")\n+        .append(field.getName())\n+        .append(\"' of class '\")\n+        .append(clz.getName())\n+        .append(\"'. Getters are expected to start with 'get' or 'is' and setters are expected to start with 'set' and they are required to\"\n+        + \" end with the name of the field (case insensitive.)\");\n+    return sb.toString();\n+  }\n+\n+  private <T> ColumnValuePair writeCollectionReferenceColumn(java.lang.reflect.Field field, Method getter, T obj)\n+      throws InvocationTargetException, IllegalAccessException, SQLException, NoSuchMethodException {\n+    ColumnValuePair columnValuePair = new ColumnValuePair();\n+    String columnName = NESTED_OBJECT_COLUMN_PREFIX + field.getName();\n+\n+    Collection<?> collection = (Collection<?>) getter.getReturnType().cast(getter.invoke(obj));\n+    Map<String, List<Integer>> nestedPrimaryKeys = new HashMap<>();\n+    for (Object o: collection) {\n+      String myActualType = o.getClass().getSimpleName();\n+      nestedPrimaryKeys.putIfAbsent(myActualType, new ArrayList<>());\n+\n+      Class typeArgClass = getGenericParamTypeOfMethodReturn(getter);\n+\n+      int id = writeImplInner(typeArgClass.cast(o));\n+      nestedPrimaryKeys.get(myActualType).add(id);\n+    }\n+    JsonArray json = new JsonArray();\n+    // Create fields with the collectionReferenceType columns\n+    for (Map.Entry<String, List<Integer>> colNameEntry: nestedPrimaryKeys.entrySet()) {\n+      JsonObject jsonObject = new JsonObject();\n+      JsonArray jsonArrayInner = new JsonArray();\n+      colNameEntry.getValue().forEach(rowId -> jsonArrayInner.add(rowId));\n+\n+      jsonObject.addProperty(TABLE_NAME_JSON_KEY, colNameEntry.getKey());\n+      jsonObject.add(ROW_IDS_JSON_KEY, jsonArrayInner);\n+\n+      json.add(jsonObject);\n+    }\n+    columnValuePair.field = (DSL.field(DSL.name(columnName), String.class));\n+    columnValuePair.value = json.toString();\n+    return columnValuePair;\n+  }\n+\n+  private <T> int writeImplInner(T obj)\n+      throws IllegalStateException, IllegalAccessException, InvocationTargetException, SQLException, NoSuchMethodException {\n+    Class<?> clz = obj.getClass();\n+    String tableName = getTableNameFromClassName(clz);", "originalCommit": "5607a226bdf2c21bfd3807acbfc210844b603ff9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ4NDk1NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482484954", "bodyText": "It may not be a good idea to persist two different FLowUnits directly into the same table. These classes can have different Fields or different number of fields, that would throw a DB exception. More checks we have to do, to convert the error messages into understandable ones.\nIf we at all want to persist two different FlowUnits into the same table, then we should create an Object in both FlowUnits, and that we should ask to persist. That way, at Java level, it will be guranteed to not throw DB exceptions because of schema mismatch.", "author": "yojs", "createdAt": "2020-09-02T21:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNzU4MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0NTcwMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482245702", "bodyText": "a high level question I have for this function is, how are we going to handle Enum type ? We have resource enum in ResourceSummary. Can we override this getter / setter to serialize / de-serialize Enum based on enum value ?", "author": "rguo-aws", "createdAt": "2020-09-02T17:31:31Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +221,426 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        // get the row with the provided rowId.\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rowID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        // If the name of the column starts with the prefix, then it is a reference Column. It means that the value contained in this\n+        // column references to a particular RowIDs in the table with name same as this column(with prefix removed).\n+        // There are two forms of this:\n+        // - It can be a reference to another table, in which case the column is an integer type.\n+        // - OR it is a collection of RowIDs from multiple tables, in which case the column type a JsonArray as String. e.g.\n+        //    [{\\\"tableName\\\":\\\"ITestImpl2\\\",\\\"rowIds\\\":[1]},{\\\"tableName\\\":\\\"ITestImpl1\\\",\\\"rowIds\\\":[1,2]}]\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // This references a row in a table.\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          if (setter.getParameterTypes().length != 1) {\n+            throw new IllegalStateException(\"A setter \" + setter.getName() + \" of class \" + clz.getSimpleName()\n+                + \" accepts more than one arguments.\");\n+          }\n+\n+          // This gives the type of the setter parameter.\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+          int nestedRowId = (int)jooqField.getValue(record);\n+\n+          // Now that we have the Type of the parameter and the rowID specifying the data the object\n+          // is to be filled with; we call the read method recursively to create the referenced Object\n+          // and then invoke the setter with it.\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethodReturn(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    return getFirstTypeFromParameterizedTypes(mtype, method.getName());\n+  }\n+\n+  private Class<?> getGenericFieldType(java.lang.reflect.Field field) {\n+    ParameterizedType mtype = (ParameterizedType) field.getGenericType();\n+    return getFirstTypeFromParameterizedTypes(mtype, field.getName());\n+  }\n+\n+  private Class<?> getFirstTypeFromParameterizedTypes(ParameterizedType mtype, String name) {\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check field/method: \" + name);\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    if (name.length() == 1) {\n+      return name.toUpperCase();\n+    }\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);\n+  }\n+\n+  private void checkValidType(java.lang.reflect.Field field, Class<?> clz) {\n+    Type type = field.getGenericType();\n+    Annotation[] annotation = field.getAnnotations();\n+    StringBuilder err = new StringBuilder();\n+    err.append(\"[class: \").append(clz.getSimpleName()).append(\":field:\").append(field.getName()).append(\"]::\");\n+\n+    if (annotation.length != 1) {\n+      err\n+          .append(\"A field can have either \")\n+          .append(ValueColumn.class.getSimpleName())\n+          .append(\" or \")\n+          .append(RefColumn.class.getSimpleName())\n+          .append(\" not both\");\n+      throw new IllegalStateException(err.toString());\n+    }\n+\n+    if (annotation[0].annotationType() == RefColumn.class) {\n+      if (type instanceof ParameterizedType) {\n+        ParameterizedType parameterizedType = (ParameterizedType) type;\n+        Class<?> actualType = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+        if (actualType.isPrimitive() || actualType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      } else {\n+        Class<?> justType = field.getType();\n+        if (justType.isPrimitive() || justType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      }\n+    } else {\n+      if (type instanceof ParameterizedType) {\n+        // TODO: This will be added if use-cases require this.\n+        err.append(\"persisting Primitives or Strings as Parameterized Types is not supported.\");\n+        throw new IllegalStateException(err.toString());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Go over all the fields of the class and then filter out all that are annotated as @AColumn or @ATable. For those fields,\n+   * try to figure out the getter and setters.\n+   * @param clz The class whose field registry is to be created.\n+   * @param <T> The Generic type of the class.\n+   * @throws IllegalStateException When getters and setters are not found for the field that is required to be persisted or they exist but\n+   *     are not public.\n+   */\n+  private <T> void createFieldRegistry(Class<T> clz) throws IllegalStateException, NoSuchMethodException {", "originalCommit": "5607a226bdf2c21bfd3807acbfc210844b603ff9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ4Nzc1NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482487754", "bodyText": "This is an excellent point. Enums are not covered. We will add support for them before we migrate Existing RCAs to be persisted using this new API.\nFor now this should unblock the persisting the deciders into DB use-case", "author": "yojs", "createdAt": "2020-09-02T21:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0NTcwMg=="}], "type": "inlineReview", "revised_code": null}]}