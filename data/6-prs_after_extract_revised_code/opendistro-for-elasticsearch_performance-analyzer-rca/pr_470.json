{"pr_number": 470, "pr_title": "Publish fault detection metrics", "pr_createdAt": "2020-10-14T11:47:56Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470", "timeline": [{"oid": "8fdbea096d2a44e284db261224bdba21271a70a5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/8fdbea096d2a44e284db261224bdba21271a70a5", "message": "Publish Fault Detection Metrics", "committedDate": "2020-10-14T10:57:27Z", "type": "commit"}, {"oid": "867752f4de0fa7a9c1a14b21b401e0a0d808d90a", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/867752f4de0fa7a9c1a14b21b401e0a0d808d90a", "message": "Publish Fault Detection Metrics", "committedDate": "2020-10-14T11:12:32Z", "type": "commit"}, {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d1f587f4950141fe228fcc86c97ab3e46523e14e", "message": "Publish Fault Detection Metrics", "committedDate": "2020-10-14T11:37:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506718476", "bodyText": "we can make it error as everything else starts with a small case ?", "author": "yojs", "createdAt": "2020-10-16T20:59:05Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUxNzk5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r507517991", "bodyText": "Changed it to fault", "author": "amathur1893", "createdAt": "2020-10-19T07:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwNDA0MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508104041", "bodyText": "Are the latest set of changes pushed ?  I do not see fault here.", "author": "khushbr", "createdAt": "2020-10-19T22:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0Njg3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446873", "bodyText": "I have made the changes. You can see it in the next revision", "author": "amathur1893", "createdAt": "2020-10-20T12:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\nindex db5c4106..bc5015a8 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\n\n@@ -1,15 +1,30 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.google.common.annotations.VisibleForTesting;\n import java.sql.Connection;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import com.google.common.annotations.VisibleForTesting;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.jooq.BatchBindStep;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTY2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506771667", "bodyText": "Can you help me understand why this is an error log ?", "author": "yojs", "createdAt": "2020-10-17T00:30:19Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");\n+\n+        private final String fieldValue;\n+\n+        Fields(String fieldValue) {\n+            this.fieldValue = fieldValue;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return fieldValue;\n+        }\n+\n+    }\n+\n+    public FaultDetectionMetricsSnapshot(Connection conn, Long windowStartTime) {\n+        this.create = DSL.using(conn, SQLDialect.SQLITE);\n+        this.windowStartTime = windowStartTime;\n+        this.tableName = \"fault_detection_\" + windowStartTime;\n+\n+        this.columns =\n+                new ArrayList<Field<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ST.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ET.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class));\n+                    }\n+                };\n+        create.createTable(this.tableName).columns(columns).execute();\n+    }\n+\n+    public BatchBindStep startBatchPut() {\n+\n+        List<Object> dummyValues = new ArrayList<>();\n+        for (int i = 0; i < columns.size(); i++) {\n+            dummyValues.add(null);\n+        }\n+        return create.batch(create.insertInto(DSL.table(this.tableName)).values(dummyValues));\n+    }\n+\n+    @VisibleForTesting\n+    public void putStartMetric(Long startTime, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ST.toString()), Long.class), startTime)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    @VisibleForTesting\n+    public void putEndMetric(Long endTime, int error, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ET.toString()), Long.class), endTime)\n+                .set(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class), error)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    public Result<Record> fetchAll() {\n+        return create.select().from(DSL.table(this.tableName)).fetch();\n+    }\n+\n+    @Override\n+    public void remove() throws Exception {\n+        create.dropTable(DSL.table(this.tableName)).execute();\n+    }\n+\n+    public void rolloverInFlightRequests(FaultDetectionMetricsSnapshot prevSnap) {\n+        // Fetch all entries that have not ended and write to current table.\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .select(create.select().from(prevSnap.fetchInFlightRequests()))\n+                .execute();\n+    }\n+\n+    public SelectHavingStep<Record> fetchInFlightRequests() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                    }\n+                };\n+\n+        return create\n+                .select(fields)\n+                .from(groupByRidAndTypeSelect())\n+                .where(\n+                        DSL.field(Fields.ST.toString())\n+                                .isNotNull()\n+                                .and(DSL.field(Fields.ET.toString()).isNull())\n+                                .and(DSL.field(Fields.ST.toString()).gt(this.windowStartTime - EXPIRE_AFTER)));\n+    }\n+\n+    public SelectHavingStep<Record> groupByRidAndTypeSelect() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ST.toString(), Long.class)).as(DSL.name(Fields.ST.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ET.toString(), Long.class)).as(DSL.name(Fields.ET.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ERROR.toString(), Integer.class)).as(DSL.name(Fields.ERROR.toString())));\n+        LOG.error(\"Initial - \" + fetchAll().size());\n+        LOG.error(\"Breakdown 1 - \" + create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString())).fetch().size());\n+        return create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString()));\n+    }\n+\n+    public SelectHavingStep<Record> fetchLatencyTable() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ERROR.toString(), Integer.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.field(Fields.ET.toString())\n+                        .minus(DSL.field(Fields.ST.toString()))\n+                        .as(DSL.name(Fields.LAT.toString())));\n+        LOG.error(\"Breakdown 2 - \" + create", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUxOTQ5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r507519495", "bodyText": "My bad. This was log used to debug an issue. Removed it", "author": "amathur1893", "createdAt": "2020-10-19T07:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\nindex db5c4106..bc5015a8 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\n\n@@ -1,15 +1,30 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.google.common.annotations.VisibleForTesting;\n import java.sql.Connection;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import com.google.common.annotations.VisibleForTesting;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.jooq.BatchBindStep;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTk0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506771945", "bodyText": "Do we need to add a new snapshot type or we can re-use the MASTER_EVENT_SNAPSHOTS here ?", "author": "yojs", "createdAt": "2020-10-17T00:32:29Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUyMjkzMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r507522931", "bodyText": "We need a new one. As far as i understand, snapshot contains table schema. Master events and Fault Detection events though both are being used to calculate latency and failure metrics have quite different schemas.", "author": "amathur1893", "createdAt": "2020-10-19T07:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\nindex c0cb9104..11477cc1 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n\n@@ -244,7 +278,9 @@ public class ReaderMetricsProcessor implements Runnable {\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n \ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);\n+    trimMap(shardStateMetricsMap, SHARD_STATE_SNAPSHOTS);\n     trimMap(gcInfoMap, GC_INFO_SNAPSHOTS);\n+    trimMap(masterThrottlingMetricsMap, MASTER_THROTTLING_SNAPSHOTS);\n \n     for (NavigableMap<Long, MemoryDBSnapshot> snap : nodeMetricsMap.values()) {\n       // do the same thing as OS_SNAPSHOTS.  Eventually MemoryDBSnapshot\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDU1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508080556", "bodyText": "Minor naming suggestion. Can we use FOLLOWER_CHECK_LATENCY and similarly LATENCY and FAILURE as suffix instead of prefix ?", "author": "khushbr", "createdAt": "2020-10-19T21:44:22Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMTk2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508431966", "bodyText": "Changed", "author": "amathur1893", "createdAt": "2020-10-20T11:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java\nindex 0e445fe4..aad4d465 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java\n\n@@ -1029,12 +1056,28 @@ public class AllMetrics {\n       public static final String SHARD_OP_COUNT_VALUE = \"ShardEvents\";\n     }\n   }\n+  /*\n+   * column names of FollowerCheck_Latency table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * column names of LeaderCheck_Latency table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * column names of FollowerCheck_Failure table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * column names of LeaderCheck_Failure table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * <p>Example:\n+   * chMe07whRwGrOAqyLTP9vw|hgi7an4RwGrOAqyLTP9vw|1.0|0.2|0.0|1.0\n+   */\n \n   public enum FaultDetectionMetric implements MetricValue {\n-    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n-    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n-    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n-    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+    FOLLOWER_CHECK_LATENCY(Constants.FOLLOWER_CHECK_LATENCY),\n+    LEADER_CHECK_LATENCY(Constants.LEADER_CHECK_LATENCY),\n+    FOLLOWER_CHECK_FAILURE(Constants.FOLLOWER_CHECK_FAILURE),\n+    LEADER_CHECK_FAILURE(Constants.LEADER_CHECK_FAILURE);\n \n     private final String value;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDk2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508080961", "bodyText": "An extension of above comment, use FollowerCheck_Latency ?", "author": "khushbr", "createdAt": "2020-10-19T21:45:13Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+\n+    private final String value;\n+\n+    FaultDetectionMetric(String value) {\n+      this.value = value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return value;\n+    }\n+\n+    public static class Constants {\n+      public static final String LATENCY_FOLLOWER_CHECK = \"Latency_FollowerCheck\";\n+      public static final String LATENCY_LEADER_CHECK = \"Latency_LeaderCheck\";\n+      public static final String FAILURE_FOLLOWER_CHECK = \"Failure_FollowerCheck\";\n+      public static final String FAILURE_LEADER_CHECK = \"Failure_LeaderCheck\";", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMjAzMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508432030", "bodyText": "Changed", "author": "amathur1893", "createdAt": "2020-10-20T11:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDk2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java\nindex 0e445fe4..aad4d465 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java\n\n@@ -1029,12 +1056,28 @@ public class AllMetrics {\n       public static final String SHARD_OP_COUNT_VALUE = \"ShardEvents\";\n     }\n   }\n+  /*\n+   * column names of FollowerCheck_Latency table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * column names of LeaderCheck_Latency table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * column names of FollowerCheck_Failure table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * column names of LeaderCheck_Failure table\n+   * SourceNodeId | TargetNodeID | sum | avg | min |max\n+   *\n+   * <p>Example:\n+   * chMe07whRwGrOAqyLTP9vw|hgi7an4RwGrOAqyLTP9vw|1.0|0.2|0.0|1.0\n+   */\n \n   public enum FaultDetectionMetric implements MetricValue {\n-    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n-    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n-    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n-    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+    FOLLOWER_CHECK_LATENCY(Constants.FOLLOWER_CHECK_LATENCY),\n+    LEADER_CHECK_LATENCY(Constants.LEADER_CHECK_LATENCY),\n+    FOLLOWER_CHECK_FAILURE(Constants.FOLLOWER_CHECK_FAILURE),\n+    LEADER_CHECK_FAILURE(Constants.LEADER_CHECK_FAILURE);\n \n     private final String value;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTI5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081292", "bodyText": "Generic variable name, where do we intend to use this ?", "author": "khushbr", "createdAt": "2020-10-19T21:45:54Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java", "diffHunk": "@@ -60,6 +61,9 @@\n   public static final String MASTER_CURRENT = \"current\";\n   public static final String MASTER_META_DATA = \"metadata\";\n   public static final String METRIC_CURRENT_TIME = \"current_time\";\n+  public static final String FAULT_DETECTION_FOLLOWER_CHECK = \"follower_check\";\n+  public static final String FAULT_DETECTION_LEADER_CHECK = \"leader_check\";\n+  public static final String ERROR = \"error\";", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNDc0NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508434744", "bodyText": "used to capture fault for both FollowerCheck and LeaderCheck hence generic", "author": "amathur1893", "createdAt": "2020-10-20T11:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java\nindex 91a4b22c..3feb2cd2 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java\n\n@@ -63,7 +65,7 @@ public class PerformanceAnalyzerMetrics {\n   public static final String METRIC_CURRENT_TIME = \"current_time\";\n   public static final String FAULT_DETECTION_FOLLOWER_CHECK = \"follower_check\";\n   public static final String FAULT_DETECTION_LEADER_CHECK = \"leader_check\";\n-  public static final String ERROR = \"error\";\n+  public static final String FAULT = \"fault\";\n   public static final int QUEUE_SIZE = PluginSettings.instance().getWriterQueueSize();\n \n   // TODO: Comeup with a more sensible number.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTYxOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081618", "bodyText": "Can we fix the indentation here?", "author": "khushbr", "createdAt": "2020-10-19T21:46:37Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java", "diffHunk": "@@ -340,6 +340,26 @@\n         new MetricAttributes(\n             MetricUnits.MILLISECOND.toString(), AllMetrics.MasterMetricDimensions.values()));\n \n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNTU3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508435575", "bodyText": "done", "author": "amathur1893", "createdAt": "2020-10-20T11:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java\nindex ddef6036..167d362a 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java\n\n@@ -341,25 +341,38 @@ public class MetricsModel {\n             MetricUnits.MILLISECOND.toString(), AllMetrics.MasterMetricDimensions.values()));\n \n     allMetricsInitializer.put(\n-            AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n-            new MetricAttributes(\n-                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+        AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+        new MetricAttributes(\n+            MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+        AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+        new MetricAttributes(\n+            MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+        AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+        new MetricAttributes(\n+            MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n \n     allMetricsInitializer.put(\n-            AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n-            new MetricAttributes(\n-                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+        AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+        new MetricAttributes(\n+            MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n \n     allMetricsInitializer.put(\n-            AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n-            new MetricAttributes(\n-                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+            AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+            new MetricAttributes(MetricUnits.COUNT.toString(), EmptyDimension.values()));\n \n     allMetricsInitializer.put(\n-            AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n-            new MetricAttributes(\n-                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+            AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+            new MetricAttributes(MetricUnits.COUNT.toString(),\n+                    EmptyDimension.values()));\n \n+    allMetricsInitializer.put(\n+        AllMetrics.ShardStateValue.SHARD_STATE.toString(),\n+        new MetricAttributes(\n+            MetricUnits.COUNT.toString(), AllMetrics.ShardStateDimension.values()));\n \n     ALL_METRICS = Collections.unmodifiableMap(allMetricsInitializer);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTg1Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081852", "bodyText": "Missing License information.", "author": "khushbr", "createdAt": "2020-10-19T21:47:06Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjY1Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508436652", "bodyText": "Added", "author": "amathur1893", "createdAt": "2020-10-20T11:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTg1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\nindex bf6aa871..8e135190 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n\n@@ -1,8 +1,24 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MjA4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508082083", "bodyText": "nit: Let's move faultDetectionMetricsMap to next line.", "author": "khushbr", "createdAt": "2020-10-19T21:47:36Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjk4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508436987", "bodyText": "done", "author": "amathur1893", "createdAt": "2020-10-20T11:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MjA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\nindex bf6aa871..8e135190 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n\n@@ -1,8 +1,24 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4NzY4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508087689", "bodyText": "I assume the keyItems or event.key will always have the expected values an index 0 and 3 here ?\nWhat happens if keyItems[3] throws an ArrayIndexOutOfBounds Exception?", "author": "khushbr", "createdAt": "2020-10-19T22:00:07Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MDE4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508440183", "bodyText": "That shouldn't be the case. If this happens somehow, it will have an ArrayIndexOutOfBoundsException. Can add assert here which can check the size of keyItems.", "author": "amathur1893", "createdAt": "2020-10-20T11:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4NzY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\nindex bf6aa871..8e135190 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n\n@@ -1,8 +1,24 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4OTYzNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508089634", "bodyText": "Let us either make this a java doc string or movie this multi-line comment to inside the function.", "author": "khushbr", "createdAt": "2020-10-19T22:04:41Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NDQxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508444411", "bodyText": "Made it javadoc", "author": "amathur1893", "createdAt": "2020-10-20T12:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4OTYzNA=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\nindex bf6aa871..8e135190 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n\n@@ -1,8 +1,24 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDIzNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508090237", "bodyText": "Import AllMetrics.FaultDetectionDimension instead of AllMetrics ?", "author": "khushbr", "createdAt": "2020-10-19T22:06:10Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTYwMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508445600", "bodyText": "done", "author": "amathur1893", "createdAt": "2020-10-20T12:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDIzNw=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\nindex bf6aa871..8e135190 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n\n@@ -1,8 +1,24 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDcxOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508090718", "bodyText": "Let's movie this line to within the try block, after line 103", "author": "khushbr", "createdAt": "2020-10-19T22:07:13Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NjU4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446583", "bodyText": "done", "author": "amathur1893", "createdAt": "2020-10-20T12:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\nindex bf6aa871..8e135190 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n\n@@ -1,8 +1,24 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTQ0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091447", "bodyText": "similar, move this to within try block after line 133", "author": "khushbr", "createdAt": "2020-10-19T22:09:00Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];\n+        try {\n+            long st = Long.parseLong(startTimeVal);\n+            // A keyItem is of the form : [fault_detection, follower_check, 76543, start]\n+            String rid = keyItems[2];\n+            handle.bind(rid, sourceNodeId, targetNodeId, fault_detection_type, st, null, 0);\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Unable to parse string. StartTime:{}\", startTimeVal);\n+            StatsCollector.instance().logException(StatExceptionCode.READER_PARSER_ERROR);\n+            throw e;\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, finish]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // FinishTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // Error:0\n+    // $\n+    private void emitFinishMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String finishTimeVal = keyValueMap.get(AllMetrics.CommonMetric.FINISH_TIME.toString());\n+        String errorString = keyValueMap.get(PerformanceAnalyzerMetrics.ERROR);\n+        String fault_detection_type = keyItems[1];", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NjUyNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446526", "bodyText": "done", "author": "amathur1893", "createdAt": "2020-10-20T12:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\nindex bf6aa871..8e135190 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java\n\n@@ -1,8 +1,24 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTUzMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091533", "bodyText": "Missing License information.", "author": "khushbr", "createdAt": "2020-10-19T22:09:11Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NjY3OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446678", "bodyText": "Added", "author": "amathur1893", "createdAt": "2020-10-20T12:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTUzMw=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\nindex db5c4106..bc5015a8 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java\n\n@@ -1,15 +1,30 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.FaultDetectionDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.google.common.annotations.VisibleForTesting;\n import java.sql.Connection;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import com.google.common.annotations.VisibleForTesting;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.jooq.BatchBindStep;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTg3MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091870", "bodyText": "Missing License information.", "author": "khushbr", "createdAt": "2020-10-19T22:09:57Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MzAyNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508463027", "bodyText": "Added", "author": "amathur1893", "createdAt": "2020-10-20T12:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTg3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e01f059f96038d2cab40090cab653175271e9d7f", "chunk": "diff --git a/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java b/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java\nindex abb7fd04..60f7b35a 100644\n--- a/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java\n+++ b/src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java\n\n@@ -1,17 +1,31 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n+import static org.junit.Assert.assertEquals;\n+\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n import org.jooq.BatchBindStep;\n import org.jooq.Record;\n import org.jooq.Result;\n import org.junit.Before;\n import org.junit.Test;\n \n-import java.sql.Connection;\n-import java.sql.DriverManager;\n-\n-import static org.junit.Assert.assertEquals;\n-\n public class FaultDetectionMetricsSnapshotTests {\n     private static final String DB_URL = \"jdbc:sqlite:\";\n     private Connection conn;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjEyNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092124", "bodyText": "nit: Can we fix the Indentation here.", "author": "khushbr", "createdAt": "2020-10-19T22:10:38Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -119,6 +121,7 @@ public ReaderMetricsProcessor(String rootLocation, boolean processNewFormat, fin\n     shardRqMetricsMap = new TreeMap<>();\n     httpRqMetricsMap = new TreeMap<>();\n     masterEventMetricsMap = new TreeMap<>();\n+\tfaultDetectionMetricsMap = new TreeMap<>();", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2Mjc3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462773", "bodyText": "fixed", "author": "amathur1893", "createdAt": "2020-10-20T12:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjEyNA=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\nindex c0cb9104..11477cc1 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n\n@@ -122,7 +136,9 @@ public class ReaderMetricsProcessor implements Runnable {\n     httpRqMetricsMap = new TreeMap<>();\n     masterEventMetricsMap = new TreeMap<>();\n \tfaultDetectionMetricsMap = new TreeMap<>();\n+    shardStateMetricsMap = new TreeMap<>();\n     gcInfoMap = new TreeMap<>();\n+    masterThrottlingMetricsMap = new TreeMap<>();\n     this.rootLocation = rootLocation;\n     this.configOverridesApplier = new ConfigOverridesApplier();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjM4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092386", "bodyText": "nit: Can we fix the Indentation here.", "author": "khushbr", "createdAt": "2020-10-19T22:11:16Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2Mjg3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462875", "bodyText": "fixed", "author": "amathur1893", "createdAt": "2020-10-20T12:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\nindex c0cb9104..11477cc1 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n\n@@ -244,7 +278,9 @@ public class ReaderMetricsProcessor implements Runnable {\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n \ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);\n+    trimMap(shardStateMetricsMap, SHARD_STATE_SNAPSHOTS);\n     trimMap(gcInfoMap, GC_INFO_SNAPSHOTS);\n+    trimMap(masterThrottlingMetricsMap, MASTER_THROTTLING_SNAPSHOTS);\n \n     for (NavigableMap<Long, MemoryDBSnapshot> snap : nodeMetricsMap.values()) {\n       // do the same thing as OS_SNAPSHOTS.  Eventually MemoryDBSnapshot\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjY1MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092651", "bodyText": "nit: Can we fix the Indentation here.", "author": "khushbr", "createdAt": "2020-10-19T22:11:54Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -540,6 +559,7 @@ is ready so it starts to read that file (go back two windows and\n     eventDispatcher.registerEventProcessor(nodeEventsProcessor);\n     eventDispatcher.registerEventProcessor(masterEventsProcessor);\n     eventDispatcher.registerEventProcessor(clusterDetailsEventsProcessor);\n+\teventDispatcher.registerEventProcessor(faultDetectionProcessor);", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2Mjk1OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462958", "bodyText": "fixed", "author": "amathur1893", "createdAt": "2020-10-20T12:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\nindex c0cb9104..11477cc1 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java\n\n@@ -558,6 +634,8 @@ public class ReaderMetricsProcessor implements Runnable {\n     eventDispatcher.registerEventProcessor(httpProcessor);\n     eventDispatcher.registerEventProcessor(nodeEventsProcessor);\n     eventDispatcher.registerEventProcessor(masterEventsProcessor);\n+    eventDispatcher.registerEventProcessor(masterThrottlingEventsProcessor);\n+    eventDispatcher.registerEventProcessor(shardStateMetricsProcessor);\n     eventDispatcher.registerEventProcessor(clusterDetailsEventsProcessor);\n \teventDispatcher.registerEventProcessor(faultDetectionProcessor);\n     eventDispatcher.registerEventProcessor(garbageCollectorInfoProcessor);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Mjk2OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092969", "bodyText": "Is this required ?", "author": "khushbr", "createdAt": "2020-10-19T22:12:45Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MTc2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508461767", "bodyText": "Removed", "author": "amathur1893", "createdAt": "2020-10-20T12:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Mjk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\nindex 78f7eb06..a27639a9 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n\n@@ -849,140 +864,297 @@ public class MetricsEmitter {\n     }\n   }\n \n-    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+  public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n \n-      long mCurrT = System.currentTimeMillis();\n-      Dimensions dimensions = new Dimensions();\n-      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n-      LOG.error(\"AHH record size is \" + res.size());\n-      List<String> dims =\n-              new ArrayList<String>() {\n-                {\n-                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n-                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n-                }\n-              };\n+    long mCurrT = System.currentTimeMillis();\n+    Dimensions dimensions = new Dimensions();\n+    Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+    LOG.error(\"AHH record size is \" + res.size());\n+    List<String> dims =\n+            new ArrayList<String>() {\n+              {\n+                this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+              }\n+            };\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      for (Record r : res) {\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n-\n-        Double sumLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n-                                .toString());\n-        Double avgLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n-                                .toString());\n-        Double minLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n-                                .toString());\n-        Double maxLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n-                                .toString());\n-\n-        Double sumError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.SUM))\n-                                .toString());\n-        Double avgError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.AVG))\n-                                .toString());\n-        Double minError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MIN))\n-                                .toString());\n-        Double maxError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MAX))\n-                                .toString());\n-        if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        }\n+    for (Record r : res) {\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n+\n+      Double sumLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n+                              .toString());\n+      Double avgLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n+                              .toString());\n+      Double minLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n+                              .toString());\n+      Double maxLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n+                              .toString());\n+\n+      Double sumError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+      Double avgError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+      Double minError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+      Double maxError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+      if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n+      } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n       }\n-      long mFinalT = System.currentTimeMillis();\n-      LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n     }\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottledTaskMetric(\n+          MetricsDB metricsDB, MasterThrottlingMetricsSnapshot masterThrottlingMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> masterThrottlingMetrics = masterThrottlingMetricsSnapshot.fetchAggregatedMetrics();\n+\n+    List<String> dims =\n+            new ArrayList<String>();\n+    emitMasterThrottlingCount(metricsDB, masterThrottlingMetrics, dims);\n+    emitDataThrottlingRetryingCount(metricsDB, masterThrottlingMetrics, dims);\n+\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing master throttling metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.MASTER_THROTTLING_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottlingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumMasterThrottledTask,\n+              avgMasterThrottledTask,\n+              minMasterThrottledTask,\n+              maxMasterThrottledTask);\n+    }\n+\n+    handle.execute();\n+  }\n+\n+  public static void emitDataThrottlingRetryingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumDataRetryingTask,\n+              avgDataRetryingTask,\n+              minDataRetryingTask,\n+              maxDataRetryingTask);\n+    }\n+    handle.execute();\n+  }\n+\n+  public static void emitShardStateMetric(\n+          MetricsDB metricsDB, ShardStateMetricsSnapshot shardStateMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> shardStateMetrics = shardStateMetricsSnapshot.fetchAll();\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+            SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+                    SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    for (Record r : shardStateMetrics) {\n+      handle.bind(\n+              r.get(AllMetrics.ShardStateDimension.INDEX_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_ID.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_TYPE.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.NODE_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_STATE.toString()).toString(),\n+              1.0,\n+              1.0,\n+              1.0,\n+              1.0);\n+    }\n+    handle.execute();\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing shard state event queue metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.SHARD_STATE_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MzQ1NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508093454", "bodyText": "Let's import AllMetrics.FaultDetectionDimension explicitly here.", "author": "khushbr", "createdAt": "2020-10-19T22:14:01Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -22,6 +22,7 @@\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoValue;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.OSMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0OTIzMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508449232", "bodyText": "done", "author": "amathur1893", "createdAt": "2020-10-20T12:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MzQ1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\nindex 78f7eb06..a27639a9 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n\n@@ -16,6 +16,7 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.config.TroubleshootingConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonMetric;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMDc4NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508100784", "bodyText": "Replace this with List<String> dimensionNames = snap.getDimensionNames(); ?", "author": "khushbr", "createdAt": "2020-10-19T22:32:27Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MjE2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462163", "bodyText": "It is a map of dimension name and its value. It will be constructed once we have the table of records", "author": "amathur1893", "createdAt": "2020-10-20T12:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMDc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\nindex 78f7eb06..a27639a9 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n\n@@ -849,140 +864,297 @@ public class MetricsEmitter {\n     }\n   }\n \n-    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+  public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n \n-      long mCurrT = System.currentTimeMillis();\n-      Dimensions dimensions = new Dimensions();\n-      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n-      LOG.error(\"AHH record size is \" + res.size());\n-      List<String> dims =\n-              new ArrayList<String>() {\n-                {\n-                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n-                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n-                }\n-              };\n+    long mCurrT = System.currentTimeMillis();\n+    Dimensions dimensions = new Dimensions();\n+    Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+    LOG.error(\"AHH record size is \" + res.size());\n+    List<String> dims =\n+            new ArrayList<String>() {\n+              {\n+                this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+              }\n+            };\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      for (Record r : res) {\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n-\n-        Double sumLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n-                                .toString());\n-        Double avgLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n-                                .toString());\n-        Double minLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n-                                .toString());\n-        Double maxLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n-                                .toString());\n-\n-        Double sumError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.SUM))\n-                                .toString());\n-        Double avgError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.AVG))\n-                                .toString());\n-        Double minError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MIN))\n-                                .toString());\n-        Double maxError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MAX))\n-                                .toString());\n-        if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        }\n+    for (Record r : res) {\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n+\n+      Double sumLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n+                              .toString());\n+      Double avgLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n+                              .toString());\n+      Double minLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n+                              .toString());\n+      Double maxLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n+                              .toString());\n+\n+      Double sumError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+      Double avgError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+      Double minError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+      Double maxError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+      if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n+      } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n       }\n-      long mFinalT = System.currentTimeMillis();\n-      LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n     }\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottledTaskMetric(\n+          MetricsDB metricsDB, MasterThrottlingMetricsSnapshot masterThrottlingMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> masterThrottlingMetrics = masterThrottlingMetricsSnapshot.fetchAggregatedMetrics();\n+\n+    List<String> dims =\n+            new ArrayList<String>();\n+    emitMasterThrottlingCount(metricsDB, masterThrottlingMetrics, dims);\n+    emitDataThrottlingRetryingCount(metricsDB, masterThrottlingMetrics, dims);\n+\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing master throttling metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.MASTER_THROTTLING_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottlingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumMasterThrottledTask,\n+              avgMasterThrottledTask,\n+              minMasterThrottledTask,\n+              maxMasterThrottledTask);\n+    }\n+\n+    handle.execute();\n+  }\n+\n+  public static void emitDataThrottlingRetryingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumDataRetryingTask,\n+              avgDataRetryingTask,\n+              minDataRetryingTask,\n+              maxDataRetryingTask);\n+    }\n+    handle.execute();\n+  }\n+\n+  public static void emitShardStateMetric(\n+          MetricsDB metricsDB, ShardStateMetricsSnapshot shardStateMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> shardStateMetrics = shardStateMetricsSnapshot.fetchAll();\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+            SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+                    SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    for (Record r : shardStateMetrics) {\n+      handle.bind(\n+              r.get(AllMetrics.ShardStateDimension.INDEX_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_ID.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_TYPE.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.NODE_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_STATE.toString()).toString(),\n+              1.0,\n+              1.0,\n+              1.0,\n+              1.0);\n+    }\n+    handle.execute();\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing shard state event queue metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.SHARD_STATE_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTM4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508101383", "bodyText": "Redundant ? We can use the dimensions defined on line 855", "author": "khushbr", "createdAt": "2020-10-19T22:34:05Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MTcwNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508461705", "bodyText": "This is used to store a key value. Dimension is a map object that has key as metric dimension and value as to what is the value for it whereas dims is a list of dimension as string .", "author": "amathur1893", "createdAt": "2020-10-20T12:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTM4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\nindex 78f7eb06..a27639a9 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n\n@@ -849,140 +864,297 @@ public class MetricsEmitter {\n     }\n   }\n \n-    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+  public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n \n-      long mCurrT = System.currentTimeMillis();\n-      Dimensions dimensions = new Dimensions();\n-      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n-      LOG.error(\"AHH record size is \" + res.size());\n-      List<String> dims =\n-              new ArrayList<String>() {\n-                {\n-                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n-                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n-                }\n-              };\n+    long mCurrT = System.currentTimeMillis();\n+    Dimensions dimensions = new Dimensions();\n+    Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+    LOG.error(\"AHH record size is \" + res.size());\n+    List<String> dims =\n+            new ArrayList<String>() {\n+              {\n+                this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+              }\n+            };\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      for (Record r : res) {\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n-\n-        Double sumLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n-                                .toString());\n-        Double avgLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n-                                .toString());\n-        Double minLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n-                                .toString());\n-        Double maxLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n-                                .toString());\n-\n-        Double sumError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.SUM))\n-                                .toString());\n-        Double avgError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.AVG))\n-                                .toString());\n-        Double minError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MIN))\n-                                .toString());\n-        Double maxError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MAX))\n-                                .toString());\n-        if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        }\n+    for (Record r : res) {\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n+\n+      Double sumLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n+                              .toString());\n+      Double avgLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n+                              .toString());\n+      Double minLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n+                              .toString());\n+      Double maxLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n+                              .toString());\n+\n+      Double sumError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+      Double avgError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+      Double minError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+      Double maxError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+      if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n+      } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n       }\n-      long mFinalT = System.currentTimeMillis();\n-      LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n     }\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottledTaskMetric(\n+          MetricsDB metricsDB, MasterThrottlingMetricsSnapshot masterThrottlingMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> masterThrottlingMetrics = masterThrottlingMetricsSnapshot.fetchAggregatedMetrics();\n+\n+    List<String> dims =\n+            new ArrayList<String>();\n+    emitMasterThrottlingCount(metricsDB, masterThrottlingMetrics, dims);\n+    emitDataThrottlingRetryingCount(metricsDB, masterThrottlingMetrics, dims);\n+\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing master throttling metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.MASTER_THROTTLING_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottlingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumMasterThrottledTask,\n+              avgMasterThrottledTask,\n+              minMasterThrottledTask,\n+              maxMasterThrottledTask);\n+    }\n+\n+    handle.execute();\n+  }\n+\n+  public static void emitDataThrottlingRetryingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumDataRetryingTask,\n+              avgDataRetryingTask,\n+              minDataRetryingTask,\n+              maxDataRetryingTask);\n+    }\n+    handle.execute();\n+  }\n+\n+  public static void emitShardStateMetric(\n+          MetricsDB metricsDB, ShardStateMetricsSnapshot shardStateMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> shardStateMetrics = shardStateMetricsSnapshot.fetchAll();\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+            SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+                    SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    for (Record r : shardStateMetrics) {\n+      handle.bind(\n+              r.get(AllMetrics.ShardStateDimension.INDEX_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_ID.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_TYPE.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.NODE_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_STATE.toString()).toString(),\n+              1.0,\n+              1.0,\n+              1.0,\n+              1.0);\n+    }\n+    handle.execute();\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing shard state event queue metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.SHARD_STATE_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTUzMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508101533", "bodyText": "Replace dims with dimensions ?", "author": "khushbr", "createdAt": "2020-10-19T22:34:29Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };\n+\n+      db.createMetric(\n+              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+              dims);", "originalCommit": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MjQwMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462402", "bodyText": "Same reasoning as above", "author": "amathur1893", "createdAt": "2020-10-20T12:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTUzMw=="}], "type": "inlineReview", "revised_code": {"commit": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "chunk": "diff --git a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\nindex 78f7eb06..a27639a9 100644\n--- a/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n+++ b/src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java\n\n@@ -849,140 +864,297 @@ public class MetricsEmitter {\n     }\n   }\n \n-    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+  public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n \n-      long mCurrT = System.currentTimeMillis();\n-      Dimensions dimensions = new Dimensions();\n-      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n-      LOG.error(\"AHH record size is \" + res.size());\n-      List<String> dims =\n-              new ArrayList<String>() {\n-                {\n-                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n-                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n-                }\n-              };\n+    long mCurrT = System.currentTimeMillis();\n+    Dimensions dimensions = new Dimensions();\n+    Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+    LOG.error(\"AHH record size is \" + res.size());\n+    List<String> dims =\n+            new ArrayList<String>() {\n+              {\n+                this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+              }\n+            };\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(), 0d),\n+            dims);\n \n-      db.createMetric(\n-              new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n-              dims);\n+    db.createMetric(\n+            new Metric<Double>(AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(), 0d),\n+            dims);\n \n-      for (Record r : res) {\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n-        dimensions.put(\n-                AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n-                r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n-\n-        Double sumLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n-                                .toString());\n-        Double avgLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n-                                .toString());\n-        Double minLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n-                                .toString());\n-        Double maxLatency =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n-                                .toString());\n-\n-        Double sumError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.SUM))\n-                                .toString());\n-        Double avgError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.AVG))\n-                                .toString());\n-        Double minError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MIN))\n-                                .toString());\n-        Double maxError =\n-                Double.parseDouble(\n-                        r.get(\n-                                DBUtils.getAggFieldName(\n-                                        FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n-                                        MetricsDB.MAX))\n-                                .toString());\n-        if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n-                .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n-                          sumLatency,\n-                          avgLatency,\n-                          minLatency,\n-                          maxLatency),\n-                  dimensions,\n-                  0);\n-          db.putMetric(\n-                  new Metric<Double>(\n-                          AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n-                          sumError,\n-                          avgError,\n-                          minError,\n-                          maxError),\n-                  dimensions,\n-                  0);\n-        }\n+    for (Record r : res) {\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()).toString());\n+      dimensions.put(\n+              AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString(),\n+              r.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()).toString());\n+\n+      Double sumLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.SUM))\n+                              .toString());\n+      Double avgLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.AVG))\n+                              .toString());\n+      Double minLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MIN))\n+                              .toString());\n+      Double maxLatency =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.LAT.toString(), MetricsDB.MAX))\n+                              .toString());\n+\n+      Double sumError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+      Double avgError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+      Double minError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+      Double maxError =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      FaultDetectionMetricsSnapshot.Fields.ERROR.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+      if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_FOLLOWER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n+      } else if (r.get(FaultDetectionMetricsSnapshot.Fields.FAULT_DETECTION_TYPE.toString()).toString()\n+              .equals(PerformanceAnalyzerMetrics.FAULT_DETECTION_LEADER_CHECK)) {\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+                        sumLatency,\n+                        avgLatency,\n+                        minLatency,\n+                        maxLatency),\n+                dimensions,\n+                0);\n+        db.putMetric(\n+                new Metric<Double>(\n+                        AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+                        sumError,\n+                        avgError,\n+                        minError,\n+                        maxError),\n+                dimensions,\n+                0);\n       }\n-      long mFinalT = System.currentTimeMillis();\n-      LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n     }\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\"Total time taken for writing fault detection metrics to metricsdb: {}\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottledTaskMetric(\n+          MetricsDB metricsDB, MasterThrottlingMetricsSnapshot masterThrottlingMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> masterThrottlingMetrics = masterThrottlingMetricsSnapshot.fetchAggregatedMetrics();\n+\n+    List<String> dims =\n+            new ArrayList<String>();\n+    emitMasterThrottlingCount(metricsDB, masterThrottlingMetrics, dims);\n+    emitDataThrottlingRetryingCount(metricsDB, masterThrottlingMetrics, dims);\n+\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing master throttling metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.MASTER_THROTTLING_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n+\n+  public static void emitMasterThrottlingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxMasterThrottledTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.MASTER_THROTTLED_PENDING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumMasterThrottledTask,\n+              avgMasterThrottledTask,\n+              minMasterThrottledTask,\n+              maxMasterThrottledTask);\n+    }\n+\n+    handle.execute();\n+  }\n+\n+  public static void emitDataThrottlingRetryingCount(MetricsDB metricsDB, Result<Record> res, List<String> dims) {\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+            dims);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(), 0d),\n+                    dims);\n+\n+    for (Record r : res) {\n+\n+      Double sumDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.SUM))\n+                              .toString());\n+\n+      Double avgDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.AVG))\n+                              .toString());\n+\n+      Double minDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MIN))\n+                              .toString());\n+\n+      Double maxDataRetryingTask =\n+              Double.parseDouble(\n+                      r.get(\n+                              DBUtils.getAggFieldName(\n+                                      AllMetrics.MasterThrottlingValue.DATA_RETRYING_TASK_COUNT.toString(),\n+                                      MetricsDB.MAX))\n+                              .toString());\n+\n+      handle.bind(\n+              sumDataRetryingTask,\n+              avgDataRetryingTask,\n+              minDataRetryingTask,\n+              maxDataRetryingTask);\n+    }\n+    handle.execute();\n+  }\n+\n+  public static void emitShardStateMetric(\n+          MetricsDB metricsDB, ShardStateMetricsSnapshot shardStateMetricsSnapshot) {\n+    long mCurrT = System.currentTimeMillis();\n+    Result<Record> shardStateMetrics = shardStateMetricsSnapshot.fetchAll();\n+    metricsDB.createMetric(\n+            new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+            SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    BatchBindStep handle =\n+            metricsDB.startBatchPut(\n+                    new Metric<Double>(AllMetrics.ShardStateValue.SHARD_STATE.toString(), 0d),\n+                    SHARD_STATE_TABLE_DIMENSIONS);\n+\n+    for (Record r : shardStateMetrics) {\n+      handle.bind(\n+              r.get(AllMetrics.ShardStateDimension.INDEX_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_ID.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_TYPE.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.NODE_NAME.toString()).toString(),\n+              r.get(AllMetrics.ShardStateDimension.SHARD_STATE.toString()).toString(),\n+              1.0,\n+              1.0,\n+              1.0,\n+              1.0);\n+    }\n+    handle.execute();\n+    long mFinalT = System.currentTimeMillis();\n+    LOG.debug(\n+            \"Total time taken for writing shard state event queue metrics metricsdb: {}\", mFinalT - mCurrT);\n+    PerformanceAnalyzerApp.READER_METRICS_AGGREGATOR.updateStat(ReaderMetrics.SHARD_STATE_EMITTER_EXECUTION_TIME,\n+            \"\", mFinalT - mCurrT);\n+  }\n }\n"}}, {"oid": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "message": "Taking upstream changes", "committedDate": "2020-10-21T16:27:10Z", "type": "commit"}, {"oid": "e01f059f96038d2cab40090cab653175271e9d7f", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/e01f059f96038d2cab40090cab653175271e9d7f", "message": "Publish Fault Detection Metrics", "committedDate": "2020-10-21T17:46:36Z", "type": "commit"}]}