{"pr_number": 4466, "pr_title": "Fix #4461 HttpOutput Aggregation", "pr_createdAt": "2020-01-09T02:16:55Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4466", "timeline": [{"oid": "e3259d6a695a59a5b3dba7f07c422a7ba5856b4f", "url": "https://github.com/eclipse/jetty.project/commit/e3259d6a695a59a5b3dba7f07c422a7ba5856b4f", "message": "Issue #4461 HttpOutput Aggregation\n\nAdded tests to check that aggregation continues after first flush of an aggregated buffer (this triggers both #4461 and the discovered bug of not aggregating because of empty at capacity aggregate buffer).\n\nAdded getAggregateSize method that does a compact to avoid empty at capacity aggregate buffer\n\nCall onWriteComplete if residue of an overflow aggregation can itself be aggregated.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-01-09T02:14:32Z", "type": "commit"}, {"oid": "5a361008ce5af7eab2377c1cc814a62f96b54df9", "url": "https://github.com/eclipse/jetty.project/commit/5a361008ce5af7eab2377c1cc814a62f96b54df9", "message": "Issue #4461 HttpOutput Aggregation\n\nRemoved implicit compact from GzipHandler\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-01-09T04:58:16Z", "type": "commit"}, {"oid": "356b1c7b7c140018e3461039a335b1591336e4e5", "url": "https://github.com/eclipse/jetty.project/commit/356b1c7b7c140018e3461039a335b1591336e4e5", "message": "Issue #4461 HttpOutput Aggregation\n\nImprove test coverage\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-01-09T05:58:33Z", "type": "commit"}, {"oid": "bda1db7322ed39a09c8f03f7054b92e64d212552", "url": "https://github.com/eclipse/jetty.project/commit/bda1db7322ed39a09c8f03f7054b92e64d212552", "message": "Issue #4461 HttpOutput Aggregation\n\nRemove case that can never happen.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-01-09T07:10:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY0ODAzOA==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364648038", "bodyText": "This is, in general, wrong.\nIf an application sets bufferSize=512, when we get _aggregate from the buffer pool, we get back a buffer with capacity 1024 (or different, depending on the buffer pool configuration).\nWe must either not rely on the capacity of the buffer to return the aggregate space, or slice() the buffer returned by the buffer pool to the desired capacity.", "author": "sbordet", "createdAt": "2020-01-09T09:56:10Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java", "diffHunk": "@@ -378,6 +378,19 @@ private boolean updateApiState(Throwable failure)\n         return wake;\n     }\n \n+    private int getAggregateSpace()\n+    {\n+        // If no aggregate, we can allocate one of bufferSize\n+        if (_aggregate == null)\n+            return getBufferSize();\n+\n+        // if the position is not zero, compact to avoid empty at capacity\n+        if (_aggregate.position() != 0)\n+            BufferUtil.compact(_aggregate);\n+\n+        return BufferUtil.space(_aggregate);", "originalCommit": "bda1db7322ed39a09c8f03f7054b92e64d212552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjY0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364682640", "bodyText": "How can the calculation of space not be based on capacity?\nThe spec allows for a larger buffer than set:\n     * The servlet container will use a buffer at least as large as \n     * the size requested.  The actual buffer size used can be found\n     * using <code>getBufferSize</code>.\n\nIt would be crazy to allocate a larger buffer and then run a shadow capacity to only use a part of it.  If you think we should not use larger buffers than requested, then the buffer pool should never return a larger buffer than requested.", "author": "gregw", "createdAt": "2020-01-09T11:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY0ODAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxOTQ1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364719456", "bodyText": "I agree with @sbordet here.\nIf a user uses HttpConfiguration.setOutputBufferSize(512) or HttpConfiguration.setOutputAggregationSize(256) then they expect behavior based on that configuration, not some larger / mysterious / black box / implementation specific size.\nThe fact that our ByteBufferPool might return a larger size is a side-effect of being efficient with memory allocation here.\nI would expect our behavior to remain unchanged, using the returned ByteBuffer (regardless of actual space/capacity) for the configured buffer size (eg: 512).", "author": "joakime", "createdAt": "2020-01-09T12:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY0ODAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyMjM5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364722395", "bodyText": "Sorry but it is nonsensical to return a larger buffer and then only use a part of it.  The contract allows for a larger buffer to be used, so why would we not use it if it has been allocated?", "author": "gregw", "createdAt": "2020-01-09T12:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY0ODAzOA=="}], "type": "inlineReview", "revised_code": {"commit": "5cbcfbdd2249fc48d37738e7a40f0f27e4eaca54", "chunk": "diff --git a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\nindex c618273af2..6102f535b6 100644\n--- a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n+++ b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n\n@@ -378,15 +378,14 @@ public class HttpOutput extends ServletOutputStream implements Runnable\n         return wake;\n     }\n \n-    private int getAggregateSpace()\n+    private int maximizeAggregateSpace()\n     {\n         // If no aggregate, we can allocate one of bufferSize\n         if (_aggregate == null)\n             return getBufferSize();\n \n-        // if the position is not zero, compact to avoid empty at capacity\n-        if (_aggregate.position() != 0)\n-            BufferUtil.compact(_aggregate);\n+        // compact to maximize space\n+        BufferUtil.compact(_aggregate);\n \n         return BufferUtil.space(_aggregate);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY0OTU2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364649569", "bodyText": "This would be a getter with side effects, it will just bite us back. Must not compact here!", "author": "sbordet", "createdAt": "2020-01-09T09:59:12Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java", "diffHunk": "@@ -378,6 +378,19 @@ private boolean updateApiState(Throwable failure)\n         return wake;\n     }\n \n+    private int getAggregateSpace()\n+    {\n+        // If no aggregate, we can allocate one of bufferSize\n+        if (_aggregate == null)\n+            return getBufferSize();\n+\n+        // if the position is not zero, compact to avoid empty at capacity\n+        if (_aggregate.position() != 0)\n+            BufferUtil.compact(_aggregate);", "originalCommit": "bda1db7322ed39a09c8f03f7054b92e64d212552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MTU4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364681582", "bodyText": "Do you have a suggestion of where the commit should be done then?\nI initially did the compact after every blocking write and in the callback of every async write, but that put the logic in many places.   Having the compact done immediately before the space is checked is the simplest solution I can think of.", "author": "gregw", "createdAt": "2020-01-09T11:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY0OTU2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5cbcfbdd2249fc48d37738e7a40f0f27e4eaca54", "chunk": "diff --git a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\nindex c618273af2..6102f535b6 100644\n--- a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n+++ b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n\n@@ -378,15 +378,14 @@ public class HttpOutput extends ServletOutputStream implements Runnable\n         return wake;\n     }\n \n-    private int getAggregateSpace()\n+    private int maximizeAggregateSpace()\n     {\n         // If no aggregate, we can allocate one of bufferSize\n         if (_aggregate == null)\n             return getBufferSize();\n \n-        // if the position is not zero, compact to avoid empty at capacity\n-        if (_aggregate.position() != 0)\n-            BufferUtil.compact(_aggregate);\n+        // compact to maximize space\n+        BufferUtil.compact(_aggregate);\n \n         return BufferUtil.space(_aggregate);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1MjQ3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364652478", "bodyText": "This code block should really be removed, so that aggregation will happen only in 1 place, and only due to computing whether it should happen or not only once.\nThe conditions at line 829 (new code) are slightly different from the conditions at line 757 (new code), so it's difficult to follow the code, trying to understand why in the world there is a call to onWriteComplete() inside a block that does aggregation.\nActually, turns out that we do (again) a similar aggregation logic in AsyncWrite.process(), so we need to clean this up even more.", "author": "sbordet", "createdAt": "2020-01-09T10:05:22Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java", "diffHunk": "@@ -801,9 +826,10 @@ public void write(byte[] b, int off, int len) throws IOException\n                 channelWrite(_aggregate, last && len == 0);\n \n                 // should we fill aggregate again from the buffer?\n-                if (len > 0 && !last && len <= _commitSize && len <= BufferUtil.space(_aggregate))\n+                if (len > 0 && !last && len <= _commitSize && len <= getAggregateSpace())\n                 {\n                     BufferUtil.append(_aggregate, b, off, len);\n+                    onWriteComplete(false, null);\n                     return;\n                 }", "originalCommit": "bda1db7322ed39a09c8f03f7054b92e64d212552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MTAxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364681015", "bodyText": "I tend to agree, but for jetty-10 only.  In Jetty-9 I do not think we should be making significant behaviour changes as they tend to have unintended consequences.", "author": "gregw", "createdAt": "2020-01-09T11:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1MjQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyMzQ4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364723486", "bodyText": "I am also concerned about the performance. Consider an app that always writes small 5, 10, 20 byte writes. Eventually a small write overflows the buffer. Currently the code fills the buffer to max size, flushes it and then aggregates the small remaining data.\nThe alternative is to flush a non full buffer and then write a small write, so we get 2 non optimal writes instead of one.\nThe real solution is to add gather writes in jetty-10 or beyond", "author": "gregw", "createdAt": "2020-01-09T12:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1MjQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "5cbcfbdd2249fc48d37738e7a40f0f27e4eaca54", "chunk": "diff --git a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\nindex c618273af2..6102f535b6 100644\n--- a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n+++ b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n\n@@ -826,7 +825,7 @@ public class HttpOutput extends ServletOutputStream implements Runnable\n                 channelWrite(_aggregate, last && len == 0);\n \n                 // should we fill aggregate again from the buffer?\n-                if (len > 0 && !last && len <= _commitSize && len <= getAggregateSpace())\n+                if (len > 0 && !last && len <= _commitSize && len <= maximizeAggregateSpace())\n                 {\n                     BufferUtil.append(_aggregate, b, off, len);\n                     onWriteComplete(false, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NjM5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364656399", "bodyText": "Why was this removed?", "author": "sbordet", "createdAt": "2020-01-09T10:13:29Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java", "diffHunk": "@@ -1670,15 +1696,6 @@ protected Action process() throws Exception\n                 return Action.SCHEDULED;\n             }\n \n-            // all content written, but if we have not yet signal completion, we\n-            // need to do so\n-            if (_last && !_completed)\n-            {\n-                _completed = true;\n-                channelWrite(BufferUtil.EMPTY_BUFFER, true, this);\n-                return Action.SCHEDULED;\n-            }\n-", "originalCommit": "bda1db7322ed39a09c8f03f7054b92e64d212552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3OTY3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364679678", "bodyText": "Because is can never ever happen.  I tried to write a unit test to give it code coverage and I was unable to do so.", "author": "gregw", "createdAt": "2020-01-09T11:03:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NjM5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5cbcfbdd2249fc48d37738e7a40f0f27e4eaca54", "chunk": "diff --git a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\nindex c618273af2..6102f535b6 100644\n--- a/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n+++ b/jetty-server/src/main/java/org/eclipse/jetty/server/HttpOutput.java\n\n@@ -1696,6 +1695,15 @@ public class HttpOutput extends ServletOutputStream implements Runnable\n                 return Action.SCHEDULED;\n             }\n \n+            // all content written, but if we have not yet signal completion, we\n+            // need to do so\n+            if (_last && !_completed)\n+            {\n+                _completed = true;\n+                channelWrite(BufferUtil.EMPTY_BUFFER, true, this);\n+                return Action.SCHEDULED;\n+            }\n+\n             if (LOG.isDebugEnabled() && _completed)\n                 LOG.debug(\"EOF of {}\", this);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzAzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364657034", "bodyText": "The test should parametrize on these values, something like [512, 512], [512, 1024], [1024, 1024], [1024, 4096].", "author": "sbordet", "createdAt": "2020-01-09T10:14:58Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/HttpOutputTest.java", "diffHunk": "@@ -54,6 +58,8 @@\n  */\n public class HttpOutputTest\n {\n+    public static final int OUTPUT_AGGREGATION_SIZE = 1024;\n+    public static final int OUTPUT_BUFFER_SIZE = 4096;", "originalCommit": "bda1db7322ed39a09c8f03f7054b92e64d212552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3OTkyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364679925", "bodyText": "why? what does the absolute size of the buffer have to do with it?", "author": "gregw", "createdAt": "2020-01-09T11:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzAzNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzgxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364657811", "bodyText": "With this, this test is testing conditions that will never be the ones with the normal Jetty code, rendering this test useless.", "author": "sbordet", "createdAt": "2020-01-09T10:16:29Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/HttpOutputTest.java", "diffHunk": "@@ -64,10 +70,25 @@ public void init() throws Exception\n     {\n         _server = new Server();\n \n+        _server.addBean(new ByteBufferPool()\n+        {\n+            @Override\n+            public ByteBuffer acquire(int size, boolean direct)\n+            {\n+                return direct ? BufferUtil.allocateDirect(size) : BufferUtil.allocate(size);\n+            }\n+\n+            @Override\n+            public void release(ByteBuffer buffer)\n+            {\n+            }\n+        });", "originalCommit": "bda1db7322ed39a09c8f03f7054b92e64d212552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MDYwMw==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364680603", "bodyText": "Because it is testing aggregation, which is dependent on the actual size of the buffer.  As our buffer pools can give back buffers with larger capacities, this test uses a simple buffer pool that gives back a buffer of exact size and thus allows the tests to be determinant about if they do or do not aggregate/commit etc.", "author": "gregw", "createdAt": "2020-01-09T11:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4NDU1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364684557", "bodyText": "The real buffer pool behaviors are one of the reasons the original code failed in a production capacity.  I think @sbordet has a point, this should use a real world scenario, not a pie-in-the-sky wishful scenario.", "author": "joakime", "createdAt": "2020-01-09T11:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4NjE5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364686199", "bodyText": "This is not pie in the sky wishful thinking.  It is a deterministic test case that actually tests what it thinks it is testing, not some random behaviour that is dependent on a buffer pool beyond the control of the test.", "author": "gregw", "createdAt": "2020-01-09T11:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNjgzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364716833", "bodyText": "OK, then add an alternate test that tests the opposite case.\nA new ByteBufferPool implementation that always returns 4x the size requested.", "author": "joakime", "createdAt": "2020-01-09T12:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyNDcwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4466#discussion_r364724706", "bodyText": "But that is not what I'm testing.  The tests only need to know if a write is bigger, smaller or the same as the buffers. It is relative size not absolute size that is important here.   If I had a 4x buffer returning pool, then I'd just have to alter the test case to write 4x as much data in each write to test the scenarios that are needed to test.\nThe point being that the HttpOutputTest is providing very good (well above average) coverage of HttpOutput.   The purpose here is not to test the buffer pools", "author": "gregw", "createdAt": "2020-01-09T12:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY1NzgxMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "5cbcfbdd2249fc48d37738e7a40f0f27e4eaca54", "url": "https://github.com/eclipse/jetty.project/commit/5cbcfbdd2249fc48d37738e7a40f0f27e4eaca54", "message": "Issue #4461 HttpOutput Aggregation\n\nupdates from review\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-01-09T12:06:03Z", "type": "commit"}]}