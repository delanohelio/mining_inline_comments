{"pr_number": 593, "pr_title": "issue #280", "pr_createdAt": "2020-01-15T16:44:51Z", "pr_url": "https://github.com/IBM/FHIR/pull/593", "timeline": [{"oid": "f1f6db76bc7fb194e8a5ac3e56eb7ea49d522411", "url": "https://github.com/IBM/FHIR/commit/f1f6db76bc7fb194e8a5ac3e56eb7ea49d522411", "message": "issue 280\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-15T16:43:32Z", "type": "commit"}, {"oid": "1238d9343a102b28b66ed6832a74dd9831264059", "url": "https://github.com/IBM/FHIR/commit/1238d9343a102b28b66ed6832a74dd9831264059", "message": "issue 280\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-15T16:53:38Z", "type": "commit"}, {"oid": "2ca3795794dfa487a67aca29e0fa755d7b61396e", "url": "https://github.com/IBM/FHIR/commit/2ca3795794dfa487a67aca29e0fa755d7b61396e", "message": "issue 280\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-15T16:55:49Z", "type": "commit"}, {"oid": "1831c67fea4c0ad05c225f7760b0c4edbac85062", "url": "https://github.com/IBM/FHIR/commit/1831c67fea4c0ad05c225f7760b0c4edbac85062", "message": "issue 280\n\n- SQL for date-value changes\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-15T21:21:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMDkwMA==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r367920900", "bodyText": "Its interesting to see that we DID have a case where we'd populate the Value and not the Start or End.  Good catch.", "author": "lmsurpre", "createdAt": "2020-01-17T12:53:16Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -1236,7 +1236,7 @@ private ExtractedParameterValue processPrimitiveValue(FHIRPathSystemValue system\n             DateParmVal p = new DateParmVal();\n             TemporalAccessor v = systemValue.asTemporalValue().temporal();\n             java.time.Instant inst = DateTimeHandler.generateValue(v);\n-            p.setValueDate(DateTimeHandler.generateTimestamp(inst));", "originalCommit": "1831c67fea4c0ad05c225f7760b0c4edbac85062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMTM1Mw==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r367921353", "bodyText": "But actually, I think we should set both the Start and End values in this case.\nAnd since FHIRPath DateTimes can be partial (just like FHIR DateTimes), we should probably do some similar logic to compute the proper end time.\nAgree?", "author": "lmsurpre", "createdAt": "2020-01-17T12:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4NTYwOA==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r370285608", "bodyText": "Yes, updated to set the same end time - as this is actually an Instant (at this point in the code)", "author": "prb112", "createdAt": "2020-01-23T18:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyMDkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "fa0b72eea8bd5671db6c80fbaeedea54a37ddb39", "chunk": "diff --git a/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java b/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java\nindex ee07afc344..cdfb89448c 100644\n--- a/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java\n+++ b/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java\n\n@@ -1237,6 +1237,7 @@ public class FHIRPersistenceJDBCImpl implements FHIRPersistence, FHIRPersistence\n             TemporalAccessor v = systemValue.asTemporalValue().temporal();\n             java.time.Instant inst = DateTimeHandler.generateValue(v);\n             p.setValueDateStart(DateTimeHandler.generateTimestamp(inst));\n+            p.setValueDateEnd(DateTimeHandler.generateTimestamp(inst));\n             parameter = p;\n         } else if (systemValue.isStringValue()) {\n             StringParmVal p = new StringParmVal();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNTk0OA==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r368025948", "bodyText": "Is this needed?  How would we get here if the SearchParamType isn't date?", "author": "lmsurpre", "createdAt": "2020-01-17T16:32:23Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -925,13 +908,10 @@ private SqlQueryData processDateParm(Class<?> resourceType, QueryParameter query\n         final String METHODNAME = \"processDateParm\";\n         log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n \n-        boolean isDateSearch = isDateSearch(resourceType, queryParm);\n-        boolean isDateRangeSearch = isDateRangeSearch(resourceType, queryParm);\n-\n-        if (log.isLoggable(Level.FINE)) {\n-            log.fine(\"isDateSearch=\" + isDateSearch + \"  isDateRangeSearch=\" + isDateRangeSearch);\n-        }\n-        if (!isDateSearch && !isDateRangeSearch) {\n+        // Check to see if this is of a type is date. \n+        String code = queryParm.getCode();\n+        SearchParamType type = SearchUtil.getSearchParameter(resourceType, code).getType();\n+        if (!SearchParamType.DATE.getValue().equals(type.getValue())) {", "originalCommit": "1831c67fea4c0ad05c225f7760b0c4edbac85062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MDQ4OA==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r370290488", "bodyText": "Good point, I'm not sure where this originated. It's definitely not needed.", "author": "prb112", "createdAt": "2020-01-23T18:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNTk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa0b72eea8bd5671db6c80fbaeedea54a37ddb39", "chunk": "diff --git a/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java b/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java\nindex 4652ba6652..7e88727453 100644\n--- a/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java\n+++ b/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java\n\n@@ -908,18 +904,6 @@ public class JDBCQueryBuilder extends AbstractQueryBuilder<SqlQueryData> {\n         final String METHODNAME = \"processDateParm\";\n         log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n \n-        // Check to see if this is of a type is date. \n-        String code = queryParm.getCode();\n-        SearchParamType type = SearchUtil.getSearchParameter(resourceType, code).getType();\n-        if (!SearchParamType.DATE.getValue().equals(type.getValue())) {\n-            throw new FHIRPersistenceException(\n-                    \"Cannot process query parameter '\" + queryParm.getCode() + \"' as a date.\").withIssue(\n-                            Issue.builder()\n-                                    .code(IssueType.INVALID)\n-                                    .severity(IssueSeverity.WARNING)\n-                                    .build());\n-        }\n-\n         StringBuilder whereClauseSegment = new StringBuilder();\n \n         // Build this piece of the segment:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNjk4Ng==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r368026986", "bodyText": "this looks like its more related to that issue we were getting when _lastUpdate and _id weren't getting handled right.  i guess there still some case where we're failing to use those properly?  maybe we need to get this fix into 4.0.1?", "author": "lmsurpre", "createdAt": "2020-01-17T16:34:22Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/SortedQuerySegmentAggregator.java", "diffHunk": "@@ -129,6 +122,15 @@ public SqlQueryData buildQuery() throws Exception {\n             // Build FROM clause\n             buildFromClause(sqlSortQuery, resourceType.getSimpleName());\n \n+            // Gather up all bind variables from the query segments\n+            // An important step here is to add _id and _lastUpdated\n+            List<Object> allBindVariables = new ArrayList<>();\n+            allBindVariables.addAll(idsObjects);\n+            allBindVariables.addAll(lastUpdatedObjects);\n+            for (SqlQueryData querySegment : this.querySegments) {\n+                allBindVariables.addAll(querySegment.getBindVariables());\n+            }", "originalCommit": "1831c67fea4c0ad05c225f7760b0c4edbac85062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4OTU3OA==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r370289578", "bodyText": "already in 4.0.1 :)", "author": "prb112", "createdAt": "2020-01-23T18:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNjk4Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNzkyOA==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r368027928", "bodyText": "Is it ok to use DATE_START and no DATE_END?  I'm not sure if I really understand how this getValueAttributeNames is used...", "author": "lmsurpre", "createdAt": "2020-01-17T16:36:14Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/SortedQuerySegmentAggregator.java", "diffHunk": "@@ -254,7 +256,7 @@ private String buildAggregateExpression(SortParameter sortParm, int sortParmInde\n             attributeNames.add(STR_VALUE);\n             break;\n         case DATE:\n-            attributeNames.add(DATE_VALUE);\n+            attributeNames.add(DATE_START);", "originalCommit": "1831c67fea4c0ad05c225f7760b0c4edbac85062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4MTM2Nw==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r370281367", "bodyText": "Yes, in this case it's for a consistent SORT order.  If you add DATE_END as well, it'll lead to very irregular sorts.", "author": "prb112", "createdAt": "2020-01-23T18:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNzkyOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMjMwNQ==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r368032305", "bodyText": "Are you sure we need to treat integer search as \"special\"?\nIt seems like a lot of code just to fail something.  I don't think supporting \"eb\" and \"sa\" prefixes for integers would cause anyone any issue.", "author": "lmsurpre", "createdAt": "2020-01-17T16:45:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/type/NumberParmBehaviorUtil.java", "diffHunk": "@@ -269,14 +284,7 @@ public static int calculateSignificantFigures(BigDecimal original) {\n     public static boolean checkIntegerSearchWithSaEb(Prefix prefix, Class<?> resourceType, QueryParameter queryParm,\n             BigDecimal originalNumber)\n             throws FHIRPersistenceException {\n-        boolean isIntegerSearch = false;\n-        try {\n-            isIntegerSearch = ValueTypesFactory.getValueTypesProcessor().isIntegerSearch(resourceType, queryParm);\n-        } catch (FHIRSearchException e) {\n-            log.log(Level.INFO, \"Caught exception while checking the value types for parameter '\"\n-                    + queryParm.getCode() + \"'; continuing...\", e);\n-            // do nothing\n-        }\n+        boolean isIntegerSearch = isIntegerSearch(resourceType, queryParm);", "originalCommit": "1831c67fea4c0ad05c225f7760b0c4edbac85062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzIyNw==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r368033227", "bodyText": "The spec says sa (starts-after) and eb (ends-before) are not used with integer values but are used for decimals. which is why we had that check in the first place.  But to me, thats pretty weak.  I recommend removing.", "author": "lmsurpre", "createdAt": "2020-01-17T16:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMjMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzg4NQ==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r368033885", "bodyText": "FYI - it's a pretty drastic change.  would love to sync back to explain.  I'll save for post 4.0.1", "author": "prb112", "createdAt": "2020-01-17T16:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMjMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNzUwMQ==", "url": "https://github.com/IBM/FHIR/pull/593#discussion_r370307501", "bodyText": "removed, and changed per discussion with Lee", "author": "prb112", "createdAt": "2020-01-23T19:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMjMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "fcfaa1f4aa457b28dd7b8547eefdd641a274f2b7", "chunk": "diff --git a/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/type/NumberParmBehaviorUtil.java b/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/type/NumberParmBehaviorUtil.java\nindex c59866a947..37f9bb279e 100644\n--- a/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/type/NumberParmBehaviorUtil.java\n+++ b/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/type/NumberParmBehaviorUtil.java\n\n@@ -265,202 +226,4 @@ public class NumberParmBehaviorUtil {\n         }\n         return count;\n     }\n-\n-    /**\n-     * per the specification we DO NOT process EB/SA integers.\n-     * <a href=\"https://hl7.org/fhir/search.html#prefix\">FHIR Specification: Search\n-     * - Prefixes</a>\n-     * <code> \n-     * sa (starts-after) and eb (ends-before) are not used with integer values but are used for decimals. \n-     * </code>\n-     * \n-     * @param prefix\n-     * @param resourceType\n-     * @param queryParm\n-     * @param originalNumber\n-     * @return boolean indicating that an integer search is being run.\n-     * @throws FHIRPersistenceException\n-     */\n-    public static boolean checkIntegerSearchWithSaEb(Prefix prefix, Class<?> resourceType, QueryParameter queryParm,\n-            BigDecimal originalNumber)\n-            throws FHIRPersistenceException {\n-        boolean isIntegerSearch = isIntegerSearch(resourceType, queryParm);\n-\n-        if (isIntegerSearch) {\n-            if (prefix == Prefix.EB || prefix == Prefix.SA) {\n-                throw new FHIRPersistenceException(\n-                        \"Search prefixes '\" + Prefix.EB.value() + \"' and '\" + Prefix.SA.value()\n-                                + \"' are not supported for integer searches.\");\n-            } else {\n-                /*\n-                 * Per Specification: <br>\n-                 * When a number search is used against a resource element that stores a simple\n-                 * integer (e.g. ImmunizationRecommendation.recommendation.doseNumber), and the\n-                 * search parameter is not expressed using the exponential forms, and does not\n-                 * include any non-zero digits after a decimal point, the significance issues\n-                 * cancel out and searching is based on exact matches. Note that if there are\n-                 * non-zero digits after a decimal point, there cannot be any matches\n-                 */\n-\n-                // Conditions:\n-                // We know the target is an integer.\n-                // if integer and ! exponential form ('E') and no non-zero\n-                // if indexOf 'E' and indexOf '.' are zero... then it's a specific equals search\n-\n-                // we need to mutate into a string to test the conditions\n-                String num = \"\" + originalNumber;\n-                if (num.indexOf('E') > -1 || num.indexOf('.') > -1) {\n-                    isIntegerSearch = false;\n-                }\n-            }\n-        }\n-\n-        return isIntegerSearch;\n-    }\n-\n-    /**\n-     * the code navigates from a resourcetype down the hierarchy of the object model and the path of the\n-     * search parameter code to determine if the queried parameter is an integer.\n-     * \n-     * @param resourceType\n-     * @param queryParm\n-     * @return\n-     */\n-    public static boolean isIntegerSearch(Class<?> resourceType, QueryParameter queryParm) {\n-        boolean result = false;\n-        try {\n-            String code = queryParm.getCode();\n-            SearchParameter searchParameter = SearchUtil.getSearchParameter(resourceType, code);\n-\n-            // Only process if the expression exists, for instance a DomainResource would not. \n-            if (searchParameter != null && searchParameter.getExpression() != null) {\n-                result =\n-                        processTheExpressionStringToComponents(resourceType,\n-                                searchParameter.getExpression().getValue());\n-            }\n-        } catch (Exception e) {\n-            log.warning(\"Exception retrieving the search parameter \" + e);\n-            e.printStackTrace();\n-        }\n-        return result;\n-    }\n-\n-    protected static boolean processTheExpressionStringToComponents(Class<?> resourceType, String expressionsString) {\n-        boolean result = false;\n-        String[] exprs = expressionsString.split(\"\\\\|\");\n-        for (String expr : exprs) {\n-            FHIRPathLexer lexer = new FHIRPathLexer(CharStreams.fromString(expr));\n-            CommonTokenStream tokens = new CommonTokenStream(lexer);\n-            FHIRPathParser parser = new FHIRPathParser(tokens);\n-            // An intentional call to generate an expression, which populates the tokens in the CommonTokenStream            \n-            parser.expression();\n-\n-            boolean isAs = false;\n-            boolean isWhere = false;\n-            int count = 0;\n-            String cast = \"\";\n-            List<String> fields = new ArrayList<>();\n-            for (Token token : tokens.getTokens()) {\n-                String tokenStr = token.getText();\n-                if (!SKIPPED_TOKENS.contains(tokenStr) && !tokenStr.trim().isEmpty()) {\n-                    if (\"as\".equals(tokenStr)) {\n-                        isAs = true;\n-                    } else if (\"where\".equals(tokenStr)) {\n-                        isWhere = true;\n-                    } else if (\"(\".equals(tokenStr)) {\n-                        count++;\n-                    } else if (\")\".equals(tokenStr)) {\n-                        count--;\n-                    } else if (isAs && count > 0) {\n-                        cast = tokenStr;\n-                        isAs = false;\n-                    } else if (isWhere && count > 0) {\n-                        isWhere = false;\n-                    } else if (count == 0) {\n-                        fields.add(tokenStr);\n-                    }\n-                }\n-            }\n-\n-            // If it's cast or the path needs to be checked.\n-            if (INTEGER_TYPE.contains(cast) || (cast.isEmpty() && followPathToCheckInteger(resourceType, fields))) {\n-                return true;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    // Navigates down the path using the fields from the Expression.\n-    protected static boolean followPathToCheckInteger(Class<?> resourceType, List<String> fields) {\n-        String simpleName = resourceType.getSimpleName();\n-\n-        // Only if the context is the class, we remove from the list. \n-        if (!fields.isEmpty() && fields.get(0).equals(simpleName)) {\n-            fields.remove(simpleName);\n-        }\n-\n-        Class<?> clz = resourceType;\n-        for (String fieldStr : fields) {\n-            if (log.isLoggable(Level.FINE)) {\n-                log.fine(\" - \" + fieldStr + \" \" + fields + \" \" + clz.getSimpleName());\n-            }\n-\n-            Class<?> found = processField(clz, fieldStr);\n-            if (found == null) {\n-                clz = clz.getSuperclass();\n-                clz = processField(clz, fieldStr);\n-            } else {\n-                clz = found;\n-            }\n-        }\n-\n-        // Checks to see if is of Integer type \n-        return INTEGER_TYPE.contains(clz.getSimpleName());\n-    }\n-\n-    public static Class<?> processField(Class<?> clz, String fieldStr) {\n-        Class<?> found = null;\n-        for (Field f : clz.getDeclaredFields()) {\n-            // Logs the field tests\n-            if (log.isLoggable(Level.FINE)) {\n-                log.fine(\"\\t\" + f.getName() + \" -<>- \" + f.getName());\n-            }\n-\n-            if (f.getName().equals(fieldStr.trim())) {\n-\n-                java.lang.reflect.Type genericType = f.getGenericType();\n-                if (genericType instanceof ParameterizedType) {\n-                    ParameterizedType parameterizedType = (ParameterizedType) genericType;\n-                    found = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n-                } else {\n-                    try {\n-                        found = Class.forName(genericType.getTypeName());\n-                    } catch (ClassNotFoundException e) {\n-                        return null;\n-                    }\n-                }\n-\n-                // Check for a choice type. \n-                for (Annotation anno : f.getAnnotationsByType(Choice.class)) {\n-                    Choice choice = (Choice) anno;\n-                    Class<?>[] clzs = choice.value();\n-                    for (Class<?> t : clzs) {\n-                        if (t.getSimpleName().contains(\"Int\")) {\n-                            found = t;\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                break;\n-            }\n-        }\n-\n-        // Logs the field tests\n-        if (log.isLoggable(Level.FINE)) {\n-            log.fine(\" Discovered the simple class -> \" + found);\n-        }\n-\n-        return found;\n-    }\n }\n\\ No newline at end of file\n"}}, {"oid": "fa0b72eea8bd5671db6c80fbaeedea54a37ddb39", "url": "https://github.com/IBM/FHIR/commit/fa0b72eea8bd5671db6c80fbaeedea54a37ddb39", "message": "issue 280\n\n- Updates per Code Review\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-23T18:46:18Z", "type": "commit"}, {"oid": "4b4f4db67408207064cbc6f4cf210eef01d969b0", "url": "https://github.com/IBM/FHIR/commit/4b4f4db67408207064cbc6f4cf210eef01d969b0", "message": "Merge branch 'master' into issue-280", "committedDate": "2020-01-23T18:46:45Z", "type": "commit"}, {"oid": "fcfaa1f4aa457b28dd7b8547eefdd641a274f2b7", "url": "https://github.com/IBM/FHIR/commit/fcfaa1f4aa457b28dd7b8547eefdd641a274f2b7", "message": "issue #280\n\n- Edit Conformance.md per discussion\n- Update NumberParmBehavior for consistent experience with number\nsearches\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-23T19:18:58Z", "type": "commit"}, {"oid": "a4a3dd5d9742ad805bf760cf835ee315f298ec3f", "url": "https://github.com/IBM/FHIR/commit/a4a3dd5d9742ad805bf760cf835ee315f298ec3f", "message": "issue #280\n\n- Update JDBC tests\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-23T19:52:38Z", "type": "commit"}, {"oid": "f6cd72b87511fea69c98e0a0f525896828622eb4", "url": "https://github.com/IBM/FHIR/commit/f6cd72b87511fea69c98e0a0f525896828622eb4", "message": "Apply suggestions from code review\r\n\r\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-27T14:53:16Z", "type": "commit"}, {"oid": "65320548a248aa5056be7884a6be5847a8102a67", "url": "https://github.com/IBM/FHIR/commit/65320548a248aa5056be7884a6be5847a8102a67", "message": "revert schema changes\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-01-30T18:45:34Z", "type": "commit"}]}