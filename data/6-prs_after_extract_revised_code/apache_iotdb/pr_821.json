{"pr_number": 821, "pr_title": "[IOTDB-298]Last time-value query", "pr_createdAt": "2020-02-17T18:35:36Z", "pr_url": "https://github.com/apache/iotdb/pull/821", "timeline": [{"oid": "553ae3ca291c94906b92d78077cc64afd91e690b", "url": "https://github.com/apache/iotdb/commit/553ae3ca291c94906b92d78077cc64afd91e690b", "message": "Add Last query implement without cache", "committedDate": "2020-02-17T07:28:00Z", "type": "commit"}, {"oid": "b4f7c6f3bc7c48d9ea6f5dd75b9c731420bfa5c4", "url": "https://github.com/apache/iotdb/commit/b4f7c6f3bc7c48d9ea6f5dd75b9c731420bfa5c4", "message": "Add Last query cache in MTree node", "committedDate": "2020-02-17T07:28:00Z", "type": "commit"}, {"oid": "611237160dbe07626588463847e13b3692b80208", "url": "https://github.com/apache/iotdb/commit/611237160dbe07626588463847e13b3692b80208", "message": "Fix null measurement display for last query", "committedDate": "2020-02-17T17:59:30Z", "type": "commit"}, {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "url": "https://github.com/apache/iotdb/commit/8ba2e9695b4629f0d7d09badf5e796ee562f8451", "message": "Add Missing license comments", "committedDate": "2020-02-18T03:04:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODYyNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380518625", "bodyText": "what's this for?", "author": "JackieTien97", "createdAt": "2020-02-18T08:26:33Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTEwNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561106", "bodyText": "Removed", "author": "wshao08", "createdAt": "2020-02-18T09:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODYyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b03c708f91031dae5dc56044211c8bebe0615fee", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\nindex 384e56eaf..5e16cd0f4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\n\n@@ -23,13 +23,11 @@ import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n-import com.sun.rowset.internal.Row;\n import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.read.TimeValuePair;\n-import org.apache.iotdb.tsfile.read.common.RowRecord;\n import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODkwMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380518901", "bodyText": "this import is not used, please remove it.", "author": "JackieTien97", "createdAt": "2020-02-18T08:27:12Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;\n import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTE4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561185", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-18T09:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b03c708f91031dae5dc56044211c8bebe0615fee", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\nindex 384e56eaf..5e16cd0f4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\n\n@@ -23,13 +23,11 @@ import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n-import com.sun.rowset.internal.Row;\n import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.read.TimeValuePair;\n-import org.apache.iotdb.tsfile.read.common.RowRecord;\n import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMTgzMw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380531833", "bodyText": "You can use the chunk and page statistics if possible. The code will be like as:\n        while (seriesReader.hasNextChunk()) {\n            if (seriesReader.canUseCurrentChunkStatistics()) {\n                if (seriesReader.currentChunkStatistics().getEndTime() > maxTime) {\n                    maxTime = seriesReader.currentChunkStatistics().getEndTime();\n                    queryResult.setPairResult(maxTime, seriesReader.currentChunkStatistics().getLastValue(), tsDataType);\n                }\n                seriesReader.skipCurrentChunk();\n                continue;\n            }\n            while (seriesReader.hasNextPage()) {\n                if (seriesReader.canUseCurrentPageStatistics()) {\n                    if (seriesReader.currentPageStatistics().getEndTime() > maxTime) {\n                        maxTime = seriesReader.currentPageStatistics().getEndTime();\n                        queryResult.setPairResult(maxTime, seriesReader.currentPageStatistics().getLastValue(), tsDataType);\n                    }\n                    seriesReader.skipCurrentPage();\n                    continue;\n                }\n                // cal by page data\n                while (seriesReader.hasNextOverlappedPage()) {\n                    BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n                    int maxIndex = nextOverlappedPageData.length() - 1;\n                    if (maxIndex < 0) {\n                        continue;\n                    }\n                    long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n                    if (time > maxTime) {\n                        maxTime = time;\n                        queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n                    }\n                    nextOverlappedPageData.resetBatchData();\n                }\n            }\n        }", "author": "JackieTien97", "createdAt": "2020-02-18T08:54:53Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;\n+\n+import java.io.IOException;\n+import java.sql.Time;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+    private List<Path> selectedSeries;\n+    private List<TSDataType> dataTypes;\n+\n+    public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+        this.selectedSeries = lastQueryPlan.getPaths();\n+        this.dataTypes = lastQueryPlan.getDataTypes();\n+    }\n+\n+    /**\n+     * execute last function\n+     *\n+     * @param context query context\n+     */\n+    public QueryDataSet execute(QueryContext context)\n+            throws StorageEngineException, IOException, QueryProcessException {\n+\n+        List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+        for (int i = 0; i < selectedSeries.size(); i++) {\n+            LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+            lastQueryResultList.add(lastQueryResult);\n+        }\n+\n+        RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+        SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+        dataSet.setRecord(resultRecord);\n+        return dataSet;\n+    }\n+\n+    /**\n+     * get aggregation result for one series\n+     *\n+     * @param context query context\n+     * @return AggregateResult list\n+     */\n+    private LastQueryResult calculateLastPairForOneSeries(\n+            Path seriesPath, TSDataType tsDataType,\n+            QueryContext context)\n+            throws IOException, QueryProcessException, StorageEngineException {\n+        LastQueryResult queryResult = new LastQueryResult();\n+        MNode node = null;\n+        try {\n+            node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+        } catch (PathException e) {\n+            throw new QueryProcessException(e);\n+        } catch (CacheException e) {\n+            throw new QueryProcessException(e.getMessage());\n+        }\n+        if (node.getCachedLast() != null) {\n+            queryResult.setPairResult(node.getCachedLast());\n+            return queryResult;\n+        }\n+\n+        // construct series reader without value filter\n+        Filter timeFilter = null;\n+        IAggregateReader seriesReader = new SeriesAggregateReader(\n+                seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+                .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+        long maxTime = Long.MIN_VALUE;\n+        while (seriesReader.hasNextChunk()) {\n+            while (seriesReader.hasNextPage()) {\n+                // cal by page data\n+                while (seriesReader.hasNextOverlappedPage()) {\n+                    BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+                    int maxIndex = nextOverlappedPageData.length() - 1;\n+                    if (maxIndex < 0) {\n+                        continue;\n+                    }\n+                    long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+                    if (time > maxTime) {\n+                        maxTime = time;\n+                        queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+                    }\n+                    nextOverlappedPageData.resetBatchData();\n+                }\n+            }\n+        }", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNTY4NA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380815684", "bodyText": "Yes, adopted", "author": "wshao08", "createdAt": "2020-02-18T17:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMTgzMw=="}], "type": "inlineReview", "revised_code": {"commit": "b03c708f91031dae5dc56044211c8bebe0615fee", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex 088d3ef1c..ab5010db9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -24,19 +24,14 @@ import org.apache.iotdb.db.exception.path.PathException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.MNode;\n-import org.apache.iotdb.db.qp.constant.SQLConstant;\n-import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n-import org.apache.iotdb.db.query.aggregation.AggregateResult;\n import org.apache.iotdb.db.query.context.QueryContext;\n import org.apache.iotdb.db.query.control.QueryResourceManager;\n import org.apache.iotdb.db.query.dataset.SingleDataSet;\n-import org.apache.iotdb.db.query.factory.AggreResultFactory;\n import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n import org.apache.iotdb.tsfile.exception.cache.CacheException;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n-import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.read.common.BatchData;\n import org.apache.iotdb.tsfile.read.common.Path;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380532638", "bodyText": "A lot of imports are not used. You should check that and delete them", "author": "JackieTien97", "createdAt": "2020-02-18T08:56:26Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTM1Nw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561357", "bodyText": "Fixed, thanks", "author": "wshao08", "createdAt": "2020-02-18T09:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "b03c708f91031dae5dc56044211c8bebe0615fee", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex 088d3ef1c..ab5010db9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -24,19 +24,14 @@ import org.apache.iotdb.db.exception.path.PathException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.MNode;\n-import org.apache.iotdb.db.qp.constant.SQLConstant;\n-import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n-import org.apache.iotdb.db.query.aggregation.AggregateResult;\n import org.apache.iotdb.db.query.context.QueryContext;\n import org.apache.iotdb.db.query.control.QueryResourceManager;\n import org.apache.iotdb.db.query.dataset.SingleDataSet;\n-import org.apache.iotdb.db.query.factory.AggreResultFactory;\n import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n import org.apache.iotdb.tsfile.exception.cache.CacheException;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n-import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.read.common.BatchData;\n import org.apache.iotdb.tsfile.read.common.Path;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNzg1OA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380537858", "bodyText": "It is not suitable to put the updateMNodeLastValues method in the InsertPlan.\nYou can update the last value in the before loop, there you already got the measurementNode.", "author": "JackieTien97", "createdAt": "2020-02-18T09:06:03Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -680,6 +674,7 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n+      insertPlan.updateMNodeLastValues(node);", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTgwNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380821805", "bodyText": "The update function is moved into MNode structure.\nI added a loop to update the last value after storageEngine.insert(). It is possible that insert() could fail and throw exceptions. In such case the last value cache will not be updated.", "author": "wshao08", "createdAt": "2020-02-18T17:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNzg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex a2d4712ff..c96d894cd 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -674,7 +683,10 @@ public class PlanExecutor implements IPlanExecutor {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n-      insertPlan.updateMNodeLastValues(node);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(insertPlan.composeTimeValuePair(i));\n+      }\n     } catch (PathException | StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n     } catch (CacheException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzODIyOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380538229", "bodyText": "The same as before", "author": "JackieTien97", "createdAt": "2020-02-18T09:06:47Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -772,8 +767,9 @@ private void checkPathExists(MNode node, String fullPath, MeasurementSchema sche\n                   measurementNode.getSchema().getType()));\n         }\n       }\n-      return storageEngine.insertBatch(batchInsertPlan);\n-\n+      Integer[] results = storageEngine.insertBatch(batchInsertPlan);\n+      batchInsertPlan.updateMNodeLastValues(node);", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex a2d4712ff..c96d894cd 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -768,7 +780,10 @@ public class PlanExecutor implements IPlanExecutor {\n         }\n       }\n       Integer[] results = storageEngine.insertBatch(batchInsertPlan);\n-      batchInsertPlan.updateMNodeLastValues(node);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(batchInsertPlan.composeLastTimeValuePair(i));\n+      }\n       return results;\n     } catch (PathException | StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzOTI5Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380539293", "bodyText": "It's better to add it to the last, because you don't know whether the programmers are using the enum's ordinal() function", "author": "JackieTien97", "createdAt": "2020-02-18T09:08:53Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -68,7 +68,7 @@ public String toString() {\n   public enum OperatorType {\n     SFW, JOIN, UNION, FILTER, GROUPBY, ORDERBY, LIMIT, SELECT, SEQTABLESCAN, HASHTABLESCAN,\n     MERGEJOIN, FILEREAD, NULL, TABLESCAN, UPDATE, INSERT, BATCHINSERT, DELETE, BASIC_FUNC, IN, QUERY, MERGEQUERY,\n-    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL,\n+    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL, LAST,", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NzUzNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380597536", "bodyText": "Modified", "author": "wshao08", "createdAt": "2020-02-18T10:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzOTI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "55f9a83f7df0d15a23465438f2122c3231ec4c6e", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\nindex 4fbccc510..2c7fe0a75 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n\n@@ -68,12 +68,12 @@ public abstract class Operator {\n   public enum OperatorType {\n     SFW, JOIN, UNION, FILTER, GROUPBY, ORDERBY, LIMIT, SELECT, SEQTABLESCAN, HASHTABLESCAN,\n     MERGEJOIN, FILEREAD, NULL, TABLESCAN, UPDATE, INSERT, BATCHINSERT, DELETE, BASIC_FUNC, IN, QUERY, MERGEQUERY,\n-    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL, LAST,\n+    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL,\n     SET_STORAGE_GROUP, CREATE_TIMESERIES, DELETE_TIMESERIES, CREATE_USER, DELETE_USER, MODIFY_PASSWORD,\n     GRANT_USER_PRIVILEGE, REVOKE_USER_PRIVILEGE, GRANT_USER_ROLE, REVOKE_USER_ROLE, CREATE_ROLE,\n     DELETE_ROLE, GRANT_ROLE_PRIVILEGE, REVOKE_ROLE_PRIVILEGE, LIST_USER, LIST_ROLE,\n     LIST_USER_PRIVILEGE, LIST_ROLE_PRIVILEGE, LIST_USER_ROLES, LIST_ROLE_USERS,\n     GRANT_WATERMARK_EMBEDDING, REVOKE_WATERMARK_EMBEDDING,\n-    TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE\n+    TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDE5NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380540195", "bodyText": "This function is not the InsertPlan's responsibility", "author": "JackieTien97", "createdAt": "2020-02-18T09:10:37Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +292,23 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public void updateMNodeLastValues(MNode node) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object[] column = (Object[]) columns[i];\n+        node.getChild(measurements[i]).updateCachedLast(maxTime, column[maxIndex], dataTypes[i]);\n+      }\n+    }\n+  }\n+", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjQ4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380796485", "bodyText": "Agree. Moved it out of InsertPlan", "author": "wshao08", "createdAt": "2020-02-18T16:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDE5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\nindex bfea215cd..de344aafb 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\n\n@@ -292,7 +291,7 @@ public class BatchInsertPlan extends PhysicalPlan {\n     return maxTime;\n   }\n \n-  public void updateMNodeLastValues(MNode node) {\n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n     long maxTime = Long.MIN_VALUE;\n     int maxIndex = 0;\n     for (int i = 0; i < times.length; i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDMzMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380540330", "bodyText": "Same as before", "author": "JackieTien97", "createdAt": "2020-02-18T09:10:51Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java", "diffHunk": "@@ -185,4 +190,13 @@ public void deserializeFrom(ByteBuffer buffer) {\n   public String toString() {\n     return \"deviceId: \" + deviceId + \", time: \" + time;\n   }\n+\n+  public void updateMNodeLastValues(MNode node) throws QueryProcessException {\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object value = CommonUtils.parseValue(dataTypes[i], values[i]);\n+        node.getChild(measurements[i]).updateCachedLast(time, value, dataTypes[i]);\n+      }\n+    }\n+  }", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjY1MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380796650", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-18T16:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java\nindex 24b43a87a..14f6f1da5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java\n\n@@ -191,12 +191,8 @@ public class InsertPlan extends PhysicalPlan {\n     return \"deviceId: \" + deviceId + \", time: \" + time;\n   }\n \n-  public void updateMNodeLastValues(MNode node) throws QueryProcessException {\n-    for (int i = 0; i < measurements.length; i++) {\n-      if (node.hasChild(measurements[i])) {\n-        Object value = CommonUtils.parseValue(dataTypes[i], values[i]);\n-        node.getChild(measurements[i]).updateCachedLast(time, value, dataTypes[i]);\n-      }\n-    }\n+  public TimeValuePair composeTimeValuePair(int measurementIndex) throws QueryProcessException {\n+    Object value = CommonUtils.parseValue(dataTypes[measurementIndex], values[measurementIndex]);\n+    return new TimeValuePair(time, TsPrimitiveType.getByType(dataTypes[measurementIndex], value));\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTE4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380541185", "bodyText": "delete it", "author": "JackieTien97", "createdAt": "2020-02-18T09:12:21Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -196,6 +196,7 @@ public static TSDataType getSeriesType(String path) throws QueryProcessException\n         case SQLConstant.FIRST_VALUE:\n         case SQLConstant.MIN_VALUE:\n         case SQLConstant.MAX_VALUE:\n+        //case SQLConstant.LAST:", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NjQ5MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380596490", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-18T10:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTE4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b03c708f91031dae5dc56044211c8bebe0615fee", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java\nindex 5ddcfa1ac..cadd91f2e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java\n\n@@ -196,7 +196,6 @@ public class TSServiceImpl implements TSIService.Iface, ServerContext {\n         case SQLConstant.FIRST_VALUE:\n         case SQLConstant.MIN_VALUE:\n         case SQLConstant.MAX_VALUE:\n-        //case SQLConstant.LAST:\n           return getSeriesType(innerPath);\n         case SQLConstant.AVG:\n         case SQLConstant.SUM:\n"}}, {"oid": "b03c708f91031dae5dc56044211c8bebe0615fee", "url": "https://github.com/apache/iotdb/commit/b03c708f91031dae5dc56044211c8bebe0615fee", "message": "Remove unused import and adjust code format", "committedDate": "2020-02-18T09:45:24Z", "type": "commit"}, {"oid": "55f9a83f7df0d15a23465438f2122c3231ec4c6e", "url": "https://github.com/apache/iotdb/commit/55f9a83f7df0d15a23465438f2122c3231ec4c6e", "message": "Fix compilation error", "committedDate": "2020-02-18T10:48:57Z", "type": "commit"}, {"oid": "97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "url": "https://github.com/apache/iotdb/commit/97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "message": "Clarify last related function behavior", "committedDate": "2020-02-18T16:42:45Z", "type": "commit"}, {"oid": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "url": "https://github.com/apache/iotdb/commit/3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "message": "Use chunk and page stats when calculating last data", "committedDate": "2020-02-18T17:10:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAyNDI0OQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381024249", "bodyText": "Why not combine this loop with the before one.", "author": "JackieTien97", "createdAt": "2020-02-19T01:04:04Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -680,6 +683,10 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(insertPlan.composeTimeValuePair(i));\n+      }", "originalCommit": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e175b5a2a31f5bcb600d9a4afc811d3b635f299", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex c96d894cd..322f9ff12 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -673,12 +696,35 @@ public class PlanExecutor implements IPlanExecutor {\n     try {\n       String[] measurementList = insertPlan.getMeasurements();\n       String deviceId = insertPlan.getDeviceId();\n-      MNode node = mManager.getNodeByPathFromCache(deviceId);\n+      MNode node = mManager.getDeviceNodeWithAutoCreateStorageGroup(deviceId);\n       String[] strValues = insertPlan.getValues();\n       TSDataType[] dataTypes = new TSDataType[measurementList.length];\n \n       for (int i = 0; i < measurementList.length; i++) {\n-        MNode measurementNode = checkPathExists(node, deviceId, measurementList[i], strValues[i]);\n+        String measurement = measurementList[i];\n+        if (!node.hasChild(measurement)) {\n+          if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n+            throw new QueryProcessException(\n+                String.format(\"Current deviceId[%s] does not contain measurement:%s\",\n+                    deviceId, measurement));\n+          }\n+          TSDataType dataType = TypeInferenceUtils.getPredictedDataType(strValues[i]);\n+          Path path = new Path(deviceId, measurement);\n+\n+          boolean result = mManager\n+              .createTimeseries(path.toString(), dataType, getDefaultEncoding(dataType),\n+                  TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+                  Collections.emptyMap());\n+          if (result) {\n+            storageEngine.addTimeSeries(path, dataType, getDefaultEncoding(dataType));\n+          }\n+        }\n+        MNode measurementNode = node.getChild(measurement);\n+        if (measurementNode instanceof InternalMNode) {\n+          throw new QueryProcessException(\n+              String.format(\"Current Path is not leaf node. %s.%s\", deviceId, measurement));\n+        }\n+\n         dataTypes[i] = measurementNode.getSchema().getType();\n       }\n       insertPlan.setDataTypes(dataTypes);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMjE1Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381032153", "bodyText": "same as before.", "author": "JackieTien97", "createdAt": "2020-02-19T01:33:29Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -772,8 +779,12 @@ private void checkPathExists(MNode node, String fullPath, MeasurementSchema sche\n                   measurementNode.getSchema().getType()));\n         }\n       }\n-      return storageEngine.insertBatch(batchInsertPlan);\n-\n+      Integer[] results = storageEngine.insertBatch(batchInsertPlan);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(batchInsertPlan.composeLastTimeValuePair(i));\n+      }", "originalCommit": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e175b5a2a31f5bcb600d9a4afc811d3b635f299", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex c96d894cd..322f9ff12 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -787,8 +812,6 @@ public class PlanExecutor implements IPlanExecutor {\n       return results;\n     } catch (PathException | StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n-    } catch (CacheException e) {\n-      throw new QueryProcessException(e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNDUzOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381034539", "bodyText": "No matter what measurementIndex is, this calculation process is the same. It only needs to be called once.\nYou can extract that method outside the the calling loop.", "author": "JackieTien97", "createdAt": "2020-02-19T01:42:13Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }", "originalCommit": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxODI2MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384918260", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-27T05:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNDUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c561dc58b9c267c3aa8533f74a6bfa25a310d2ec", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\nindex de344aafb..6a1c58c9a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\n\n@@ -292,16 +292,12 @@ public class BatchInsertPlan extends PhysicalPlan {\n   }\n \n   public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n-    long maxTime = Long.MIN_VALUE;\n-    int maxIndex = 0;\n-    for (int i = 0; i < times.length; i++) {\n-      if (times[i] > maxTime) {\n-        maxTime = times[i];\n-        maxIndex = i;\n-      }\n-    }\n+    if (measurementIndex >= columns.length) return null;\n+\n     Object[] column = (Object[]) columns[measurementIndex];\n-    return new TimeValuePair(maxTime, TsPrimitiveType.getByType(dataTypes[measurementIndex], column[maxIndex]));\n+    // Use [end - 1] as the max time index as the time in BatchInsertPlan is in ascending order\n+    TsPrimitiveType value = TsPrimitiveType.getByType(dataTypes[measurementIndex], column[end - 1]);\n+    return new TimeValuePair(times[end - 1], value);\n   }\n \n   public long[] getTimes() {\n"}}, {"oid": "21e761566a8da68446492e0aa82cedf2bd236291", "url": "https://github.com/apache/iotdb/commit/21e761566a8da68446492e0aa82cedf2bd236291", "message": "Fix last query syntax bug", "committedDate": "2020-02-20T15:30:19Z", "type": "commit"}, {"oid": "afbc0937a690fa07f25edab5e0d2236cda69e068", "url": "https://github.com/apache/iotdb/commit/afbc0937a690fa07f25edab5e0d2236cda69e068", "message": "Add java doc for last", "committedDate": "2020-02-20T15:30:36Z", "type": "commit"}, {"oid": "0abe34f828e8aab11194d8025d95cf4ad44388d2", "url": "https://github.com/apache/iotdb/commit/0abe34f828e8aab11194d8025d95cf4ad44388d2", "message": "Update java doc", "committedDate": "2020-02-20T17:27:47Z", "type": "commit"}, {"oid": "c2ee32b765b44332bbe188126729b187c119746a", "url": "https://github.com/apache/iotdb/commit/c2ee32b765b44332bbe188126729b187c119746a", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into new_series_reader", "committedDate": "2020-02-20T17:47:44Z", "type": "commit"}, {"oid": "409a7b96ecfe3e68fe4d3e09405d33720092a1a4", "url": "https://github.com/apache/iotdb/commit/409a7b96ecfe3e68fe4d3e09405d33720092a1a4", "message": "Add unit test for last", "committedDate": "2020-02-20T18:40:22Z", "type": "commit"}, {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "url": "https://github.com/apache/iotdb/commit/f43426a7987c156d3d373fbf1cfa1d9858a2815d", "message": "Fix ut compilation error", "committedDate": "2020-02-21T01:12:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4MTIwNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382381206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {\n          \n          \n            \n                } else if (timeValuePair.getTimestamp() >= cachedLastValuePair.getTimestamp()) {\n          \n      \n    \n    \n  \n\ninsert time-value 1-1\ninsert time-value 1-2\nthe vlaue of 1 should be updated to 2", "author": "qiaojialin", "createdAt": "2020-02-21T03:32:36Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -238,4 +241,23 @@ public String getFullPath() {\n     }\n     return fullPath = builder.toString();\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public void setCachedLast(TimeValuePair timeValuePair) {\n+    cachedLastValuePair = timeValuePair;\n+  }\n+\n+  public void updateCachedLast(TimeValuePair timeValuePair) {\n+    if (timeValuePair == null)\n+      return;\n+    if (cachedLastValuePair == null) {\n+      cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NTg0Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384645843", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-26T17:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4MTIwNg=="}], "type": "inlineReview", "revised_code": {"commit": "3e175b5a2a31f5bcb600d9a4afc811d3b635f299", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\ndeleted file mode 100644\nindex 433338615..000000000\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MNode.java\n+++ /dev/null\n\n@@ -1,263 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.metadata;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-\n-import org.apache.iotdb.db.conf.IoTDBConstant;\n-import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n-import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n-import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n-import org.apache.iotdb.tsfile.read.TimeValuePair;\n-import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n-\n-/**\n- * This class is the implementation of Metadata Node where \"MNode\" is the shorthand of \"Metadata\n- * Node\". One MNode instance represents one node in the Metadata Tree\n- */\n-public class MNode implements Serializable {\n-\n-  private static final long serialVersionUID = -770028375899514063L;\n-\n-  // The name of the MNode\n-  private String name;\n-  // Whether current node is a leaf in the Metadata Tree\n-  private boolean isLeaf;\n-  // Whether current node is Storage group in the Metadata Tree\n-  private boolean isStorageGroup;\n-  // Map for the schema in this storage group\n-  private Map<String, MeasurementSchema> schemaMap;\n-  private Map<String, Integer> numSchemaMap;\n-  // Corresponding data file name for current node\n-  private String dataFileName;\n-  // Column's Schema for one timeseries represented by current node if current\n-  // node is one leaf\n-  private MeasurementSchema schema;\n-  private MNode parent;\n-  private Map<String, MNode> children;\n-\n-  private String fullPath;\n-  private TimeValuePair cachedLastValuePair = null;\n-\n-  /**\n-   * when the data in a storage group is older than dataTTL, it is considered invalid and will\n-   * be eventually removed.\n-   * only set at storage group level.\n-   */\n-  private long dataTTL = Long.MAX_VALUE;\n-\n-  /**\n-   * Constructor of MNode.\n-   */\n-  public MNode(String name, MNode parent, boolean isLeaf) {\n-    this.setName(name);\n-    this.parent = parent;\n-    this.isLeaf = isLeaf;\n-    this.isStorageGroup = false;\n-    if (!isLeaf) {\n-      children = new LinkedHashMap<>();\n-    }\n-  }\n-\n-  public MNode(String name, MNode parent, TSDataType dataType, TSEncoding encoding,\n-      CompressionType type) {\n-    this(name, parent, true);\n-    this.schema = new MeasurementSchema(name, dataType, encoding, type);\n-  }\n-\n-  public boolean isStorageGroup() {\n-    return isStorageGroup;\n-  }\n-\n-  /**\n-   * function for setting storage group.\n-   */\n-  public void setStorageGroup(boolean b) {\n-    this.isStorageGroup = b;\n-    if (b) {\n-      schemaMap = new HashMap<>();\n-      numSchemaMap = new HashMap<>();\n-    } else {\n-      numSchemaMap = null;\n-      schemaMap = null;\n-    }\n-  }\n-\n-  public Map<String, MeasurementSchema> getSchemaMap() {\n-    return schemaMap;\n-  }\n-\n-  public Map<String, Integer> getNumSchemaMap() {\n-    return numSchemaMap;\n-  }\n-\n-  public boolean isLeaf() {\n-    return isLeaf;\n-  }\n-\n-  public void setLeaf(boolean isLeaf) {\n-    this.isLeaf = isLeaf;\n-  }\n-\n-  /**\n-   * function for checking whether the mnode has child mnode.\n-   */\n-  public boolean hasChildren() {\n-    if (!isLeaf) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * function for checking whether mnode's children contain the given key.\n-   */\n-  public boolean hasChild(String key) {\n-    if (!isLeaf) {\n-      return this.children.containsKey(key);\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * function for adding the given key to the given child mnode.\n-   */\n-  public void addChild(String key, MNode child) {\n-    if (!isLeaf) {\n-      this.children.put(key, child);\n-    }\n-  }\n-\n-  public void deleteChild(String key) {\n-    children.remove(key);\n-  }\n-\n-  /**\n-   * function for getting the child mnode under the given key.\n-   */\n-  public MNode getChild(String key) {\n-    if (!isLeaf) {\n-      return children.get(key);\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * function for getting the count of all leaves whose ancestor is current node.\n-   */\n-  public int getLeafCount() {\n-    if (isLeaf) {\n-      return 1;\n-    } else {\n-      int leafCount = 0;\n-      for (MNode child : this.children.values()) {\n-        leafCount += child.getLeafCount();\n-      }\n-      return leafCount;\n-    }\n-  }\n-\n-  public String getDataFileName() {\n-    return dataFileName;\n-  }\n-\n-  public void setDataFileName(String dataFileName) {\n-    this.dataFileName = dataFileName;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return this.getName();\n-  }\n-\n-  public MeasurementSchema getSchema() {\n-    return schema;\n-  }\n-\n-  public void setSchema(MeasurementSchema schema) {\n-    this.schema = schema;\n-  }\n-\n-  public MNode getParent() {\n-    return parent;\n-  }\n-\n-  public void setParent(MNode parent) {\n-    this.parent = parent;\n-  }\n-\n-  public Map<String, MNode> getChildren() {\n-    return children;\n-  }\n-\n-  public void setChildren(Map<String, MNode> children) {\n-    this.children = children;\n-  }\n-\n-  public String getName() {\n-    return name;\n-  }\n-\n-  public void setName(String name) {\n-    this.name = name;\n-  }\n-\n-  public long getDataTTL() {\n-    return dataTTL;\n-  }\n-\n-  public void setDataTTL(long dataTTL) {\n-    this.dataTTL = dataTTL;\n-  }\n-\n-  public String getFullPath() {\n-    if (fullPath != null) {\n-      return fullPath;\n-    }\n-    StringBuilder builder = new StringBuilder(name);\n-    MNode curr = this;\n-    while (curr.parent != null) {\n-      curr = curr.parent;\n-      builder.insert(0, IoTDBConstant.PATH_SEPARATOR).insert(0, curr.name);\n-    }\n-    return fullPath = builder.toString();\n-  }\n-\n-  public TimeValuePair getCachedLast() {\n-    return cachedLastValuePair;\n-  }\n-\n-  public void setCachedLast(TimeValuePair timeValuePair) {\n-    cachedLastValuePair = timeValuePair;\n-  }\n-\n-  public void updateCachedLast(TimeValuePair timeValuePair) {\n-    if (timeValuePair == null)\n-      return;\n-    if (cachedLastValuePair == null) {\n-      cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n-    } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {\n-      cachedLastValuePair.setTimestamp(timeValuePair.getTimestamp());\n-      cachedLastValuePair.setValue(timeValuePair.getValue());\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzczMg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382463732", "bodyText": "the time in BatchInsertPlan is always in ascending order, you could directly get the last", "author": "qiaojialin", "createdAt": "2020-02-21T08:57:09Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjAwNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646004", "bodyText": "Done", "author": "wshao08", "createdAt": "2020-02-26T17:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzczMg=="}], "type": "inlineReview", "revised_code": {"commit": "c561dc58b9c267c3aa8533f74a6bfa25a310d2ec", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\nindex de344aafb..6a1c58c9a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java\n\n@@ -292,16 +292,12 @@ public class BatchInsertPlan extends PhysicalPlan {\n   }\n \n   public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n-    long maxTime = Long.MIN_VALUE;\n-    int maxIndex = 0;\n-    for (int i = 0; i < times.length; i++) {\n-      if (times[i] > maxTime) {\n-        maxTime = times[i];\n-        maxIndex = i;\n-      }\n-    }\n+    if (measurementIndex >= columns.length) return null;\n+\n     Object[] column = (Object[]) columns[measurementIndex];\n-    return new TimeValuePair(maxTime, TsPrimitiveType.getByType(dataTypes[measurementIndex], column[maxIndex]));\n+    // Use [end - 1] as the max time index as the time in BatchInsertPlan is in ascending order\n+    TsPrimitiveType value = TsPrimitiveType.getByType(dataTypes[measurementIndex], column[end - 1]);\n+    return new TimeValuePair(times[end - 1], value);\n   }\n \n   public long[] getTimes() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDU3NA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382464574", "bodyText": "the sql needs update", "author": "qiaojialin", "createdAt": "2020-02-21T08:58:52Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -1047,6 +1048,16 @@ public void enterSelectElement(SelectElementContext ctx) {\n     queryOp.setSelectOperator(selectOp);\n   }\n \n+  @Override\n+  public void enterLastElement(SqlBaseParser.LastElementContext ctx) {\n+    super.enterLastElement(ctx);\n+    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n+    LastFunctionCallContext functionCallContext = ctx.lastFunctionCall();\n+    Path path = parseSuffixPath(functionCallContext.suffixPath());\n+    selectOp.addLastPath(path, functionCallContext.LAST().getText());\n+    queryOp.setSelectOperator(selectOp);", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjgzOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646838", "bodyText": "Sql syntax updated", "author": "wshao08", "createdAt": "2020-02-26T17:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "5736f861baa2cf0d4a02735450492f2fd2b4946a", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java b/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\nindex a9fc01752..bc723e553 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\n\n@@ -1052,10 +988,15 @@ public class LogicalGenerator extends SqlBaseBaseListener {\n   public void enterLastElement(SqlBaseParser.LastElementContext ctx) {\n     super.enterLastElement(ctx);\n     selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    LastFunctionCallContext functionCallContext = ctx.lastFunctionCall();\n-    Path path = parseSuffixPath(functionCallContext.suffixPath());\n-    selectOp.addLastPath(path, functionCallContext.LAST().getText());\n+    LastClauseContext lastClauseContext = ctx.lastClause();\n+    List<SuffixPathContext> suffixPaths = lastClauseContext.suffixPath();\n+    for (SuffixPathContext suffixPath : suffixPaths) {\n+      Path path = parseSuffixPath(suffixPath);\n+      selectOp.addLastPath(path);\n+    }\n     queryOp.setSelectOperator(selectOp);\n+    queryOp.setAlignByTime(false);\n+    queryOp.setAlignByDevice(false);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTYzOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382465639", "bodyText": "The result format should be updated to path, time, value", "author": "qiaojialin", "createdAt": "2020-02-21T09:01:09Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NzAyMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384647020", "bodyText": "Result set updated", "author": "wshao08", "createdAt": "2020-02-26T17:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "92c43917a94f540416413eb85ed95c55b606b628", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex 47d370c29..487b0ede2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -20,10 +20,8 @@\n package org.apache.iotdb.db.query.executor;\n \n import org.apache.iotdb.db.exception.StorageEngineException;\n-import org.apache.iotdb.db.exception.path.PathException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n-import org.apache.iotdb.db.metadata.MNode;\n import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n import org.apache.iotdb.db.query.aggregation.AggregateResult;\n import org.apache.iotdb.db.query.context.QueryContext;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzA5MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382467091", "bodyText": "I think this class is not needed, you could use TimeValuePair directly unless you store the path of a series in this class.", "author": "qiaojialin", "createdAt": "2020-02-21T09:04:14Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());\n+    return queryResult;\n+  }\n+\n+  /**\n+   * using last result data list construct QueryDataSet.\n+   *\n+   * @param lastQueryResultList last result list\n+   */\n+  private RowRecord constructLastRowRecord(List<LastQueryResult> lastQueryResultList) {\n+    long maxTime = Long.MIN_VALUE;\n+    for (LastQueryResult lastPair : lastQueryResultList) {\n+      if (lastPair.hasResult() && lastPair.getTimestamp() > maxTime)\n+        maxTime = lastPair.getTimestamp();\n+    }\n+\n+    RowRecord resultRecord = new RowRecord(maxTime);\n+    for (int i = 0; i < lastQueryResultList.size(); i++) {\n+      TSDataType dataType = dataTypes.get(i);\n+      LastQueryResult lastPair = lastQueryResultList.get(i);\n+      if (lastPair.hasResult() && lastPair.getTimestamp() == maxTime)\n+        resultRecord.addField(lastPair.getValue(), dataType);\n+      else\n+        resultRecord.addField(null, dataType);\n+    }\n+\n+    return resultRecord;\n+  }\n+\n+  class LastQueryResult {", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjE3Ng==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646176", "bodyText": "Removed in the new version", "author": "wshao08", "createdAt": "2020-02-26T17:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "92c43917a94f540416413eb85ed95c55b606b628", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex 47d370c29..487b0ede2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -20,10 +20,8 @@\n package org.apache.iotdb.db.query.executor;\n \n import org.apache.iotdb.db.exception.StorageEngineException;\n-import org.apache.iotdb.db.exception.path.PathException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n-import org.apache.iotdb.db.metadata.MNode;\n import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n import org.apache.iotdb.db.query.aggregation.AggregateResult;\n import org.apache.iotdb.db.query.context.QueryContext;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQwNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382476404", "bodyText": "remove this field and use null directly", "author": "qiaojialin", "createdAt": "2020-02-21T09:24:28Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjI0Mg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646242", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-26T17:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQwNA=="}], "type": "inlineReview", "revised_code": {"commit": "92c43917a94f540416413eb85ed95c55b606b628", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex 47d370c29..487b0ede2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -20,10 +20,8 @@\n package org.apache.iotdb.db.query.executor;\n \n import org.apache.iotdb.db.exception.StorageEngineException;\n-import org.apache.iotdb.db.exception.path.PathException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n-import org.apache.iotdb.db.metadata.MNode;\n import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n import org.apache.iotdb.db.query.aggregation.AggregateResult;\n import org.apache.iotdb.db.query.context.QueryContext;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4MjA0MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382482041", "bodyText": "Notice:  considering inserting a point while querying.\nIt's better to remove the setCachedLast and change updateCachedLast method to a synchronized one. Then, extend updateCachedLast with a parameter: boolean highPriority, which is to determine whether update the value if the time is equal to the previous cached one.\nThen, in the normal inserting process, update the cache with high priority. Here, update the cache with low priority.\nThis could resolve the condition: there is an insert (10,11) when you get the last point (10,10) from disk.", "author": "qiaojialin", "createdAt": "2020-02-21T09:36:10Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjQ1Nw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646457", "bodyText": "Updated, thanks", "author": "wshao08", "createdAt": "2020-02-26T17:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4MjA0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "92c43917a94f540416413eb85ed95c55b606b628", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex 47d370c29..487b0ede2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -20,10 +20,8 @@\n package org.apache.iotdb.db.query.executor;\n \n import org.apache.iotdb.db.exception.StorageEngineException;\n-import org.apache.iotdb.db.exception.path.PathException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n-import org.apache.iotdb.db.metadata.MNode;\n import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n import org.apache.iotdb.db.query.aggregation.AggregateResult;\n import org.apache.iotdb.db.query.context.QueryContext;\n"}}, {"oid": "1f1f2c0279cbbd3931357944655d51d92e953cc3", "url": "https://github.com/apache/iotdb/commit/1f1f2c0279cbbd3931357944655d51d92e953cc3", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into new_series_reader", "committedDate": "2020-02-24T09:04:11Z", "type": "commit"}, {"oid": "3e175b5a2a31f5bcb600d9a4afc811d3b635f299", "url": "https://github.com/apache/iotdb/commit/3e175b5a2a31f5bcb600d9a4afc811d3b635f299", "message": "Merge branch 'master' into new_series_reader", "committedDate": "2020-02-24T09:18:40Z", "type": "commit"}, {"oid": "92c43917a94f540416413eb85ed95c55b606b628", "url": "https://github.com/apache/iotdb/commit/92c43917a94f540416413eb85ed95c55b606b628", "message": "Fix compilation error", "committedDate": "2020-02-24T09:24:05Z", "type": "commit"}, {"oid": "e10aa614335133d5f9dac0d893063fe237cafa3f", "url": "https://github.com/apache/iotdb/commit/e10aa614335133d5f9dac0d893063fe237cafa3f", "message": "Update new version of LAST query in java doc", "committedDate": "2020-02-24T16:38:22Z", "type": "commit"}, {"oid": "5736f861baa2cf0d4a02735450492f2fd2b4946a", "url": "https://github.com/apache/iotdb/commit/5736f861baa2cf0d4a02735450492f2fd2b4946a", "message": "Modify Last query syntax", "committedDate": "2020-02-25T16:17:42Z", "type": "commit"}, {"oid": "c561dc58b9c267c3aa8533f74a6bfa25a310d2ec", "url": "https://github.com/apache/iotdb/commit/c561dc58b9c267c3aa8533f74a6bfa25a310d2ec", "message": "Update last query behavior", "committedDate": "2020-02-26T17:14:03Z", "type": "commit"}, {"oid": "1e65ee361738ebcf5162108b57c42071290a76d6", "url": "https://github.com/apache/iotdb/commit/1e65ee361738ebcf5162108b57c42071290a76d6", "message": "Merge remote-tracking branch 'upstream/master' into new_series_reader", "committedDate": "2020-02-26T17:23:39Z", "type": "commit"}, {"oid": "c137074a1623d27db285673a9e39b161743cd9d0", "url": "https://github.com/apache/iotdb/commit/c137074a1623d27db285673a9e39b161743cd9d0", "message": "Fix test compile issue", "committedDate": "2020-02-27T00:50:50Z", "type": "commit"}, {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362", "url": "https://github.com/apache/iotdb/commit/f6fb25b2b7d96e1459911b09844e2418defb7362", "message": "Update unit tests for new syntax", "committedDate": "2020-02-27T01:12:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDU3OA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384930578", "bodyText": "move this to LeafMNode", "author": "qiaojialin", "createdAt": "2020-02-27T06:13:31Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzQyNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593426", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-28T09:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDU3OA=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\nindex dd41b3629..60008bfa0 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\n\n@@ -44,8 +43,6 @@ public abstract class MNode implements Serializable {\n    */\n   protected String fullPath;\n \n-  private TimeValuePair cachedLastValuePair = null;\n-\n   /**\n    * Constructor of MNode.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDc2MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384930761", "bodyText": "add javadoc for highPriorityUpdate", "author": "qiaojialin", "createdAt": "2020-02-27T06:14:11Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -113,4 +116,22 @@ public String getName() {\n   public void setName(String name) {\n     this.name = name;\n   }\n-}\n\\ No newline at end of file\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\nindex dd41b3629..2b2f1e8db 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\n\n@@ -117,21 +117,7 @@ public abstract class MNode implements Serializable {\n     this.name = name;\n   }\n \n-  public TimeValuePair getCachedLast() {\n-    return cachedLastValuePair;\n-  }\n+  public abstract TimeValuePair getCachedLast();\n \n-  public synchronized void updateCachedLast(\n-      TimeValuePair timeValuePair, boolean highPriorityUpdate) {\n-    if (timeValuePair == null) return;\n-    if (cachedLastValuePair == null) {\n-      cachedLastValuePair =\n-          new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n-    } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()\n-        || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n-            && highPriorityUpdate)) {\n-      cachedLastValuePair.setTimestamp(timeValuePair.getTimestamp());\n-      cachedLastValuePair.setValue(timeValuePair.getValue());\n-    }\n-  }\n+  public abstract void updateCachedLast(TimeValuePair timeValuePair, boolean highPriorityUpdate);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTI2Mg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931262", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private boolean hasLast;\n          \n          \n            \n              private boolean lastQuery;", "author": "qiaojialin", "createdAt": "2020-02-27T06:16:04Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "diffHunk": "@@ -30,6 +30,7 @@\n \n   private List<Path> suffixList;\n   private List<String> aggregations;\n+  private boolean hasLast;", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java b/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java\nindex 00d65ba03..38b8ef6ce 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java\n\n@@ -30,7 +30,7 @@ public final class SelectOperator extends Operator {\n \n   private List<Path> suffixList;\n   private List<String> aggregations;\n-  private boolean hasLast;\n+  private boolean lastQuery;\n \n   /**\n    * init with tokenIntType, default operatorType is <code>OperatorType.SELECT</code>.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTUxNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if (queryOperator.hasLast()) {\n          \n          \n            \n                } else if (queryOperator.isLastQuery()) {", "author": "qiaojialin", "createdAt": "2020-02-27T06:17:04Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java", "diffHunk": "@@ -236,6 +237,8 @@ private PhysicalPlan transformQuery(QueryOperator queryOperator)\n       queryPlan = new AggregationPlan();\n       ((AggregationPlan) queryPlan)\n           .setAggregations(queryOperator.getSelectOperator().getAggregations());\n+    } else if (queryOperator.hasLast()) {", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java b/server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java\nindex 8a19c49f9..9b92b2cf5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java\n\n@@ -237,7 +237,7 @@ public class PhysicalGenerator {\n       queryPlan = new AggregationPlan();\n       ((AggregationPlan) queryPlan)\n           .setAggregations(queryOperator.getSelectOperator().getAggregations());\n-    } else if (queryOperator.hasLast()) {\n+    } else if (queryOperator.isLastQuery()) {\n       queryPlan = new LastQueryPlan();\n     } else {\n       queryPlan = new RawDataQueryPlan();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTcxMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ListDataSet dataSet =\n          \n          \n            \n                        new ListDataSet(\n          \n          \n            \n                ListDataSet dataSet = new ListDataSet(", "author": "qiaojialin", "createdAt": "2020-02-27T06:17:55Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet =\n+            new ListDataSet(", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzU2MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593560", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-28T09:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTcxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex 27b584ff0..8dad8558f 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -22,6 +22,11 @@ package org.apache.iotdb.db.query.executor;\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n \n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDMwMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384934300", "bodyText": "\uff1f", "author": "qiaojialin", "createdAt": "2020-02-27T06:28:07Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -646,7 +644,7 @@ private TSExecuteStatementResp executeQueryStatement(\n       resp.setOperationType(plan.getOperatorType().toString());\n       // generate the queryId for the operation\n       long queryId = generateQueryId(true);\n-      // put it into the corresponding Set\n+      // put it into the corresponding SetO", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzYwNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593605", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-28T09:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDMwMA=="}], "type": "inlineReview", "revised_code": {"commit": "548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java\nindex 2d7e2e007..eae72ff17 100644\n--- a/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java\n\n@@ -644,7 +644,7 @@ public class TSServiceImpl implements TSIService.Iface, ServerContext {\n       resp.setOperationType(plan.getOperatorType().toString());\n       // generate the queryId for the operation\n       long queryId = generateQueryId(true);\n-      // put it into the corresponding SetO\n+      // put it into the corresponding Set\n \n       statementId2QueryId.computeIfAbsent(statementId, k -> new HashSet<>()).add(queryId);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDY4MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384934680", "bodyText": "I don't remember, doesn't the respColumns contain time column?", "author": "qiaojialin", "createdAt": "2020-02-27T06:29:38Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -916,6 +913,15 @@ else if (constMeasurementsLoc < plan.getConstMeasurements().size()\n     plan.setDataTypeConsistencyChecker(null);\n   }\n \n+  private void getLastQueryHeaders(", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "url": "https://github.com/apache/iotdb/commit/548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "message": "Optimize last query process and fix review issues", "committedDate": "2020-02-28T07:08:11Z", "type": "commit"}, {"oid": "c4039c28586158ceb5c2a23f7c9bc10dfee9e1b1", "url": "https://github.com/apache/iotdb/commit/c4039c28586158ceb5c2a23f7c9bc10dfee9e1b1", "message": "Modify last cache update strategy", "committedDate": "2020-02-28T09:28:17Z", "type": "commit"}, {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "url": "https://github.com/apache/iotdb/commit/2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "message": "Move last cache insert into StorageGroupProcessor", "committedDate": "2020-02-28T10:36:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTI1MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385661250", "bodyText": "add a blank line...", "author": "qiaojialin", "createdAt": "2020-02-28T12:08:40Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -235,7 +235,6 @@ public void insert(InsertPlan insertPlan)\n       throw new QueryProcessException(e);\n     }\n   }\n-", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjc2OQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032769", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTI1MA=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java b/server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java\nindex 7efeb3059..cf99279b9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java\n\n@@ -235,6 +235,7 @@ public class StorageEngine implements IService {\n       throw new QueryProcessException(e);\n     }\n   }\n+\n   /**\n    * insert a BatchInsertPlan to a storage group\n    *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTgyMg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385661822", "bodyText": "rename this to latestDeviceFlushedTimeInEachPartition distinguish with globalLatestFlushedTimeForEachDevice", "author": "qiaojialin", "createdAt": "2020-02-28T12:10:11Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -178,6 +180,12 @@\n    * file.\n    */\n   private Map<Long, Map<String, Long>> latestFlushedTimeForEachDevice = new HashMap<>();", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e15c19a473971cb135bf8209fb8bff55464d6bc", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..210afa666 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -168,22 +168,22 @@ public class StorageGroupProcessor {\n   /*\n    * time partition id -> map, which contains\n    * device -> global latest timestamp of each device latestTimeForEachDevice caches non-flushed\n-   * changes upon timestamps of each device, and is used to update latestFlushedTimeForEachDevice\n+   * changes upon timestamps of each device, and is used to update partitionLatestFlushedTimeForEachDevice\n    * when a flush is issued.\n    */\n   private Map<Long, Map<String, Long>> latestTimeForEachDevice = new HashMap<>();\n   /**\n    * time partition id -> map, which contains device -> largest timestamp of the latest memtable to\n-   * be submitted to asyncTryToFlush latestFlushedTimeForEachDevice determines whether a data point\n+   * be submitted to asyncTryToFlush partitionLatestFlushedTimeForEachDevice determines whether a data point\n    * should be put into a sequential file or an unsequential file. Data of some device with\n    * timestamp less than or equals to the device's latestFlushedTime should go into an unsequential\n    * file.\n    */\n-  private Map<Long, Map<String, Long>> latestFlushedTimeForEachDevice = new HashMap<>();\n+  private Map<Long, Map<String, Long>> partitionLatestFlushedTimeForEachDevice = new HashMap<>();\n   /**\n    * global mapping of device -> largest timestamp of the latest memtable to * be submitted to\n    * asyncTryToFlush, globalLatestFlushedTimeForEachDevice is utilized to maintain global\n-   * latestFlushedTime of devices and will be updated along with latestFlushedTimeForEachDevice\n+   * latestFlushedTime of devices and will be updated along with partitionLatestFlushedTimeForEachDevice\n    */\n   private Map<String, Long> globalLatestFlushedTimeForEachDevice = new HashMap<>();\n   private String storageGroupName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2Njc3MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385666771", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n          \n          \n            \n                  long globalLatestFlushTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "author": "qiaojialin", "createdAt": "2020-02-28T12:23:18Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..91482b223 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -511,38 +512,15 @@ public class StorageGroupProcessor {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n-      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n-              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n-\n-      updateInsertPlanLast(insertPlan, latestFlushedTime);\n-      if (latestFlushedTime < insertPlan.getTime())\n-        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n     } finally {\n       writeUnlock();\n     }\n   }\n \n-  public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)\n-          throws QueryProcessException {\n-    try {\n-      MNode node =\n-              MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(plan.getDeviceId());\n-      String[] measurementList = plan.getMeasurements();\n-      for (int i = 0; i < measurementList.length; i++) {\n-        // Update cached last value with high priority\n-        MNode measurementNode = node.getChild(measurementList[i]);\n-        ((LeafMNode)measurementNode).updateCachedLast(\n-                plan.composeTimeValuePair(i), true, latestFlushedTime);\n-      }\n-    } catch (MetadataException e) {\n-      throw new QueryProcessException(e);\n-    }\n-  }\n-\n   public Integer[] insertBatch(BatchInsertPlan batchInsertPlan) throws QueryProcessException {\n     writeLock();\n     try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385667354", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (latestFlushedTime < insertPlan.getTime())\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n          \n          \n            \n                  if (latestFlushedTime < insertPlan.getTime()) {\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n          \n          \n            \n                  }", "author": "qiaojialin", "createdAt": "2020-02-28T12:24:43Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MjUxMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385672511", "bodyText": "Then, move these three lines to insertToTsFileProcessor(), make it updated at the same time as the lastFlushTimeForEachDevice", "author": "qiaojialin", "createdAt": "2020-02-28T12:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjgxOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032819", "bodyText": "Yes moved, looks better now.", "author": "wshao08", "createdAt": "2020-02-29T14:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..91482b223 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -511,38 +512,15 @@ public class StorageGroupProcessor {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n-      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n-              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n-\n-      updateInsertPlanLast(insertPlan, latestFlushedTime);\n-      if (latestFlushedTime < insertPlan.getTime())\n-        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n     } finally {\n       writeUnlock();\n     }\n   }\n \n-  public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)\n-          throws QueryProcessException {\n-    try {\n-      MNode node =\n-              MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(plan.getDeviceId());\n-      String[] measurementList = plan.getMeasurements();\n-      for (int i = 0; i < measurementList.length; i++) {\n-        // Update cached last value with high priority\n-        MNode measurementNode = node.getChild(measurementList[i]);\n-        ((LeafMNode)measurementNode).updateCachedLast(\n-                plan.composeTimeValuePair(i), true, latestFlushedTime);\n-      }\n-    } catch (MetadataException e) {\n-      throw new QueryProcessException(e);\n-    }\n-  }\n-\n   public Integer[] insertBatch(BatchInsertPlan batchInsertPlan) throws QueryProcessException {\n     writeLock();\n     try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3Mjc4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385672785", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)\n          \n          \n            \n              public void tryToUpdateCache(InsertPlan plan, Long latestFlushedTime)", "author": "qiaojialin", "createdAt": "2020-02-28T12:38:00Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n     } finally {\n       writeUnlock();\n     }\n   }\n \n+  public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..91482b223 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -511,38 +512,15 @@ public class StorageGroupProcessor {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n-      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n-              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n-\n-      updateInsertPlanLast(insertPlan, latestFlushedTime);\n-      if (latestFlushedTime < insertPlan.getTime())\n-        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n     } finally {\n       writeUnlock();\n     }\n   }\n \n-  public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)\n-          throws QueryProcessException {\n-    try {\n-      MNode node =\n-              MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(plan.getDeviceId());\n-      String[] measurementList = plan.getMeasurements();\n-      for (int i = 0; i < measurementList.length; i++) {\n-        // Update cached last value with high priority\n-        MNode measurementNode = node.getChild(measurementList[i]);\n-        ((LeafMNode)measurementNode).updateCachedLast(\n-                plan.composeTimeValuePair(i), true, latestFlushedTime);\n-      }\n-    } catch (MetadataException e) {\n-      throw new QueryProcessException(e);\n-    }\n-  }\n-\n   public Integer[] insertBatch(BatchInsertPlan batchInsertPlan) throws QueryProcessException {\n     writeLock();\n     try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzM2MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673361", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n          \n          \n            \n                  long globalLatestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "author": "qiaojialin", "createdAt": "2020-02-28T12:39:20Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..91482b223 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -607,16 +585,11 @@ public class StorageGroupProcessor {\n         }\n       }\n \n-      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n-              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n-      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n-      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n-        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n \n       return results;\n     } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673528", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (latestFlushedTime < batchInsertPlan.getMaxTime())\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n          \n          \n            \n                  if (latestFlushedTime < batchInsertPlan.getMaxTime()) {\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n          \n          \n            \n                  }", "author": "qiaojialin", "createdAt": "2020-02-28T12:39:45Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzcyNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673726", "bodyText": "move this into insertBatchToTsFileProcessor()", "author": "qiaojialin", "createdAt": "2020-02-28T12:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY1OA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032658", "bodyText": "Moved", "author": "wshao08", "createdAt": "2020-02-29T14:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..91482b223 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -607,16 +585,11 @@ public class StorageGroupProcessor {\n         }\n       }\n \n-      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n-              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n-      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n-      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n-        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n \n       return results;\n     } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NDM1Nw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385674357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ((LeafMNode)measurementNode).updateCachedLast(\n          \n          \n            \n                    ((LeafMNode) measurementNode).updateCachedLast(\n          \n      \n    \n    \n  \n\nimport java-google-code.xml  code style and format the code", "author": "qiaojialin", "createdAt": "2020-02-28T12:41:33Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n \n       return results;\n     } finally {\n       writeUnlock();\n     }\n   }\n \n+  public void updateBatchInsertPlanLast(BatchInsertPlan plan, Long latestFlushedTime)\n+          throws QueryProcessException {\n+    try {\n+      MNode node =\n+              MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(plan.getDeviceId());\n+      String[] measurementList = plan.getMeasurements();\n+      for (int i = 0; i < measurementList.length; i++) {\n+        // Update cached last value with high priority\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        ((LeafMNode)measurementNode).updateCachedLast(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY0NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032645", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NDM1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..91482b223 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -607,16 +585,11 @@ public class StorageGroupProcessor {\n         }\n       }\n \n-      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n-              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n-      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n-      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n-        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n \n       return results;\n     } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTMzNw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675337", "bodyText": "update javadoc", "author": "qiaojialin", "createdAt": "2020-02-28T12:43:51Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1695,6 +1759,10 @@ private void updateLatestTimeMap(TsFileResource newTsFileResource) {\n             .computeIfAbsent(timePartitionId, id -> new HashMap<String, Long>())\n             .put(device, endTime);\n       }\n+      if (!globalLatestFlushedTimeForEachDevice.containsKey(device)", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\nindex e64ed2274..91482b223 100755\n--- a/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n\n@@ -1760,7 +1763,7 @@ public class StorageGroupProcessor {\n             .put(device, endTime);\n       }\n       if (!globalLatestFlushedTimeForEachDevice.containsKey(device)\n-              || globalLatestFlushedTimeForEachDevice.get(device) < endTime) {\n+          || globalLatestFlushedTimeForEachDevice.get(device) < endTime) {\n         globalLatestFlushedTimeForEachDevice.put(device, endTime);\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTU1Ng==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675556", "bodyText": "remove", "author": "qiaojialin", "createdAt": "2020-02-28T12:44:26Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -20,6 +20,8 @@\n \n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import org.apache.iotdb.tsfile.read.TimeValuePair;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY0MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032640", "bodyText": "Done", "author": "wshao08", "createdAt": "2020-02-29T14:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java\nindex 6c0673e06..a215d4576 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java\n\n@@ -21,7 +21,6 @@ package org.apache.iotdb.db.metadata.mnode;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n-import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n \n public class InternalMNode extends MNode {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTgxNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675814", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {\n          \n          \n            \n                  if (!insertionUpdate || latestFlushedTime <= timeValuePair.getTimestamp()) {", "author": "qiaojialin", "createdAt": "2020-02-28T12:44:58Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;\n+\n+    if (cachedLastValuePair == null){\n+      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n+      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYzOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032639", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\nindex e4bb3cd36..c6eea0304 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n\n@@ -82,17 +82,18 @@ public class LeafMNode extends MNode {\n     return cachedLastValuePair;\n   }\n \n-  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n-                                            Long latestFlushedTime) {\n+  public synchronized void updateCachedLast(\n+      TimeValuePair timeValuePair, boolean insertionUpdate, Long latestFlushedTime) {\n     if (timeValuePair == null || timeValuePair.getValue() == null) return;\n \n-    if (cachedLastValuePair == null){\n-      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n-      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {\n-        cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    if (cachedLastValuePair == null) {\n+      // If no cached last, (1) a last query (2) an unseq insertion or (3) a seq insertion will update cache.\n+      if (!insertionUpdate || latestFlushedTime <= timeValuePair.getTimestamp()) {\n+        cachedLastValuePair =\n+            new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n       }\n     } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()\n-            || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n+        || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n             && insertionUpdate)) {\n       cachedLastValuePair.setTimestamp(timeValuePair.getTimestamp());\n       cachedLastValuePair.setValue(timeValuePair.getValue());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NjA1NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385676055", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n          \n          \n            \n              public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean updateAtSameTime,\n          \n      \n    \n    \n  \n\nadd java doc", "author": "qiaojialin", "createdAt": "2020-02-28T12:45:33Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\nindex e4bb3cd36..c6eea0304 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n\n@@ -82,17 +82,18 @@ public class LeafMNode extends MNode {\n     return cachedLastValuePair;\n   }\n \n-  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n-                                            Long latestFlushedTime) {\n+  public synchronized void updateCachedLast(\n+      TimeValuePair timeValuePair, boolean insertionUpdate, Long latestFlushedTime) {\n     if (timeValuePair == null || timeValuePair.getValue() == null) return;\n \n-    if (cachedLastValuePair == null){\n-      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n-      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {\n-        cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    if (cachedLastValuePair == null) {\n+      // If no cached last, (1) a last query (2) an unseq insertion or (3) a seq insertion will update cache.\n+      if (!insertionUpdate || latestFlushedTime <= timeValuePair.getTimestamp()) {\n+        cachedLastValuePair =\n+            new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n       }\n     } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()\n-            || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n+        || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n             && insertionUpdate)) {\n       cachedLastValuePair.setTimestamp(timeValuePair.getTimestamp());\n       cachedLastValuePair.setValue(timeValuePair.getValue());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODkwOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385678908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n          \n          \n            \n                  // If no cached last, (1) a last query or (2) an unseq insertion at globalLastFlushTime or (3) a seq insertion will update cache.", "author": "qiaojialin", "createdAt": "2020-02-28T12:52:32Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;\n+\n+    if (cachedLastValuePair == null){\n+      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\nindex e4bb3cd36..c6eea0304 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n\n@@ -82,17 +82,18 @@ public class LeafMNode extends MNode {\n     return cachedLastValuePair;\n   }\n \n-  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n-                                            Long latestFlushedTime) {\n+  public synchronized void updateCachedLast(\n+      TimeValuePair timeValuePair, boolean insertionUpdate, Long latestFlushedTime) {\n     if (timeValuePair == null || timeValuePair.getValue() == null) return;\n \n-    if (cachedLastValuePair == null){\n-      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n-      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {\n-        cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    if (cachedLastValuePair == null) {\n+      // If no cached last, (1) a last query (2) an unseq insertion or (3) a seq insertion will update cache.\n+      if (!insertionUpdate || latestFlushedTime <= timeValuePair.getTimestamp()) {\n+        cachedLastValuePair =\n+            new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n       }\n     } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()\n-            || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n+        || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n             && insertionUpdate)) {\n       cachedLastValuePair.setTimestamp(timeValuePair.getTimestamp());\n       cachedLastValuePair.setValue(timeValuePair.getValue());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODk1NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385678955", "bodyText": "format", "author": "qiaojialin", "createdAt": "2020-02-28T12:52:38Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYyMw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032623", "bodyText": "Done", "author": "wshao08", "createdAt": "2020-02-29T14:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\nindex e4bb3cd36..c6eea0304 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java\n\n@@ -82,17 +82,18 @@ public class LeafMNode extends MNode {\n     return cachedLastValuePair;\n   }\n \n-  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n-                                            Long latestFlushedTime) {\n+  public synchronized void updateCachedLast(\n+      TimeValuePair timeValuePair, boolean insertionUpdate, Long latestFlushedTime) {\n     if (timeValuePair == null || timeValuePair.getValue() == null) return;\n \n-    if (cachedLastValuePair == null){\n-      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n-      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {\n-        cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    if (cachedLastValuePair == null) {\n+      // If no cached last, (1) a last query (2) an unseq insertion or (3) a seq insertion will update cache.\n+      if (!insertionUpdate || latestFlushedTime <= timeValuePair.getTimestamp()) {\n+        cachedLastValuePair =\n+            new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n       }\n     } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()\n-            || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n+        || (timeValuePair.getTimestamp() == cachedLastValuePair.getTimestamp()\n             && insertionUpdate)) {\n       cachedLastValuePair.setTimestamp(timeValuePair.getTimestamp());\n       cachedLastValuePair.setValue(timeValuePair.getValue());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTEwOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385679108", "bodyText": "remove this and its import", "author": "qiaojialin", "createdAt": "2020-02-28T12:52:58Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYyMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032620", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\nindex d34cbfb07..60008bfa0 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java\n\n@@ -44,8 +43,6 @@ public abstract class MNode implements Serializable {\n    */\n   protected String fullPath;\n \n-  private TimeValuePair cachedLastValuePair = null;\n-\n   /**\n    * Constructor of MNode.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTgzNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385679836", "bodyText": "I suggest use addSelectPath to replace this method and add a setLastQuery()", "author": "qiaojialin", "createdAt": "2020-02-28T12:54:52Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "diffHunk": "@@ -50,6 +52,11 @@ public void addClusterPath(Path suffixPath, String aggregation) {\n     aggregations.add(aggregation);\n   }\n \n+  public void addLastPath(Path suffixPath) {", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e15c19a473971cb135bf8209fb8bff55464d6bc", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java b/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java\nindex 38b8ef6ce..a0e566ee3 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java\n\n@@ -52,8 +52,7 @@ public final class SelectOperator extends Operator {\n     aggregations.add(aggregation);\n   }\n \n-  public void addLastPath(Path suffixPath) {\n-    suffixList.add(suffixPath);\n+  public void setLastQuery() {\n     lastQuery = true;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDc3Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385680773", "bodyText": "extract this to a Tools static method", "author": "qiaojialin", "createdAt": "2020-02-28T12:57:02Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjU5Mg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032592", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDc3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex b04ad5efb..30940f5df 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -39,6 +39,7 @@ import org.apache.iotdb.db.query.control.FileReaderManager;\n import org.apache.iotdb.db.query.control.QueryResourceManager;\n import org.apache.iotdb.db.query.dataset.ListDataSet;\n import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.FileLoaderUtils;\n import org.apache.iotdb.db.utils.QueryUtils;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDk3MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385680971", "bodyText": "no need to loop, get the last one directly", "author": "qiaojialin", "createdAt": "2020-02-28T12:57:35Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYwMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032601", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDk3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex b04ad5efb..30940f5df 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -39,6 +39,7 @@ import org.apache.iotdb.db.query.control.FileReaderManager;\n import org.apache.iotdb.db.query.control.QueryResourceManager;\n import org.apache.iotdb.db.query.dataset.ListDataSet;\n import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.FileLoaderUtils;\n import org.apache.iotdb.db.utils.QueryUtils;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTc1MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385681751", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                TimeValuePair lastPair = new TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));\n          \n          \n            \n                return lastPair;\n          \n          \n            \n                return TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));", "author": "qiaojialin", "createdAt": "2020-02-28T12:59:26Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+            context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader = FileReaderManager.getInstance()\n+                .get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }\n+    }\n+    List<ReadOnlyMemChunk> memChunks = resource.getReadOnlyMemChunk();\n+    if (memChunks != null) {\n+      for (ReadOnlyMemChunk readOnlyMemChunk : memChunks) {\n+        if (!memChunks.isEmpty()) {\n+          currentChunkMetaDataList.add(readOnlyMemChunk.getChunkMetaData());\n+        }\n+      }\n+    }\n+    return currentChunkMetaDataList;\n+  }\n+\n+  private TimeValuePair constructLastPair(long timestamp, Object value, TSDataType dataType) {\n+    TimeValuePair lastPair = new TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));\n+    return lastPair;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYwOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032609", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex b04ad5efb..30940f5df 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -39,6 +39,7 @@ import org.apache.iotdb.db.query.control.FileReaderManager;\n import org.apache.iotdb.db.query.control.QueryResourceManager;\n import org.apache.iotdb.db.query.dataset.ListDataSet;\n import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.FileLoaderUtils;\n import org.apache.iotdb.db.utils.QueryUtils;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MjQwNw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385682407", "bodyText": "when I saw this line, I think maybe move the lastFlushTime out of the updateCachedLast mehod and check in the insertion is better", "author": "qiaojialin", "createdAt": "2020-02-28T13:01:05Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex b04ad5efb..30940f5df 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -39,6 +39,7 @@ import org.apache.iotdb.db.query.control.FileReaderManager;\n import org.apache.iotdb.db.query.control.QueryResourceManager;\n import org.apache.iotdb.db.query.dataset.ListDataSet;\n import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.FileLoaderUtils;\n import org.apache.iotdb.db.utils.QueryUtils;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MzcxNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385683715", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n          \n          \n            \n                TimeValuePair resultPair;", "author": "qiaojialin", "createdAt": "2020-02-28T13:04:18Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\nindex b04ad5efb..30940f5df 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java\n\n@@ -39,6 +39,7 @@ import org.apache.iotdb.db.query.control.FileReaderManager;\n import org.apache.iotdb.db.query.control.QueryResourceManager;\n import org.apache.iotdb.db.query.dataset.ListDataSet;\n import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.FileLoaderUtils;\n import org.apache.iotdb.db.utils.QueryUtils;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n"}}, {"oid": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "url": "https://github.com/apache/iotdb/commit/39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "message": "Fix review issues and make code more readable", "committedDate": "2020-02-29T14:37:36Z", "type": "commit"}, {"oid": "6e15c19a473971cb135bf8209fb8bff55464d6bc", "url": "https://github.com/apache/iotdb/commit/6e15c19a473971cb135bf8209fb8bff55464d6bc", "message": "Add more java docs and rename some variables", "committedDate": "2020-03-02T02:14:13Z", "type": "commit"}, {"oid": "f136bcce40237672236cca1f1de738cfb450a9a8", "url": "https://github.com/apache/iotdb/commit/f136bcce40237672236cca1f1de738cfb450a9a8", "message": "Merge remote-tracking branch 'upstream/master' into new_series_reader", "committedDate": "2020-03-02T02:15:15Z", "type": "commit"}, {"oid": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e", "url": "https://github.com/apache/iotdb/commit/8aa9e2b608c9f6d88a3547a89f19e8229dd0486e", "message": "add sync property file to pass sync test case", "committedDate": "2020-03-02T09:30:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2MDcwNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386360706", "bodyText": "Remove the if judgement, it will cause the file closed null pointer exception.\nlike:\nfor (ChunkMetaData data : currentChunkMetaDataList) {\nTsFileSequenceReader tsFileSequenceReader =\nFileReaderManager.getInstance().get(resource, resource.isClosed());\ndata.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n}\nit's ok to do so. because tsFileSequenceReader has been cached.", "author": "JackieTien97", "createdAt": "2020-03-02T12:21:14Z", "path": "server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java", "diffHunk": "@@ -64,4 +72,40 @@ public static void updateTsFileResource(TsFileMetaData metaData, TsFileSequenceR\n       }\n     }\n   }\n+\n+  public static List<ChunkMetaData> loadChunkMetadataFromTsFileResource(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+        context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader =\n+            FileReaderManager.getInstance().get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }", "originalCommit": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM5NDgxNw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386394817", "bodyText": "removed", "author": "wshao08", "createdAt": "2020-03-02T13:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2MDcwNg=="}], "type": "inlineReview", "revised_code": {"commit": "bebfc0e4e1758b16d15a75b84343feb03e5aa4ab", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java b/server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java\nindex c3e75d12d..671e5d402 100644\n--- a/server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java\n+++ b/server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java\n\n@@ -92,11 +92,9 @@ public class FileLoaderUtils {\n     }\n \n     for (ChunkMetaData data : currentChunkMetaDataList) {\n-      if (data.getChunkLoader() == null) {\n-        TsFileSequenceReader tsFileSequenceReader =\n-            FileReaderManager.getInstance().get(resource, resource.isClosed());\n-        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n-      }\n+      TsFileSequenceReader tsFileSequenceReader =\n+          FileReaderManager.getInstance().get(resource, resource.isClosed());\n+      data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n     }\n     List<ReadOnlyMemChunk> memChunks = resource.getReadOnlyMemChunk();\n     if (memChunks != null) {\n"}}, {"oid": "bebfc0e4e1758b16d15a75b84343feb03e5aa4ab", "url": "https://github.com/apache/iotdb/commit/bebfc0e4e1758b16d15a75b84343feb03e5aa4ab", "message": "Fix unit test bugs", "committedDate": "2020-03-02T13:04:10Z", "type": "commit"}, {"oid": "c26b2b5c6b1fe1e39d6d0afb59840554ac871301", "url": "https://github.com/apache/iotdb/commit/c26b2b5c6b1fe1e39d6d0afb59840554ac871301", "message": "Add Integration test for last query", "committedDate": "2020-03-02T14:34:17Z", "type": "commit"}, {"oid": "6d009ad198cc8e9c094e071d160275c290c72d6a", "url": "https://github.com/apache/iotdb/commit/6d009ad198cc8e9c094e071d160275c290c72d6a", "message": "Add missing licence", "committedDate": "2020-03-02T15:05:20Z", "type": "commit"}]}