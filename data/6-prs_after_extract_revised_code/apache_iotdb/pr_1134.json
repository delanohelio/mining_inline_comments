{"pr_number": 1134, "pr_title": "[IOTDB-631] Using new TsFile MetadataIndex to optimize query and cache", "pr_createdAt": "2020-04-30T09:11:50Z", "pr_url": "https://github.com/apache/iotdb/pull/1134", "timeline": [{"oid": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "url": "https://github.com/apache/iotdb/commit/4339c68bbbfb0886d3661a3308b90feb83f681b1", "message": "[IOTDB-631] Using new TsFile MetadataIndex to optimize query and cache", "committedDate": "2020-04-30T09:10:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTYyMA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418935620", "bodyText": "Hi, the key.measurement should be also in the allSensors set. Therefore, we only need to query the allSensor, put them into cache. Then return the queried sensor's TimeseriesMetadata.", "author": "qiaojialin", "createdAt": "2020-05-02T09:22:18Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/TimeSeriesMetadataCache.java", "diffHunk": "@@ -125,9 +130,20 @@ public TimeseriesMetadata get(TimeSeriesMetadataCacheKey key, Set<String> allSen\n         return null;\n       }\n       TsFileSequenceReader reader = FileReaderManager.getInstance().get(key.filePath, true);\n-      TimeseriesMetadata timeseriesMetadata = reader.readTimeseriesMetadata(new Path(key.device, key.measurement));\n-      lruCache.put(key, timeseriesMetadata);\n-      return timeseriesMetadata;\n+      TimeseriesMetadata resultTimeseriesMetadata = reader\n+          .readTimeseriesMetadata(new Path(key.device, key.measurement));\n+      lruCache.put(key, resultTimeseriesMetadata);\n+\n+      List<TimeseriesMetadata> timeSeriesMetadataList = reader\n+          .readTimeseriesMetadata(key.device, allSensors);\n+      if (!allSensors.isEmpty()) {\n+        // put TimeSeriesMetadata of all sensors used in this query into cache\n+        timeSeriesMetadataList.forEach(timeseriesMetadata -> {\n+          lruCache.put(new TimeSeriesMetadataCacheKey(key.filePath, key.device,\n+              timeseriesMetadata.getMeasurementId()), timeseriesMetadata);\n+        });\n+      }", "originalCommit": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk2NTIzNA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418965234", "bodyText": "Hi, when I tried to only query the allSensor, I found some tests failed... which means that the allSensors set doesn't contain key.measurement... Is it a bug in query module? Or it was designed as this?", "author": "samperson1997", "createdAt": "2020-05-02T14:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNzczOA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420517738", "bodyText": "it's a bug..", "author": "qiaojialin", "createdAt": "2020-05-06T02:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "c1eca42db3e3e23b3249abfb7c24292a3c9fe3c2", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/engine/cache/TimeSeriesMetadataCache.java b/server/src/main/java/org/apache/iotdb/db/engine/cache/TimeSeriesMetadataCache.java\nindex 1fb7c8a8db..d4d50c16e8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/engine/cache/TimeSeriesMetadataCache.java\n+++ b/server/src/main/java/org/apache/iotdb/db/engine/cache/TimeSeriesMetadataCache.java\n\n@@ -130,20 +131,18 @@ public class TimeSeriesMetadataCache {\n         return null;\n       }\n       TsFileSequenceReader reader = FileReaderManager.getInstance().get(key.filePath, true);\n-      TimeseriesMetadata resultTimeseriesMetadata = reader\n-          .readTimeseriesMetadata(new Path(key.device, key.measurement));\n-      lruCache.put(key, resultTimeseriesMetadata);\n-\n+      Set<String> allSensorsIncludingKey = new HashSet<>(allSensors);\n+      allSensorsIncludingKey.add(key.measurement);\n       List<TimeseriesMetadata> timeSeriesMetadataList = reader\n-          .readTimeseriesMetadata(key.device, allSensors);\n-      if (!allSensors.isEmpty()) {\n+          .readTimeseriesMetadata(key.device, allSensorsIncludingKey);\n+      if (!allSensorsIncludingKey.isEmpty()) {\n         // put TimeSeriesMetadata of all sensors used in this query into cache\n         timeSeriesMetadataList.forEach(timeseriesMetadata -> {\n           lruCache.put(new TimeSeriesMetadataCacheKey(key.filePath, key.device,\n               timeseriesMetadata.getMeasurementId()), timeseriesMetadata);\n         });\n       }\n-      return resultTimeseriesMetadata;\n+      return lruCache.get(key);\n     } catch (IOException e) {\n       logger.error(\"something wrong happened while reading {}\", key.filePath);\n       throw e;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTk1OA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418935958", "bodyText": "check if the size of measurements reaches a threshold, just traversing from start to end is quicker, no need to binary search for each", "author": "qiaojialin", "createdAt": "2020-05-02T09:25:51Z", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -314,28 +311,76 @@ public TsFileMetadata readFileMetadata() throws IOException {\n   public TimeseriesMetadata readTimeseriesMetadata(Path path) throws IOException {\n     readFileMetadata();\n     MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n-    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetaDataAndEndOffset(\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n         deviceMetadataIndexNode, path.getDevice(), MetadataIndexNodeType.INTERNAL_DEVICE);\n     ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (!metadataIndexPair.left.getChildNodeType()\n         .equals(MetadataIndexNodeType.LEAF_MEASUREMENT)) {\n       MetadataIndexNode metadataIndexNode = MetadataIndexNode.deserializeFrom(buffer);\n-      metadataIndexPair = getMetaDataAndEndOffset(metadataIndexNode,\n+      metadataIndexPair = getMetadataAndEndOffset(metadataIndexNode,\n           path.getMeasurement(), MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n     }\n     List<TimeseriesMetadata> timeseriesMetadataList = new ArrayList<>();\n     buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (buffer.hasRemaining()) {\n       timeseriesMetadataList.add(TimeseriesMetadata.deserializeFrom(buffer));\n     }\n-    String[] measurementNameList = timeseriesMetadataList.stream()\n-        .map(TimeseriesMetadata::getMeasurementId).collect(Collectors.toList())\n-        .toArray(new String[timeseriesMetadataList.size()]);\n-\n     // return null if path does not exist in the TsFile\n-    int searchResult;\n-    return (searchResult = Arrays.binarySearch(measurementNameList, path.getMeasurement())) >= 0\n-        ? timeseriesMetadataList.get(searchResult) : null;\n+    int searchResult = binarySearchInTimeseriesMetadataList(timeseriesMetadataList,\n+        path.getMeasurement());\n+    return searchResult >= 0 ? timeseriesMetadataList.get(searchResult) : null;\n+  }\n+\n+  public List<TimeseriesMetadata> readTimeseriesMetadata(String device, Set<String> measurements)\n+      throws IOException {\n+    readFileMetadata();\n+    MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n+        deviceMetadataIndexNode, device, MetadataIndexNodeType.INTERNAL_DEVICE);\n+    List<TimeseriesMetadata> resultTimeseriesMetadataList = new ArrayList<>();\n+    for (String measurement : measurements) {\n+      ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n+      Pair<MetadataIndexEntry, Long> measurementMetadataIndexPair = metadataIndexPair;\n+      List<TimeseriesMetadata> timeseriesMetadataList = new ArrayList<>();\n+      while (!measurementMetadataIndexPair.left.getChildNodeType()\n+          .equals(MetadataIndexNodeType.LEAF_MEASUREMENT)) {\n+        MetadataIndexNode metadataIndexNode = MetadataIndexNode.deserializeFrom(buffer);\n+        measurementMetadataIndexPair = getMetadataAndEndOffset(metadataIndexNode,\n+            measurement, MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n+      }\n+      buffer = readData(measurementMetadataIndexPair.left.getOffset(),\n+          measurementMetadataIndexPair.right);\n+      while (buffer.hasRemaining()) {\n+        timeseriesMetadataList.add(TimeseriesMetadata.deserializeFrom(buffer));\n+      }\n+      int searchResult = binarySearchInTimeseriesMetadataList(timeseriesMetadataList,", "originalCommit": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1MDYxOA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418950618", "bodyText": "How to define the threshold? So should we use 2 different methods for 2 situation (measurements number > threshold and < threshold)?", "author": "samperson1997", "createdAt": "2020-05-02T12:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyMDU5OQ==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420520599", "bodyText": "yes\uff0c just calculate the search number is ok", "author": "qiaojialin", "createdAt": "2020-05-06T03:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTk1OA=="}], "type": "inlineReview", "revised_code": {"commit": "c1eca42db3e3e23b3249abfb7c24292a3c9fe3c2", "chunk": "diff --git a/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java b/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java\nindex b11a524bd1..9f05ec7685 100644\n--- a/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java\n+++ b/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java\n\n@@ -338,6 +338,11 @@ public class TsFileSequenceReader implements AutoCloseable {\n     Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n         deviceMetadataIndexNode, device, MetadataIndexNodeType.INTERNAL_DEVICE);\n     List<TimeseriesMetadata> resultTimeseriesMetadataList = new ArrayList<>();\n+    if (measurements.size() > config.getMaxDegreeOfIndexNode()) {\n+      traverseAndReadTimeseriesMetadataInOneDevice(resultTimeseriesMetadataList, metadataIndexPair,\n+          measurements);\n+      return resultTimeseriesMetadataList;\n+    }\n     for (String measurement : measurements) {\n       ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n       Pair<MetadataIndexEntry, Long> measurementMetadataIndexPair = metadataIndexPair;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNjE5Ng==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418936196", "bodyText": "I'm not clear about the MetadataIndexNodeType.INTERNAL_DEVICE, how can I see this parameter, the queried node type? Shouldn't this be Leaf_Device?", "author": "qiaojialin", "createdAt": "2020-05-02T09:28:33Z", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -314,28 +311,76 @@ public TsFileMetadata readFileMetadata() throws IOException {\n   public TimeseriesMetadata readTimeseriesMetadata(Path path) throws IOException {\n     readFileMetadata();\n     MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n-    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetaDataAndEndOffset(\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n         deviceMetadataIndexNode, path.getDevice(), MetadataIndexNodeType.INTERNAL_DEVICE);\n     ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (!metadataIndexPair.left.getChildNodeType()\n         .equals(MetadataIndexNodeType.LEAF_MEASUREMENT)) {\n       MetadataIndexNode metadataIndexNode = MetadataIndexNode.deserializeFrom(buffer);\n-      metadataIndexPair = getMetaDataAndEndOffset(metadataIndexNode,\n+      metadataIndexPair = getMetadataAndEndOffset(metadataIndexNode,\n           path.getMeasurement(), MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n     }\n     List<TimeseriesMetadata> timeseriesMetadataList = new ArrayList<>();\n     buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (buffer.hasRemaining()) {\n       timeseriesMetadataList.add(TimeseriesMetadata.deserializeFrom(buffer));\n     }\n-    String[] measurementNameList = timeseriesMetadataList.stream()\n-        .map(TimeseriesMetadata::getMeasurementId).collect(Collectors.toList())\n-        .toArray(new String[timeseriesMetadataList.size()]);\n-\n     // return null if path does not exist in the TsFile\n-    int searchResult;\n-    return (searchResult = Arrays.binarySearch(measurementNameList, path.getMeasurement())) >= 0\n-        ? timeseriesMetadataList.get(searchResult) : null;\n+    int searchResult = binarySearchInTimeseriesMetadataList(timeseriesMetadataList,\n+        path.getMeasurement());\n+    return searchResult >= 0 ? timeseriesMetadataList.get(searchResult) : null;\n+  }\n+\n+  public List<TimeseriesMetadata> readTimeseriesMetadata(String device, Set<String> measurements)\n+      throws IOException {\n+    readFileMetadata();\n+    MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n+        deviceMetadataIndexNode, device, MetadataIndexNodeType.INTERNAL_DEVICE);", "originalCommit": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1ODk2Nw==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418958967", "bodyText": "I could explain why I use INTERAL_DEVICE / INTERNAL_MEASUREMENT in method getMetadataAndEndOffset:\nThe statement which ends the recursion is: if (!childIndexEntry.left.getChildNodeType().equals(type)). For example, when searching for a device node, we look for LEAF_DEVICE, so we return when it is not INTERNAL_DEVICE. Likewise, when searching for a measurement node, we look for LEAF_MEASUREMENT, so we return when it is not INTERNAL_MEASUREMENT.\nWhy not judging by == LEAF_DEVICE or == LEAF_MEASUREMENT? Because this works for the situation when we are searching for device, but the index tree does not have the device level and only has the measurement level. Or we will never meet the LEAF_DEVICE.", "author": "samperson1997", "createdAt": "2020-05-02T13:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNjE5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c1eca42db3e3e23b3249abfb7c24292a3c9fe3c2", "chunk": "diff --git a/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java b/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java\nindex b11a524bd1..9f05ec7685 100644\n--- a/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java\n+++ b/tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java\n\n@@ -338,6 +338,11 @@ public class TsFileSequenceReader implements AutoCloseable {\n     Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n         deviceMetadataIndexNode, device, MetadataIndexNodeType.INTERNAL_DEVICE);\n     List<TimeseriesMetadata> resultTimeseriesMetadataList = new ArrayList<>();\n+    if (measurements.size() > config.getMaxDegreeOfIndexNode()) {\n+      traverseAndReadTimeseriesMetadataInOneDevice(resultTimeseriesMetadataList, metadataIndexPair,\n+          measurements);\n+      return resultTimeseriesMetadataList;\n+    }\n     for (String measurement : measurements) {\n       ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n       Pair<MetadataIndexEntry, Long> measurementMetadataIndexPair = metadataIndexPair;\n"}}, {"oid": "c1eca42db3e3e23b3249abfb7c24292a3c9fe3c2", "url": "https://github.com/apache/iotdb/commit/c1eca42db3e3e23b3249abfb7c24292a3c9fe3c2", "message": "Fix code review", "committedDate": "2020-05-02T14:46:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODYyMA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420548620", "bodyText": "A very small misspelling.\nFor query clause \"select s1, s2 form root -> For query clause \"select s1, s2 from root", "author": "HTHou", "createdAt": "2020-05-06T05:11:54Z", "path": "server/src/main/java/org/apache/iotdb/db/query/timegenerator/ServerTimeGenerator.java", "diffHunk": "@@ -33,8 +36,6 @@\n import org.apache.iotdb.tsfile.read.query.timegenerator.TimeGenerator;\n import org.apache.iotdb.tsfile.read.reader.IBatchReader;\n \n-import java.io.IOException;\n-\n /**\n  * A timestamp generator for query with filter. e.g. For query clause \"select s1, s2 form root where\n  * s3 < 0 and time > 100\", this class can iterate back to every timestamp of the query.", "originalCommit": "de83282bcf452589707c1c59c948414739dd93a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MTY4NA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420551684", "bodyText": "Thanks!  Good catch : )", "author": "samperson1997", "createdAt": "2020-05-06T05:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "05c1367777675b67738fb14f8eea0224b3c0099d", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/timegenerator/ServerTimeGenerator.java b/server/src/main/java/org/apache/iotdb/db/query/timegenerator/ServerTimeGenerator.java\nindex 54031f2326..7b857cd6f4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/timegenerator/ServerTimeGenerator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/timegenerator/ServerTimeGenerator.java\n\n@@ -37,7 +35,7 @@ import org.apache.iotdb.tsfile.read.query.timegenerator.TimeGenerator;\n import org.apache.iotdb.tsfile.read.reader.IBatchReader;\n \n /**\n- * A timestamp generator for query with filter. e.g. For query clause \"select s1, s2 form root where\n+ * A timestamp generator for query with filter. e.g. For query clause \"select s1, s2 from root where\n  * s3 < 0 and time > 100\", this class can iterate back to every timestamp of the query.\n  */\n public class ServerTimeGenerator extends TimeGenerator {\n"}}, {"oid": "05c1367777675b67738fb14f8eea0224b3c0099d", "url": "https://github.com/apache/iotdb/commit/05c1367777675b67738fb14f8eea0224b3c0099d", "message": "Fix PhysicalGenerator", "committedDate": "2020-05-06T08:09:45Z", "type": "commit"}, {"oid": "05c1367777675b67738fb14f8eea0224b3c0099d", "url": "https://github.com/apache/iotdb/commit/05c1367777675b67738fb14f8eea0224b3c0099d", "message": "Fix PhysicalGenerator", "committedDate": "2020-05-06T08:09:45Z", "type": "forcePushed"}, {"oid": "5f319cf38309fdd07b3bace77fb5b38ccc7cde4b", "url": "https://github.com/apache/iotdb/commit/5f319cf38309fdd07b3bace77fb5b38ccc7cde4b", "message": "Fix code review", "committedDate": "2020-05-06T08:13:12Z", "type": "commit"}, {"oid": "6384244de4c572c5043720d1a89fc2993eae2b47", "url": "https://github.com/apache/iotdb/commit/6384244de4c572c5043720d1a89fc2993eae2b47", "message": "Add filterPath in deviceToMeasurements", "committedDate": "2020-05-06T08:25:16Z", "type": "commit"}, {"oid": "549a645627c62c625f3de40ff444b921a2e972d0", "url": "https://github.com/apache/iotdb/commit/549a645627c62c625f3de40ff444b921a2e972d0", "message": "Fix tests", "committedDate": "2020-05-06T09:23:02Z", "type": "commit"}]}