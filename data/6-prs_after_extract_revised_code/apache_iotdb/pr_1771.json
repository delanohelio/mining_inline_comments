{"pr_number": 1771, "pr_title": "[IOTDB-884] batch create timeSeriesPlan", "pr_createdAt": "2020-09-27T05:41:15Z", "pr_url": "https://github.com/apache/iotdb/pull/1771", "timeline": [{"oid": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "url": "https://github.com/apache/iotdb/commit/3f0cd65f499698adf341746b1aa68edb4a6e952b", "message": "[IOTDB-884] batch create timeSeriesPlan", "committedDate": "2020-09-27T04:27:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjAwMQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496346001", "bodyText": "alias maybe null, please change the logic here.", "author": "Alima777", "createdAt": "2020-09-29T02:45:28Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * create multiple timeSeries, could be split to several sub Plans to execute in different DataGroup\n+ */\n+public class CreateMultiTimeSeriesPlan extends PhysicalPlan {\n+  private List<PartialPath> paths;\n+  private List<TSDataType> dataTypes;\n+  private List<TSEncoding> encodings;\n+  private List<CompressionType> compressors;\n+  private List<String> alias;\n+  private List<Map<String, String>> props = null;\n+  private List<Map<String, String>> tags = null;\n+  private List<Map<String, String>> attributes = null;\n+\n+  /*\n+   ** record the result of creation of time series\n+   */\n+  private Map<Integer, Boolean> results = new HashMap<>();\n+  private List<Integer> indexes;\n+\n+  public CreateMultiTimeSeriesPlan() {\n+    super(false, Operator.OperatorType.CREATE_MULTI_TIMESERIES);\n+  }\n+\n+  @Override\n+  public List<PartialPath> getPaths() {\n+    return paths;\n+  }\n+\n+  public void setPaths(List<PartialPath> paths) {\n+    this.paths = paths;\n+  }\n+\n+  public List<TSDataType> getDataTypes() {\n+    return dataTypes;\n+  }\n+\n+  public void setDataTypes(List<TSDataType> dataTypes) {\n+    this.dataTypes = dataTypes;\n+  }\n+\n+  public List<TSEncoding> getEncodings() {\n+    return encodings;\n+  }\n+\n+  public void setEncodings(List<TSEncoding> encodings) {\n+    this.encodings = encodings;\n+  }\n+\n+  public List<CompressionType> getCompressors() {\n+    return compressors;\n+  }\n+\n+  public void setCompressors(List<CompressionType> compressors) {\n+    this.compressors = compressors;\n+  }\n+\n+  public List<String> getAlias() {\n+    return alias;\n+  }\n+\n+  public void setAlias(List<String> alias) {\n+    this.alias = alias;\n+  }\n+\n+  public List<Map<String, String>> getProps() {\n+    return props;\n+  }\n+\n+  public void setProps(List<Map<String, String>> props) {\n+    this.props = props;\n+  }\n+\n+  public List<Map<String, String>> getTags() {\n+    return tags;\n+  }\n+\n+  public void setTags(List<Map<String, String>> tags) {\n+    this.tags = tags;\n+  }\n+\n+  public List<Map<String, String>> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public void setAttributes(List<Map<String, String>> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  public List<Integer> getIndexes() {\n+    return indexes;\n+  }\n+\n+  public void setIndexes(List<Integer> indexes) {\n+    this.indexes = indexes;\n+  }\n+\n+  public Map<Integer, Boolean> getResults() {\n+    return results;\n+  }\n+\n+  public void setResults(Map<Integer, Boolean> results) {\n+    this.results = results;\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream stream) throws IOException {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    stream.write(type);\n+    stream.writeInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(stream, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      stream.write(dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      stream.write(encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      stream.write(compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {", "originalCommit": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM1MjA5Mg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496352092", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-29T03:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "279942253e08a2636c25e4f523542fbf805ac069", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\nindex f0fbbd2c07..fca42795cd 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\n\n@@ -30,6 +30,7 @@ import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n import java.io.DataOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjIxMg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496346212", "bodyText": "Same.", "author": "Alima777", "createdAt": "2020-09-29T02:46:16Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * create multiple timeSeries, could be split to several sub Plans to execute in different DataGroup\n+ */\n+public class CreateMultiTimeSeriesPlan extends PhysicalPlan {\n+  private List<PartialPath> paths;\n+  private List<TSDataType> dataTypes;\n+  private List<TSEncoding> encodings;\n+  private List<CompressionType> compressors;\n+  private List<String> alias;\n+  private List<Map<String, String>> props = null;\n+  private List<Map<String, String>> tags = null;\n+  private List<Map<String, String>> attributes = null;\n+\n+  /*\n+   ** record the result of creation of time series\n+   */\n+  private Map<Integer, Boolean> results = new HashMap<>();\n+  private List<Integer> indexes;\n+\n+  public CreateMultiTimeSeriesPlan() {\n+    super(false, Operator.OperatorType.CREATE_MULTI_TIMESERIES);\n+  }\n+\n+  @Override\n+  public List<PartialPath> getPaths() {\n+    return paths;\n+  }\n+\n+  public void setPaths(List<PartialPath> paths) {\n+    this.paths = paths;\n+  }\n+\n+  public List<TSDataType> getDataTypes() {\n+    return dataTypes;\n+  }\n+\n+  public void setDataTypes(List<TSDataType> dataTypes) {\n+    this.dataTypes = dataTypes;\n+  }\n+\n+  public List<TSEncoding> getEncodings() {\n+    return encodings;\n+  }\n+\n+  public void setEncodings(List<TSEncoding> encodings) {\n+    this.encodings = encodings;\n+  }\n+\n+  public List<CompressionType> getCompressors() {\n+    return compressors;\n+  }\n+\n+  public void setCompressors(List<CompressionType> compressors) {\n+    this.compressors = compressors;\n+  }\n+\n+  public List<String> getAlias() {\n+    return alias;\n+  }\n+\n+  public void setAlias(List<String> alias) {\n+    this.alias = alias;\n+  }\n+\n+  public List<Map<String, String>> getProps() {\n+    return props;\n+  }\n+\n+  public void setProps(List<Map<String, String>> props) {\n+    this.props = props;\n+  }\n+\n+  public List<Map<String, String>> getTags() {\n+    return tags;\n+  }\n+\n+  public void setTags(List<Map<String, String>> tags) {\n+    this.tags = tags;\n+  }\n+\n+  public List<Map<String, String>> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public void setAttributes(List<Map<String, String>> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  public List<Integer> getIndexes() {\n+    return indexes;\n+  }\n+\n+  public void setIndexes(List<Integer> indexes) {\n+    this.indexes = indexes;\n+  }\n+\n+  public Map<Integer, Boolean> getResults() {\n+    return results;\n+  }\n+\n+  public void setResults(Map<Integer, Boolean> results) {\n+    this.results = results;\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream stream) throws IOException {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    stream.write(type);\n+    stream.writeInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(stream, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      stream.write(dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      stream.write(encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      stream.write(compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(stream, name);\n+    }\n+\n+    if (props != null) {\n+      stream.write(1);\n+      for (Map<String, String> prop : props) {\n+        ReadWriteIOUtils.write(prop, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (tags != null) {\n+      stream.write(1);\n+      for (Map<String, String> tag : tags) {\n+        ReadWriteIOUtils.write(tag, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (attributes != null) {\n+      stream.write(1);\n+      for (Map<String, String> attribute : attributes) {\n+        ReadWriteIOUtils.write(attribute, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+  }\n+\n+  @Override\n+  public void serialize(ByteBuffer buffer) {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    buffer.put((byte) type);\n+    buffer.putInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(buffer, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      buffer.put((byte) dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      buffer.put((byte) encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      buffer.put((byte) compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(buffer, name);\n+    }\n+\n+    if (props != null) {\n+      buffer.put((byte) 1);\n+      for (Map<String, String> prop : props) {\n+        ReadWriteIOUtils.write(prop, buffer);\n+      }\n+    } else {\n+      buffer.put((byte) 0);\n+    }\n+\n+    if (tags != null) {\n+      buffer.put((byte) 1);\n+      for (Map<String, String> tag : tags) {\n+        ReadWriteIOUtils.write(tag, buffer);\n+      }\n+    } else {\n+      buffer.put((byte) 0);\n+    }\n+\n+    if (attributes != null) {\n+      buffer.put((byte) 1);\n+      for (Map<String, String> attribute : attributes) {\n+        ReadWriteIOUtils.write(attribute, buffer);\n+      }\n+    } else {\n+      buffer.put((byte) 0);\n+    }\n+  }\n+\n+  @Override\n+  public void deserialize(ByteBuffer buffer) throws IllegalPathException {\n+    int totalSize = buffer.getInt();\n+    for (int i = 0; i < totalSize; i++) {\n+      paths.add(new PartialPath(readString(buffer)));\n+    }\n+    for (int i = 0; i < totalSize; i++) {\n+      dataTypes.add(TSDataType.values()[buffer.get()]);\n+    }\n+    for (int i = 0; i < totalSize; i++) {\n+      encodings.add(TSEncoding.values()[buffer.get()]);\n+    }\n+\n+    for (int i = 0; i < totalSize; i++) {\n+      alias.add(readString(buffer));\n+    }", "originalCommit": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "279942253e08a2636c25e4f523542fbf805ac069", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\nindex f0fbbd2c07..fca42795cd 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\n\n@@ -30,6 +30,7 @@ import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n import java.io.DataOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjI3Mg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496346272", "bodyText": "Same.", "author": "Alima777", "createdAt": "2020-09-29T02:46:28Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * create multiple timeSeries, could be split to several sub Plans to execute in different DataGroup\n+ */\n+public class CreateMultiTimeSeriesPlan extends PhysicalPlan {\n+  private List<PartialPath> paths;\n+  private List<TSDataType> dataTypes;\n+  private List<TSEncoding> encodings;\n+  private List<CompressionType> compressors;\n+  private List<String> alias;\n+  private List<Map<String, String>> props = null;\n+  private List<Map<String, String>> tags = null;\n+  private List<Map<String, String>> attributes = null;\n+\n+  /*\n+   ** record the result of creation of time series\n+   */\n+  private Map<Integer, Boolean> results = new HashMap<>();\n+  private List<Integer> indexes;\n+\n+  public CreateMultiTimeSeriesPlan() {\n+    super(false, Operator.OperatorType.CREATE_MULTI_TIMESERIES);\n+  }\n+\n+  @Override\n+  public List<PartialPath> getPaths() {\n+    return paths;\n+  }\n+\n+  public void setPaths(List<PartialPath> paths) {\n+    this.paths = paths;\n+  }\n+\n+  public List<TSDataType> getDataTypes() {\n+    return dataTypes;\n+  }\n+\n+  public void setDataTypes(List<TSDataType> dataTypes) {\n+    this.dataTypes = dataTypes;\n+  }\n+\n+  public List<TSEncoding> getEncodings() {\n+    return encodings;\n+  }\n+\n+  public void setEncodings(List<TSEncoding> encodings) {\n+    this.encodings = encodings;\n+  }\n+\n+  public List<CompressionType> getCompressors() {\n+    return compressors;\n+  }\n+\n+  public void setCompressors(List<CompressionType> compressors) {\n+    this.compressors = compressors;\n+  }\n+\n+  public List<String> getAlias() {\n+    return alias;\n+  }\n+\n+  public void setAlias(List<String> alias) {\n+    this.alias = alias;\n+  }\n+\n+  public List<Map<String, String>> getProps() {\n+    return props;\n+  }\n+\n+  public void setProps(List<Map<String, String>> props) {\n+    this.props = props;\n+  }\n+\n+  public List<Map<String, String>> getTags() {\n+    return tags;\n+  }\n+\n+  public void setTags(List<Map<String, String>> tags) {\n+    this.tags = tags;\n+  }\n+\n+  public List<Map<String, String>> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public void setAttributes(List<Map<String, String>> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  public List<Integer> getIndexes() {\n+    return indexes;\n+  }\n+\n+  public void setIndexes(List<Integer> indexes) {\n+    this.indexes = indexes;\n+  }\n+\n+  public Map<Integer, Boolean> getResults() {\n+    return results;\n+  }\n+\n+  public void setResults(Map<Integer, Boolean> results) {\n+    this.results = results;\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream stream) throws IOException {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    stream.write(type);\n+    stream.writeInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(stream, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      stream.write(dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      stream.write(encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      stream.write(compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(stream, name);\n+    }\n+\n+    if (props != null) {\n+      stream.write(1);\n+      for (Map<String, String> prop : props) {\n+        ReadWriteIOUtils.write(prop, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (tags != null) {\n+      stream.write(1);\n+      for (Map<String, String> tag : tags) {\n+        ReadWriteIOUtils.write(tag, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (attributes != null) {\n+      stream.write(1);\n+      for (Map<String, String> attribute : attributes) {\n+        ReadWriteIOUtils.write(attribute, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+  }\n+\n+  @Override\n+  public void serialize(ByteBuffer buffer) {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    buffer.put((byte) type);\n+    buffer.putInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(buffer, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      buffer.put((byte) dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      buffer.put((byte) encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      buffer.put((byte) compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(buffer, name);\n+    }", "originalCommit": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "279942253e08a2636c25e4f523542fbf805ac069", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\nindex f0fbbd2c07..fca42795cd 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java\n\n@@ -30,6 +30,7 @@ import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n import java.io.DataOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"oid": "279942253e08a2636c25e4f523542fbf805ac069", "url": "https://github.com/apache/iotdb/commit/279942253e08a2636c25e4f523542fbf805ac069", "message": "fix tags null", "committedDate": "2020-09-29T03:18:28Z", "type": "commit"}, {"oid": "366b8d082e26881f43f5946e29b63a62a583b120", "url": "https://github.com/apache/iotdb/commit/366b8d082e26881f43f5946e29b63a62a583b120", "message": "fix cross-tests", "committedDate": "2020-09-29T05:21:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDQyMA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496444420", "bodyText": "I recommend that you straightly make results a Map<Integer, Exception> and record the potential QueryProcessException into it since createTimeSeries always returns true if there is no exception. And when changed this way, you would be able to tell the user what are the reasons behind the failures, instead of a simple failure.", "author": "jt2594838", "createdAt": "2020-09-29T06:23:59Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -1040,6 +1029,31 @@ private boolean createTimeSeries(CreateTimeSeriesPlan createTimeSeriesPlan)\n     return true;\n   }\n \n+  private boolean createMultiTimeSeries(CreateMultiTimeSeriesPlan createMultiTimeSeriesPlan) {\n+    Map<Integer, Boolean> results = new HashMap<>(createMultiTimeSeriesPlan.getPaths().size());\n+    for (int i = 0; i < createMultiTimeSeriesPlan.getPaths().size(); i++) {\n+      CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(createMultiTimeSeriesPlan.getPaths().get(i),\n+        createMultiTimeSeriesPlan.getDataTypes().get(i), createMultiTimeSeriesPlan.getEncodings().get(i),\n+        createMultiTimeSeriesPlan.getCompressors().get(i),\n+        createMultiTimeSeriesPlan.getProps() == null ? null : createMultiTimeSeriesPlan.getProps().get(i),\n+        createMultiTimeSeriesPlan.getTags() == null ? null : createMultiTimeSeriesPlan.getTags().get(i),\n+        createMultiTimeSeriesPlan.getAttributes() == null ? null : createMultiTimeSeriesPlan.getAttributes().get(i),\n+        createMultiTimeSeriesPlan.getAlias() == null ? null : createMultiTimeSeriesPlan.getAlias().get(i));\n+\n+      boolean success = false;\n+      try {\n+        success = createTimeSeries(plan);\n+      } catch (QueryProcessException e) {\n+        // do nothing\n+        logger.debug(\"meet error while processing create timeseries. \", e);\n+      } finally {\n+        results.put(createMultiTimeSeriesPlan.getIndexes().get(i), success);", "originalCommit": "366b8d082e26881f43f5946e29b63a62a583b120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4NzY1Mw==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496487653", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-29T07:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDQyMA=="}], "type": "inlineReview", "revised_code": {"commit": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex fb41bda1ab..a8ad151e0d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -1030,7 +1030,7 @@ public class PlanExecutor implements IPlanExecutor {\n   }\n \n   private boolean createMultiTimeSeries(CreateMultiTimeSeriesPlan createMultiTimeSeriesPlan) {\n-    Map<Integer, Boolean> results = new HashMap<>(createMultiTimeSeriesPlan.getPaths().size());\n+    Map<Integer, Exception> results = new HashMap<>(createMultiTimeSeriesPlan.getPaths().size());\n     for (int i = 0; i < createMultiTimeSeriesPlan.getPaths().size(); i++) {\n       CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(createMultiTimeSeriesPlan.getPaths().get(i),\n         createMultiTimeSeriesPlan.getDataTypes().get(i), createMultiTimeSeriesPlan.getEncodings().get(i),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDkyOA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496444928", "bodyText": "What is this plan for?", "author": "jt2594838", "createdAt": "2020-09-29T06:25:13Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -1533,14 +1528,35 @@ public TSStatus createMultiTimeseries(TSCreateMultiTimeseriesReq req) {\n             req.getPaths().size(), req.getPaths().get(0));\n       }\n       List<TSStatus> statusList = new ArrayList<>(req.paths.size());\n+      CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan();", "originalCommit": "366b8d082e26881f43f5946e29b63a62a583b120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4OTI0MA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496489240", "bodyText": "Just to do some check, like checkAuthority before execute the CreateMultiTimeSeriesPlan.", "author": "mychaow", "createdAt": "2020-09-29T07:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDkyOA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "url": "https://github.com/apache/iotdb/commit/72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "message": "record exception when failed", "committedDate": "2020-09-29T08:22:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NzI3MQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502167271", "bodyText": "It's not recommended to use star syntax in import", "author": "yuqi1129", "createdAt": "2020-10-09T03:39:53Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -98,26 +98,7 @@\n import org.apache.iotdb.db.qp.physical.crud.QueryPlan;\n import org.apache.iotdb.db.qp.physical.crud.RawDataQueryPlan;\n import org.apache.iotdb.db.qp.physical.crud.UpdatePlan;\n-import org.apache.iotdb.db.qp.physical.sys.AlterTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.AuthorPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CountPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DataAuthPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.FlushPlan;\n-import org.apache.iotdb.db.qp.physical.sys.LoadConfigurationPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MergePlan;\n-import org.apache.iotdb.db.qp.physical.sys.OperateFilePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowChildPathsPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowDevicesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.TracingPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;", "originalCommit": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NzEyNQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502177125", "bodyText": "thanks, I will fix it", "author": "mychaow", "createdAt": "2020-10-09T04:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NzI3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb7f704ca6ef61d77c40772d45ad540f12875700", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex a8ad151e0d..a54d91c825 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -98,7 +98,27 @@ import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n import org.apache.iotdb.db.qp.physical.crud.QueryPlan;\n import org.apache.iotdb.db.qp.physical.crud.RawDataQueryPlan;\n import org.apache.iotdb.db.qp.physical.crud.UpdatePlan;\n-import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.qp.physical.sys.AlterTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.AuthorPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CountPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateMultiTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DataAuthPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.FlushPlan;\n+import org.apache.iotdb.db.qp.physical.sys.LoadConfigurationPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MergePlan;\n+import org.apache.iotdb.db.qp.physical.sys.OperateFilePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ShowChildPathsPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ShowDevicesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ShowPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ShowStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ShowTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ShowTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.TracingPlan;\n import org.apache.iotdb.db.query.context.QueryContext;\n import org.apache.iotdb.db.query.dataset.AlignByDeviceDataSet;\n import org.apache.iotdb.db.query.dataset.ListDataSet;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3MDQyMg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502170422", "bodyText": "Maybe we need a switch to allow partial success if error log was output in debug level", "author": "yuqi1129", "createdAt": "2020-10-09T03:46:40Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -1040,6 +1029,29 @@ private boolean createTimeSeries(CreateTimeSeriesPlan createTimeSeriesPlan)\n     return true;\n   }\n \n+  private boolean createMultiTimeSeries(CreateMultiTimeSeriesPlan createMultiTimeSeriesPlan) {\n+    Map<Integer, Exception> results = new HashMap<>(createMultiTimeSeriesPlan.getPaths().size());\n+    for (int i = 0; i < createMultiTimeSeriesPlan.getPaths().size(); i++) {\n+      CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(createMultiTimeSeriesPlan.getPaths().get(i),\n+        createMultiTimeSeriesPlan.getDataTypes().get(i), createMultiTimeSeriesPlan.getEncodings().get(i),\n+        createMultiTimeSeriesPlan.getCompressors().get(i),\n+        createMultiTimeSeriesPlan.getProps() == null ? null : createMultiTimeSeriesPlan.getProps().get(i),\n+        createMultiTimeSeriesPlan.getTags() == null ? null : createMultiTimeSeriesPlan.getTags().get(i),\n+        createMultiTimeSeriesPlan.getAttributes() == null ? null : createMultiTimeSeriesPlan.getAttributes().get(i),\n+        createMultiTimeSeriesPlan.getAlias() == null ? null : createMultiTimeSeriesPlan.getAlias().get(i));\n+\n+      try {\n+        createTimeSeries(plan);\n+      } catch (QueryProcessException e) {\n+        // do nothing\n+        results.put(createMultiTimeSeriesPlan.getIndexes().get(i), e);\n+        logger.debug(\"meet error while processing create timeseries. \", e);", "originalCommit": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjIwODQ1Ng==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502208456", "bodyText": "yes, I will return error message to client", "author": "mychaow", "createdAt": "2020-10-09T06:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3MDQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "eb7f704ca6ef61d77c40772d45ad540f12875700", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex a8ad151e0d..a54d91c825 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -1043,7 +1060,6 @@ public class PlanExecutor implements IPlanExecutor {\n       try {\n         createTimeSeries(plan);\n       } catch (QueryProcessException e) {\n-        // do nothing\n         results.put(createMultiTimeSeriesPlan.getIndexes().get(i), e);\n         logger.debug(\"meet error while processing create timeseries. \", e);\n       }\n"}}, {"oid": "eb7f704ca6ef61d77c40772d45ad540f12875700", "url": "https://github.com/apache/iotdb/commit/eb7f704ca6ef61d77c40772d45ad540f12875700", "message": "return error message to client when create time series", "committedDate": "2020-10-12T07:45:35Z", "type": "commit"}, {"oid": "eb7f704ca6ef61d77c40772d45ad540f12875700", "url": "https://github.com/apache/iotdb/commit/eb7f704ca6ef61d77c40772d45ad540f12875700", "message": "return error message to client when create time series", "committedDate": "2020-10-12T07:45:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzMDY5OQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r503130699", "bodyText": "I think the messages of the exceptions should be put into the statuses.\nRpcUtils.getStatus(TSStatusCode.EXECUTE_STATEMENT_ERROR, entry.getValue().getMessage())", "author": "jt2594838", "createdAt": "2020-10-12T08:38:21Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -1607,9 +1607,9 @@ public TSStatus createMultiTimeseries(TSCreateMultiTimeseriesReq req) {\n \n       boolean isAllSuccessful = true;\n \n-      for (Map.Entry<Integer, Boolean> entry : createMultiTimeSeriesPlan.getResults().entrySet()) {\n-        if (!entry.getValue()) {\n-          isAllSuccessful = false;\n+      if (createMultiTimeSeriesPlan.getResults().entrySet().size() > 0) {\n+        isAllSuccessful = false;\n+        for (Map.Entry<Integer, Exception> entry : createMultiTimeSeriesPlan.getResults().entrySet()) {\n           statusList.set(entry.getKey(), RpcUtils.getStatus(TSStatusCode.EXECUTE_STATEMENT_ERROR));", "originalCommit": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE2NjI2OA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r503166268", "bodyText": "yes, I have fixed it.", "author": "mychaow", "createdAt": "2020-10-12T09:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzMDY5OQ=="}], "type": "inlineReview", "revised_code": null}]}