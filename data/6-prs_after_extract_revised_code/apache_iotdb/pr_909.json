{"pr_number": 909, "pr_title": "[IOTDB-355] Start-up checks", "pr_createdAt": "2020-03-14T05:41:39Z", "pr_url": "https://github.com/apache/iotdb/pull/909", "timeline": [{"oid": "41db9d5a1b86344a9ae8ef8fc42b626218c24473", "url": "https://github.com/apache/iotdb/commit/41db9d5a1b86344a9ae8ef8fc42b626218c24473", "message": "fix some typo", "committedDate": "2020-03-14T05:38:53Z", "type": "commit"}, {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "url": "https://github.com/apache/iotdb/commit/6abea8410570fb569a8749cfe4b88b2e2b56690f", "message": "start up check", "committedDate": "2020-03-14T14:30:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODQ1Mw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392858453", "bodyText": "This check should only be used when a node tries to form the initial cluster (startCluster()). If a node wants to join a cluster, the size of its seeds does not really matter.", "author": "jt2594838", "createdAt": "2020-03-16T08:42:52Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java", "diffHunk": "@@ -56,16 +59,22 @@\n   // to register the ClusterMonitor that helps monitoring the cluster\n   private RegisterManager registerManager = new RegisterManager();\n \n-  public MetaClusterServer() throws QueryProcessException {\n+  public MetaClusterServer() throws QueryProcessException, StartupException {\n     super();\n     member = new MetaGroupMember(protocolFactory, thisNode);\n-    // TODO-Cluster#355: check the initial cluster size and refuse to start when the size <\n-    //  #replication\n+    // check the initial cluster size and refuse to start when the size < quorum\n+    int quorum = config.getReplicationNum() / 2 + 1;\n+    if (config.getSeedNodeUrls().size() < quorum) {\n+      String message = String.format(\"Seed number less than quorum, seed number: {}, quorum: {}.\",\n+          config.getSeedNodeUrls().size(), quorum);\n+      throw new StartupException(member.getName(), message);\n+    }", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNzkzMA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r393637930", "bodyText": "Thanks for your suggestion. I will change it.", "author": "Ring-k", "createdAt": "2020-03-17T12:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "186335a727b2419bbdff65d58980f3180c6f27dd", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java\nindex 301e62239c..4debf6da06 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java\n\n@@ -62,13 +62,6 @@ public class MetaClusterServer extends RaftServer implements TSMetaService.Async\n   public MetaClusterServer() throws QueryProcessException, StartupException {\n     super();\n     member = new MetaGroupMember(protocolFactory, thisNode);\n-    // check the initial cluster size and refuse to start when the size < quorum\n-    int quorum = config.getReplicationNum() / 2 + 1;\n-    if (config.getSeedNodeUrls().size() < quorum) {\n-      String message = String.format(\"Seed number less than quorum, seed number: {}, quorum: {}.\",\n-          config.getSeedNodeUrls().size(), quorum);\n-      throw new StartupException(member.getName(), message);\n-    }\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODY4Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392858687", "bodyText": "remove this or use a log", "author": "jt2594838", "createdAt": "2020-03-16T08:43:18Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java", "diffHunk": "@@ -74,6 +83,7 @@ public void start() throws TTransportException, StartupException {\n     super.start();\n     ioTDB = new IoTDB();\n     ioTDB.active();\n+    System.out.println(\"--------------------start connecting\");", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MTU0NQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392871545", "bodyText": "This line of code is removed.", "author": "Ring-k", "createdAt": "2020-03-16T09:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java\nindex 301e62239c..e542a2a3bd 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java\n\n@@ -83,7 +83,6 @@ public class MetaClusterServer extends RaftServer implements TSMetaService.Async\n     super.start();\n     ioTDB = new IoTDB();\n     ioTDB.active();\n-    System.out.println(\"--------------------start connecting\");\n     member.start();\n     registerManager.register(ClusterMonitor.INSTANCE);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTgxMg==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392859812", "bodyText": "Is it necessary to new here? I think the handler should always have the result set by onComplete.", "author": "jt2594838", "createdAt": "2020-03-16T08:45:31Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandler.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.iotdb.cluster.server.handlers.caller;\n+\n+import org.apache.iotdb.cluster.rpc.thrift.CheckStatusResponse;\n+import org.apache.thrift.async.AsyncMethodCallback;\n+\n+public class CheckStatusHandler implements AsyncMethodCallback<CheckStatusResponse> {\n+\n+  CheckStatusResponse checkStatusResponse;\n+\n+  public CheckStatusHandler() {\n+    this.checkStatusResponse = new CheckStatusResponse();", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MjExNQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392872115", "bodyText": "I used GenericHandler instead in the updated version. This class is removed.", "author": "Ring-k", "createdAt": "2020-03-16T09:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTgxMg=="}], "type": "inlineReview", "revised_code": {"commit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandler.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandler.java\ndeleted file mode 100644\nindex 833740c7f6..0000000000\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandler.java\n+++ /dev/null\n\n@@ -1,27 +0,0 @@\n-package org.apache.iotdb.cluster.server.handlers.caller;\n-\n-import org.apache.iotdb.cluster.rpc.thrift.CheckStatusResponse;\n-import org.apache.thrift.async.AsyncMethodCallback;\n-\n-public class CheckStatusHandler implements AsyncMethodCallback<CheckStatusResponse> {\n-\n-  CheckStatusResponse checkStatusResponse;\n-\n-  public CheckStatusHandler() {\n-    this.checkStatusResponse = new CheckStatusResponse();\n-  }\n-\n-  public CheckStatusResponse getCheckStatusResponse() {\n-    return checkStatusResponse;\n-  }\n-\n-  @Override\n-  public void onComplete(CheckStatusResponse response) {\n-    this.checkStatusResponse = response;\n-  }\n-\n-  @Override\n-  public void onError(Exception e) {\n-\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MTg0NQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392861845", "bodyText": "I think it is simpler to just add these configurations that should be checked into the AddNodeRequest so that you can cut one communication down.\nBesides, please remove the commented code.", "author": "jt2594838", "createdAt": "2020-03-16T08:49:29Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -623,6 +627,50 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n         return true;\n       }\n \n+      // check status of the new node\n+//      AsyncClient client = (AsyncClient) connectNode(node);\n+//      try {\n+//        AsyncMethodCallback<String> result = new AsyncMethodCallback<String>() {\n+//          String words;\n+//          @Override\n+//          public void onComplete(String s) {\n+//            this.words = s;\n+//          }\n+//          @Override\n+//          public void onError(Exception e) {\n+//            System.out.println(\"some error happens\");\n+//          }\n+//          public String getWords() {\n+//            return words;\n+//          }\n+//        };\n+//        System.out.println(result);\n+//        client.echo(\"hello world\", result);\n+//      } catch (TException e) {\n+//        e.printStackTrace();\n+//      }\n+      CheckStatusRequest checkStatusRequest = new CheckStatusRequest();\n+      checkStatusRequest.setHashSalt(ClusterConstant.HASH_SALT);\n+      checkStatusRequest\n+          .setPartitionInterval(IoTDBDescriptor.getInstance().getConfig().getPartitionInterval());\n+      checkStatusRequest.setReplicationNumber(config.getReplicationNum());\n+      CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+      try {\n+        sendStatusToNewNode(node, checkStatusRequest, checkStatusHandler);\n+      } catch (TException exception) {\n+        logger.error(\"Failed to send current state to the new node {}\", node, exception);\n+      }\n+      if (!checkStatusHandler.getCheckStatusResponse().isPartitionalIntervalEquals()) {\n+        logger.info(\"The partition interval of the new node {} conflicts.\", node);\n+        return true;\n+      } else if (!checkStatusHandler.getCheckStatusResponse().isHashSaltIntervalEquals()) {\n+        logger.info(\"The hash salt of the new node {} conflicts.\", node);\n+        return true;\n+      } else if (!checkStatusHandler.getCheckStatusResponse().isReplicationNumEquals()) {\n+        logger.info(\"The replication number of the new node {} conflicts.\", node);\n+        return true;\n+      }", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NDAxMw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392874013", "bodyText": "That's a good idea. I will change it", "author": "Ring-k", "createdAt": "2020-03-16T09:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MTg0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 3dcf87b5fb..512e69eda6 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -628,45 +627,32 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n       }\n \n       // check status of the new node\n-//      AsyncClient client = (AsyncClient) connectNode(node);\n-//      try {\n-//        AsyncMethodCallback<String> result = new AsyncMethodCallback<String>() {\n-//          String words;\n-//          @Override\n-//          public void onComplete(String s) {\n-//            this.words = s;\n-//          }\n-//          @Override\n-//          public void onError(Exception e) {\n-//            System.out.println(\"some error happens\");\n-//          }\n-//          public String getWords() {\n-//            return words;\n-//          }\n-//        };\n-//        System.out.println(result);\n-//        client.echo(\"hello world\", result);\n-//      } catch (TException e) {\n-//        e.printStackTrace();\n-//      }\n       CheckStatusRequest checkStatusRequest = new CheckStatusRequest();\n       checkStatusRequest.setHashSalt(ClusterConstant.HASH_SALT);\n       checkStatusRequest\n           .setPartitionInterval(IoTDBDescriptor.getInstance().getConfig().getPartitionInterval());\n       checkStatusRequest.setReplicationNumber(config.getReplicationNum());\n-      CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+\n+      AtomicReference<CheckStatusResponse> checkStatusResponseReference = new AtomicReference<>();\n+      GenericHandler<CheckStatusResponse> checkStatusHandler = new GenericHandler<>(node,\n+          checkStatusResponseReference);\n       try {\n-        sendStatusToNewNode(node, checkStatusRequest, checkStatusHandler);\n-      } catch (TException exception) {\n+        synchronized (checkStatusResponseReference) {\n+          AsyncClient client = (AsyncClient) connectNode(node);\n+          client.checkStatus(checkStatusRequest, checkStatusHandler);\n+          checkStatusResponseReference.wait(connectionTimeoutInMS);\n+        }\n+      } catch (TException | InterruptedException exception) {\n         logger.error(\"Failed to send current state to the new node {}\", node, exception);\n       }\n-      if (!checkStatusHandler.getCheckStatusResponse().isPartitionalIntervalEquals()) {\n+      CheckStatusResponse checkStatusResult = checkStatusResponseReference.get();\n+      if (!checkStatusResult.isPartitionalIntervalEquals()) {\n         logger.info(\"The partition interval of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isHashSaltIntervalEquals()) {\n+      } else if (!checkStatusResult.isHashSaltIntervalEquals()) {\n         logger.info(\"The hash salt of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isReplicationNumEquals()) {\n+      } else if (!checkStatusResult.isReplicationNumEquals()) {\n         logger.info(\"The replication number of the new node {} conflicts.\", node);\n         return true;\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzMwMQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392863301", "bodyText": "client.checkStatus is an asynchronous method, so if you use it like this, you will probably get nothing in the response. Please refer to other usages where a lock (synchronized) is used to assure that the result is returned before we move on.", "author": "jt2594838", "createdAt": "2020-03-16T08:52:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -663,6 +711,14 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n     return false;\n   }\n \n+\n+  private void sendStatusToNewNode(Node node, CheckStatusRequest checkStatusRequest,\n+      AsyncMethodCallback<CheckStatusResponse> response)\n+      throws TException {\n+    AsyncClient client = (AsyncClient) connectNode(node);\n+    client.checkStatus(checkStatusRequest, response);", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NDk3OQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392874979", "bodyText": "Thanks for your suggestion. I will implement it.", "author": "Ring-k", "createdAt": "2020-03-16T09:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 3dcf87b5fb..512e69eda6 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -711,14 +697,6 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n     return false;\n   }\n \n-\n-  private void sendStatusToNewNode(Node node, CheckStatusRequest checkStatusRequest,\n-      AsyncMethodCallback<CheckStatusResponse> response)\n-      throws TException {\n-    AsyncClient client = (AsyncClient) connectNode(node);\n-    client.checkStatus(checkStatusRequest, response);\n-  }\n-\n   /**\n    * Send the log the all data groups and return a success only when each group's quorum has\n    * accepted this log.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NDMzMg==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392864332", "bodyText": "Please also fulfill the tests.", "author": "jt2594838", "createdAt": "2020-03-16T08:54:22Z", "path": "cluster/src/test/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandlerTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.iotdb.cluster.server.handlers.caller;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertFalse;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.iotdb.cluster.common.TestException;\n+import org.apache.iotdb.cluster.common.TestLogManager;\n+import org.apache.iotdb.cluster.common.TestMetaGroupMember;\n+import org.apache.iotdb.cluster.common.TestUtils;\n+import org.apache.iotdb.cluster.log.LogManager;\n+import org.apache.iotdb.cluster.rpc.thrift.HeartbeatResponse;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.server.Response;\n+import org.apache.iotdb.cluster.server.member.MetaGroupMember;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class CheckStatusHandlerTest {\n+  private MetaGroupMember metaGroupMember;\n+  private boolean catchUpFlag;\n+\n+  @Before\n+  public void setUp() {\n+    metaGroupMember = new TestMetaGroupMember() {\n+      @Override\n+      public void catchUp(Node follower, long followerLastLogIndex) {\n+        synchronized (metaGroupMember) {\n+          catchUpFlag = true;\n+          metaGroupMember.notifyAll();\n+        }\n+      }\n+\n+      @Override\n+      public LogManager getLogManager() {\n+        return new TestLogManager();\n+      }\n+    };\n+  }\n+\n+  @Test\n+  public void testComplete() throws InterruptedException {\n+    CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+    // TODO\n+  }", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MzkzNA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392873934", "bodyText": "I removed the CheckStatusHander class. The unit test is also removed.", "author": "Ring-k", "createdAt": "2020-03-16T09:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NDMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "chunk": "diff --git a/cluster/src/test/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandlerTest.java b/cluster/src/test/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandlerTest.java\ndeleted file mode 100644\nindex 6e4c3246e8..0000000000\n--- a/cluster/src/test/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandlerTest.java\n+++ /dev/null\n\n@@ -1,47 +0,0 @@\n-package org.apache.iotdb.cluster.server.handlers.caller;\n-\n-import static junit.framework.TestCase.assertEquals;\n-import static junit.framework.TestCase.assertFalse;\n-import static junit.framework.TestCase.assertTrue;\n-\n-import org.apache.iotdb.cluster.common.TestException;\n-import org.apache.iotdb.cluster.common.TestLogManager;\n-import org.apache.iotdb.cluster.common.TestMetaGroupMember;\n-import org.apache.iotdb.cluster.common.TestUtils;\n-import org.apache.iotdb.cluster.log.LogManager;\n-import org.apache.iotdb.cluster.rpc.thrift.HeartbeatResponse;\n-import org.apache.iotdb.cluster.rpc.thrift.Node;\n-import org.apache.iotdb.cluster.server.Response;\n-import org.apache.iotdb.cluster.server.member.MetaGroupMember;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-public class CheckStatusHandlerTest {\n-  private MetaGroupMember metaGroupMember;\n-  private boolean catchUpFlag;\n-\n-  @Before\n-  public void setUp() {\n-    metaGroupMember = new TestMetaGroupMember() {\n-      @Override\n-      public void catchUp(Node follower, long followerLastLogIndex) {\n-        synchronized (metaGroupMember) {\n-          catchUpFlag = true;\n-          metaGroupMember.notifyAll();\n-        }\n-      }\n-\n-      @Override\n-      public LogManager getLogManager() {\n-        return new TestLogManager();\n-      }\n-    };\n-  }\n-\n-  @Test\n-  public void testComplete() throws InterruptedException {\n-    CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n-    // TODO\n-  }\n-\n-}\n"}}, {"oid": "850a3af48f766b84404dd1d653e50e831d7c20b4", "url": "https://github.com/apache/iotdb/commit/850a3af48f766b84404dd1d653e50e831d7c20b4", "message": "implement startup check", "committedDate": "2020-03-16T09:05:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3OTk1OQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392879959", "bodyText": "Please reverse this.", "author": "jt2594838", "createdAt": "2020-03-16T09:24:14Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -60,7 +60,7 @@\n   /**\n    * Port which the JDBC server listens to.\n    */\n-  private int rpcPort = 6667;\n+  private int rpcPort = 6670;", "originalCommit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4OTQ0OA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r393389448", "bodyText": "Thanks for your reminding. This is reversed.", "author": "Ring-k", "createdAt": "2020-03-17T00:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3OTk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "32681c926673032db696bf0aeef8b274a12127a2", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\nindex 4dbcda399e..274dd91688 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n\n@@ -60,7 +60,7 @@ public class IoTDBConfig {\n   /**\n    * Port which the JDBC server listens to.\n    */\n-  private int rpcPort = 6670;\n+  private int rpcPort = 6667;\n \n   /**\n    * Max concurrent client number\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MTY2Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392881667", "bodyText": "If you decide to return true, then you must call either resultHandler.onComplete() or resultHandler.onError(), otherwise the requestor will wait forever.\nAnd be sure to let the requestor know why there is a failure.", "author": "jt2594838", "createdAt": "2020-03-16T09:27:21Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -628,45 +627,32 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n       }\n \n       // check status of the new node\n-//      AsyncClient client = (AsyncClient) connectNode(node);\n-//      try {\n-//        AsyncMethodCallback<String> result = new AsyncMethodCallback<String>() {\n-//          String words;\n-//          @Override\n-//          public void onComplete(String s) {\n-//            this.words = s;\n-//          }\n-//          @Override\n-//          public void onError(Exception e) {\n-//            System.out.println(\"some error happens\");\n-//          }\n-//          public String getWords() {\n-//            return words;\n-//          }\n-//        };\n-//        System.out.println(result);\n-//        client.echo(\"hello world\", result);\n-//      } catch (TException e) {\n-//        e.printStackTrace();\n-//      }\n       CheckStatusRequest checkStatusRequest = new CheckStatusRequest();\n       checkStatusRequest.setHashSalt(ClusterConstant.HASH_SALT);\n       checkStatusRequest\n           .setPartitionInterval(IoTDBDescriptor.getInstance().getConfig().getPartitionInterval());\n       checkStatusRequest.setReplicationNumber(config.getReplicationNum());\n-      CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+\n+      AtomicReference<CheckStatusResponse> checkStatusResponseReference = new AtomicReference<>();\n+      GenericHandler<CheckStatusResponse> checkStatusHandler = new GenericHandler<>(node,\n+          checkStatusResponseReference);\n       try {\n-        sendStatusToNewNode(node, checkStatusRequest, checkStatusHandler);\n-      } catch (TException exception) {\n+        synchronized (checkStatusResponseReference) {\n+          AsyncClient client = (AsyncClient) connectNode(node);\n+          client.checkStatus(checkStatusRequest, checkStatusHandler);\n+          checkStatusResponseReference.wait(connectionTimeoutInMS);\n+        }\n+      } catch (TException | InterruptedException exception) {\n         logger.error(\"Failed to send current state to the new node {}\", node, exception);\n       }\n-      if (!checkStatusHandler.getCheckStatusResponse().isPartitionalIntervalEquals()) {\n+      CheckStatusResponse checkStatusResult = checkStatusResponseReference.get();\n+      if (!checkStatusResult.isPartitionalIntervalEquals()) {\n         logger.info(\"The partition interval of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isHashSaltIntervalEquals()) {\n+      } else if (!checkStatusResult.isHashSaltIntervalEquals()) {\n         logger.info(\"The hash salt of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isReplicationNumEquals()) {\n+      } else if (!checkStatusResult.isReplicationNumEquals()) {\n         logger.info(\"The replication number of the new node {} conflicts.\", node);\n         return true;", "originalCommit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0MTk0Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r393641947", "bodyText": "Thanks for your reminding. The onComplete() method will be called before returning results.", "author": "Ring-k", "createdAt": "2020-03-17T12:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MTY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6cec35de3cc498311785f1b5c1d254c2382bb433", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 512e69eda6..c808ffaa81 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -648,12 +648,18 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n       CheckStatusResponse checkStatusResult = checkStatusResponseReference.get();\n       if (!checkStatusResult.isPartitionalIntervalEquals()) {\n         logger.info(\"The partition interval of the new node {} conflicts.\", node);\n+        response.setRespNum((int) Response.RESPONSE_NEW_NODE_PARAMETER_CONFLICT);\n+        resultHandler.onComplete(response);\n         return true;\n       } else if (!checkStatusResult.isHashSaltIntervalEquals()) {\n         logger.info(\"The hash salt of the new node {} conflicts.\", node);\n+        response.setRespNum((int) Response.RESPONSE_NEW_NODE_PARAMETER_CONFLICT);\n+        resultHandler.onComplete(response);\n         return true;\n       } else if (!checkStatusResult.isReplicationNumEquals()) {\n         logger.info(\"The replication number of the new node {} conflicts.\", node);\n+        response.setRespNum((int) Response.RESPONSE_NEW_NODE_PARAMETER_CONFLICT);\n+        resultHandler.onComplete(response);\n         return true;\n       }\n \n"}}, {"oid": "32681c926673032db696bf0aeef8b274a12127a2", "url": "https://github.com/apache/iotdb/commit/32681c926673032db696bf0aeef8b274a12127a2", "message": "reset iotdb config", "committedDate": "2020-03-16T10:50:54Z", "type": "commit"}, {"oid": "186335a727b2419bbdff65d58980f3180c6f27dd", "url": "https://github.com/apache/iotdb/commit/186335a727b2419bbdff65d58980f3180c6f27dd", "message": "start up check on -s mode", "committedDate": "2020-03-17T12:12:51Z", "type": "commit"}, {"oid": "6cec35de3cc498311785f1b5c1d254c2382bb433", "url": "https://github.com/apache/iotdb/commit/6cec35de3cc498311785f1b5c1d254c2382bb433", "message": "call onComplete() before returning", "committedDate": "2020-03-17T12:26:22Z", "type": "commit"}, {"oid": "a269b96788a3994dd4655708d427f0e3a2979296", "url": "https://github.com/apache/iotdb/commit/a269b96788a3994dd4655708d427f0e3a2979296", "message": "merge check status in add node", "committedDate": "2020-03-18T13:51:17Z", "type": "commit"}, {"oid": "c9d0c10634efbd5fdd7fd9e3c76ccbaf34797b51", "url": "https://github.com/apache/iotdb/commit/c9d0c10634efbd5fdd7fd9e3c76ccbaf34797b51", "message": "remove useless comment", "committedDate": "2020-03-18T13:52:12Z", "type": "commit"}, {"oid": "db5019c0483230de9650702bc431c557898911e7", "url": "https://github.com/apache/iotdb/commit/db5019c0483230de9650702bc431c557898911e7", "message": "add unit test", "committedDate": "2020-03-18T14:14:36Z", "type": "commit"}, {"oid": "c8642a2cb02a0488fea39cdab1b0bdaab8bc5e68", "url": "https://github.com/apache/iotdb/commit/c8642a2cb02a0488fea39cdab1b0bdaab8bc5e68", "message": "fix conflict", "committedDate": "2020-03-18T14:41:18Z", "type": "commit"}, {"oid": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "url": "https://github.com/apache/iotdb/commit/79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "message": "fix conflict", "committedDate": "2020-03-19T14:08:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyMzc5Ng==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395423796", "bodyText": "Please notice the conflict marks and resolve them. I will mark all I see in case you miss any.", "author": "jt2594838", "createdAt": "2020-03-20T03:22:47Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c", "originalCommit": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNjI3Mg==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395426272", "bodyText": "Thanks for your reminding. I will remove them.", "author": "Ring-k", "createdAt": "2020-03-20T03:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyMzc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5fcb9f0786aee2f36e1b224931059371cfc9b465", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\nindex 46d2ede210..2399c7f20b 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\n\n@@ -550,487 +550,477 @@ public abstract class RaftMember implements RaftService.AsyncIface {\n   }\n \n \n-    /**\n-     * Sub-classes will add their own process of HeartBeatResponse in this method.\n-     * @param response\n-     * @param receiver\n-     */\n-    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n+  /**\n+   * Sub-classes will add their own process of HeartBeatResponse in this method.\n+   *\n+   * @param response\n+   * @param receiver\n+   */\n+  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n \n-    }\n+  }\n \n-    /**\n-     * The actions performed when the node wins in an election (becoming a leader).\n-     */\n-    public void onElectionWins () {\n+  /**\n+   * The actions performed when the node wins in an election (becoming a leader).\n+   */\n+  public void onElectionWins() {\n \n-    }\n+  }\n \n \n-      /**\n-       * Sub-classes will add their own process of HeartBeatRequest in this method.\n-       * @param request\n-       * @param response\n-       */\n-      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n+  /**\n+   * Sub-classes will add their own process of HeartBeatRequest in this method.\n+   *\n+   * @param request\n+   * @param response\n+   */\n+  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n \n-      }\n+  }\n \n-      /**\n-       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-       * reset heartbeat timer.\n-       * @param newTerm\n-       */\n-      public void retireFromLeader ( long newTerm){\n-        synchronized (term) {\n-          long currTerm = term.get();\n-          // confirm that the heartbeat of the new leader hasn't come\n-          if (currTerm < newTerm) {\n-            term.set(newTerm);\n-            setCharacter(NodeCharacter.FOLLOWER);\n-            setLeader(null);\n-            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-          }\n-        }\n+  /**\n+   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and reset\n+   * heartbeat timer.\n+   *\n+   * @param newTerm\n+   */\n+  public void retireFromLeader(long newTerm) {\n+    synchronized (term) {\n+      long currTerm = term.get();\n+      // confirm that the heartbeat of the new leader hasn't come\n+      if (currTerm < newTerm) {\n+        term.set(newTerm);\n+        setCharacter(NodeCharacter.FOLLOWER);\n+        setLeader(null);\n+        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n       }\n+    }\n+  }\n \n-      /**\n-       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-       * request is valid.\n-       * @param electionRequest\n-       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-       */\n-      long processElectionRequest (ElectionRequest electionRequest){\n-\n-        long thatTerm = electionRequest.getTerm();\n-        long thatLastLogId = electionRequest.getLastLogIndex();\n-        long thatLastLogTerm = electionRequest.getLastLogTerm();\n-        logger\n-            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-                name, thatTerm,\n-                thatLastLogId, thatLastLogTerm);\n-\n-        long lastLogIndex = logManager.getLastLogIndex();\n-        long lastLogTerm = logManager.getLastLogTerm();\n-\n-        synchronized (term) {\n-          long thisTerm = term.get();\n-          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-              thatLastLogTerm);\n-          if (resp == Response.RESPONSE_AGREE) {\n-            term.set(thatTerm);\n-            setCharacter(NodeCharacter.FOLLOWER);\n-            lastHeartbeatReceivedTime = System.currentTimeMillis();\n-            leader = electionRequest.getElector();\n-            // interrupt election\n-            term.notifyAll();\n-          }\n-          return resp;\n-        }\n-      }\n+  /**\n+   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+   * request is valid.\n+   *\n+   * @param electionRequest\n+   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has a\n+   * smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+   */\n+  long processElectionRequest(ElectionRequest electionRequest) {\n \n-      /**\n-       *  Reject the election if one of the four holds:\n-       *   1. the term of the candidate is no bigger than the voter's\n-       *   2. the lastLogTerm of the candidate is smaller than the voter's\n-       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-       *      smaller than the voter's\n-       *   Otherwise accept the election.\n-       * @param thisTerm\n-       * @param thisLastLogIndex\n-       * @param thisLastLogTerm\n-       * @param thatTerm\n-       * @param thatLastLogId\n-       * @param thatLastLogTerm\n-       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-       */\n-      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n-        long response;\n-        if (thatTerm <= thisTerm) {\n-          response = thisTerm;\n-          logger.debug(\"{} rejected an election request, term:{}/{}\",\n-              name, thatTerm, thisTerm);\n-        } else if (thatLastLogTerm < thisLastLogTerm\n-            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-          response = Response.RESPONSE_LOG_MISMATCH;\n-        } else {\n-          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-              thisLastLogTerm);\n-          response = Response.RESPONSE_AGREE;\n-        }\n-        return response;\n+    long thatTerm = electionRequest.getTerm();\n+    long thatLastLogId = electionRequest.getLastLogIndex();\n+    long thatLastLogTerm = electionRequest.getLastLogTerm();\n+    logger\n+        .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+            name, thatTerm,\n+            thatLastLogId, thatLastLogTerm);\n+\n+    long lastLogIndex = logManager.getLastLogIndex();\n+    long lastLogTerm = logManager.getLastLogTerm();\n+\n+    synchronized (term) {\n+      long thisTerm = term.get();\n+      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+          thatLastLogTerm);\n+      if (resp == Response.RESPONSE_AGREE) {\n+        term.set(thatTerm);\n+        setCharacter(NodeCharacter.FOLLOWER);\n+        lastHeartbeatReceivedTime = System.currentTimeMillis();\n+        leader = electionRequest.getElector();\n+        // interrupt election\n+        term.notifyAll();\n       }\n+      return resp;\n+    }\n+  }\n \n-      /**\n-       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-       * follower. If some of the logs are not in memory, also send the snapshot.\n-       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-       *\n-       * @param follower\n-       * @param followerLastLogIndex\n-       */\n-      public void catchUp (Node follower,long followerLastLogIndex){\n-        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-        // for one follower, there is at most one ongoing catch-up\n-        synchronized (follower) {\n-          // check if the last catch-up is still ongoing\n-          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-          if (lastCatchupResp != null\n-              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-            return;\n-          } else {\n-            // record the start of the catch-up\n-            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n-          }\n-        }\n-        if (followerLastLogIndex == -1) {\n-          // if the follower does not have any logs, send from the first one\n-          followerLastLogIndex = 0;\n-        }\n+  /**\n+   * Reject the election if one of the four holds: 1. the term of the candidate is no bigger than\n+   * the voter's 2. the lastLogTerm of the candidate is smaller than the voter's 3. the lastLogTerm\n+   * of the candidate equals to the voter's but its lastLogIndex is smaller than the voter's\n+   * Otherwise accept the election.\n+   *\n+   * @param thisTerm\n+   * @param thisLastLogIndex\n+   * @param thisLastLogTerm\n+   * @param thatTerm\n+   * @param thatLastLogId\n+   * @param thatLastLogTerm\n+   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has a\n+   * smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+   */\n+  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n+    long response;\n+    if (thatTerm <= thisTerm) {\n+      response = thisTerm;\n+      logger.debug(\"{} rejected an election request, term:{}/{}\",\n+          name, thatTerm, thisTerm);\n+    } else if (thatLastLogTerm < thisLastLogTerm\n+        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+      response = Response.RESPONSE_LOG_MISMATCH;\n+    } else {\n+      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+          thisLastLogTerm);\n+      response = Response.RESPONSE_AGREE;\n+    }\n+    return response;\n+  }\n \n-        AsyncClient client = connectNode(follower);\n-        if (client != null) {\n-          List<Log> logs;\n-          boolean allLogsValid;\n-          Snapshot snapshot = null;\n-          synchronized (logManager) {\n-            // check if the very first log has been snapshot\n-            allLogsValid = logManager.logValid(followerLastLogIndex);\n-            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-            if (!allLogsValid) {\n-              // if the first log has been snapshot, the snapshot should also be sent to the\n-              // follower, otherwise some data will be missing\n-              snapshot = logManager.getSnapshot();\n-            }\n-          }\n+  /**\n+   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+   * follower. If some of the logs are not in memory, also send the snapshot.\n+   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+   *\n+   * @param follower\n+   * @param followerLastLogIndex\n+   */\n+  public void catchUp(Node follower, long followerLastLogIndex) {\n+    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+    // for one follower, there is at most one ongoing catch-up\n+    synchronized (follower) {\n+      // check if the last catch-up is still ongoing\n+      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+      if (lastCatchupResp != null\n+          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+        return;\n+      } else {\n+        // record the start of the catch-up\n+        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      }\n+    }\n+    if (followerLastLogIndex == -1) {\n+      // if the follower does not have any logs, send from the first one\n+      followerLastLogIndex = 0;\n+    }\n \n-          if (allLogsValid) {\n-            if (logger.isDebugEnabled()) {\n-              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n-            }\n-            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-          } else {\n-            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n-          }\n-        } else {\n-          lastCatchUpResponseTime.remove(follower);\n-          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+    AsyncClient client = connectNode(follower);\n+    if (client != null) {\n+      List<Log> logs;\n+      boolean allLogsValid;\n+      Snapshot snapshot = null;\n+      synchronized (logManager) {\n+        // check if the very first log has been snapshot\n+        allLogsValid = logManager.logValid(followerLastLogIndex);\n+        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+        if (!allLogsValid) {\n+          // if the first log has been snapshot, the snapshot should also be sent to the\n+          // follower, otherwise some data will be missing\n+          snapshot = logManager.getSnapshot();\n         }\n       }\n \n-      public String getName () {\n-        return name;\n+      if (allLogsValid) {\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+        }\n+        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+      } else {\n+        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n       }\n+    } else {\n+      lastCatchUpResponseTime.remove(follower);\n+      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+    }\n+  }\n \n-      /**\n-       * @return the header of the data raft group or null if this is in a meta group.\n-       */\n-      public Node getHeader () {\n-        return null;\n-      }\n+  public String getName() {\n+    return name;\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * Forward a plan to a node using the default client.\n-       *\n-       * @param plan\n-       * @param node\n-      =======\n-       * Forward a non-query plan to a node using the default client.\n-       * @param plan a non-query plan\n-       * @param node cannot be the local node\n-      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param header must be set for data group communication, set to null for meta group\n-       *               communication\n-       * @return a TSStatus indicating if the forwarding is successful.\n-       */\n-      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n-        if (node == thisNode || node == null) {\n-          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-          return StatusUtils.NO_LEADER;\n-        }\n+  /**\n+   * @return the header of the data raft group or null if this is in a meta group.\n+   */\n+  public Node getHeader() {\n+    return null;\n+  }\n+\n+  /**\n+   * Forward a non-query plan to a node using the default client.\n+   *\n+   * @param plan   a non-query plan\n+   * @param node   cannot be the local node\n+   * @param header must be set for data group communication, set to null for meta group\n+   *               communication\n+   * @return a TSStatus indicating if the forwarding is successful.\n+   */\n+  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n+    if (node == thisNode || node == null) {\n+      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+      return StatusUtils.NO_LEADER;\n+    }\n \n-        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n \n-        AsyncClient client = connectNode(node);\n-        if (client != null) {\n-          return forwardPlan(plan, client, node, header);\n-        }\n-        return StatusUtils.TIME_OUT;\n-      }\n+    AsyncClient client = connectNode(node);\n+    if (client != null) {\n+      return forwardPlan(plan, client, node, header);\n+    }\n+    return StatusUtils.TIME_OUT;\n+  }\n \n-      /**\n-       * Forward a non-query plan to \"receiver\" using \"client\".\n-       * @param plan a non-query plan\n-       * @param client\n-       * @param receiver\n-       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-       * @return a TSStatus indicating if the forwarding is successful.\n-       */\n-      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-        try {\n-          plan.serializeTo(dataOutputStream);\n-          AtomicReference<TSStatus> status = new AtomicReference<>();\n-          ExecutNonQueryReq req = new ExecutNonQueryReq();\n-          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-          if (header != null) {\n-            req.setHeader(header);\n-          }\n-          synchronized (status) {\n-            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-            status.wait(RaftServer.connectionTimeoutInMS);\n-          }\n-          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-        } catch (IOException | TException e) {\n-          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-          status.setMessage(e.getMessage());\n-          logger\n-              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-          return status;\n-        } catch (InterruptedException e) {\n-          return StatusUtils.TIME_OUT;\n-        }\n+  /**\n+   * Forward a non-query plan to \"receiver\" using \"client\".\n+   *\n+   * @param plan     a non-query plan\n+   * @param client\n+   * @param receiver\n+   * @param header   to determine which DataGroupMember of \"receiver\" will process the request.\n+   * @return a TSStatus indicating if the forwarding is successful.\n+   */\n+  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+    try {\n+      plan.serializeTo(dataOutputStream);\n+      AtomicReference<TSStatus> status = new AtomicReference<>();\n+      ExecutNonQueryReq req = new ExecutNonQueryReq();\n+      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+      if (header != null) {\n+        req.setHeader(header);\n       }\n+      synchronized (status) {\n+        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+        status.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+    } catch (IOException | TException e) {\n+      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+      status.setMessage(e.getMessage());\n+      logger\n+          .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+      return status;\n+    } catch (InterruptedException e) {\n+      return StatusUtils.TIME_OUT;\n+    }\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * Only the group leader can call this method. Will commit the log locally and send it to\n-       * followers\n-       *\n-       =======\n-       * Create a log for \"plan\" and append it locally and to all followers.\n-       * Only the group leader can call this method.\n-       * Will commit the log locally and send it to followers\n-       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param plan\n-       * @return OK if over half of the followers accept the log or null if the leadership is lost\n-       * during the appending\n-       */\n-      TSStatus processPlanLocally (PhysicalPlan plan){\n-        logger.debug(\"{}: Processing plan {}\", name, plan);\n-        if (readOnly) {\n-          return StatusUtils.NODE_READ_ONLY;\n-        }\n+  /**\n+   * Create a log for \"plan\" and append it locally and to all followers. Only the group leader can\n+   * call this method. Will commit the log locally and send it to followers\n+   *\n+   * @param plan\n+   * @return OK if over half of the followers accept the log or null if the leadership is lost\n+   * during the appending\n+   */\n+  TSStatus processPlanLocally(PhysicalPlan plan) {\n+    logger.debug(\"{}: Processing plan {}\", name, plan);\n+    if (readOnly) {\n+      return StatusUtils.NODE_READ_ONLY;\n+    }\n \n-        PhysicalPlanLog log = new PhysicalPlanLog();\n-        // assign term and index to the new log and append it\n-        synchronized (logManager) {\n-          log.setCurrLogTerm(getTerm().get());\n-          log.setPreviousLogIndex(logManager.getLastLogIndex());\n-          log.setPreviousLogTerm(logManager.getLastLogTerm());\n-          log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n+    PhysicalPlanLog log = new PhysicalPlanLog();\n+    // assign term and index to the new log and append it\n+    synchronized (logManager) {\n+      log.setCurrLogTerm(getTerm().get());\n+      log.setPreviousLogIndex(logManager.getLastLogIndex());\n+      log.setPreviousLogTerm(logManager.getLastLogTerm());\n+      log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-          log.setPlan(plan);\n-          logManager.appendLog(log);\n-        }\n+      log.setPlan(plan);\n+      logManager.appendLog(log);\n+    }\n \n-        if (appendLogInGroup(log)) {\n-          return StatusUtils.OK;\n-        }\n-        return null;\n-      }\n+    if (appendLogInGroup(log)) {\n+      return StatusUtils.OK;\n+    }\n+    return null;\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n-       * send it to followers depends on the implementation of executeNonQuery()).\n-       *\n-       =======\n-       * Append a log to all followers in the group until half of them accept the log or the\n-       * leadership is lost.\n-       * @param log\n-       * @return true if the log is accepted by the quorum of the group, false otherwise\n-       */\n-      protected boolean appendLogInGroup (Log log){\n-        int retryTime = 0;\n-        retry:\n-        while (true) {\n-          logger.debug(\"{}: Send log {} to other nodes, retry times: {}\", name, log, retryTime);\n-          AppendLogResult result = sendLogToFollowers(log, allNodes.size() / 2);\n-          switch (result) {\n-            case OK:\n-              logger.debug(\"{}: log {} is accepted\", name, log);\n-              logManager.commitLog(log.getCurrLogIndex());\n-              return true;\n-            case TIME_OUT:\n-              logger.debug(\"{}: log {} timed out, retrying...\", name, log);\n-              retryTime++;\n-              break;\n-            case LEADERSHIP_STALE:\n-              // abort the appending, the new leader will fix the local logs by catch-up\n-            default:\n-              break retry;\n-          }\n-        }\n-        return false;\n+\n+  /**\n+   * Append a log to all followers in the group until half of them accept the log or the leadership\n+   * is lost.\n+   *\n+   * @param log\n+   * @return true if the log is accepted by the quorum of the group, false otherwise\n+   */\n+  protected boolean appendLogInGroup(Log log) {\n+    int retryTime = 0;\n+    retry:\n+    while (true) {\n+      logger.debug(\"{}: Send log {} to other nodes, retry times: {}\", name, log, retryTime);\n+      AppendLogResult result = sendLogToFollowers(log, allNodes.size() / 2);\n+      switch (result) {\n+        case OK:\n+          logger.debug(\"{}: log {} is accepted\", name, log);\n+          logManager.commitLog(log.getCurrLogIndex());\n+          return true;\n+        case TIME_OUT:\n+          logger.debug(\"{}: log {} timed out, retrying...\", name, log);\n+          retryTime++;\n+          break;\n+        case LEADERSHIP_STALE:\n+          // abort the appending, the new leader will fix the local logs by catch-up\n+        default:\n+          break retry;\n       }\n+    }\n+    return false;\n+  }\n \n-      /**\n-       * If the node is not a leader, the request will be sent to the leader or reports an error if\n-       * there is no leader.\n-       * Otherwise execute the plan locally (whether to send it to followers depends on the\n-       * type of the plan).\n-       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param request\n-       * @param resultHandler\n-       */\n-      public void executeNonQueryPlan (ExecutNonQueryReq request,\n-          AsyncMethodCallback < TSStatus > resultHandler){\n-        if (character != NodeCharacter.LEADER) {\n-          // forward the plan to the leader\n-          AsyncClient client = connectNode(leader);\n-          if (client != null) {\n-            try {\n-              client.executeNonQueryPlan(request, resultHandler);\n-            } catch (TException e) {\n-              resultHandler.onError(e);\n-            }\n-          } else {\n-            resultHandler.onComplete(StatusUtils.NO_LEADER);\n-          }\n-          return;\n-        }\n+  /**\n+   * If the node is not a leader, the request will be sent to the leader or reports an error if\n+   * there is no leader. Otherwise execute the plan locally (whether to send it to followers depends\n+   * on the type of the plan).\n+   *\n+   * @param request\n+   * @param resultHandler\n+   */\n+  public void executeNonQueryPlan(ExecutNonQueryReq request,\n+      AsyncMethodCallback<TSStatus> resultHandler) {\n+    if (character != NodeCharacter.LEADER) {\n+      // forward the plan to the leader\n+      AsyncClient client = connectNode(leader);\n+      if (client != null) {\n         try {\n-          // process the plan locally\n-          PhysicalPlan plan = PhysicalPlan.Factory.create(request.planBytes);\n-          logger.debug(\"{}: Received a plan {}\", name, plan);\n-          resultHandler.onComplete(executeNonQuery(plan));\n-        } catch (Exception e) {\n+          client.executeNonQueryPlan(request, resultHandler);\n+        } catch (TException e) {\n           resultHandler.onError(e);\n         }\n+      } else {\n+        resultHandler.onComplete(StatusUtils.NO_LEADER);\n       }\n+      return;\n+    }\n+    try {\n+      // process the plan locally\n+      PhysicalPlan plan = PhysicalPlan.Factory.create(request.planBytes);\n+      logger.debug(\"{}: Received a plan {}\", name, plan);\n+      resultHandler.onComplete(executeNonQuery(plan));\n+    } catch (Exception e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n \n-      /**\n-       * Request and check the leader's commitId to see whether this node has caught up. If not, wait\n-       * until this node catches up.\n-       *\n-       * @return true if the node has caught up, false otherwise\n-       */\n-      public boolean syncLeader () {\n-        if (character == NodeCharacter.LEADER) {\n-          return true;\n-        }\n-        if (leader == null) {\n-          // the leader has not been elected, we must assume the node falls behind\n-          return false;\n-        }\n-        logger.debug(\"{}: try synchronizing with the leader {}\", name, leader);\n-        long startTime = System.currentTimeMillis();\n-        long waitedTime = 0;\n-        AtomicReference<Long> commitIdResult = new AtomicReference<>(Long.MAX_VALUE);\n-        while (waitedTime < RaftServer.syncLeaderMaxWaitMs) {\n-          AsyncClient client = connectNode(leader);\n-          if (client == null) {\n-            // cannot connect to the leader\n-            return false;\n-          }\n-          try {\n-            synchronized (commitIdResult) {\n-              client.requestCommitIndex(getHeader(), new GenericHandler<>(leader, commitIdResult));\n-              commitIdResult.wait(RaftServer.syncLeaderMaxWaitMs);\n-            }\n-            long leaderCommitId = commitIdResult.get();\n-            long localCommitId = logManager.getCommitLogIndex();\n-            logger\n-                .debug(\"{}: synchronizing commitIndex {}/{}\", name, localCommitId, leaderCommitId);\n-            if (leaderCommitId <= localCommitId) {\n-              // before the response comes, the leader may commit new logs and the localCommitId may be\n-              // updated by catching up, so it is possible that localCommitId > leaderCommitId at\n-              // this time\n-              // this node has caught up\n-              if (logger.isDebugEnabled()) {\n-                waitedTime = System.currentTimeMillis() - startTime;\n-                logger.debug(\"{}: synchronized with the leader after {}ms\", name, waitedTime);\n-              }\n-              return true;\n-            }\n-            // wait for next heartbeat to catch up\n-            // the local node will not perform a commit here according to the leaderCommitId because\n-            // the node may have some inconsistent logs with the leader\n-            waitedTime = System.currentTimeMillis() - startTime;\n-            synchronized (syncLock) {\n-              syncLock.wait(RaftServer.heartBeatIntervalMs);\n-            }\n-          } catch (TException | InterruptedException e) {\n-            logger.error(\"{}: Cannot request commit index from {}\", name, leader, e);\n-          }\n-        }\n+  /**\n+   * Request and check the leader's commitId to see whether this node has caught up. If not, wait\n+   * until this node catches up.\n+   *\n+   * @return true if the node has caught up, false otherwise\n+   */\n+  public boolean syncLeader() {\n+    if (character == NodeCharacter.LEADER) {\n+      return true;\n+    }\n+    if (leader == null) {\n+      // the leader has not been elected, we must assume the node falls behind\n+      return false;\n+    }\n+    logger.debug(\"{}: try synchronizing with the leader {}\", name, leader);\n+    long startTime = System.currentTimeMillis();\n+    long waitedTime = 0;\n+    AtomicReference<Long> commitIdResult = new AtomicReference<>(Long.MAX_VALUE);\n+    while (waitedTime < RaftServer.syncLeaderMaxWaitMs) {\n+      AsyncClient client = connectNode(leader);\n+      if (client == null) {\n+        // cannot connect to the leader\n         return false;\n       }\n-\n-      /**\n-       * Execute a non-query plan.\n-       * @param plan a non-query plan.\n-       * @return A TSStatus indicating the execution result.\n-       */\n-      abstract TSStatus executeNonQuery (PhysicalPlan plan);\n-\n-      /**\n-       * Tell the requester the current commit index if the local node is the leader of the group\n-       * headed by header. Or forward it to the leader. Otherwise report an error.\n-       * @param header to determine the DataGroupMember in data groups\n-       * @param resultHandler\n-       */\n-      @Override\n-      public void requestCommitIndex (Node header, AsyncMethodCallback < Long > resultHandler){\n-        if (character == NodeCharacter.LEADER) {\n-          resultHandler.onComplete(logManager.getCommitLogIndex());\n-          return;\n+      try {\n+        synchronized (commitIdResult) {\n+          client.requestCommitIndex(getHeader(), new GenericHandler<>(leader, commitIdResult));\n+          commitIdResult.wait(RaftServer.syncLeaderMaxWaitMs);\n         }\n-        AsyncClient client = connectNode(leader);\n-        if (client == null) {\n-          resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n-          return;\n+        long leaderCommitId = commitIdResult.get();\n+        long localCommitId = logManager.getCommitLogIndex();\n+        logger.debug(\"{}: synchronizing commitIndex {}/{}\", name, localCommitId, leaderCommitId);\n+        if (leaderCommitId <= localCommitId) {\n+          // before the response comes, the leader may commit new logs and the localCommitId may be\n+          // updated by catching up, so it is possible that localCommitId > leaderCommitId at\n+          // this time\n+          // this node has caught up\n+          if (logger.isDebugEnabled()) {\n+            waitedTime = System.currentTimeMillis() - startTime;\n+            logger.debug(\"{}: synchronized with the leader after {}ms\", name, waitedTime);\n+          }\n+          return true;\n         }\n-        try {\n-          client.requestCommitIndex(header, resultHandler);\n-        } catch (TException e) {\n-          resultHandler.onError(e);\n+        // wait for next heartbeat to catch up\n+        // the local node will not perform a commit here according to the leaderCommitId because\n+        // the node may have some inconsistent logs with the leader\n+        waitedTime = System.currentTimeMillis() - startTime;\n+        synchronized (syncLock) {\n+          syncLock.wait(RaftServer.heartBeatIntervalMs);\n         }\n+      } catch (TException | InterruptedException e) {\n+        logger.error(\"{}: Cannot request commit index from {}\", name, leader, e);\n       }\n+    }\n+    return false;\n+  }\n \n-      /**\n-       * An ftp-like interface that is used for a node to pull chunks of files like TsFiles.\n-       * @param filePath\n-       * @param offset\n-       * @param length\n-       * @param header to determine the DataGroupMember in data groups\n-       * @param resultHandler\n-       */\n-      @Override\n-      public void readFile (String filePath,long offset, int length, Node header,\n-          AsyncMethodCallback < ByteBuffer > resultHandler){\n-        try (BufferedInputStream bufferedInputStream =\n-            new BufferedInputStream(new FileInputStream(filePath))) {\n-          bufferedInputStream.skip(offset);\n-          byte[] bytes = new byte[length];\n-          ByteBuffer result = ByteBuffer.wrap(bytes);\n-          int len = bufferedInputStream.read(bytes);\n-          result.limit(Math.max(len, 0));\n-\n-          resultHandler.onComplete(result);\n-        } catch (IOException e) {\n-          resultHandler.onError(e);\n-        }\n-      }\n+  /**\n+   * Execute a non-query plan.\n+   *\n+   * @param plan a non-query plan.\n+   * @return A TSStatus indicating the execution result.\n+   */\n+  abstract TSStatus executeNonQuery(PhysicalPlan plan);\n \n-      public void setReadOnly () {\n-        synchronized (logManager) {\n-          readOnly = true;\n-        }\n-      }\n+  /**\n+   * Tell the requester the current commit index if the local node is the leader of the group headed\n+   * by header. Or forward it to the leader. Otherwise report an error.\n+   *\n+   * @param header        to determine the DataGroupMember in data groups\n+   * @param resultHandler\n+   */\n+  @Override\n+  public void requestCommitIndex(Node header, AsyncMethodCallback<Long> resultHandler) {\n+    if (character == NodeCharacter.LEADER) {\n+      resultHandler.onComplete(logManager.getCommitLogIndex());\n+      return;\n+    }\n+    AsyncClient client = connectNode(leader);\n+    if (client == null) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    try {\n+      client.requestCommitIndex(header, resultHandler);\n+    } catch (TException e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n \n-      public void setAllNodes (List < Node > allNodes) {\n-        this.allNodes = allNodes;\n-      }\n+  /**\n+   * An ftp-like interface that is used for a node to pull chunks of files like TsFiles.\n+   *\n+   * @param filePath\n+   * @param offset\n+   * @param length\n+   * @param header        to determine the DataGroupMember in data groups\n+   * @param resultHandler\n+   */\n+  @Override\n+  public void readFile(String filePath, long offset, int length, Node header,\n+      AsyncMethodCallback<ByteBuffer> resultHandler) {\n+    try (BufferedInputStream bufferedInputStream =\n+        new BufferedInputStream(new FileInputStream(filePath))) {\n+      bufferedInputStream.skip(offset);\n+      byte[] bytes = new byte[length];\n+      ByteBuffer result = ByteBuffer.wrap(bytes);\n+      int len = bufferedInputStream.read(bytes);\n+      result.limit(Math.max(len, 0));\n+\n+      resultHandler.onComplete(result);\n+    } catch (IOException e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n+\n+  public void setReadOnly() {\n+    synchronized (logManager) {\n+      readOnly = true;\n     }\n+  }\n+\n+  public void setAllNodes(List<Node> allNodes) {\n+    this.allNodes = allNodes;\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA1OA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395424058", "bodyText": "Conflict marks.", "author": "jt2594838", "createdAt": "2020-03-20T03:24:02Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param header must be set for data group communication, set to null for meta group\n+       *               communication\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n+        if (node == thisNode || node == null) {\n+          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+          return StatusUtils.NO_LEADER;\n+        }\n+\n+        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+\n+        AsyncClient client = connectNode(node);\n+        if (client != null) {\n+          return forwardPlan(plan, client, node, header);\n+        }\n+        return StatusUtils.TIME_OUT;\n       }\n-      synchronized (status) {\n-        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-        status.wait(RaftServer.connectionTimeoutInMS);\n+\n+      /**\n+       * Forward a non-query plan to \"receiver\" using \"client\".\n+       * @param plan a non-query plan\n+       * @param client\n+       * @param receiver\n+       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+        try {\n+          plan.serializeTo(dataOutputStream);\n+          AtomicReference<TSStatus> status = new AtomicReference<>();\n+          ExecutNonQueryReq req = new ExecutNonQueryReq();\n+          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+          if (header != null) {\n+            req.setHeader(header);\n+          }\n+          synchronized (status) {\n+            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+            status.wait(RaftServer.connectionTimeoutInMS);\n+          }\n+          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+        } catch (IOException | TException e) {\n+          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+          status.setMessage(e.getMessage());\n+          logger\n+              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+          return status;\n+        } catch (InterruptedException e) {\n+          return StatusUtils.TIME_OUT;\n+        }\n       }\n-      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-    } catch (IOException | TException e) {\n-      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-      status.setMessage(e.getMessage());\n-      logger.error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-      return status;\n-    } catch (InterruptedException e) {\n-      return StatusUtils.TIME_OUT;\n-    }\n-  }\n \n-  /**\n-   * Only the group leader can call this method. Will commit the log locally and send it to\n-   * followers\n-   *\n-   * @param plan\n-   * @return OK if over half of the followers accept the log or null if the leadership is lost\n-   * during the appending\n-   */\n-  TSStatus processPlanLocally(PhysicalPlan plan) {\n-    logger.debug(\"{}: Processing plan {}\", name, plan);\n-    if (readOnly) {\n-      return StatusUtils.NODE_READ_ONLY;\n-    }\n+      /**\n+       <<<<<<< HEAD\n+       * Only the group leader can call this method. Will commit the log locally and send it to\n+       * followers\n+       *\n+       =======\n+       * Create a log for \"plan\" and append it locally and to all followers.\n+       * Only the group leader can call this method.\n+       * Will commit the log locally and send it to followers\n+       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c", "originalCommit": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNjI4OA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395426288", "bodyText": "Thanks for your reminding. I will remove them.", "author": "Ring-k", "createdAt": "2020-03-20T03:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "5fcb9f0786aee2f36e1b224931059371cfc9b465", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\nindex 46d2ede210..2399c7f20b 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\n\n@@ -550,487 +550,477 @@ public abstract class RaftMember implements RaftService.AsyncIface {\n   }\n \n \n-    /**\n-     * Sub-classes will add their own process of HeartBeatResponse in this method.\n-     * @param response\n-     * @param receiver\n-     */\n-    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n+  /**\n+   * Sub-classes will add their own process of HeartBeatResponse in this method.\n+   *\n+   * @param response\n+   * @param receiver\n+   */\n+  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n \n-    }\n+  }\n \n-    /**\n-     * The actions performed when the node wins in an election (becoming a leader).\n-     */\n-    public void onElectionWins () {\n+  /**\n+   * The actions performed when the node wins in an election (becoming a leader).\n+   */\n+  public void onElectionWins() {\n \n-    }\n+  }\n \n \n-      /**\n-       * Sub-classes will add their own process of HeartBeatRequest in this method.\n-       * @param request\n-       * @param response\n-       */\n-      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n+  /**\n+   * Sub-classes will add their own process of HeartBeatRequest in this method.\n+   *\n+   * @param request\n+   * @param response\n+   */\n+  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n \n-      }\n+  }\n \n-      /**\n-       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-       * reset heartbeat timer.\n-       * @param newTerm\n-       */\n-      public void retireFromLeader ( long newTerm){\n-        synchronized (term) {\n-          long currTerm = term.get();\n-          // confirm that the heartbeat of the new leader hasn't come\n-          if (currTerm < newTerm) {\n-            term.set(newTerm);\n-            setCharacter(NodeCharacter.FOLLOWER);\n-            setLeader(null);\n-            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-          }\n-        }\n+  /**\n+   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and reset\n+   * heartbeat timer.\n+   *\n+   * @param newTerm\n+   */\n+  public void retireFromLeader(long newTerm) {\n+    synchronized (term) {\n+      long currTerm = term.get();\n+      // confirm that the heartbeat of the new leader hasn't come\n+      if (currTerm < newTerm) {\n+        term.set(newTerm);\n+        setCharacter(NodeCharacter.FOLLOWER);\n+        setLeader(null);\n+        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n       }\n+    }\n+  }\n \n-      /**\n-       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-       * request is valid.\n-       * @param electionRequest\n-       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-       */\n-      long processElectionRequest (ElectionRequest electionRequest){\n-\n-        long thatTerm = electionRequest.getTerm();\n-        long thatLastLogId = electionRequest.getLastLogIndex();\n-        long thatLastLogTerm = electionRequest.getLastLogTerm();\n-        logger\n-            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-                name, thatTerm,\n-                thatLastLogId, thatLastLogTerm);\n-\n-        long lastLogIndex = logManager.getLastLogIndex();\n-        long lastLogTerm = logManager.getLastLogTerm();\n-\n-        synchronized (term) {\n-          long thisTerm = term.get();\n-          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-              thatLastLogTerm);\n-          if (resp == Response.RESPONSE_AGREE) {\n-            term.set(thatTerm);\n-            setCharacter(NodeCharacter.FOLLOWER);\n-            lastHeartbeatReceivedTime = System.currentTimeMillis();\n-            leader = electionRequest.getElector();\n-            // interrupt election\n-            term.notifyAll();\n-          }\n-          return resp;\n-        }\n-      }\n+  /**\n+   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+   * request is valid.\n+   *\n+   * @param electionRequest\n+   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has a\n+   * smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+   */\n+  long processElectionRequest(ElectionRequest electionRequest) {\n \n-      /**\n-       *  Reject the election if one of the four holds:\n-       *   1. the term of the candidate is no bigger than the voter's\n-       *   2. the lastLogTerm of the candidate is smaller than the voter's\n-       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-       *      smaller than the voter's\n-       *   Otherwise accept the election.\n-       * @param thisTerm\n-       * @param thisLastLogIndex\n-       * @param thisLastLogTerm\n-       * @param thatTerm\n-       * @param thatLastLogId\n-       * @param thatLastLogTerm\n-       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-       */\n-      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n-        long response;\n-        if (thatTerm <= thisTerm) {\n-          response = thisTerm;\n-          logger.debug(\"{} rejected an election request, term:{}/{}\",\n-              name, thatTerm, thisTerm);\n-        } else if (thatLastLogTerm < thisLastLogTerm\n-            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-          response = Response.RESPONSE_LOG_MISMATCH;\n-        } else {\n-          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-              thisLastLogTerm);\n-          response = Response.RESPONSE_AGREE;\n-        }\n-        return response;\n+    long thatTerm = electionRequest.getTerm();\n+    long thatLastLogId = electionRequest.getLastLogIndex();\n+    long thatLastLogTerm = electionRequest.getLastLogTerm();\n+    logger\n+        .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+            name, thatTerm,\n+            thatLastLogId, thatLastLogTerm);\n+\n+    long lastLogIndex = logManager.getLastLogIndex();\n+    long lastLogTerm = logManager.getLastLogTerm();\n+\n+    synchronized (term) {\n+      long thisTerm = term.get();\n+      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+          thatLastLogTerm);\n+      if (resp == Response.RESPONSE_AGREE) {\n+        term.set(thatTerm);\n+        setCharacter(NodeCharacter.FOLLOWER);\n+        lastHeartbeatReceivedTime = System.currentTimeMillis();\n+        leader = electionRequest.getElector();\n+        // interrupt election\n+        term.notifyAll();\n       }\n+      return resp;\n+    }\n+  }\n \n-      /**\n-       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-       * follower. If some of the logs are not in memory, also send the snapshot.\n-       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-       *\n-       * @param follower\n-       * @param followerLastLogIndex\n-       */\n-      public void catchUp (Node follower,long followerLastLogIndex){\n-        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-        // for one follower, there is at most one ongoing catch-up\n-        synchronized (follower) {\n-          // check if the last catch-up is still ongoing\n-          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-          if (lastCatchupResp != null\n-              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-            return;\n-          } else {\n-            // record the start of the catch-up\n-            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n-          }\n-        }\n-        if (followerLastLogIndex == -1) {\n-          // if the follower does not have any logs, send from the first one\n-          followerLastLogIndex = 0;\n-        }\n+  /**\n+   * Reject the election if one of the four holds: 1. the term of the candidate is no bigger than\n+   * the voter's 2. the lastLogTerm of the candidate is smaller than the voter's 3. the lastLogTerm\n+   * of the candidate equals to the voter's but its lastLogIndex is smaller than the voter's\n+   * Otherwise accept the election.\n+   *\n+   * @param thisTerm\n+   * @param thisLastLogIndex\n+   * @param thisLastLogTerm\n+   * @param thatTerm\n+   * @param thatLastLogId\n+   * @param thatLastLogTerm\n+   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has a\n+   * smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+   */\n+  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n+    long response;\n+    if (thatTerm <= thisTerm) {\n+      response = thisTerm;\n+      logger.debug(\"{} rejected an election request, term:{}/{}\",\n+          name, thatTerm, thisTerm);\n+    } else if (thatLastLogTerm < thisLastLogTerm\n+        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+      response = Response.RESPONSE_LOG_MISMATCH;\n+    } else {\n+      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+          thisLastLogTerm);\n+      response = Response.RESPONSE_AGREE;\n+    }\n+    return response;\n+  }\n \n-        AsyncClient client = connectNode(follower);\n-        if (client != null) {\n-          List<Log> logs;\n-          boolean allLogsValid;\n-          Snapshot snapshot = null;\n-          synchronized (logManager) {\n-            // check if the very first log has been snapshot\n-            allLogsValid = logManager.logValid(followerLastLogIndex);\n-            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-            if (!allLogsValid) {\n-              // if the first log has been snapshot, the snapshot should also be sent to the\n-              // follower, otherwise some data will be missing\n-              snapshot = logManager.getSnapshot();\n-            }\n-          }\n+  /**\n+   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+   * follower. If some of the logs are not in memory, also send the snapshot.\n+   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+   *\n+   * @param follower\n+   * @param followerLastLogIndex\n+   */\n+  public void catchUp(Node follower, long followerLastLogIndex) {\n+    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+    // for one follower, there is at most one ongoing catch-up\n+    synchronized (follower) {\n+      // check if the last catch-up is still ongoing\n+      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+      if (lastCatchupResp != null\n+          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+        return;\n+      } else {\n+        // record the start of the catch-up\n+        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      }\n+    }\n+    if (followerLastLogIndex == -1) {\n+      // if the follower does not have any logs, send from the first one\n+      followerLastLogIndex = 0;\n+    }\n \n-          if (allLogsValid) {\n-            if (logger.isDebugEnabled()) {\n-              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n-            }\n-            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-          } else {\n-            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n-          }\n-        } else {\n-          lastCatchUpResponseTime.remove(follower);\n-          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+    AsyncClient client = connectNode(follower);\n+    if (client != null) {\n+      List<Log> logs;\n+      boolean allLogsValid;\n+      Snapshot snapshot = null;\n+      synchronized (logManager) {\n+        // check if the very first log has been snapshot\n+        allLogsValid = logManager.logValid(followerLastLogIndex);\n+        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+        if (!allLogsValid) {\n+          // if the first log has been snapshot, the snapshot should also be sent to the\n+          // follower, otherwise some data will be missing\n+          snapshot = logManager.getSnapshot();\n         }\n       }\n \n-      public String getName () {\n-        return name;\n+      if (allLogsValid) {\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+        }\n+        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+      } else {\n+        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n       }\n+    } else {\n+      lastCatchUpResponseTime.remove(follower);\n+      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+    }\n+  }\n \n-      /**\n-       * @return the header of the data raft group or null if this is in a meta group.\n-       */\n-      public Node getHeader () {\n-        return null;\n-      }\n+  public String getName() {\n+    return name;\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * Forward a plan to a node using the default client.\n-       *\n-       * @param plan\n-       * @param node\n-      =======\n-       * Forward a non-query plan to a node using the default client.\n-       * @param plan a non-query plan\n-       * @param node cannot be the local node\n-      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param header must be set for data group communication, set to null for meta group\n-       *               communication\n-       * @return a TSStatus indicating if the forwarding is successful.\n-       */\n-      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n-        if (node == thisNode || node == null) {\n-          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-          return StatusUtils.NO_LEADER;\n-        }\n+  /**\n+   * @return the header of the data raft group or null if this is in a meta group.\n+   */\n+  public Node getHeader() {\n+    return null;\n+  }\n+\n+  /**\n+   * Forward a non-query plan to a node using the default client.\n+   *\n+   * @param plan   a non-query plan\n+   * @param node   cannot be the local node\n+   * @param header must be set for data group communication, set to null for meta group\n+   *               communication\n+   * @return a TSStatus indicating if the forwarding is successful.\n+   */\n+  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n+    if (node == thisNode || node == null) {\n+      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+      return StatusUtils.NO_LEADER;\n+    }\n \n-        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n \n-        AsyncClient client = connectNode(node);\n-        if (client != null) {\n-          return forwardPlan(plan, client, node, header);\n-        }\n-        return StatusUtils.TIME_OUT;\n-      }\n+    AsyncClient client = connectNode(node);\n+    if (client != null) {\n+      return forwardPlan(plan, client, node, header);\n+    }\n+    return StatusUtils.TIME_OUT;\n+  }\n \n-      /**\n-       * Forward a non-query plan to \"receiver\" using \"client\".\n-       * @param plan a non-query plan\n-       * @param client\n-       * @param receiver\n-       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-       * @return a TSStatus indicating if the forwarding is successful.\n-       */\n-      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-        try {\n-          plan.serializeTo(dataOutputStream);\n-          AtomicReference<TSStatus> status = new AtomicReference<>();\n-          ExecutNonQueryReq req = new ExecutNonQueryReq();\n-          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-          if (header != null) {\n-            req.setHeader(header);\n-          }\n-          synchronized (status) {\n-            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-            status.wait(RaftServer.connectionTimeoutInMS);\n-          }\n-          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-        } catch (IOException | TException e) {\n-          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-          status.setMessage(e.getMessage());\n-          logger\n-              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-          return status;\n-        } catch (InterruptedException e) {\n-          return StatusUtils.TIME_OUT;\n-        }\n+  /**\n+   * Forward a non-query plan to \"receiver\" using \"client\".\n+   *\n+   * @param plan     a non-query plan\n+   * @param client\n+   * @param receiver\n+   * @param header   to determine which DataGroupMember of \"receiver\" will process the request.\n+   * @return a TSStatus indicating if the forwarding is successful.\n+   */\n+  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+    try {\n+      plan.serializeTo(dataOutputStream);\n+      AtomicReference<TSStatus> status = new AtomicReference<>();\n+      ExecutNonQueryReq req = new ExecutNonQueryReq();\n+      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+      if (header != null) {\n+        req.setHeader(header);\n       }\n+      synchronized (status) {\n+        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+        status.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+    } catch (IOException | TException e) {\n+      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+      status.setMessage(e.getMessage());\n+      logger\n+          .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+      return status;\n+    } catch (InterruptedException e) {\n+      return StatusUtils.TIME_OUT;\n+    }\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * Only the group leader can call this method. Will commit the log locally and send it to\n-       * followers\n-       *\n-       =======\n-       * Create a log for \"plan\" and append it locally and to all followers.\n-       * Only the group leader can call this method.\n-       * Will commit the log locally and send it to followers\n-       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param plan\n-       * @return OK if over half of the followers accept the log or null if the leadership is lost\n-       * during the appending\n-       */\n-      TSStatus processPlanLocally (PhysicalPlan plan){\n-        logger.debug(\"{}: Processing plan {}\", name, plan);\n-        if (readOnly) {\n-          return StatusUtils.NODE_READ_ONLY;\n-        }\n+  /**\n+   * Create a log for \"plan\" and append it locally and to all followers. Only the group leader can\n+   * call this method. Will commit the log locally and send it to followers\n+   *\n+   * @param plan\n+   * @return OK if over half of the followers accept the log or null if the leadership is lost\n+   * during the appending\n+   */\n+  TSStatus processPlanLocally(PhysicalPlan plan) {\n+    logger.debug(\"{}: Processing plan {}\", name, plan);\n+    if (readOnly) {\n+      return StatusUtils.NODE_READ_ONLY;\n+    }\n \n-        PhysicalPlanLog log = new PhysicalPlanLog();\n-        // assign term and index to the new log and append it\n-        synchronized (logManager) {\n-          log.setCurrLogTerm(getTerm().get());\n-          log.setPreviousLogIndex(logManager.getLastLogIndex());\n-          log.setPreviousLogTerm(logManager.getLastLogTerm());\n-          log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n+    PhysicalPlanLog log = new PhysicalPlanLog();\n+    // assign term and index to the new log and append it\n+    synchronized (logManager) {\n+      log.setCurrLogTerm(getTerm().get());\n+      log.setPreviousLogIndex(logManager.getLastLogIndex());\n+      log.setPreviousLogTerm(logManager.getLastLogTerm());\n+      log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-          log.setPlan(plan);\n-          logManager.appendLog(log);\n-        }\n+      log.setPlan(plan);\n+      logManager.appendLog(log);\n+    }\n \n-        if (appendLogInGroup(log)) {\n-          return StatusUtils.OK;\n-        }\n-        return null;\n-      }\n+    if (appendLogInGroup(log)) {\n+      return StatusUtils.OK;\n+    }\n+    return null;\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n-       * send it to followers depends on the implementation of executeNonQuery()).\n-       *\n-       =======\n-       * Append a log to all followers in the group until half of them accept the log or the\n-       * leadership is lost.\n-       * @param log\n-       * @return true if the log is accepted by the quorum of the group, false otherwise\n-       */\n-      protected boolean appendLogInGroup (Log log){\n-        int retryTime = 0;\n-        retry:\n-        while (true) {\n-          logger.debug(\"{}: Send log {} to other nodes, retry times: {}\", name, log, retryTime);\n-          AppendLogResult result = sendLogToFollowers(log, allNodes.size() / 2);\n-          switch (result) {\n-            case OK:\n-              logger.debug(\"{}: log {} is accepted\", name, log);\n-              logManager.commitLog(log.getCurrLogIndex());\n-              return true;\n-            case TIME_OUT:\n-              logger.debug(\"{}: log {} timed out, retrying...\", name, log);\n-              retryTime++;\n-              break;\n-            case LEADERSHIP_STALE:\n-              // abort the appending, the new leader will fix the local logs by catch-up\n-            default:\n-              break retry;\n-          }\n-        }\n-        return false;\n+\n+  /**\n+   * Append a log to all followers in the group until half of them accept the log or the leadership\n+   * is lost.\n+   *\n+   * @param log\n+   * @return true if the log is accepted by the quorum of the group, false otherwise\n+   */\n+  protected boolean appendLogInGroup(Log log) {\n+    int retryTime = 0;\n+    retry:\n+    while (true) {\n+      logger.debug(\"{}: Send log {} to other nodes, retry times: {}\", name, log, retryTime);\n+      AppendLogResult result = sendLogToFollowers(log, allNodes.size() / 2);\n+      switch (result) {\n+        case OK:\n+          logger.debug(\"{}: log {} is accepted\", name, log);\n+          logManager.commitLog(log.getCurrLogIndex());\n+          return true;\n+        case TIME_OUT:\n+          logger.debug(\"{}: log {} timed out, retrying...\", name, log);\n+          retryTime++;\n+          break;\n+        case LEADERSHIP_STALE:\n+          // abort the appending, the new leader will fix the local logs by catch-up\n+        default:\n+          break retry;\n       }\n+    }\n+    return false;\n+  }\n \n-      /**\n-       * If the node is not a leader, the request will be sent to the leader or reports an error if\n-       * there is no leader.\n-       * Otherwise execute the plan locally (whether to send it to followers depends on the\n-       * type of the plan).\n-       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param request\n-       * @param resultHandler\n-       */\n-      public void executeNonQueryPlan (ExecutNonQueryReq request,\n-          AsyncMethodCallback < TSStatus > resultHandler){\n-        if (character != NodeCharacter.LEADER) {\n-          // forward the plan to the leader\n-          AsyncClient client = connectNode(leader);\n-          if (client != null) {\n-            try {\n-              client.executeNonQueryPlan(request, resultHandler);\n-            } catch (TException e) {\n-              resultHandler.onError(e);\n-            }\n-          } else {\n-            resultHandler.onComplete(StatusUtils.NO_LEADER);\n-          }\n-          return;\n-        }\n+  /**\n+   * If the node is not a leader, the request will be sent to the leader or reports an error if\n+   * there is no leader. Otherwise execute the plan locally (whether to send it to followers depends\n+   * on the type of the plan).\n+   *\n+   * @param request\n+   * @param resultHandler\n+   */\n+  public void executeNonQueryPlan(ExecutNonQueryReq request,\n+      AsyncMethodCallback<TSStatus> resultHandler) {\n+    if (character != NodeCharacter.LEADER) {\n+      // forward the plan to the leader\n+      AsyncClient client = connectNode(leader);\n+      if (client != null) {\n         try {\n-          // process the plan locally\n-          PhysicalPlan plan = PhysicalPlan.Factory.create(request.planBytes);\n-          logger.debug(\"{}: Received a plan {}\", name, plan);\n-          resultHandler.onComplete(executeNonQuery(plan));\n-        } catch (Exception e) {\n+          client.executeNonQueryPlan(request, resultHandler);\n+        } catch (TException e) {\n           resultHandler.onError(e);\n         }\n+      } else {\n+        resultHandler.onComplete(StatusUtils.NO_LEADER);\n       }\n+      return;\n+    }\n+    try {\n+      // process the plan locally\n+      PhysicalPlan plan = PhysicalPlan.Factory.create(request.planBytes);\n+      logger.debug(\"{}: Received a plan {}\", name, plan);\n+      resultHandler.onComplete(executeNonQuery(plan));\n+    } catch (Exception e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n \n-      /**\n-       * Request and check the leader's commitId to see whether this node has caught up. If not, wait\n-       * until this node catches up.\n-       *\n-       * @return true if the node has caught up, false otherwise\n-       */\n-      public boolean syncLeader () {\n-        if (character == NodeCharacter.LEADER) {\n-          return true;\n-        }\n-        if (leader == null) {\n-          // the leader has not been elected, we must assume the node falls behind\n-          return false;\n-        }\n-        logger.debug(\"{}: try synchronizing with the leader {}\", name, leader);\n-        long startTime = System.currentTimeMillis();\n-        long waitedTime = 0;\n-        AtomicReference<Long> commitIdResult = new AtomicReference<>(Long.MAX_VALUE);\n-        while (waitedTime < RaftServer.syncLeaderMaxWaitMs) {\n-          AsyncClient client = connectNode(leader);\n-          if (client == null) {\n-            // cannot connect to the leader\n-            return false;\n-          }\n-          try {\n-            synchronized (commitIdResult) {\n-              client.requestCommitIndex(getHeader(), new GenericHandler<>(leader, commitIdResult));\n-              commitIdResult.wait(RaftServer.syncLeaderMaxWaitMs);\n-            }\n-            long leaderCommitId = commitIdResult.get();\n-            long localCommitId = logManager.getCommitLogIndex();\n-            logger\n-                .debug(\"{}: synchronizing commitIndex {}/{}\", name, localCommitId, leaderCommitId);\n-            if (leaderCommitId <= localCommitId) {\n-              // before the response comes, the leader may commit new logs and the localCommitId may be\n-              // updated by catching up, so it is possible that localCommitId > leaderCommitId at\n-              // this time\n-              // this node has caught up\n-              if (logger.isDebugEnabled()) {\n-                waitedTime = System.currentTimeMillis() - startTime;\n-                logger.debug(\"{}: synchronized with the leader after {}ms\", name, waitedTime);\n-              }\n-              return true;\n-            }\n-            // wait for next heartbeat to catch up\n-            // the local node will not perform a commit here according to the leaderCommitId because\n-            // the node may have some inconsistent logs with the leader\n-            waitedTime = System.currentTimeMillis() - startTime;\n-            synchronized (syncLock) {\n-              syncLock.wait(RaftServer.heartBeatIntervalMs);\n-            }\n-          } catch (TException | InterruptedException e) {\n-            logger.error(\"{}: Cannot request commit index from {}\", name, leader, e);\n-          }\n-        }\n+  /**\n+   * Request and check the leader's commitId to see whether this node has caught up. If not, wait\n+   * until this node catches up.\n+   *\n+   * @return true if the node has caught up, false otherwise\n+   */\n+  public boolean syncLeader() {\n+    if (character == NodeCharacter.LEADER) {\n+      return true;\n+    }\n+    if (leader == null) {\n+      // the leader has not been elected, we must assume the node falls behind\n+      return false;\n+    }\n+    logger.debug(\"{}: try synchronizing with the leader {}\", name, leader);\n+    long startTime = System.currentTimeMillis();\n+    long waitedTime = 0;\n+    AtomicReference<Long> commitIdResult = new AtomicReference<>(Long.MAX_VALUE);\n+    while (waitedTime < RaftServer.syncLeaderMaxWaitMs) {\n+      AsyncClient client = connectNode(leader);\n+      if (client == null) {\n+        // cannot connect to the leader\n         return false;\n       }\n-\n-      /**\n-       * Execute a non-query plan.\n-       * @param plan a non-query plan.\n-       * @return A TSStatus indicating the execution result.\n-       */\n-      abstract TSStatus executeNonQuery (PhysicalPlan plan);\n-\n-      /**\n-       * Tell the requester the current commit index if the local node is the leader of the group\n-       * headed by header. Or forward it to the leader. Otherwise report an error.\n-       * @param header to determine the DataGroupMember in data groups\n-       * @param resultHandler\n-       */\n-      @Override\n-      public void requestCommitIndex (Node header, AsyncMethodCallback < Long > resultHandler){\n-        if (character == NodeCharacter.LEADER) {\n-          resultHandler.onComplete(logManager.getCommitLogIndex());\n-          return;\n+      try {\n+        synchronized (commitIdResult) {\n+          client.requestCommitIndex(getHeader(), new GenericHandler<>(leader, commitIdResult));\n+          commitIdResult.wait(RaftServer.syncLeaderMaxWaitMs);\n         }\n-        AsyncClient client = connectNode(leader);\n-        if (client == null) {\n-          resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n-          return;\n+        long leaderCommitId = commitIdResult.get();\n+        long localCommitId = logManager.getCommitLogIndex();\n+        logger.debug(\"{}: synchronizing commitIndex {}/{}\", name, localCommitId, leaderCommitId);\n+        if (leaderCommitId <= localCommitId) {\n+          // before the response comes, the leader may commit new logs and the localCommitId may be\n+          // updated by catching up, so it is possible that localCommitId > leaderCommitId at\n+          // this time\n+          // this node has caught up\n+          if (logger.isDebugEnabled()) {\n+            waitedTime = System.currentTimeMillis() - startTime;\n+            logger.debug(\"{}: synchronized with the leader after {}ms\", name, waitedTime);\n+          }\n+          return true;\n         }\n-        try {\n-          client.requestCommitIndex(header, resultHandler);\n-        } catch (TException e) {\n-          resultHandler.onError(e);\n+        // wait for next heartbeat to catch up\n+        // the local node will not perform a commit here according to the leaderCommitId because\n+        // the node may have some inconsistent logs with the leader\n+        waitedTime = System.currentTimeMillis() - startTime;\n+        synchronized (syncLock) {\n+          syncLock.wait(RaftServer.heartBeatIntervalMs);\n         }\n+      } catch (TException | InterruptedException e) {\n+        logger.error(\"{}: Cannot request commit index from {}\", name, leader, e);\n       }\n+    }\n+    return false;\n+  }\n \n-      /**\n-       * An ftp-like interface that is used for a node to pull chunks of files like TsFiles.\n-       * @param filePath\n-       * @param offset\n-       * @param length\n-       * @param header to determine the DataGroupMember in data groups\n-       * @param resultHandler\n-       */\n-      @Override\n-      public void readFile (String filePath,long offset, int length, Node header,\n-          AsyncMethodCallback < ByteBuffer > resultHandler){\n-        try (BufferedInputStream bufferedInputStream =\n-            new BufferedInputStream(new FileInputStream(filePath))) {\n-          bufferedInputStream.skip(offset);\n-          byte[] bytes = new byte[length];\n-          ByteBuffer result = ByteBuffer.wrap(bytes);\n-          int len = bufferedInputStream.read(bytes);\n-          result.limit(Math.max(len, 0));\n-\n-          resultHandler.onComplete(result);\n-        } catch (IOException e) {\n-          resultHandler.onError(e);\n-        }\n-      }\n+  /**\n+   * Execute a non-query plan.\n+   *\n+   * @param plan a non-query plan.\n+   * @return A TSStatus indicating the execution result.\n+   */\n+  abstract TSStatus executeNonQuery(PhysicalPlan plan);\n \n-      public void setReadOnly () {\n-        synchronized (logManager) {\n-          readOnly = true;\n-        }\n-      }\n+  /**\n+   * Tell the requester the current commit index if the local node is the leader of the group headed\n+   * by header. Or forward it to the leader. Otherwise report an error.\n+   *\n+   * @param header        to determine the DataGroupMember in data groups\n+   * @param resultHandler\n+   */\n+  @Override\n+  public void requestCommitIndex(Node header, AsyncMethodCallback<Long> resultHandler) {\n+    if (character == NodeCharacter.LEADER) {\n+      resultHandler.onComplete(logManager.getCommitLogIndex());\n+      return;\n+    }\n+    AsyncClient client = connectNode(leader);\n+    if (client == null) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    try {\n+      client.requestCommitIndex(header, resultHandler);\n+    } catch (TException e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n \n-      public void setAllNodes (List < Node > allNodes) {\n-        this.allNodes = allNodes;\n-      }\n+  /**\n+   * An ftp-like interface that is used for a node to pull chunks of files like TsFiles.\n+   *\n+   * @param filePath\n+   * @param offset\n+   * @param length\n+   * @param header        to determine the DataGroupMember in data groups\n+   * @param resultHandler\n+   */\n+  @Override\n+  public void readFile(String filePath, long offset, int length, Node header,\n+      AsyncMethodCallback<ByteBuffer> resultHandler) {\n+    try (BufferedInputStream bufferedInputStream =\n+        new BufferedInputStream(new FileInputStream(filePath))) {\n+      bufferedInputStream.skip(offset);\n+      byte[] bytes = new byte[length];\n+      ByteBuffer result = ByteBuffer.wrap(bytes);\n+      int len = bufferedInputStream.read(bytes);\n+      result.limit(Math.max(len, 0));\n+\n+      resultHandler.onComplete(result);\n+    } catch (IOException e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n+\n+  public void setReadOnly() {\n+    synchronized (logManager) {\n+      readOnly = true;\n     }\n+  }\n+\n+  public void setAllNodes(List<Node> allNodes) {\n+    this.allNodes = allNodes;\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA4Ng==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395424086", "bodyText": "Conflict marks.", "author": "jt2594838", "createdAt": "2020-03-20T03:24:13Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param header must be set for data group communication, set to null for meta group\n+       *               communication\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n+        if (node == thisNode || node == null) {\n+          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+          return StatusUtils.NO_LEADER;\n+        }\n+\n+        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+\n+        AsyncClient client = connectNode(node);\n+        if (client != null) {\n+          return forwardPlan(plan, client, node, header);\n+        }\n+        return StatusUtils.TIME_OUT;\n       }\n-      synchronized (status) {\n-        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-        status.wait(RaftServer.connectionTimeoutInMS);\n+\n+      /**\n+       * Forward a non-query plan to \"receiver\" using \"client\".\n+       * @param plan a non-query plan\n+       * @param client\n+       * @param receiver\n+       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+        try {\n+          plan.serializeTo(dataOutputStream);\n+          AtomicReference<TSStatus> status = new AtomicReference<>();\n+          ExecutNonQueryReq req = new ExecutNonQueryReq();\n+          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+          if (header != null) {\n+            req.setHeader(header);\n+          }\n+          synchronized (status) {\n+            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+            status.wait(RaftServer.connectionTimeoutInMS);\n+          }\n+          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+        } catch (IOException | TException e) {\n+          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+          status.setMessage(e.getMessage());\n+          logger\n+              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+          return status;\n+        } catch (InterruptedException e) {\n+          return StatusUtils.TIME_OUT;\n+        }\n       }\n-      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-    } catch (IOException | TException e) {\n-      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-      status.setMessage(e.getMessage());\n-      logger.error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-      return status;\n-    } catch (InterruptedException e) {\n-      return StatusUtils.TIME_OUT;\n-    }\n-  }\n \n-  /**\n-   * Only the group leader can call this method. Will commit the log locally and send it to\n-   * followers\n-   *\n-   * @param plan\n-   * @return OK if over half of the followers accept the log or null if the leadership is lost\n-   * during the appending\n-   */\n-  TSStatus processPlanLocally(PhysicalPlan plan) {\n-    logger.debug(\"{}: Processing plan {}\", name, plan);\n-    if (readOnly) {\n-      return StatusUtils.NODE_READ_ONLY;\n-    }\n+      /**\n+       <<<<<<< HEAD\n+       * Only the group leader can call this method. Will commit the log locally and send it to\n+       * followers\n+       *\n+       =======\n+       * Create a log for \"plan\" and append it locally and to all followers.\n+       * Only the group leader can call this method.\n+       * Will commit the log locally and send it to followers\n+       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param plan\n+       * @return OK if over half of the followers accept the log or null if the leadership is lost\n+       * during the appending\n+       */\n+      TSStatus processPlanLocally (PhysicalPlan plan){\n+        logger.debug(\"{}: Processing plan {}\", name, plan);\n+        if (readOnly) {\n+          return StatusUtils.NODE_READ_ONLY;\n+        }\n \n-    PhysicalPlanLog log = new PhysicalPlanLog();\n-    // assign term and index to the new log and append it\n-    synchronized (logManager) {\n-      log.setCurrLogTerm(getTerm().get());\n-      log.setPreviousLogIndex(logManager.getLastLogIndex());\n-      log.setPreviousLogTerm(logManager.getLastLogTerm());\n-      log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n+        PhysicalPlanLog log = new PhysicalPlanLog();\n+        // assign term and index to the new log and append it\n+        synchronized (logManager) {\n+          log.setCurrLogTerm(getTerm().get());\n+          log.setPreviousLogIndex(logManager.getLastLogIndex());\n+          log.setPreviousLogTerm(logManager.getLastLogTerm());\n+          log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-      log.setPlan(plan);\n-      logManager.appendLog(log);\n-    }\n+          log.setPlan(plan);\n+          logManager.appendLog(log);\n+        }\n \n-    if (appendLogInGroup(log)) {\n-      return StatusUtils.OK;\n-    }\n-    return null;\n-  }\n+        if (appendLogInGroup(log)) {\n+          return StatusUtils.OK;\n+        }\n+        return null;\n+      }\n \n-  /**\n-   * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n-   * send it to followers depends on the implementation of executeNonQuery()).\n-   *\n-   * @param request\n-   * @param resultHandler\n-   */\n-  public void executeNonQueryPlan(ExecutNonQueryReq request,\n-      AsyncMethodCallback<TSStatus> resultHandler) {\n-    if (character != NodeCharacter.LEADER) {\n-      // forward the plan to the leader\n-      AsyncClient client = connectNode(leader);\n-      if (client != null) {\n+      /**\n+       <<<<<<< HEAD\n+       * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n+       * send it to followers depends on the implementation of executeNonQuery()).\n+       *\n+       =======\n+       * Append a log to all followers in the group until half of them accept the log or the\n+       * leadership is lost.\n+       * @param log\n+       * @return true if the log is accepted by the quorum of the group, false otherwise", "originalCommit": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNjI5Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395426297", "bodyText": "Thanks for your reminding. I will remove them.", "author": "Ring-k", "createdAt": "2020-03-20T03:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5fcb9f0786aee2f36e1b224931059371cfc9b465", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\nindex 46d2ede210..2399c7f20b 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java\n\n@@ -550,487 +550,477 @@ public abstract class RaftMember implements RaftService.AsyncIface {\n   }\n \n \n-    /**\n-     * Sub-classes will add their own process of HeartBeatResponse in this method.\n-     * @param response\n-     * @param receiver\n-     */\n-    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n+  /**\n+   * Sub-classes will add their own process of HeartBeatResponse in this method.\n+   *\n+   * @param response\n+   * @param receiver\n+   */\n+  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n \n-    }\n+  }\n \n-    /**\n-     * The actions performed when the node wins in an election (becoming a leader).\n-     */\n-    public void onElectionWins () {\n+  /**\n+   * The actions performed when the node wins in an election (becoming a leader).\n+   */\n+  public void onElectionWins() {\n \n-    }\n+  }\n \n \n-      /**\n-       * Sub-classes will add their own process of HeartBeatRequest in this method.\n-       * @param request\n-       * @param response\n-       */\n-      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n+  /**\n+   * Sub-classes will add their own process of HeartBeatRequest in this method.\n+   *\n+   * @param request\n+   * @param response\n+   */\n+  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n \n-      }\n+  }\n \n-      /**\n-       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-       * reset heartbeat timer.\n-       * @param newTerm\n-       */\n-      public void retireFromLeader ( long newTerm){\n-        synchronized (term) {\n-          long currTerm = term.get();\n-          // confirm that the heartbeat of the new leader hasn't come\n-          if (currTerm < newTerm) {\n-            term.set(newTerm);\n-            setCharacter(NodeCharacter.FOLLOWER);\n-            setLeader(null);\n-            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-          }\n-        }\n+  /**\n+   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and reset\n+   * heartbeat timer.\n+   *\n+   * @param newTerm\n+   */\n+  public void retireFromLeader(long newTerm) {\n+    synchronized (term) {\n+      long currTerm = term.get();\n+      // confirm that the heartbeat of the new leader hasn't come\n+      if (currTerm < newTerm) {\n+        term.set(newTerm);\n+        setCharacter(NodeCharacter.FOLLOWER);\n+        setLeader(null);\n+        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n       }\n+    }\n+  }\n \n-      /**\n-       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-       * request is valid.\n-       * @param electionRequest\n-       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-       */\n-      long processElectionRequest (ElectionRequest electionRequest){\n-\n-        long thatTerm = electionRequest.getTerm();\n-        long thatLastLogId = electionRequest.getLastLogIndex();\n-        long thatLastLogTerm = electionRequest.getLastLogTerm();\n-        logger\n-            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-                name, thatTerm,\n-                thatLastLogId, thatLastLogTerm);\n-\n-        long lastLogIndex = logManager.getLastLogIndex();\n-        long lastLogTerm = logManager.getLastLogTerm();\n-\n-        synchronized (term) {\n-          long thisTerm = term.get();\n-          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-              thatLastLogTerm);\n-          if (resp == Response.RESPONSE_AGREE) {\n-            term.set(thatTerm);\n-            setCharacter(NodeCharacter.FOLLOWER);\n-            lastHeartbeatReceivedTime = System.currentTimeMillis();\n-            leader = electionRequest.getElector();\n-            // interrupt election\n-            term.notifyAll();\n-          }\n-          return resp;\n-        }\n-      }\n+  /**\n+   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+   * request is valid.\n+   *\n+   * @param electionRequest\n+   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has a\n+   * smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+   */\n+  long processElectionRequest(ElectionRequest electionRequest) {\n \n-      /**\n-       *  Reject the election if one of the four holds:\n-       *   1. the term of the candidate is no bigger than the voter's\n-       *   2. the lastLogTerm of the candidate is smaller than the voter's\n-       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-       *      smaller than the voter's\n-       *   Otherwise accept the election.\n-       * @param thisTerm\n-       * @param thisLastLogIndex\n-       * @param thisLastLogTerm\n-       * @param thatTerm\n-       * @param thatLastLogId\n-       * @param thatLastLogTerm\n-       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-       */\n-      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n-        long response;\n-        if (thatTerm <= thisTerm) {\n-          response = thisTerm;\n-          logger.debug(\"{} rejected an election request, term:{}/{}\",\n-              name, thatTerm, thisTerm);\n-        } else if (thatLastLogTerm < thisLastLogTerm\n-            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-          response = Response.RESPONSE_LOG_MISMATCH;\n-        } else {\n-          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-              thisLastLogTerm);\n-          response = Response.RESPONSE_AGREE;\n-        }\n-        return response;\n+    long thatTerm = electionRequest.getTerm();\n+    long thatLastLogId = electionRequest.getLastLogIndex();\n+    long thatLastLogTerm = electionRequest.getLastLogTerm();\n+    logger\n+        .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+            name, thatTerm,\n+            thatLastLogId, thatLastLogTerm);\n+\n+    long lastLogIndex = logManager.getLastLogIndex();\n+    long lastLogTerm = logManager.getLastLogTerm();\n+\n+    synchronized (term) {\n+      long thisTerm = term.get();\n+      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+          thatLastLogTerm);\n+      if (resp == Response.RESPONSE_AGREE) {\n+        term.set(thatTerm);\n+        setCharacter(NodeCharacter.FOLLOWER);\n+        lastHeartbeatReceivedTime = System.currentTimeMillis();\n+        leader = electionRequest.getElector();\n+        // interrupt election\n+        term.notifyAll();\n       }\n+      return resp;\n+    }\n+  }\n \n-      /**\n-       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-       * follower. If some of the logs are not in memory, also send the snapshot.\n-       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-       *\n-       * @param follower\n-       * @param followerLastLogIndex\n-       */\n-      public void catchUp (Node follower,long followerLastLogIndex){\n-        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-        // for one follower, there is at most one ongoing catch-up\n-        synchronized (follower) {\n-          // check if the last catch-up is still ongoing\n-          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-          if (lastCatchupResp != null\n-              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-            return;\n-          } else {\n-            // record the start of the catch-up\n-            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n-          }\n-        }\n-        if (followerLastLogIndex == -1) {\n-          // if the follower does not have any logs, send from the first one\n-          followerLastLogIndex = 0;\n-        }\n+  /**\n+   * Reject the election if one of the four holds: 1. the term of the candidate is no bigger than\n+   * the voter's 2. the lastLogTerm of the candidate is smaller than the voter's 3. the lastLogTerm\n+   * of the candidate equals to the voter's but its lastLogIndex is smaller than the voter's\n+   * Otherwise accept the election.\n+   *\n+   * @param thisTerm\n+   * @param thisLastLogIndex\n+   * @param thisLastLogTerm\n+   * @param thatTerm\n+   * @param thatLastLogId\n+   * @param thatLastLogTerm\n+   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has a\n+   * smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+   */\n+  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n+    long response;\n+    if (thatTerm <= thisTerm) {\n+      response = thisTerm;\n+      logger.debug(\"{} rejected an election request, term:{}/{}\",\n+          name, thatTerm, thisTerm);\n+    } else if (thatLastLogTerm < thisLastLogTerm\n+        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+      response = Response.RESPONSE_LOG_MISMATCH;\n+    } else {\n+      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+          thisLastLogTerm);\n+      response = Response.RESPONSE_AGREE;\n+    }\n+    return response;\n+  }\n \n-        AsyncClient client = connectNode(follower);\n-        if (client != null) {\n-          List<Log> logs;\n-          boolean allLogsValid;\n-          Snapshot snapshot = null;\n-          synchronized (logManager) {\n-            // check if the very first log has been snapshot\n-            allLogsValid = logManager.logValid(followerLastLogIndex);\n-            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-            if (!allLogsValid) {\n-              // if the first log has been snapshot, the snapshot should also be sent to the\n-              // follower, otherwise some data will be missing\n-              snapshot = logManager.getSnapshot();\n-            }\n-          }\n+  /**\n+   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+   * follower. If some of the logs are not in memory, also send the snapshot.\n+   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+   *\n+   * @param follower\n+   * @param followerLastLogIndex\n+   */\n+  public void catchUp(Node follower, long followerLastLogIndex) {\n+    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+    // for one follower, there is at most one ongoing catch-up\n+    synchronized (follower) {\n+      // check if the last catch-up is still ongoing\n+      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+      if (lastCatchupResp != null\n+          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+        return;\n+      } else {\n+        // record the start of the catch-up\n+        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      }\n+    }\n+    if (followerLastLogIndex == -1) {\n+      // if the follower does not have any logs, send from the first one\n+      followerLastLogIndex = 0;\n+    }\n \n-          if (allLogsValid) {\n-            if (logger.isDebugEnabled()) {\n-              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n-            }\n-            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-          } else {\n-            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n-          }\n-        } else {\n-          lastCatchUpResponseTime.remove(follower);\n-          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+    AsyncClient client = connectNode(follower);\n+    if (client != null) {\n+      List<Log> logs;\n+      boolean allLogsValid;\n+      Snapshot snapshot = null;\n+      synchronized (logManager) {\n+        // check if the very first log has been snapshot\n+        allLogsValid = logManager.logValid(followerLastLogIndex);\n+        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+        if (!allLogsValid) {\n+          // if the first log has been snapshot, the snapshot should also be sent to the\n+          // follower, otherwise some data will be missing\n+          snapshot = logManager.getSnapshot();\n         }\n       }\n \n-      public String getName () {\n-        return name;\n+      if (allLogsValid) {\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+        }\n+        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+      } else {\n+        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n       }\n+    } else {\n+      lastCatchUpResponseTime.remove(follower);\n+      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+    }\n+  }\n \n-      /**\n-       * @return the header of the data raft group or null if this is in a meta group.\n-       */\n-      public Node getHeader () {\n-        return null;\n-      }\n+  public String getName() {\n+    return name;\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * Forward a plan to a node using the default client.\n-       *\n-       * @param plan\n-       * @param node\n-      =======\n-       * Forward a non-query plan to a node using the default client.\n-       * @param plan a non-query plan\n-       * @param node cannot be the local node\n-      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param header must be set for data group communication, set to null for meta group\n-       *               communication\n-       * @return a TSStatus indicating if the forwarding is successful.\n-       */\n-      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n-        if (node == thisNode || node == null) {\n-          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-          return StatusUtils.NO_LEADER;\n-        }\n+  /**\n+   * @return the header of the data raft group or null if this is in a meta group.\n+   */\n+  public Node getHeader() {\n+    return null;\n+  }\n+\n+  /**\n+   * Forward a non-query plan to a node using the default client.\n+   *\n+   * @param plan   a non-query plan\n+   * @param node   cannot be the local node\n+   * @param header must be set for data group communication, set to null for meta group\n+   *               communication\n+   * @return a TSStatus indicating if the forwarding is successful.\n+   */\n+  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n+    if (node == thisNode || node == null) {\n+      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+      return StatusUtils.NO_LEADER;\n+    }\n \n-        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n \n-        AsyncClient client = connectNode(node);\n-        if (client != null) {\n-          return forwardPlan(plan, client, node, header);\n-        }\n-        return StatusUtils.TIME_OUT;\n-      }\n+    AsyncClient client = connectNode(node);\n+    if (client != null) {\n+      return forwardPlan(plan, client, node, header);\n+    }\n+    return StatusUtils.TIME_OUT;\n+  }\n \n-      /**\n-       * Forward a non-query plan to \"receiver\" using \"client\".\n-       * @param plan a non-query plan\n-       * @param client\n-       * @param receiver\n-       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-       * @return a TSStatus indicating if the forwarding is successful.\n-       */\n-      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-        try {\n-          plan.serializeTo(dataOutputStream);\n-          AtomicReference<TSStatus> status = new AtomicReference<>();\n-          ExecutNonQueryReq req = new ExecutNonQueryReq();\n-          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-          if (header != null) {\n-            req.setHeader(header);\n-          }\n-          synchronized (status) {\n-            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-            status.wait(RaftServer.connectionTimeoutInMS);\n-          }\n-          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-        } catch (IOException | TException e) {\n-          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-          status.setMessage(e.getMessage());\n-          logger\n-              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-          return status;\n-        } catch (InterruptedException e) {\n-          return StatusUtils.TIME_OUT;\n-        }\n+  /**\n+   * Forward a non-query plan to \"receiver\" using \"client\".\n+   *\n+   * @param plan     a non-query plan\n+   * @param client\n+   * @param receiver\n+   * @param header   to determine which DataGroupMember of \"receiver\" will process the request.\n+   * @return a TSStatus indicating if the forwarding is successful.\n+   */\n+  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+    try {\n+      plan.serializeTo(dataOutputStream);\n+      AtomicReference<TSStatus> status = new AtomicReference<>();\n+      ExecutNonQueryReq req = new ExecutNonQueryReq();\n+      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+      if (header != null) {\n+        req.setHeader(header);\n       }\n+      synchronized (status) {\n+        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+        status.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+    } catch (IOException | TException e) {\n+      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+      status.setMessage(e.getMessage());\n+      logger\n+          .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+      return status;\n+    } catch (InterruptedException e) {\n+      return StatusUtils.TIME_OUT;\n+    }\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * Only the group leader can call this method. Will commit the log locally and send it to\n-       * followers\n-       *\n-       =======\n-       * Create a log for \"plan\" and append it locally and to all followers.\n-       * Only the group leader can call this method.\n-       * Will commit the log locally and send it to followers\n-       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param plan\n-       * @return OK if over half of the followers accept the log or null if the leadership is lost\n-       * during the appending\n-       */\n-      TSStatus processPlanLocally (PhysicalPlan plan){\n-        logger.debug(\"{}: Processing plan {}\", name, plan);\n-        if (readOnly) {\n-          return StatusUtils.NODE_READ_ONLY;\n-        }\n+  /**\n+   * Create a log for \"plan\" and append it locally and to all followers. Only the group leader can\n+   * call this method. Will commit the log locally and send it to followers\n+   *\n+   * @param plan\n+   * @return OK if over half of the followers accept the log or null if the leadership is lost\n+   * during the appending\n+   */\n+  TSStatus processPlanLocally(PhysicalPlan plan) {\n+    logger.debug(\"{}: Processing plan {}\", name, plan);\n+    if (readOnly) {\n+      return StatusUtils.NODE_READ_ONLY;\n+    }\n \n-        PhysicalPlanLog log = new PhysicalPlanLog();\n-        // assign term and index to the new log and append it\n-        synchronized (logManager) {\n-          log.setCurrLogTerm(getTerm().get());\n-          log.setPreviousLogIndex(logManager.getLastLogIndex());\n-          log.setPreviousLogTerm(logManager.getLastLogTerm());\n-          log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n+    PhysicalPlanLog log = new PhysicalPlanLog();\n+    // assign term and index to the new log and append it\n+    synchronized (logManager) {\n+      log.setCurrLogTerm(getTerm().get());\n+      log.setPreviousLogIndex(logManager.getLastLogIndex());\n+      log.setPreviousLogTerm(logManager.getLastLogTerm());\n+      log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-          log.setPlan(plan);\n-          logManager.appendLog(log);\n-        }\n+      log.setPlan(plan);\n+      logManager.appendLog(log);\n+    }\n \n-        if (appendLogInGroup(log)) {\n-          return StatusUtils.OK;\n-        }\n-        return null;\n-      }\n+    if (appendLogInGroup(log)) {\n+      return StatusUtils.OK;\n+    }\n+    return null;\n+  }\n \n-      /**\n-       <<<<<<< HEAD\n-       * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n-       * send it to followers depends on the implementation of executeNonQuery()).\n-       *\n-       =======\n-       * Append a log to all followers in the group until half of them accept the log or the\n-       * leadership is lost.\n-       * @param log\n-       * @return true if the log is accepted by the quorum of the group, false otherwise\n-       */\n-      protected boolean appendLogInGroup (Log log){\n-        int retryTime = 0;\n-        retry:\n-        while (true) {\n-          logger.debug(\"{}: Send log {} to other nodes, retry times: {}\", name, log, retryTime);\n-          AppendLogResult result = sendLogToFollowers(log, allNodes.size() / 2);\n-          switch (result) {\n-            case OK:\n-              logger.debug(\"{}: log {} is accepted\", name, log);\n-              logManager.commitLog(log.getCurrLogIndex());\n-              return true;\n-            case TIME_OUT:\n-              logger.debug(\"{}: log {} timed out, retrying...\", name, log);\n-              retryTime++;\n-              break;\n-            case LEADERSHIP_STALE:\n-              // abort the appending, the new leader will fix the local logs by catch-up\n-            default:\n-              break retry;\n-          }\n-        }\n-        return false;\n+\n+  /**\n+   * Append a log to all followers in the group until half of them accept the log or the leadership\n+   * is lost.\n+   *\n+   * @param log\n+   * @return true if the log is accepted by the quorum of the group, false otherwise\n+   */\n+  protected boolean appendLogInGroup(Log log) {\n+    int retryTime = 0;\n+    retry:\n+    while (true) {\n+      logger.debug(\"{}: Send log {} to other nodes, retry times: {}\", name, log, retryTime);\n+      AppendLogResult result = sendLogToFollowers(log, allNodes.size() / 2);\n+      switch (result) {\n+        case OK:\n+          logger.debug(\"{}: log {} is accepted\", name, log);\n+          logManager.commitLog(log.getCurrLogIndex());\n+          return true;\n+        case TIME_OUT:\n+          logger.debug(\"{}: log {} timed out, retrying...\", name, log);\n+          retryTime++;\n+          break;\n+        case LEADERSHIP_STALE:\n+          // abort the appending, the new leader will fix the local logs by catch-up\n+        default:\n+          break retry;\n       }\n+    }\n+    return false;\n+  }\n \n-      /**\n-       * If the node is not a leader, the request will be sent to the leader or reports an error if\n-       * there is no leader.\n-       * Otherwise execute the plan locally (whether to send it to followers depends on the\n-       * type of the plan).\n-       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n-       * @param request\n-       * @param resultHandler\n-       */\n-      public void executeNonQueryPlan (ExecutNonQueryReq request,\n-          AsyncMethodCallback < TSStatus > resultHandler){\n-        if (character != NodeCharacter.LEADER) {\n-          // forward the plan to the leader\n-          AsyncClient client = connectNode(leader);\n-          if (client != null) {\n-            try {\n-              client.executeNonQueryPlan(request, resultHandler);\n-            } catch (TException e) {\n-              resultHandler.onError(e);\n-            }\n-          } else {\n-            resultHandler.onComplete(StatusUtils.NO_LEADER);\n-          }\n-          return;\n-        }\n+  /**\n+   * If the node is not a leader, the request will be sent to the leader or reports an error if\n+   * there is no leader. Otherwise execute the plan locally (whether to send it to followers depends\n+   * on the type of the plan).\n+   *\n+   * @param request\n+   * @param resultHandler\n+   */\n+  public void executeNonQueryPlan(ExecutNonQueryReq request,\n+      AsyncMethodCallback<TSStatus> resultHandler) {\n+    if (character != NodeCharacter.LEADER) {\n+      // forward the plan to the leader\n+      AsyncClient client = connectNode(leader);\n+      if (client != null) {\n         try {\n-          // process the plan locally\n-          PhysicalPlan plan = PhysicalPlan.Factory.create(request.planBytes);\n-          logger.debug(\"{}: Received a plan {}\", name, plan);\n-          resultHandler.onComplete(executeNonQuery(plan));\n-        } catch (Exception e) {\n+          client.executeNonQueryPlan(request, resultHandler);\n+        } catch (TException e) {\n           resultHandler.onError(e);\n         }\n+      } else {\n+        resultHandler.onComplete(StatusUtils.NO_LEADER);\n       }\n+      return;\n+    }\n+    try {\n+      // process the plan locally\n+      PhysicalPlan plan = PhysicalPlan.Factory.create(request.planBytes);\n+      logger.debug(\"{}: Received a plan {}\", name, plan);\n+      resultHandler.onComplete(executeNonQuery(plan));\n+    } catch (Exception e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n \n-      /**\n-       * Request and check the leader's commitId to see whether this node has caught up. If not, wait\n-       * until this node catches up.\n-       *\n-       * @return true if the node has caught up, false otherwise\n-       */\n-      public boolean syncLeader () {\n-        if (character == NodeCharacter.LEADER) {\n-          return true;\n-        }\n-        if (leader == null) {\n-          // the leader has not been elected, we must assume the node falls behind\n-          return false;\n-        }\n-        logger.debug(\"{}: try synchronizing with the leader {}\", name, leader);\n-        long startTime = System.currentTimeMillis();\n-        long waitedTime = 0;\n-        AtomicReference<Long> commitIdResult = new AtomicReference<>(Long.MAX_VALUE);\n-        while (waitedTime < RaftServer.syncLeaderMaxWaitMs) {\n-          AsyncClient client = connectNode(leader);\n-          if (client == null) {\n-            // cannot connect to the leader\n-            return false;\n-          }\n-          try {\n-            synchronized (commitIdResult) {\n-              client.requestCommitIndex(getHeader(), new GenericHandler<>(leader, commitIdResult));\n-              commitIdResult.wait(RaftServer.syncLeaderMaxWaitMs);\n-            }\n-            long leaderCommitId = commitIdResult.get();\n-            long localCommitId = logManager.getCommitLogIndex();\n-            logger\n-                .debug(\"{}: synchronizing commitIndex {}/{}\", name, localCommitId, leaderCommitId);\n-            if (leaderCommitId <= localCommitId) {\n-              // before the response comes, the leader may commit new logs and the localCommitId may be\n-              // updated by catching up, so it is possible that localCommitId > leaderCommitId at\n-              // this time\n-              // this node has caught up\n-              if (logger.isDebugEnabled()) {\n-                waitedTime = System.currentTimeMillis() - startTime;\n-                logger.debug(\"{}: synchronized with the leader after {}ms\", name, waitedTime);\n-              }\n-              return true;\n-            }\n-            // wait for next heartbeat to catch up\n-            // the local node will not perform a commit here according to the leaderCommitId because\n-            // the node may have some inconsistent logs with the leader\n-            waitedTime = System.currentTimeMillis() - startTime;\n-            synchronized (syncLock) {\n-              syncLock.wait(RaftServer.heartBeatIntervalMs);\n-            }\n-          } catch (TException | InterruptedException e) {\n-            logger.error(\"{}: Cannot request commit index from {}\", name, leader, e);\n-          }\n-        }\n+  /**\n+   * Request and check the leader's commitId to see whether this node has caught up. If not, wait\n+   * until this node catches up.\n+   *\n+   * @return true if the node has caught up, false otherwise\n+   */\n+  public boolean syncLeader() {\n+    if (character == NodeCharacter.LEADER) {\n+      return true;\n+    }\n+    if (leader == null) {\n+      // the leader has not been elected, we must assume the node falls behind\n+      return false;\n+    }\n+    logger.debug(\"{}: try synchronizing with the leader {}\", name, leader);\n+    long startTime = System.currentTimeMillis();\n+    long waitedTime = 0;\n+    AtomicReference<Long> commitIdResult = new AtomicReference<>(Long.MAX_VALUE);\n+    while (waitedTime < RaftServer.syncLeaderMaxWaitMs) {\n+      AsyncClient client = connectNode(leader);\n+      if (client == null) {\n+        // cannot connect to the leader\n         return false;\n       }\n-\n-      /**\n-       * Execute a non-query plan.\n-       * @param plan a non-query plan.\n-       * @return A TSStatus indicating the execution result.\n-       */\n-      abstract TSStatus executeNonQuery (PhysicalPlan plan);\n-\n-      /**\n-       * Tell the requester the current commit index if the local node is the leader of the group\n-       * headed by header. Or forward it to the leader. Otherwise report an error.\n-       * @param header to determine the DataGroupMember in data groups\n-       * @param resultHandler\n-       */\n-      @Override\n-      public void requestCommitIndex (Node header, AsyncMethodCallback < Long > resultHandler){\n-        if (character == NodeCharacter.LEADER) {\n-          resultHandler.onComplete(logManager.getCommitLogIndex());\n-          return;\n+      try {\n+        synchronized (commitIdResult) {\n+          client.requestCommitIndex(getHeader(), new GenericHandler<>(leader, commitIdResult));\n+          commitIdResult.wait(RaftServer.syncLeaderMaxWaitMs);\n         }\n-        AsyncClient client = connectNode(leader);\n-        if (client == null) {\n-          resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n-          return;\n+        long leaderCommitId = commitIdResult.get();\n+        long localCommitId = logManager.getCommitLogIndex();\n+        logger.debug(\"{}: synchronizing commitIndex {}/{}\", name, localCommitId, leaderCommitId);\n+        if (leaderCommitId <= localCommitId) {\n+          // before the response comes, the leader may commit new logs and the localCommitId may be\n+          // updated by catching up, so it is possible that localCommitId > leaderCommitId at\n+          // this time\n+          // this node has caught up\n+          if (logger.isDebugEnabled()) {\n+            waitedTime = System.currentTimeMillis() - startTime;\n+            logger.debug(\"{}: synchronized with the leader after {}ms\", name, waitedTime);\n+          }\n+          return true;\n         }\n-        try {\n-          client.requestCommitIndex(header, resultHandler);\n-        } catch (TException e) {\n-          resultHandler.onError(e);\n+        // wait for next heartbeat to catch up\n+        // the local node will not perform a commit here according to the leaderCommitId because\n+        // the node may have some inconsistent logs with the leader\n+        waitedTime = System.currentTimeMillis() - startTime;\n+        synchronized (syncLock) {\n+          syncLock.wait(RaftServer.heartBeatIntervalMs);\n         }\n+      } catch (TException | InterruptedException e) {\n+        logger.error(\"{}: Cannot request commit index from {}\", name, leader, e);\n       }\n+    }\n+    return false;\n+  }\n \n-      /**\n-       * An ftp-like interface that is used for a node to pull chunks of files like TsFiles.\n-       * @param filePath\n-       * @param offset\n-       * @param length\n-       * @param header to determine the DataGroupMember in data groups\n-       * @param resultHandler\n-       */\n-      @Override\n-      public void readFile (String filePath,long offset, int length, Node header,\n-          AsyncMethodCallback < ByteBuffer > resultHandler){\n-        try (BufferedInputStream bufferedInputStream =\n-            new BufferedInputStream(new FileInputStream(filePath))) {\n-          bufferedInputStream.skip(offset);\n-          byte[] bytes = new byte[length];\n-          ByteBuffer result = ByteBuffer.wrap(bytes);\n-          int len = bufferedInputStream.read(bytes);\n-          result.limit(Math.max(len, 0));\n-\n-          resultHandler.onComplete(result);\n-        } catch (IOException e) {\n-          resultHandler.onError(e);\n-        }\n-      }\n+  /**\n+   * Execute a non-query plan.\n+   *\n+   * @param plan a non-query plan.\n+   * @return A TSStatus indicating the execution result.\n+   */\n+  abstract TSStatus executeNonQuery(PhysicalPlan plan);\n \n-      public void setReadOnly () {\n-        synchronized (logManager) {\n-          readOnly = true;\n-        }\n-      }\n+  /**\n+   * Tell the requester the current commit index if the local node is the leader of the group headed\n+   * by header. Or forward it to the leader. Otherwise report an error.\n+   *\n+   * @param header        to determine the DataGroupMember in data groups\n+   * @param resultHandler\n+   */\n+  @Override\n+  public void requestCommitIndex(Node header, AsyncMethodCallback<Long> resultHandler) {\n+    if (character == NodeCharacter.LEADER) {\n+      resultHandler.onComplete(logManager.getCommitLogIndex());\n+      return;\n+    }\n+    AsyncClient client = connectNode(leader);\n+    if (client == null) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    try {\n+      client.requestCommitIndex(header, resultHandler);\n+    } catch (TException e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n \n-      public void setAllNodes (List < Node > allNodes) {\n-        this.allNodes = allNodes;\n-      }\n+  /**\n+   * An ftp-like interface that is used for a node to pull chunks of files like TsFiles.\n+   *\n+   * @param filePath\n+   * @param offset\n+   * @param length\n+   * @param header        to determine the DataGroupMember in data groups\n+   * @param resultHandler\n+   */\n+  @Override\n+  public void readFile(String filePath, long offset, int length, Node header,\n+      AsyncMethodCallback<ByteBuffer> resultHandler) {\n+    try (BufferedInputStream bufferedInputStream =\n+        new BufferedInputStream(new FileInputStream(filePath))) {\n+      bufferedInputStream.skip(offset);\n+      byte[] bytes = new byte[length];\n+      ByteBuffer result = ByteBuffer.wrap(bytes);\n+      int len = bufferedInputStream.read(bytes);\n+      result.limit(Math.max(len, 0));\n+\n+      resultHandler.onComplete(result);\n+    } catch (IOException e) {\n+      resultHandler.onError(e);\n+    }\n+  }\n+\n+  public void setReadOnly() {\n+    synchronized (logManager) {\n+      readOnly = true;\n     }\n+  }\n+\n+  public void setAllNodes(List<Node> allNodes) {\n+    this.allNodes = allNodes;\n+  }\n+}\n"}}, {"oid": "5fcb9f0786aee2f36e1b224931059371cfc9b465", "url": "https://github.com/apache/iotdb/commit/5fcb9f0786aee2f36e1b224931059371cfc9b465", "message": "fix conflict in RaftMember", "committedDate": "2020-03-20T03:36:02Z", "type": "commit"}]}