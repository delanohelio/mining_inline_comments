{"pr_number": 1691, "pr_title": "[IOTDB-814] Cache and redirect distributed IoTDB's leader for write requests in IoTDB's client ", "pr_createdAt": "2020-09-04T07:27:08Z", "pr_url": "https://github.com/apache/iotdb/pull/1691", "timeline": [{"oid": "703ed15d17f20df8dbe7879186caa8a23641a26e", "url": "https://github.com/apache/iotdb/commit/703ed15d17f20df8dbe7879186caa8a23641a26e", "message": "add clientPort for Node", "committedDate": "2020-08-27T16:08:42Z", "type": "commit"}, {"oid": "c7232307728d050f1ac755595c3fd7a09e3f070f", "url": "https://github.com/apache/iotdb/commit/c7232307728d050f1ac755595c3fd7a09e3f070f", "message": "finish server logic", "committedDate": "2020-09-01T09:05:13Z", "type": "commit"}, {"oid": "11c4264e9d143c27d00ba6d5844669a6d063a97f", "url": "https://github.com/apache/iotdb/commit/11c4264e9d143c27d00ba6d5844669a6d063a97f", "message": "adjust stane-alone session architecture to support cluster session interface", "committedDate": "2020-09-04T07:23:44Z", "type": "commit"}, {"oid": "ed4895a03291a3a7e85742244efd3b6bb5f25a24", "url": "https://github.com/apache/iotdb/commit/ed4895a03291a3a7e85742244efd3b6bb5f25a24", "message": "add single insert redirection && deepcopy status in server to avoid mistake", "committedDate": "2020-09-07T14:06:54Z", "type": "commit"}, {"oid": "09fd396edae096e66f6f65d7284f632e779bd5ad", "url": "https://github.com/apache/iotdb/commit/09fd396edae096e66f6f65d7284f632e779bd5ad", "message": "add batch insert direction", "committedDate": "2020-09-10T01:29:46Z", "type": "commit"}, {"oid": "8110e22cb46aca6c3dd2c6f595de6c53e9b839cf", "url": "https://github.com/apache/iotdb/commit/8110e22cb46aca6c3dd2c6f595de6c53e9b839cf", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-10T02:21:42Z", "type": "commit"}, {"oid": "83574a1f7dbdc122c598946e8212faf2aab43cd3", "url": "https://github.com/apache/iotdb/commit/83574a1f7dbdc122c598946e8212faf2aab43cd3", "message": "update clientport docs and nodetools", "committedDate": "2020-09-10T02:57:30Z", "type": "commit"}, {"oid": "392b75ffe1c91aa2ccb2a3f4a5c52c3d0b9d159c", "url": "https://github.com/apache/iotdb/commit/392b75ffe1c91aa2ccb2a3f4a5c52c3d0b9d159c", "message": "adjust close cache leader logic to avoid NPE && add TODO parallel && remove sessionExample wrong comments", "committedDate": "2020-09-10T05:17:42Z", "type": "forcePushed"}, {"oid": "f6f43e827d05b8d143bd6e124623d017a19c9741", "url": "https://github.com/apache/iotdb/commit/f6f43e827d05b8d143bd6e124623d017a19c9741", "message": "adjust close cache leader logic to avoid NPE && add TODO parallel && remove sessionExample wrong comments", "committedDate": "2020-09-10T05:23:56Z", "type": "forcePushed"}, {"oid": "229779f895d86ffc464b3901ae878b75d1b21e1d", "url": "https://github.com/apache/iotdb/commit/229779f895d86ffc464b3901ae878b75d1b21e1d", "message": "adjust close cache leader logic to avoid NPE && add TODO parallel && remove sessionExample wrong comments and test codes", "committedDate": "2020-09-10T05:26:32Z", "type": "commit"}, {"oid": "229779f895d86ffc464b3901ae878b75d1b21e1d", "url": "https://github.com/apache/iotdb/commit/229779f895d86ffc464b3901ae878b75d1b21e1d", "message": "adjust close cache leader logic to avoid NPE && add TODO parallel && remove sessionExample wrong comments and test codes", "committedDate": "2020-09-10T05:26:32Z", "type": "forcePushed"}, {"oid": "d6331be4745840925d733a482194a4b1caa9abec", "url": "https://github.com/apache/iotdb/commit/d6331be4745840925d733a482194a4b1caa9abec", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-10T12:47:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODY4OQ==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486728689", "bodyText": "I think the redirect strategy can be improved a little.\nMostly the plan is forwarded to multiple groups because its data has crossed multiple time partitions, and generally, this only happens on time partition borders as a plan contains a relatively short time range compared to the time partition length.\nSo typically planGroupMap.size() <= 2,  and when it is 2, the following plans most probably belong to the second group. Consequently, it would reasonable if we always set the redirect target to that of the sub-plan with the largest timestamp.\nFor example, if the partition length is a day, and a plan that contains data from Thuesday 11:50 to Wednesday 00:10 will be split into two sub-plans, each contains data from Thuesday 11:50 to Thuesday 11:59 and  Wednesday 00:00 to  Wednesday 00:10 respectively, and the two sub-plans are forwarded to NodeA and NodeB.\nIt is clear that the following plans, which contain data of Wednesday, should be forwarded to NodeB.\nBy the way, I think the use of a map to split plan is unnecessary, and a List<Pair<>> should be just enough, and you may sort it according to the largest timestamp easily.", "author": "jt2594838", "createdAt": "2020-09-11T01:58:31Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1688,13 +1693,20 @@ private TSStatus forwardInsertTabletPlan(Map<PhysicalPlan, PartitionGroup> planG\n     TSStatus[] subStatus = null;\n     boolean noFailure = true;\n     boolean isBatchFailure = false;\n+    boolean allRedirect = true;\n+    EndPoint endPoint = null;\n     for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n       tmpStatus = forwardToSingleGroup(entry);\n       logger.debug(\"{}: from {},{},{}\", name, entry.getKey(), entry.getValue(), tmpStatus);\n       noFailure =\n           (tmpStatus.getCode() == TSStatusCode.SUCCESS_STATUS.getStatusCode()) && noFailure;\n       isBatchFailure = (tmpStatus.getCode() == TSStatusCode.MULTIPLE_ERROR.getStatusCode())\n           || isBatchFailure;\n+      if (tmpStatus.isSetRedirectNode()) {\n+        endPoint = tmpStatus.getRedirectNode();\n+      } else {\n+        allRedirect = false;\n+      }", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2NzUxNA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486867514", "bodyText": "One more thing:\nif the last element of the tmpStatus not set the RedirectNode, the final allRedirect value is false,\nThis situation should be considered.", "author": "neuyilan", "createdAt": "2020-09-11T08:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTQ5NQ==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r487021495", "bodyText": "Actually I designed this on purpose.If the last element of the tmpStatus do not set the RedirectNode, which means the coordinator can process at lease one plan locally, so the final allRedirect value is false, the server will not recomment client a new Node to redirect.\nBTW, maybe in our user's most scenarios, forwarding the plan to second Node is better, I will fix this.", "author": "LebronAl", "createdAt": "2020-09-11T12:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex f2ce874052..bbe98ba8dc 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1693,19 +1694,18 @@ public class MetaGroupMember extends RaftMember {\n     TSStatus[] subStatus = null;\n     boolean noFailure = true;\n     boolean isBatchFailure = false;\n-    boolean allRedirect = true;\n     EndPoint endPoint = null;\n+    InsertTabletPlan subPlan;\n     for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n       tmpStatus = forwardToSingleGroup(entry);\n+      subPlan = (InsertTabletPlan) entry.getKey();\n       logger.debug(\"{}: from {},{},{}\", name, entry.getKey(), entry.getValue(), tmpStatus);\n       noFailure =\n           (tmpStatus.getCode() == TSStatusCode.SUCCESS_STATUS.getStatusCode()) && noFailure;\n       isBatchFailure = (tmpStatus.getCode() == TSStatusCode.MULTIPLE_ERROR.getStatusCode())\n           || isBatchFailure;\n-      if (tmpStatus.isSetRedirectNode()) {\n+      if (tmpStatus.isSetRedirectNode() && subPlan.getMaxTime() == plan.getMaxTime()) {\n         endPoint = tmpStatus.getRedirectNode();\n-      } else {\n-        allRedirect = false;\n       }\n       if (tmpStatus.getCode() == TSStatusCode.MULTIPLE_ERROR.getStatusCode()) {\n         if (subStatus == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjk5Ng==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486736996", "bodyText": "Assuming current metaConnection is to NodeA, but the actual leader is NodeB:\n\nsetStorageGroup(\"root.sg1\") is executed, and a redirection to NodeB is returned\nleader switched to NodeA\nsetStorageGroup(\"root.sg2\") is executed, and a redirection to NodeA is returned\nmetaSessionConnection = new SessionConnection(this, e.getEndPoint()) is executed, but as there is already one connection to NodeA in endPointToSessionConnection, the new connection will be lost when the next redirection comes.\n\nSo, maybe you should check endPointToSessionConnection before newing a connection.", "author": "jt2594838", "createdAt": "2020-09-11T02:29:50Z", "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "diffHunk": "@@ -121,209 +105,326 @@ private synchronized void open(boolean enableRPCCompression, int connectionTimeo\n     if (!isClosed) {\n       return;\n     }\n+    this.enableRPCCompression = enableRPCCompression;\n+    this.connectionTimeoutInMs = connectionTimeoutInMs;\n \n-    transport = new TFastFramedTransport(new TSocket(host, port, connectionTimeoutInMs));\n+    defaultSessionConnection = new SessionConnection(this, defaultEndPoint);\n+    metaSessionConnection = defaultSessionConnection;\n+    isClosed = false;\n+    if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+      deviceIdToEndpoint = new HashMap<>();\n+      endPointToSessionConnection = new HashMap<EndPoint, SessionConnection>() {{\n+        put(defaultEndPoint, defaultSessionConnection);\n+      }};\n+    }\n+  }\n \n-    if (!transport.isOpen()) {\n-      try {\n-        transport.open();\n-      } catch (TTransportException e) {\n-        throw new IoTDBConnectionException(e);\n+  public synchronized void close() throws IoTDBConnectionException {\n+    if (isClosed) {\n+      return;\n+    }\n+    try {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        for (SessionConnection sessionConnection : endPointToSessionConnection.values()) {\n+          sessionConnection.close();\n+        }\n+      } else {\n+        defaultSessionConnection.close();\n       }\n+    } finally {\n+      isClosed = true;\n     }\n+  }\n \n-    if (enableRPCCompression) {\n-      client = new TSIService.Client(new TCompactProtocol(transport));\n-    } else {\n-      client = new TSIService.Client(new TBinaryProtocol(transport));\n-    }\n+  public synchronized String getTimeZone()\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    return defaultSessionConnection.getTimeZone();\n+  }\n \n-    TSOpenSessionReq openReq = new TSOpenSessionReq();\n-    openReq.setUsername(username);\n-    openReq.setPassword(password);\n+  public synchronized void setTimeZone(String zoneId)\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    defaultSessionConnection.setTimeZone(zoneId);\n+  }\n \n+  public void setStorageGroup(String storageGroup)\n+      throws IoTDBConnectionException, StatementExecutionException {\n     try {\n-      TSOpenSessionResp openResp = client.openSession(openReq);\n+      metaSessionConnection.setStorageGroup(storageGroup);\n+    } catch (RedirectException e) {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        logger.debug(\"storageGroup[{}]:{}\", storageGroup, e.getMessage());\n+        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n+        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MzYxMA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486863610", "bodyText": "OK, I intend to update endPointToSessionConnection  first and then update metaSessionConnection from endPointToSessionConnection", "author": "LebronAl", "createdAt": "2020-09-11T08:39:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjk5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/session/src/main/java/org/apache/iotdb/session/Session.java b/session/src/main/java/org/apache/iotdb/session/Session.java\nindex 7fa2096352..276e2c7ddc 100644\n--- a/session/src/main/java/org/apache/iotdb/session/Session.java\n+++ b/session/src/main/java/org/apache/iotdb/session/Session.java\n\n@@ -153,8 +154,9 @@ public class Session {\n     } catch (RedirectException e) {\n       if (Config.DEFAULT_CACHE_LEADER_MODE) {\n         logger.debug(\"storageGroup[{}]:{}\", storageGroup, e.getMessage());\n-        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n-        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);\n+        endPointToSessionConnection\n+            .putIfAbsent(e.getEndPoint(), new SessionConnection(this, e.getEndPoint()));\n+        metaSessionConnection = endPointToSessionConnection.get(e.getEndPoint());\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzI1NA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486737254", "bodyText": "Collections.singletonList() should be enough.", "author": "jt2594838", "createdAt": "2020-09-11T02:30:48Z", "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "diffHunk": "@@ -121,209 +105,326 @@ private synchronized void open(boolean enableRPCCompression, int connectionTimeo\n     if (!isClosed) {\n       return;\n     }\n+    this.enableRPCCompression = enableRPCCompression;\n+    this.connectionTimeoutInMs = connectionTimeoutInMs;\n \n-    transport = new TFastFramedTransport(new TSocket(host, port, connectionTimeoutInMs));\n+    defaultSessionConnection = new SessionConnection(this, defaultEndPoint);\n+    metaSessionConnection = defaultSessionConnection;\n+    isClosed = false;\n+    if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+      deviceIdToEndpoint = new HashMap<>();\n+      endPointToSessionConnection = new HashMap<EndPoint, SessionConnection>() {{\n+        put(defaultEndPoint, defaultSessionConnection);\n+      }};\n+    }\n+  }\n \n-    if (!transport.isOpen()) {\n-      try {\n-        transport.open();\n-      } catch (TTransportException e) {\n-        throw new IoTDBConnectionException(e);\n+  public synchronized void close() throws IoTDBConnectionException {\n+    if (isClosed) {\n+      return;\n+    }\n+    try {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        for (SessionConnection sessionConnection : endPointToSessionConnection.values()) {\n+          sessionConnection.close();\n+        }\n+      } else {\n+        defaultSessionConnection.close();\n       }\n+    } finally {\n+      isClosed = true;\n     }\n+  }\n \n-    if (enableRPCCompression) {\n-      client = new TSIService.Client(new TCompactProtocol(transport));\n-    } else {\n-      client = new TSIService.Client(new TBinaryProtocol(transport));\n-    }\n+  public synchronized String getTimeZone()\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    return defaultSessionConnection.getTimeZone();\n+  }\n \n-    TSOpenSessionReq openReq = new TSOpenSessionReq();\n-    openReq.setUsername(username);\n-    openReq.setPassword(password);\n+  public synchronized void setTimeZone(String zoneId)\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    defaultSessionConnection.setTimeZone(zoneId);\n+  }\n \n+  public void setStorageGroup(String storageGroup)\n+      throws IoTDBConnectionException, StatementExecutionException {\n     try {\n-      TSOpenSessionResp openResp = client.openSession(openReq);\n+      metaSessionConnection.setStorageGroup(storageGroup);\n+    } catch (RedirectException e) {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        logger.debug(\"storageGroup[{}]:{}\", storageGroup, e.getMessage());\n+        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n+        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);\n+      }\n+    }\n+  }\n \n-      RpcUtils.verifySuccess(openResp.getStatus());\n+  public void deleteStorageGroup(String storageGroup)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    try {\n+      metaSessionConnection.deleteStorageGroups(new ArrayList<String>() {{\n+        add(storageGroup);", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MjQxNA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486862414", "bodyText": "ok~", "author": "LebronAl", "createdAt": "2020-09-11T08:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/session/src/main/java/org/apache/iotdb/session/Session.java b/session/src/main/java/org/apache/iotdb/session/Session.java\nindex 7fa2096352..276e2c7ddc 100644\n--- a/session/src/main/java/org/apache/iotdb/session/Session.java\n+++ b/session/src/main/java/org/apache/iotdb/session/Session.java\n\n@@ -153,8 +154,9 @@ public class Session {\n     } catch (RedirectException e) {\n       if (Config.DEFAULT_CACHE_LEADER_MODE) {\n         logger.debug(\"storageGroup[{}]:{}\", storageGroup, e.getMessage());\n-        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n-        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);\n+        endPointToSessionConnection\n+            .putIfAbsent(e.getEndPoint(), new SessionConnection(this, e.getEndPoint()));\n+        metaSessionConnection = endPointToSessionConnection.get(e.getEndPoint());\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczOTI3MA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486739270", "bodyText": "I think new ArrayList<> is unnecessary.", "author": "jt2594838", "createdAt": "2020-09-11T02:38:05Z", "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "diffHunk": "@@ -121,209 +105,326 @@ private synchronized void open(boolean enableRPCCompression, int connectionTimeo\n     if (!isClosed) {\n       return;\n     }\n+    this.enableRPCCompression = enableRPCCompression;\n+    this.connectionTimeoutInMs = connectionTimeoutInMs;\n \n-    transport = new TFastFramedTransport(new TSocket(host, port, connectionTimeoutInMs));\n+    defaultSessionConnection = new SessionConnection(this, defaultEndPoint);\n+    metaSessionConnection = defaultSessionConnection;\n+    isClosed = false;\n+    if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+      deviceIdToEndpoint = new HashMap<>();\n+      endPointToSessionConnection = new HashMap<EndPoint, SessionConnection>() {{\n+        put(defaultEndPoint, defaultSessionConnection);\n+      }};\n+    }\n+  }\n \n-    if (!transport.isOpen()) {\n-      try {\n-        transport.open();\n-      } catch (TTransportException e) {\n-        throw new IoTDBConnectionException(e);\n+  public synchronized void close() throws IoTDBConnectionException {\n+    if (isClosed) {\n+      return;\n+    }\n+    try {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        for (SessionConnection sessionConnection : endPointToSessionConnection.values()) {\n+          sessionConnection.close();\n+        }\n+      } else {\n+        defaultSessionConnection.close();\n       }\n+    } finally {\n+      isClosed = true;\n     }\n+  }\n \n-    if (enableRPCCompression) {\n-      client = new TSIService.Client(new TCompactProtocol(transport));\n-    } else {\n-      client = new TSIService.Client(new TBinaryProtocol(transport));\n-    }\n+  public synchronized String getTimeZone()\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    return defaultSessionConnection.getTimeZone();\n+  }\n \n-    TSOpenSessionReq openReq = new TSOpenSessionReq();\n-    openReq.setUsername(username);\n-    openReq.setPassword(password);\n+  public synchronized void setTimeZone(String zoneId)\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    defaultSessionConnection.setTimeZone(zoneId);\n+  }\n \n+  public void setStorageGroup(String storageGroup)\n+      throws IoTDBConnectionException, StatementExecutionException {\n     try {\n-      TSOpenSessionResp openResp = client.openSession(openReq);\n+      metaSessionConnection.setStorageGroup(storageGroup);\n+    } catch (RedirectException e) {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        logger.debug(\"storageGroup[{}]:{}\", storageGroup, e.getMessage());\n+        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n+        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);\n+      }\n+    }\n+  }\n \n-      RpcUtils.verifySuccess(openResp.getStatus());\n+  public void deleteStorageGroup(String storageGroup)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    try {\n+      metaSessionConnection.deleteStorageGroups(new ArrayList<String>() {{\n+        add(storageGroup);\n+      }});\n+    } catch (RedirectException e) {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        logger.debug(\"storageGroup[{}]:{}\", storageGroup, e.getMessage());\n+        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n+        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);\n+      }\n+    }\n+  }\n \n-      if (protocolVersion.getValue() != openResp.getServerProtocolVersion().getValue()) {\n-        logger.warn(\"Protocol differ, Client version is {}}, but Server version is {}\",\n-            protocolVersion.getValue(), openResp.getServerProtocolVersion().getValue());\n-        if (openResp.getServerProtocolVersion().getValue() == 0) {// less than 0.10\n-          throw new TException(String\n-              .format(\"Protocol not supported, Client version is %s, but Server version is %s\",\n-                  protocolVersion.getValue(), openResp.getServerProtocolVersion().getValue()));\n-        }\n+  public void deleteStorageGroups(List<String> storageGroups)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    try {\n+      metaSessionConnection.deleteStorageGroups(storageGroups);\n+    } catch (RedirectException e) {\n+      if (Config.DEFAULT_CACHE_LEADER_MODE) {\n+        logger.debug(e.getMessage());\n+        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n+        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);\n       }\n+    }\n+  }\n \n-      sessionId = openResp.getSessionId();\n+  public void createTimeseries(String path, TSDataType dataType,\n+      TSEncoding encoding, CompressionType compressor)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    TSCreateTimeseriesReq request = genTSCreateTimeseriesReq(path, dataType, encoding, compressor,\n+        null, null, null, null);\n+    defaultSessionConnection.createTimeseries(request);\n+  }\n \n-      statementId = client.requestStatementId(sessionId);\n+  public void createTimeseries(String path, TSDataType dataType,\n+      TSEncoding encoding, CompressionType compressor, Map<String, String> props,\n+      Map<String, String> tags, Map<String, String> attributes, String measurementAlias)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    TSCreateTimeseriesReq request = genTSCreateTimeseriesReq(path, dataType, encoding, compressor,\n+        props, tags, attributes, measurementAlias);\n+    defaultSessionConnection.createTimeseries(request);\n+  }\n \n-      if (zoneId != null) {\n-        setTimeZone(zoneId.toString());\n-      } else {\n-        zoneId = ZoneId.of(getTimeZone());\n-      }\n+  private TSCreateTimeseriesReq genTSCreateTimeseriesReq(String path, TSDataType dataType,\n+      TSEncoding encoding, CompressionType compressor, Map<String, String> props,\n+      Map<String, String> tags, Map<String, String> attributes, String measurementAlias) {\n+    TSCreateTimeseriesReq request = new TSCreateTimeseriesReq();\n+    request.setPath(path);\n+    request.setDataType(dataType.ordinal());\n+    request.setEncoding(encoding.ordinal());\n+    request.setCompressor(compressor.ordinal());\n+    request.setProps(props);\n+    request.setTags(tags);\n+    request.setAttributes(attributes);\n+    request.setMeasurementAlias(measurementAlias);\n+    return request;\n+  }\n \n-    } catch (Exception e) {\n-      transport.close();\n-      throw new IoTDBConnectionException(e);\n-    }\n-    isClosed = false;\n+  public void createMultiTimeseries(List<String> paths, List<TSDataType> dataTypes,\n+      List<TSEncoding> encodings, List<CompressionType> compressors,\n+      List<Map<String, String>> propsList, List<Map<String, String>> tagsList,\n+      List<Map<String, String>> attributesList, List<String> measurementAliasList)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    TSCreateMultiTimeseriesReq request = genTSCreateMultiTimeseriesReq(paths, dataTypes, encodings,\n+        compressors, propsList, tagsList, attributesList, measurementAliasList);\n+    defaultSessionConnection.createMultiTimeseries(request);\n+  }\n \n-    client = RpcUtils.newSynchronizedClient(client);\n+  private TSCreateMultiTimeseriesReq genTSCreateMultiTimeseriesReq(List<String> paths,\n+      List<TSDataType> dataTypes,\n+      List<TSEncoding> encodings, List<CompressionType> compressors,\n+      List<Map<String, String>> propsList, List<Map<String, String>> tagsList,\n+      List<Map<String, String>> attributesList, List<String> measurementAliasList) {\n+    TSCreateMultiTimeseriesReq request = new TSCreateMultiTimeseriesReq();\n \n-  }\n+    request.setPaths(paths);\n \n-  public synchronized void close() throws IoTDBConnectionException {\n-    if (isClosed) {\n-      return;\n+    List<Integer> dataTypeOrdinals = new ArrayList<>(paths.size());\n+    for (TSDataType dataType : dataTypes) {\n+      dataTypeOrdinals.add(dataType.ordinal());\n     }\n-    TSCloseSessionReq req = new TSCloseSessionReq(sessionId);\n-    try {\n-      client.closeSession(req);\n-    } catch (TException e) {\n-      throw new IoTDBConnectionException(\n-          \"Error occurs when closing session at server. Maybe server is down.\", e);\n-    } finally {\n-      isClosed = true;\n-      if (transport != null) {\n-        transport.close();\n-      }\n+    request.setDataTypes(dataTypeOrdinals);\n+\n+    List<Integer> encodingOrdinals = new ArrayList<>(paths.size());\n+    for (TSEncoding encoding : encodings) {\n+      encodingOrdinals.add(encoding.ordinal());\n     }\n-  }\n+    request.setEncodings(encodingOrdinals);\n \n-  /**\n-   * insert data in one row, if you want to improve your performance, please use insertRecords\n-   * method or insertTablet method\n-   *\n-   * @see Session#insertRecords(List, List, List, List, List)\n-   * @see Session#insertTablet(Tablet)\n-   */\n-  public void insertRecord(String deviceId, long time, List<String> measurements,\n-      List<TSDataType> types,\n-      Object... values) throws IoTDBConnectionException, StatementExecutionException {\n-    List<Object> valuesList = new ArrayList<>(Arrays.asList(values));\n+    List<Integer> compressionOrdinals = new ArrayList<>(paths.size());\n+    for (CompressionType compression : compressors) {\n+      compressionOrdinals.add(compression.ordinal());\n+    }\n+    request.setCompressors(compressionOrdinals);\n \n-    insertRecord(deviceId, time, measurements, types, valuesList);\n+    request.setPropsList(propsList);\n+    request.setTagsList(tagsList);\n+    request.setAttributesList(attributesList);\n+    request.setMeasurementAliasList(measurementAliasList);\n+\n+    return request;\n   }\n \n+  public boolean checkTimeseriesExists(String path)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    return defaultSessionConnection.checkTimeseriesExists(path);\n+  }\n \n   /**\n-   * insert the data of a device. For each timestamp, the number of measurements is the same.\n-   * <p>\n-   * a Tablet example:\n-   * <p>\n-   * device1 time s1, s2, s3 1,   1,  1,  1 2,   2,  2,  2 3,   3,  3,  3\n-   * <p>\n-   * times in Tablet may be not in ascending order\n+   * execure query sql\n    *\n-   * @param tablet data batch\n+   * @param sql query statement\n+   * @return result set\n    */\n-  public void insertTablet(Tablet tablet)\n+  public SessionDataSet executeQueryStatement(String sql)\n       throws StatementExecutionException, IoTDBConnectionException {\n-    insertTablet(tablet, false);\n+    return defaultSessionConnection.executeQueryStatement(sql);\n   }\n \n   /**\n-   * insert a Tablet\n+   * execute non query statement\n    *\n-   * @param tablet data batch\n-   * @param sorted whether times in Tablet are in ascending order\n+   * @param sql non query statement\n    */\n-  public void insertTablet(Tablet tablet, boolean sorted)\n+  public void executeNonQueryStatement(String sql)\n       throws IoTDBConnectionException, StatementExecutionException {\n-    TSInsertTabletReq request = genTSInsertTabletReq(tablet, sorted);\n-    try {\n-      RpcUtils.verifySuccess(client.insertTablet(request));\n-    } catch (TException e) {\n-      throw new IoTDBConnectionException(e);\n-    }\n+    defaultSessionConnection.executeNonQueryStatement(sql);\n   }\n \n-  private TSInsertTabletReq genTSInsertTabletReq(Tablet tablet, boolean sorted)\n-      throws BatchExecutionException {\n-    if (sorted) {\n-      if (!checkSorted(tablet)) {\n-        throw new BatchExecutionException(\"Times in Tablet are not in ascending order\");\n-      }\n-    } else {\n-      sortTablet(tablet);\n-    }\n+  /**\n+   * query eg. select * from paths where time >= startTime and time < endTime time interval include\n+   * startTime and exclude endTime\n+   *\n+   * @param paths\n+   * @param startTime included\n+   * @param endTime   excluded\n+   * @return\n+   * @throws StatementExecutionException\n+   * @throws IoTDBConnectionException\n+   */\n \n-    TSInsertTabletReq request = new TSInsertTabletReq();\n-    request.setSessionId(sessionId);\n-    request.deviceId = tablet.deviceId;\n-    for (MeasurementSchema measurementSchema : tablet.getSchemas()) {\n-      request.addToMeasurements(measurementSchema.getMeasurementId());\n-      request.addToTypes(measurementSchema.getType().ordinal());\n-    }\n-    request.setTimestamps(SessionUtils.getTimeBuffer(tablet));\n-    request.setValues(SessionUtils.getValueBuffer(tablet));\n-    request.setSize(tablet.rowSize);\n+  public SessionDataSet executeRawDataQuery(List<String> paths, long startTime, long endTime)\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    TSRawDataQueryReq request = genTSRawDataQueryReq(paths, startTime, endTime);\n+    return defaultSessionConnection.executeRawDataQuery(request);\n+  }\n+\n+  private TSRawDataQueryReq genTSRawDataQueryReq(List<String> paths, long startTime, long endTime) {\n+    TSRawDataQueryReq request = new TSRawDataQueryReq();\n+    request.setPaths(paths);\n+    request.setStartTime(startTime);\n+    request.setEndTime(endTime);\n     return request;\n   }\n \n   /**\n-   * insert the data of several deivces. Given a deivce, for each timestamp, the number of\n-   * measurements is the same.\n-   * <p>\n-   * Times in each Tablet may not be in ascending order\n+   * insert data in one row, if you want to improve your performance, please use insertRecords\n+   * method or insertTablet method\n    *\n-   * @param tablets data batch in multiple device\n+   * @see Session#insertRecords(List, List, List, List, List)\n+   * @see Session#insertTablet(Tablet)\n    */\n-  public void insertTablets(Map<String, Tablet> tablets)\n-      throws IoTDBConnectionException, StatementExecutionException {\n-    insertTablets(tablets, false);\n+  public void insertRecord(String deviceId, long time, List<String> measurements,\n+      List<TSDataType> types,\n+      Object... values) throws IoTDBConnectionException, StatementExecutionException {\n+    TSInsertRecordReq request = genTSInsertRecordReq(deviceId, time, measurements, types,\n+        new ArrayList<>(Arrays.asList(values)));", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MjA3NQ==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486862075", "bodyText": "ok~", "author": "LebronAl", "createdAt": "2020-09-11T08:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczOTI3MA=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/session/src/main/java/org/apache/iotdb/session/Session.java b/session/src/main/java/org/apache/iotdb/session/Session.java\nindex 7fa2096352..276e2c7ddc 100644\n--- a/session/src/main/java/org/apache/iotdb/session/Session.java\n+++ b/session/src/main/java/org/apache/iotdb/session/Session.java\n\n@@ -153,8 +154,9 @@ public class Session {\n     } catch (RedirectException e) {\n       if (Config.DEFAULT_CACHE_LEADER_MODE) {\n         logger.debug(\"storageGroup[{}]:{}\", storageGroup, e.getMessage());\n-        metaSessionConnection = new SessionConnection(this, e.getEndPoint());\n-        endPointToSessionConnection.putIfAbsent(e.getEndPoint(), metaSessionConnection);\n+        endPointToSessionConnection\n+            .putIfAbsent(e.getEndPoint(), new SessionConnection(this, e.getEndPoint()));\n+        metaSessionConnection = endPointToSessionConnection.get(e.getEndPoint());\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NDc0Mw==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486744743", "bodyText": "Collections.singletonList should be enough.", "author": "jt2594838", "createdAt": "2020-09-11T02:58:46Z", "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "diffHunk": "@@ -691,42 +857,38 @@ public void testInsertRecord(String deviceId, long time, List<String> measuremen\n    */\n   public void deleteTimeseries(String path)\n       throws IoTDBConnectionException, StatementExecutionException {\n-    List<String> paths = new ArrayList<>();\n-    paths.add(path);\n-    deleteTimeseries(paths);\n+    defaultSessionConnection.deleteTimeseries(new ArrayList<String>() {{\n+      add(path);", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MTY1NQ==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486861655", "bodyText": "OK~", "author": "LebronAl", "createdAt": "2020-09-11T08:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NDc0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/session/src/main/java/org/apache/iotdb/session/Session.java b/session/src/main/java/org/apache/iotdb/session/Session.java\nindex 7fa2096352..276e2c7ddc 100644\n--- a/session/src/main/java/org/apache/iotdb/session/Session.java\n+++ b/session/src/main/java/org/apache/iotdb/session/Session.java\n\n@@ -857,9 +857,7 @@ public class Session {\n    */\n   public void deleteTimeseries(String path)\n       throws IoTDBConnectionException, StatementExecutionException {\n-    defaultSessionConnection.deleteTimeseries(new ArrayList<String>() {{\n-      add(path);\n-    }});\n+    defaultSessionConnection.deleteTimeseries(Collections.singletonList(path));\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTY4MA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486745680", "bodyText": "I think this condition is redundant.", "author": "jt2594838", "createdAt": "2020-09-11T03:02:22Z", "path": "session/src/main/java/org/apache/iotdb/session/SessionConnection.java", "diffHunk": "@@ -0,0 +1,401 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.session;\n+\n+import java.time.ZoneId;\n+import java.util.List;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.RedirectException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.service.rpc.thrift.EndPoint;\n+import org.apache.iotdb.service.rpc.thrift.TSCloseSessionReq;\n+import org.apache.iotdb.service.rpc.thrift.TSCreateMultiTimeseriesReq;\n+import org.apache.iotdb.service.rpc.thrift.TSCreateTimeseriesReq;\n+import org.apache.iotdb.service.rpc.thrift.TSDeleteDataReq;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteStatementReq;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSGetTimeZoneResp;\n+import org.apache.iotdb.service.rpc.thrift.TSIService;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertRecordReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertRecordsReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertStringRecordReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertStringRecordsReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertTabletReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertTabletsReq;\n+import org.apache.iotdb.service.rpc.thrift.TSOpenSessionReq;\n+import org.apache.iotdb.service.rpc.thrift.TSOpenSessionResp;\n+import org.apache.iotdb.service.rpc.thrift.TSRawDataQueryReq;\n+import org.apache.iotdb.service.rpc.thrift.TSSetTimeZoneReq;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.thrift.TException;\n+import org.apache.thrift.protocol.TBinaryProtocol;\n+import org.apache.thrift.protocol.TCompactProtocol;\n+import org.apache.thrift.transport.TFastFramedTransport;\n+import org.apache.thrift.transport.TSocket;\n+import org.apache.thrift.transport.TTransport;\n+import org.apache.thrift.transport.TTransportException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SessionConnection {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionConnection.class);\n+  private Session session;\n+  private TTransport transport;\n+  private TSIService.Iface client;\n+  private long sessionId;\n+  private long statementId;\n+  private ZoneId zoneId;\n+\n+  public SessionConnection(Session session, EndPoint endPoint) throws IoTDBConnectionException {\n+    this.session = session;\n+    init(endPoint);\n+  }\n+\n+  private void init(EndPoint endPoint) throws IoTDBConnectionException {\n+    transport = new TFastFramedTransport(\n+        new TSocket(endPoint.getIp(), endPoint.getPort(), session.connectionTimeoutInMs));\n+\n+    if (!transport.isOpen()) {", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MDgxNQ==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486860815", "bodyText": "I copy this from old session's implemention.I will delete it anyway.", "author": "LebronAl", "createdAt": "2020-09-11T08:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/session/src/main/java/org/apache/iotdb/session/SessionConnection.java b/session/src/main/java/org/apache/iotdb/session/SessionConnection.java\nindex 7d9def47ba..47bad3cd74 100644\n--- a/session/src/main/java/org/apache/iotdb/session/SessionConnection.java\n+++ b/session/src/main/java/org/apache/iotdb/session/SessionConnection.java\n\n@@ -74,12 +74,10 @@ public class SessionConnection {\n     transport = new TFastFramedTransport(\n         new TSocket(endPoint.getIp(), endPoint.getPort(), session.connectionTimeoutInMs));\n \n-    if (!transport.isOpen()) {\n-      try {\n-        transport.open();\n-      } catch (TTransportException e) {\n-        throw new IoTDBConnectionException(e);\n-      }\n+    try {\n+      transport.open();\n+    } catch (TTransportException e) {\n+      throw new IoTDBConnectionException(e);\n     }\n \n     if (session.enableRPCCompression) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0ODgzOQ==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486748839", "bodyText": "Close operation should be put into a finally block.", "author": "jt2594838", "createdAt": "2020-09-11T03:15:19Z", "path": "session/src/main/java/org/apache/iotdb/session/SessionConnection.java", "diffHunk": "@@ -0,0 +1,401 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.session;\n+\n+import java.time.ZoneId;\n+import java.util.List;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.RedirectException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.service.rpc.thrift.EndPoint;\n+import org.apache.iotdb.service.rpc.thrift.TSCloseSessionReq;\n+import org.apache.iotdb.service.rpc.thrift.TSCreateMultiTimeseriesReq;\n+import org.apache.iotdb.service.rpc.thrift.TSCreateTimeseriesReq;\n+import org.apache.iotdb.service.rpc.thrift.TSDeleteDataReq;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteStatementReq;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSGetTimeZoneResp;\n+import org.apache.iotdb.service.rpc.thrift.TSIService;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertRecordReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertRecordsReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertStringRecordReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertStringRecordsReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertTabletReq;\n+import org.apache.iotdb.service.rpc.thrift.TSInsertTabletsReq;\n+import org.apache.iotdb.service.rpc.thrift.TSOpenSessionReq;\n+import org.apache.iotdb.service.rpc.thrift.TSOpenSessionResp;\n+import org.apache.iotdb.service.rpc.thrift.TSRawDataQueryReq;\n+import org.apache.iotdb.service.rpc.thrift.TSSetTimeZoneReq;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.thrift.TException;\n+import org.apache.thrift.protocol.TBinaryProtocol;\n+import org.apache.thrift.protocol.TCompactProtocol;\n+import org.apache.thrift.transport.TFastFramedTransport;\n+import org.apache.thrift.transport.TSocket;\n+import org.apache.thrift.transport.TTransport;\n+import org.apache.thrift.transport.TTransportException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SessionConnection {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionConnection.class);\n+  private Session session;\n+  private TTransport transport;\n+  private TSIService.Iface client;\n+  private long sessionId;\n+  private long statementId;\n+  private ZoneId zoneId;\n+\n+  public SessionConnection(Session session, EndPoint endPoint) throws IoTDBConnectionException {\n+    this.session = session;\n+    init(endPoint);\n+  }\n+\n+  private void init(EndPoint endPoint) throws IoTDBConnectionException {\n+    transport = new TFastFramedTransport(\n+        new TSocket(endPoint.getIp(), endPoint.getPort(), session.connectionTimeoutInMs));\n+\n+    if (!transport.isOpen()) {\n+      try {\n+        transport.open();\n+      } catch (TTransportException e) {\n+        throw new IoTDBConnectionException(e);\n+      }\n+    }\n+\n+    if (session.enableRPCCompression) {\n+      client = new TSIService.Client(new TCompactProtocol(transport));\n+    } else {\n+      client = new TSIService.Client(new TBinaryProtocol(transport));\n+    }\n+\n+    TSOpenSessionReq openReq = new TSOpenSessionReq();\n+    openReq.setUsername(session.username);\n+    openReq.setPassword(session.password);\n+\n+    try {\n+      TSOpenSessionResp openResp = client.openSession(openReq);\n+\n+      RpcUtils.verifySuccess(openResp.getStatus());\n+\n+      if (session.protocolVersion.getValue() != openResp.getServerProtocolVersion().getValue()) {\n+        logger.warn(\"Protocol differ, Client version is {}}, but Server version is {}\",\n+            session.protocolVersion.getValue(), openResp.getServerProtocolVersion().getValue());\n+        if (openResp.getServerProtocolVersion().getValue() == 0) {// less than 0.10\n+          throw new TException(String\n+              .format(\"Protocol not supported, Client version is %s, but Server version is %s\",\n+                  session.protocolVersion.getValue(),\n+                  openResp.getServerProtocolVersion().getValue()));\n+        }\n+      }\n+\n+      sessionId = openResp.getSessionId();\n+      statementId = client.requestStatementId(sessionId);\n+\n+      if (zoneId != null) {\n+        setTimeZone(zoneId.toString());\n+      } else {\n+        zoneId = ZoneId.of(getTimeZone());\n+      }\n+\n+    } catch (Exception e) {\n+      transport.close();\n+      throw new IoTDBConnectionException(e);\n+    }\n+  }\n+\n+\n+  public void close() throws IoTDBConnectionException {\n+    TSCloseSessionReq req = new TSCloseSessionReq(sessionId);\n+    try {\n+      client.closeSession(req);\n+    } catch (TException e) {\n+      throw new IoTDBConnectionException(\n+          \"Error occurs when closing session at server. Maybe server is down.\", e);\n+    } finally {\n+      if (transport != null) {\n+        transport.close();\n+      }\n+    }\n+  }\n+\n+  protected void setTimeZone(String zoneId)\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    TSSetTimeZoneReq req = new TSSetTimeZoneReq(sessionId, zoneId);\n+    TSStatus resp;\n+    try {\n+      resp = client.setTimeZone(req);\n+    } catch (TException e) {\n+      throw new IoTDBConnectionException(e);\n+    }\n+    RpcUtils.verifySuccess(resp);\n+    this.zoneId = ZoneId.of(zoneId);\n+  }\n+\n+  protected String getTimeZone()\n+      throws StatementExecutionException, IoTDBConnectionException {\n+    if (zoneId != null) {\n+      return zoneId.toString();\n+    }\n+    TSGetTimeZoneResp resp;\n+    try {\n+      resp = client.getTimeZone(sessionId);\n+    } catch (TException e) {\n+      throw new IoTDBConnectionException(e);\n+    }\n+    RpcUtils.verifySuccess(resp.getStatus());\n+    return resp.getTimeZone();\n+  }\n+\n+  protected void setStorageGroup(String storageGroup)\n+      throws IoTDBConnectionException, StatementExecutionException, RedirectException {\n+    try {\n+      RpcUtils.verifySuccessWithRedirection(client.setStorageGroup(sessionId, storageGroup));\n+    } catch (TException e) {\n+      throw new IoTDBConnectionException(e);\n+    }\n+  }\n+\n+  protected void deleteStorageGroups(List<String> storageGroups)\n+      throws IoTDBConnectionException, StatementExecutionException, RedirectException {\n+    try {\n+      RpcUtils.verifySuccessWithRedirection(client.deleteStorageGroups(sessionId, storageGroups));\n+    } catch (TException e) {\n+      throw new IoTDBConnectionException(e);\n+    }\n+  }\n+\n+  protected void createTimeseries(TSCreateTimeseriesReq request)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    request.setSessionId(sessionId);\n+    try {\n+      RpcUtils.verifySuccess(client.createTimeseries(request));\n+    } catch (TException e) {\n+      throw new IoTDBConnectionException(e);\n+    }\n+  }\n+\n+  protected void createMultiTimeseries(TSCreateMultiTimeseriesReq request)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    request.setSessionId(sessionId);\n+    try {\n+      RpcUtils.verifySuccess(client.createMultiTimeseries(request));\n+    } catch (TException e) {\n+      throw new IoTDBConnectionException(e);\n+    }\n+  }\n+\n+  protected boolean checkTimeseriesExists(String path)\n+      throws IoTDBConnectionException, StatementExecutionException {\n+    SessionDataSet dataSet = executeQueryStatement(String.format(\"SHOW TIMESERIES %s\", path));\n+    boolean result = dataSet.hasNext();\n+    dataSet.closeOperationHandle();", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MDAyNQ==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486860025", "bodyText": "OK~", "author": "LebronAl", "createdAt": "2020-09-11T08:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0ODgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/session/src/main/java/org/apache/iotdb/session/SessionConnection.java b/session/src/main/java/org/apache/iotdb/session/SessionConnection.java\nindex 7d9def47ba..47bad3cd74 100644\n--- a/session/src/main/java/org/apache/iotdb/session/SessionConnection.java\n+++ b/session/src/main/java/org/apache/iotdb/session/SessionConnection.java\n\n@@ -74,12 +74,10 @@ public class SessionConnection {\n     transport = new TFastFramedTransport(\n         new TSocket(endPoint.getIp(), endPoint.getPort(), session.connectionTimeoutInMs));\n \n-    if (!transport.isOpen()) {\n-      try {\n-        transport.open();\n-      } catch (TTransportException e) {\n-        throw new IoTDBConnectionException(e);\n-      }\n+    try {\n+      transport.open();\n+    } catch (TTransportException e) {\n+      throw new IoTDBConnectionException(e);\n     }\n \n     if (session.enableRPCCompression) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNzc0NA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486807744", "bodyText": "the return result; statements should be outside of the if (!StatusUtils.NO_LEADER.equals(result)) { statements?\nOtherwise, the plan will be executed twice.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!StatusUtils.NO_LEADER.equals(result)) {\n          \n          \n            \n                    result.setRedirectNode(new EndPoint(leader.getIp(), leader.getClientPort()));\n          \n          \n            \n                    return result;\n          \n          \n            \n                  }\n          \n          \n            \n                  if (!StatusUtils.NO_LEADER.equals(result)) {\n          \n          \n            \n                    result.setRedirectNode(new EndPoint(leader.getIp(), leader.getClientPort()));\n          \n          \n            \n                  }\n          \n          \n            \n                  return result;", "author": "neuyilan", "createdAt": "2020-09-11T06:46:17Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1115,7 +1118,11 @@ TSStatus executeNonQueryPlan(PhysicalPlan plan) {\n         return status;\n       }\n     } else if (leader != null) {\n-      return forwardPlan(plan, leader, getHeader());\n+      TSStatus result = forwardPlan(plan, leader, getHeader());\n+      if (!StatusUtils.NO_LEADER.equals(result)) {\n+        result.setRedirectNode(new EndPoint(leader.getIp(), leader.getClientPort()));\n+        return result;\n+      }", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxNzk1Mg==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r487017952", "bodyText": "Actually I designed this on purpose. If the first call to the forwardPlan function returns StatusUtils.NO_LEADER. We should block this request until the new leader is elected. So the following code should be called. This is why I put this return statement in the scope of if. Of course,  If the second call to the forwardPlan function returns StatusUtils.NO_LEADER too, then maybe just return will be better~", "author": "LebronAl", "createdAt": "2020-09-11T12:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM1MjIxMA==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r487352210", "bodyText": "I got it, better add more comments here~", "author": "neuyilan", "createdAt": "2020-09-12T01:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3MjkzNw==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r487372937", "bodyText": "copy that!", "author": "LebronAl", "createdAt": "2020-09-12T05:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNzc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\nindex c14650694c..5b5dd1e445 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n\n@@ -1119,6 +1119,7 @@ public class DataGroupMember extends RaftMember {\n       }\n     } else if (leader != null) {\n       TSStatus result = forwardPlan(plan, leader, getHeader());\n+      // If result equals StatusUtils.NO_LEADER, block this request until the new leader is elected.\n       if (!StatusUtils.NO_LEADER.equals(result)) {\n         result.setRedirectNode(new EndPoint(leader.getIp(), leader.getClientPort()));\n         return result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwOTA4Mw==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r486809083", "bodyText": "same as above, outside of the if statement", "author": "neuyilan", "createdAt": "2020-09-11T06:49:22Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1486,7 +1485,11 @@ private TSStatus processNonPartitionedMetaPlan(PhysicalPlan plan) {\n         return status;\n       }\n     } else if (leader != null) {\n-      return forwardPlan(plan, leader, null);\n+      TSStatus result = forwardPlan(plan, leader, null);\n+      if (!StatusUtils.NO_LEADER.equals(result)) {\n+        result.setRedirectNode(new EndPoint(leader.getIp(), leader.getClientPort()));\n+        return result;", "originalCommit": "d6331be4745840925d733a482194a4b1caa9abec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxODczMg==", "url": "https://github.com/apache/iotdb/pull/1691#discussion_r487018732", "bodyText": "same as above~ Anything can be discussed here~", "author": "LebronAl", "createdAt": "2020-09-11T12:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwOTA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "dabae00afab9813d45e0056f232c6dcef3532a84", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex f2ce874052..ca5ce9421d 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1474,11 +1309,8 @@ public class MetaGroupMember extends RaftMember {\n    * so the MetaLeader should take the responsible to make sure that every node receives the plan.\n    * Thus the plan will be processed locally only by the MetaLeader and forwarded by non-leader\n    * nodes.\n-   *\n-   * @param plan\n-   * @return\n    */\n-  private TSStatus processNonPartitionedMetaPlan(PhysicalPlan plan) {\n+  public TSStatus processNonPartitionedMetaPlan(PhysicalPlan plan) {\n     if (character == NodeCharacter.LEADER) {\n       TSStatus status = processPlanLocally(plan);\n       if (status != null) {\n"}}, {"oid": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "url": "https://github.com/apache/iotdb/commit/31817d16af5acb83929a13efb2d4e98fd92ca9b5", "message": "fix review", "committedDate": "2020-09-14T02:51:13Z", "type": "commit"}, {"oid": "31817d16af5acb83929a13efb2d4e98fd92ca9b5", "url": "https://github.com/apache/iotdb/commit/31817d16af5acb83929a13efb2d4e98fd92ca9b5", "message": "fix review", "committedDate": "2020-09-14T02:51:13Z", "type": "forcePushed"}, {"oid": "efcf3fe9b75a4fc788b5672b289ffa86eccf81f4", "url": "https://github.com/apache/iotdb/commit/efcf3fe9b75a4fc788b5672b289ffa86eccf81f4", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-14T02:52:52Z", "type": "commit"}, {"oid": "efcf3fe9b75a4fc788b5672b289ffa86eccf81f4", "url": "https://github.com/apache/iotdb/commit/efcf3fe9b75a4fc788b5672b289ffa86eccf81f4", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-14T02:52:52Z", "type": "forcePushed"}, {"oid": "8178bba53033239fa8dcc20fd924cdf9f686293b", "url": "https://github.com/apache/iotdb/commit/8178bba53033239fa8dcc20fd924cdf9f686293b", "message": "adjust insertTabletPlan maxTime and minTime cache", "committedDate": "2020-09-14T07:54:04Z", "type": "forcePushed"}, {"oid": "5869775d7fc4a60ec1a52879a81ea1dcacb76d22", "url": "https://github.com/apache/iotdb/commit/5869775d7fc4a60ec1a52879a81ea1dcacb76d22", "message": "adjust insertTabletPlan maxTime and minTime cache", "committedDate": "2020-09-14T07:57:02Z", "type": "commit"}, {"oid": "dabae00afab9813d45e0056f232c6dcef3532a84", "url": "https://github.com/apache/iotdb/commit/dabae00afab9813d45e0056f232c6dcef3532a84", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-14T08:29:26Z", "type": "commit"}, {"oid": "dabae00afab9813d45e0056f232c6dcef3532a84", "url": "https://github.com/apache/iotdb/commit/dabae00afab9813d45e0056f232c6dcef3532a84", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-14T08:29:26Z", "type": "forcePushed"}, {"oid": "b2e92ed6809cf7fe6ef1cc5ca0f2fa2b9ffb8feb", "url": "https://github.com/apache/iotdb/commit/b2e92ed6809cf7fe6ef1cc5ca0f2fa2b9ffb8feb", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-15T11:29:47Z", "type": "commit"}, {"oid": "7d12d5ba2cd61f505864219bf946289423b50e73", "url": "https://github.com/apache/iotdb/commit/7d12d5ba2cd61f505864219bf946289423b50e73", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-17T15:43:17Z", "type": "commit"}, {"oid": "ba4a74dbb4a67008b958c191e444ad68c7cdc1dd", "url": "https://github.com/apache/iotdb/commit/ba4a74dbb4a67008b958c191e444ad68c7cdc1dd", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-18T08:25:54Z", "type": "commit"}, {"oid": "3a949ba5601747cdffa038b6354c55415d58d28c", "url": "https://github.com/apache/iotdb/commit/3a949ba5601747cdffa038b6354c55415d58d28c", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_cache_leader", "committedDate": "2020-09-18T12:34:05Z", "type": "commit"}]}