{"pr_number": 1387, "pr_title": "[IOTDB-709] Create schema automatically", "pr_createdAt": "2020-06-18T09:02:13Z", "pr_url": "https://github.com/apache/iotdb/pull/1387", "timeline": [{"oid": "e4f19e52c55ba2171ed939ce2b40da13c5c299fa", "url": "https://github.com/apache/iotdb/commit/e4f19e52c55ba2171ed939ce2b40da13c5c299fa", "message": "auto schema creation", "committedDate": "2020-06-18T07:50:29Z", "type": "commit"}, {"oid": "267c814be2c8cd0457bbda9996a1b3c2b7515be8", "url": "https://github.com/apache/iotdb/commit/267c814be2c8cd0457bbda9996a1b3c2b7515be8", "message": "add comment", "committedDate": "2020-06-18T09:12:42Z", "type": "commit"}, {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "url": "https://github.com/apache/iotdb/commit/484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "message": "fix sonar", "committedDate": "2020-06-19T00:37:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMwOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442594308", "bodyText": "This should still be debug.", "author": "jt2594838", "createdAt": "2020-06-19T02:12:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()\n+          .isAutoCreateSchemaEnabled()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.info(\"Failed to set storage group of device id {}\", deviceId);\n+        }\n+      }\n+      logger.error(\"{}: Cannot found storage groups for {}\", name, plan);\n       return StatusUtils.NO_STORAGE_GROUP;\n     }\n-    logger.debug(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);\n+    logger.error(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTA2NA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443679064", "bodyText": "Alright, I will revert.", "author": "Ring-k", "createdAt": "2020-06-22T16:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMwOA=="}], "type": "inlineReview", "revised_code": {"commit": "8ea91ee1062bb191e6047f873b71b10e22120f42", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 0c2139dd1a..42087c5a62 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1559,7 +1569,7 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n       return StatusUtils.NO_STORAGE_GROUP;\n     }\n     logger.error(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);\n-    return forwardPlan(planGroupMap);\n+    return forwardPlan(planGroupMap, plan);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjE5Nw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442596197", "bodyText": "I think we should add a specific status code like \"TSStatusCode.NO_TIMESERIES\", as this one is too abstract and we are not sure whether it is because of no metadata.", "author": "jt2594838", "createdAt": "2020-06-19T02:20:40Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwNjk0OA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444706948", "bodyText": "Thanks for your suggestion. The error code TIMESERIES_NOT_EXIST will be introduced.", "author": "Ring-k", "createdAt": "2020-06-24T07:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8ea91ee1062bb191e6047f873b71b10e22120f42", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 0c2139dd1a..42087c5a62 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1569,30 +1579,134 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n    * @param planGroupMap\n    * @return\n    */\n-  TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n-    TSStatus status;\n+  TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap, PhysicalPlan plan) {\n     // the error codes from the groups that cannot execute the plan\n-    List<String> errorCodePartitionGroups = new ArrayList<>();\n-    TSStatus subStatus = StatusUtils.OK;\n-    for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n+    TSStatus status;\n+    if (planGroupMap.size() == 1) {\n+      Map.Entry<PhysicalPlan, PartitionGroup> entry = planGroupMap.entrySet().iterator().next();\n       if (entry.getValue().contains(thisNode)) {\n         // the query should be handled by a group the local node is in, handle it with in the group\n-        subStatus = getLocalDataMember(entry.getValue().getHeader())\n+        logger.debug(\"Execute {} in a local group of {}\", entry.getKey(),\n+            entry.getValue().getHeader());\n+        status = getLocalDataMember(entry.getValue().getHeader())\n             .executeNonQuery(entry.getKey());\n       } else {\n         // forward the query to the group that should handle it\n-        subStatus = forwardPlan(entry.getKey(), entry.getValue());\n+        logger.debug(\"Forward {} to a remote group of {}\", entry.getKey(),\n+            entry.getValue().getHeader());\n+        status = forwardPlan(entry.getKey(), entry.getValue());\n+      }\n+    } else {\n+      TSStatus tmpStatus;\n+      List<String> errorCodePartitionGroups = new ArrayList<>();\n+      if (plan instanceof InsertTabletPlan) {\n+        TSStatus[] subStatus = new TSStatus[((InsertTabletPlan) plan).getRowCount()];\n+        boolean noFailure = true;\n+        boolean isBatchFailure = false;\n+        for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n+          if (entry.getValue().contains(thisNode)) {\n+            // the query should be handled by a group the local node is in, handle it with in the group\n+            logger.debug(\"Execute {} in a local group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = getLocalDataMember(entry.getValue().getHeader())\n+                .executeNonQuery(entry.getKey());\n+          } else {\n+            // forward the query to the group that should handle it\n+            logger.debug(\"Forward {} to a remote group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = forwardPlan(entry.getKey(), entry.getValue());\n+          }\n+          logger.debug(\"{}: from {},{},{}\", name, entry.getKey(), entry.getValue(), tmpStatus);\n+          noFailure =\n+              (tmpStatus.getCode() == TSStatusCode.SUCCESS_STATUS.getStatusCode()) && noFailure;\n+          isBatchFailure = (tmpStatus.getCode() == TSStatusCode.MULTIPLE_ERROR.getStatusCode())\n+              || isBatchFailure;\n+          PartitionUtils.reordering((InsertTabletPlan) entry.getKey(), subStatus,\n+              tmpStatus.subStatus == null ? RpcUtils\n+                  .getStatus(((InsertTabletPlan) entry.getKey()).getRowCount())\n+                  : tmpStatus.subStatus.toArray(new TSStatus[]{}));\n+          if (tmpStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            // execution failed, record the error message\n+            errorCodePartitionGroups.add(String.format(\"[%s@%s:%s:%s]\",\n+                tmpStatus.getCode(), entry.getValue().getHeader(),\n+                tmpStatus.getMessage(), tmpStatus.subStatus));\n+          }\n+        }\n+        if (noFailure) {\n+          status = StatusUtils.OK;\n+        } else if (isBatchFailure) {\n+          status = RpcUtils.getStatus(Arrays.asList(subStatus));\n+        } else {\n+          status = StatusUtils.EXECUTE_STATEMENT_ERROR.deepCopy();\n+          status.setMessage(\"The following errors occurred when executing the query, \"\n+              + \"please retry or contact the DBA: \" + errorCodePartitionGroups.toString());\n+        }\n+      } else {\n+        for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n+          if (entry.getValue().contains(thisNode)) {\n+            // the query should be handled by a group the local node is in, handle it with in the group\n+            logger.debug(\"Execute {} in a local group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = getLocalDataMember(entry.getValue().getHeader())\n+                .executeNonQuery(entry.getKey());\n+          } else {\n+            // forward the query to the group that should handle it\n+            logger.debug(\"Forward {} to a remote group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = forwardPlan(entry.getKey(), entry.getValue());\n+          }\n+          if (tmpStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            // execution failed, record the error message\n+            errorCodePartitionGroups.add(String.format(\"[%s@%s:%s]\",\n+                tmpStatus.getCode(), entry.getValue().getHeader(),\n+                tmpStatus.getMessage()));\n+          }\n+        }\n+        if (errorCodePartitionGroups.size() == 0) {\n+          status = StatusUtils.OK;\n+        } else {\n+          status = StatusUtils.EXECUTE_STATEMENT_ERROR.deepCopy();\n+          status.setMessage(\"The following errors occurred when executing the query, \"\n+              + \"please retry or contact the DBA: \" + errorCodePartitionGroups.toString());\n+        }\n+      }\n+    }\n+    logger.debug(\"{}: executed {} with answer {}\", name, plan, status);\n+    return status;\n+  }\n+\n+  /**\n+   * Forward plans to all DataGroupMember groups. Only when all nodes time out, will a TIME_OUT be\n+   * returned.\n+   *\n+   * @param partitionGroups\n+   * @return\n+   * @para plan\n+   */\n+  TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n+    // the error codes from the groups that cannot execute the plan\n+    TSStatus status;\n+    List<String> errorCodePartitionGroups = new ArrayList<>();\n+    for (PartitionGroup partitionGroup : partitionGroups) {\n+      if (partitionGroup.contains(thisNode)) {\n+        // the query should be handled by a group the local node is in, handle it with in the group\n+        logger.debug(\"Execute {} in a local group of {}\", plan, partitionGroup.getHeader());\n+        status = getLocalDataMember(partitionGroup.getHeader())\n+            .executeNonQuery(plan);\n+      } else {\n+        // forward the query to the group that should handle it\n+        logger.debug(\"Forward {} to a remote group of {}\", plan,\n+            partitionGroup.getHeader());\n+        status = forwardPlan(plan, partitionGroup);\n       }\n-      if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n-        if (entry.getKey() instanceof InsertPlan\n-            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n+      if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (plan instanceof InsertPlan\n+            && status.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n             && IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n           // try to create timeseries\n-          boolean hasCreate = autoCreateTimeseries((InsertPlan) entry.getKey(), entry.getValue());\n+          boolean hasCreate = autoCreateTimeseries((InsertPlan) plan, partitionGroup);\n           if (hasCreate) {\n-            Map<PhysicalPlan, PartitionGroup> subPlan = new HashMap<>();\n-            subPlan.put(entry.getKey(), entry.getValue());\n-            subStatus = forwardPlan(subPlan);\n+            status = forwardPlan(plan, partitionGroup);\n             continue;\n           } else {\n             logger.error(\"{}, Cannot auto create timeseries.\", thisNode);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5ODM1Mg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442598352", "bodyText": "\"entry.getValue()\" is the data group you are going to send the plan to, and it may not be the group that should hold the metadata, so create timeseries plans should be forward to the group that should hold the metadata.", "author": "jt2594838", "createdAt": "2020-06-19T02:29:52Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n+            && IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n+          // try to create timeseries\n+          boolean hasCreate = autoCreateTimeseries((InsertPlan) entry.getKey(), entry.getValue());", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ea91ee1062bb191e6047f873b71b10e22120f42", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 0c2139dd1a..42087c5a62 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1569,30 +1579,134 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n    * @param planGroupMap\n    * @return\n    */\n-  TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n-    TSStatus status;\n+  TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap, PhysicalPlan plan) {\n     // the error codes from the groups that cannot execute the plan\n-    List<String> errorCodePartitionGroups = new ArrayList<>();\n-    TSStatus subStatus = StatusUtils.OK;\n-    for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n+    TSStatus status;\n+    if (planGroupMap.size() == 1) {\n+      Map.Entry<PhysicalPlan, PartitionGroup> entry = planGroupMap.entrySet().iterator().next();\n       if (entry.getValue().contains(thisNode)) {\n         // the query should be handled by a group the local node is in, handle it with in the group\n-        subStatus = getLocalDataMember(entry.getValue().getHeader())\n+        logger.debug(\"Execute {} in a local group of {}\", entry.getKey(),\n+            entry.getValue().getHeader());\n+        status = getLocalDataMember(entry.getValue().getHeader())\n             .executeNonQuery(entry.getKey());\n       } else {\n         // forward the query to the group that should handle it\n-        subStatus = forwardPlan(entry.getKey(), entry.getValue());\n+        logger.debug(\"Forward {} to a remote group of {}\", entry.getKey(),\n+            entry.getValue().getHeader());\n+        status = forwardPlan(entry.getKey(), entry.getValue());\n+      }\n+    } else {\n+      TSStatus tmpStatus;\n+      List<String> errorCodePartitionGroups = new ArrayList<>();\n+      if (plan instanceof InsertTabletPlan) {\n+        TSStatus[] subStatus = new TSStatus[((InsertTabletPlan) plan).getRowCount()];\n+        boolean noFailure = true;\n+        boolean isBatchFailure = false;\n+        for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n+          if (entry.getValue().contains(thisNode)) {\n+            // the query should be handled by a group the local node is in, handle it with in the group\n+            logger.debug(\"Execute {} in a local group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = getLocalDataMember(entry.getValue().getHeader())\n+                .executeNonQuery(entry.getKey());\n+          } else {\n+            // forward the query to the group that should handle it\n+            logger.debug(\"Forward {} to a remote group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = forwardPlan(entry.getKey(), entry.getValue());\n+          }\n+          logger.debug(\"{}: from {},{},{}\", name, entry.getKey(), entry.getValue(), tmpStatus);\n+          noFailure =\n+              (tmpStatus.getCode() == TSStatusCode.SUCCESS_STATUS.getStatusCode()) && noFailure;\n+          isBatchFailure = (tmpStatus.getCode() == TSStatusCode.MULTIPLE_ERROR.getStatusCode())\n+              || isBatchFailure;\n+          PartitionUtils.reordering((InsertTabletPlan) entry.getKey(), subStatus,\n+              tmpStatus.subStatus == null ? RpcUtils\n+                  .getStatus(((InsertTabletPlan) entry.getKey()).getRowCount())\n+                  : tmpStatus.subStatus.toArray(new TSStatus[]{}));\n+          if (tmpStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            // execution failed, record the error message\n+            errorCodePartitionGroups.add(String.format(\"[%s@%s:%s:%s]\",\n+                tmpStatus.getCode(), entry.getValue().getHeader(),\n+                tmpStatus.getMessage(), tmpStatus.subStatus));\n+          }\n+        }\n+        if (noFailure) {\n+          status = StatusUtils.OK;\n+        } else if (isBatchFailure) {\n+          status = RpcUtils.getStatus(Arrays.asList(subStatus));\n+        } else {\n+          status = StatusUtils.EXECUTE_STATEMENT_ERROR.deepCopy();\n+          status.setMessage(\"The following errors occurred when executing the query, \"\n+              + \"please retry or contact the DBA: \" + errorCodePartitionGroups.toString());\n+        }\n+      } else {\n+        for (Map.Entry<PhysicalPlan, PartitionGroup> entry : planGroupMap.entrySet()) {\n+          if (entry.getValue().contains(thisNode)) {\n+            // the query should be handled by a group the local node is in, handle it with in the group\n+            logger.debug(\"Execute {} in a local group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = getLocalDataMember(entry.getValue().getHeader())\n+                .executeNonQuery(entry.getKey());\n+          } else {\n+            // forward the query to the group that should handle it\n+            logger.debug(\"Forward {} to a remote group of {}\", entry.getKey(),\n+                entry.getValue().getHeader());\n+            tmpStatus = forwardPlan(entry.getKey(), entry.getValue());\n+          }\n+          if (tmpStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            // execution failed, record the error message\n+            errorCodePartitionGroups.add(String.format(\"[%s@%s:%s]\",\n+                tmpStatus.getCode(), entry.getValue().getHeader(),\n+                tmpStatus.getMessage()));\n+          }\n+        }\n+        if (errorCodePartitionGroups.size() == 0) {\n+          status = StatusUtils.OK;\n+        } else {\n+          status = StatusUtils.EXECUTE_STATEMENT_ERROR.deepCopy();\n+          status.setMessage(\"The following errors occurred when executing the query, \"\n+              + \"please retry or contact the DBA: \" + errorCodePartitionGroups.toString());\n+        }\n+      }\n+    }\n+    logger.debug(\"{}: executed {} with answer {}\", name, plan, status);\n+    return status;\n+  }\n+\n+  /**\n+   * Forward plans to all DataGroupMember groups. Only when all nodes time out, will a TIME_OUT be\n+   * returned.\n+   *\n+   * @param partitionGroups\n+   * @return\n+   * @para plan\n+   */\n+  TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n+    // the error codes from the groups that cannot execute the plan\n+    TSStatus status;\n+    List<String> errorCodePartitionGroups = new ArrayList<>();\n+    for (PartitionGroup partitionGroup : partitionGroups) {\n+      if (partitionGroup.contains(thisNode)) {\n+        // the query should be handled by a group the local node is in, handle it with in the group\n+        logger.debug(\"Execute {} in a local group of {}\", plan, partitionGroup.getHeader());\n+        status = getLocalDataMember(partitionGroup.getHeader())\n+            .executeNonQuery(plan);\n+      } else {\n+        // forward the query to the group that should handle it\n+        logger.debug(\"Forward {} to a remote group of {}\", plan,\n+            partitionGroup.getHeader());\n+        status = forwardPlan(plan, partitionGroup);\n       }\n-      if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n-        if (entry.getKey() instanceof InsertPlan\n-            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n+      if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (plan instanceof InsertPlan\n+            && status.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n             && IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n           // try to create timeseries\n-          boolean hasCreate = autoCreateTimeseries((InsertPlan) entry.getKey(), entry.getValue());\n+          boolean hasCreate = autoCreateTimeseries((InsertPlan) plan, partitionGroup);\n           if (hasCreate) {\n-            Map<PhysicalPlan, PartitionGroup> subPlan = new HashMap<>();\n-            subPlan.put(entry.getKey(), entry.getValue());\n-            subStatus = forwardPlan(subPlan);\n+            status = forwardPlan(plan, partitionGroup);\n             continue;\n           } else {\n             logger.error(\"{}, Cannot auto create timeseries.\", thisNode);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTcxOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442599718", "bodyText": "getting -> get\nI would suggest print something like \"{} and other {} paths\", seriesList.get(0), seriesList.size() - 1 instead of \"{}\", serieseList, in case that the list is too long.\nAnd if you want to print a list in a log, you can just use the list as a parameter and there is no need to wrap it with \"Arrays.toString(seriesList.toArray(new String[0]))\".", "author": "jt2594838", "createdAt": "2020-06-19T02:35:30Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        Map<String, Boolean> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        for (Map.Entry<String, Boolean> entry : result.entrySet()) {\n+          if (!entry.getValue()) {\n+            unregistered.add(entry.getKey());\n+          }\n+        }\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered series list {} from {}\", name,", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTM4Mw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443679383", "bodyText": "Thanks for your suggestion. I will change that.", "author": "Ring-k", "createdAt": "2020-06-22T16:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "8ea91ee1062bb191e6047f873b71b10e22120f42", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 0c2139dd1a..42087c5a62 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1600,19 +1714,18 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n         }\n         // execution failed, record the error message\n         errorCodePartitionGroups.add(String.format(\"[%s@%s:%s]\",\n-            subStatus.getCode(), entry.getValue().getHeader(),\n-            subStatus.getMessage()));\n+            status.getCode(), partitionGroup.getHeader(),\n+            status.getMessage()));\n       }\n     }\n-    if (errorCodePartitionGroups.size() <= 1) {\n-      // when size = 0, no error occurs, the plan is successfully executed, return OK\n-      // when size = 1, one error occurs, set status = subStatus and return\n-      status = subStatus;\n+    if (errorCodePartitionGroups.size() == 0) {\n+      status = StatusUtils.OK;\n     } else {\n       status = StatusUtils.EXECUTE_STATEMENT_ERROR.deepCopy();\n       status.setMessage(\"The following errors occurred when executing the query, \"\n           + \"please retry or contact the DBA: \" + errorCodePartitionGroups.toString());\n     }\n+    logger.debug(\"{}: executed {} with answer {}\", name, plan, status);\n     return status;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMDU3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442600576", "bodyText": "Please add a TODO here: \"TODO-Cluster: add executeNonQueryBatch()\", so we can cut the number of communications later.", "author": "jt2594838", "createdAt": "2020-06-19T02:39:11Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3Njc3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443676776", "bodyText": "Thanks for your reminding. I will add the comment.", "author": "Ring-k", "createdAt": "2020-06-22T16:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMDU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8ea91ee1062bb191e6047f873b71b10e22120f42", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 0c2139dd1a..42087c5a62 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1600,19 +1714,18 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n         }\n         // execution failed, record the error message\n         errorCodePartitionGroups.add(String.format(\"[%s@%s:%s]\",\n-            subStatus.getCode(), entry.getValue().getHeader(),\n-            subStatus.getMessage()));\n+            status.getCode(), partitionGroup.getHeader(),\n+            status.getMessage()));\n       }\n     }\n-    if (errorCodePartitionGroups.size() <= 1) {\n-      // when size = 0, no error occurs, the plan is successfully executed, return OK\n-      // when size = 1, one error occurs, set status = subStatus and return\n-      status = subStatus;\n+    if (errorCodePartitionGroups.size() == 0) {\n+      status = StatusUtils.OK;\n     } else {\n       status = StatusUtils.EXECUTE_STATEMENT_ERROR.deepCopy();\n       status.setMessage(\"The following errors occurred when executing the query, \"\n           + \"please retry or contact the DBA: \" + errorCodePartitionGroups.toString());\n     }\n+    logger.debug(\"{}: executed {} with answer {}\", name, plan, status);\n     return status;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442601202", "bodyText": "The schema may be auto-created concurrently, so I think the status code should be carefully checked, and if it says that the timeseries are already created, we should also return true.", "author": "jt2594838", "createdAt": "2020-06-19T02:41:43Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcxOTcwMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444719702", "bodyText": "Thanks for your suggestion. An extra condition will be added in the if clause to make sure of it.", "author": "Ring-k", "createdAt": "2020-06-24T08:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "8ea91ee1062bb191e6047f873b71b10e22120f42", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 0c2139dd1a..42087c5a62 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1600,19 +1714,18 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n         }\n         // execution failed, record the error message\n         errorCodePartitionGroups.add(String.format(\"[%s@%s:%s]\",\n-            subStatus.getCode(), entry.getValue().getHeader(),\n-            subStatus.getMessage()));\n+            status.getCode(), partitionGroup.getHeader(),\n+            status.getMessage()));\n       }\n     }\n-    if (errorCodePartitionGroups.size() <= 1) {\n-      // when size = 0, no error occurs, the plan is successfully executed, return OK\n-      // when size = 1, one error occurs, set status = subStatus and return\n-      status = subStatus;\n+    if (errorCodePartitionGroups.size() == 0) {\n+      status = StatusUtils.OK;\n     } else {\n       status = StatusUtils.EXECUTE_STATEMENT_ERROR.deepCopy();\n       status.setMessage(\"The following errors occurred when executing the query, \"\n           + \"please retry or contact the DBA: \" + errorCodePartitionGroups.toString());\n     }\n+    logger.debug(\"{}: executed {} with answer {}\", name, plan, status);\n     return status;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODkzMw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442608933", "bodyText": "How about CreateTimeSeriesPlan? and other plans which can cause first check storage group exist or not ?", "author": "neuyilan", "createdAt": "2020-06-19T03:15:35Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzMzUxNA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443933514", "bodyText": "The problem you mentioned refers to CreateTimeseriesPlan, InsertTimeseriesPlan, DeleteTimeseriesPlan and DeleteTimeseriesPlan. However, if storage group is not set when executing DeleteTimeseriesPlan and DeleteTimeseriesPlan, logically there's no necessity for the storage group to be created. As in the method executeNonQuery in MetaGroupMember, these two plans will trigger processNonPartitionDataPlan and processNonPartitionMetaPlan respectively. CreateTimeseriesPlan and InsertTimeseriesPlan are \"partitioned plans\". As a result, if storage group is not set for these 2 types, auto creation will be performed.", "author": "Ring-k", "createdAt": "2020-06-23T02:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODkzMw=="}], "type": "inlineReview", "revised_code": {"commit": "8ea91ee1062bb191e6047f873b71b10e22120f42", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 0c2139dd1a..42087c5a62 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1559,7 +1569,7 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n       return StatusUtils.NO_STORAGE_GROUP;\n     }\n     logger.error(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);\n-    return forwardPlan(planGroupMap);\n+    return forwardPlan(planGroupMap, plan);\n   }\n \n   /**\n"}}, {"oid": "8ea91ee1062bb191e6047f873b71b10e22120f42", "url": "https://github.com/apache/iotdb/commit/8ea91ee1062bb191e6047f873b71b10e22120f42", "message": "fix conflict", "committedDate": "2020-06-22T15:20:51Z", "type": "commit"}, {"oid": "0bca1a88bb8bd36b47bed84e76f992509660e3ce", "url": "https://github.com/apache/iotdb/commit/0bca1a88bb8bd36b47bed84e76f992509660e3ce", "message": "error->debug", "committedDate": "2020-06-22T15:26:01Z", "type": "commit"}, {"oid": "da7a76aa10b7d559fc1919fad2bc0d0ad2f46872", "url": "https://github.com/apache/iotdb/commit/da7a76aa10b7d559fc1919fad2bc0d0ad2f46872", "message": "cluster properties", "committedDate": "2020-06-22T15:40:06Z", "type": "commit"}, {"oid": "283cf21e45755ec8e47bff25c36e5851ee7f7de5", "url": "https://github.com/apache/iotdb/commit/283cf21e45755ec8e47bff25c36e5851ee7f7de5", "message": "map -> list", "committedDate": "2020-06-22T15:51:44Z", "type": "commit"}, {"oid": "78c7c230a3af641ed6abaeb54cfc9e3a70e93757", "url": "https://github.com/apache/iotdb/commit/78c7c230a3af641ed6abaeb54cfc9e3a70e93757", "message": "measurement -> timeseries", "committedDate": "2020-06-22T16:30:35Z", "type": "commit"}, {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029", "url": "https://github.com/apache/iotdb/commit/3c7b5079ddafe3212684986dcecdd877946e6029", "message": "change name", "committedDate": "2020-06-23T01:14:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjU3MA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916570", "bodyText": "Please resolve the conflicts.", "author": "jt2594838", "createdAt": "2020-06-23T01:52:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1073,7 +1072,12 @@ public void pullTimeSeriesSchema(PullSchemaRequest request,\n \n   /**\n    * Create an IPointReader of \"path\" with \u201ctimeFilter\u201d and \"valueFilter\". A synchronization with\n+<<<<<<< HEAD\n+   * the leader will be performed first to preserve strong consistency. TODO-Cluster: also support\n+   * weak consistency\n+=======\n    * the leader will be performed according to consistency level\n+>>>>>>> origin/cluster_new", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY5NzgyNQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444697825", "bodyText": "Thanks for your reminding.", "author": "Ring-k", "createdAt": "2020-06-24T07:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjU3MA=="}], "type": "inlineReview", "revised_code": {"commit": "4687aaad5b3ce268d08401c7f94fcf3a345e7171", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\nindex 04f5f9c865..6edc4086d5 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n\n@@ -1072,12 +1072,7 @@ public class DataGroupMember extends RaftMember implements TSDataService.AsyncIf\n \n   /**\n    * Create an IPointReader of \"path\" with \u201ctimeFilter\u201d and \"valueFilter\". A synchronization with\n-<<<<<<< HEAD\n-   * the leader will be performed first to preserve strong consistency. TODO-Cluster: also support\n-   * weak consistency\n-=======\n    * the leader will be performed according to consistency level\n->>>>>>> origin/cluster_new\n    *\n    * @param path\n    * @param dataType\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjkwMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916902", "bodyText": "I think there is a method syncLeaderWithConsistencyCheck now, and that one should be used.", "author": "jt2594838", "createdAt": "2020-06-23T01:53:39Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY5OTMzNg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444699336", "bodyText": "Thank you for your suggestion. The method syncLeaderWithConsistencyCheck will be used.", "author": "Ring-k", "createdAt": "2020-06-24T07:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\nindex 04f5f9c865..8c4762fa73 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n\n@@ -1625,6 +1611,7 @@ public class DataGroupMember extends RaftMember implements TSDataService.AsyncIf\n \n   /**\n    * Check if the given measurements are registered or not\n+   *\n    * @param header\n    * @param timeseriesList\n    * @param resultHandler\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzM5NQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443917395", "bodyText": "Better add the seriesPath which triggers the exception into the message.", "author": "jt2594838", "createdAt": "2020-06-23T01:55:25Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    List<String> result = new ArrayList<>();\n+    for (String seriesPath : timeseriesList) {\n+      try {\n+        List<String> path = MManager.getInstance().getAllTimeseriesName(seriesPath);\n+        if (path.size() != 1) {\n+          throw new MetadataException(\"Size of the path is not 1.\");", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMDM3Nw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444700377", "bodyText": "Thanks for your suggestion. The information of the series will be included.", "author": "Ring-k", "createdAt": "2020-06-24T07:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\nindex 04f5f9c865..8c4762fa73 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java\n\n@@ -1625,6 +1611,7 @@ public class DataGroupMember extends RaftMember implements TSDataService.AsyncIf\n \n   /**\n    * Check if the given measurements are registered or not\n+   *\n    * @param header\n    * @param timeseriesList\n    * @param resultHandler\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODQwOQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443918409", "bodyText": "Report the status code and its message in the exception.", "author": "jt2594838", "createdAt": "2020-06-23T01:58:58Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,29 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMDkyMw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444700923", "bodyText": "Thanks for your suggestion. The status code will be included in the exception.", "author": "Ring-k", "createdAt": "2020-06-24T07:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "523f1063953f57b5ac537213cf38ca2b4a717593", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 4b7b76ee31..73def9adac 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1561,9 +1561,13 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n             throw new MetadataException(\"Failed to set storage group \" + storageGroupName);\n           }\n           // try to create timeseries\n+          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan)plan);\n+          if(!isAutoCreateTimeseriesSuccess){\n+            throw new MetadataException(\"Failed to create timeseries automatically.\");\n+          }\n           return executeNonQuery(plan);\n         } catch (MetadataException e) {\n-          logger.info(\"Failed to set storage group of device id {}\", deviceId);\n+          logger.error(\"Failed to set storage group or create timeseries, because {}\", e.getMessage());\n         }\n       }\n       logger.error(\"{}: Cannot found storage groups for {}\", name, plan);\n"}}, {"oid": "523f1063953f57b5ac537213cf38ca2b4a717593", "url": "https://github.com/apache/iotdb/commit/523f1063953f57b5ac537213cf38ca2b4a717593", "message": "route meta", "committedDate": "2020-06-23T02:36:31Z", "type": "commit"}, {"oid": "4687aaad5b3ce268d08401c7f94fcf3a345e7171", "url": "https://github.com/apache/iotdb/commit/4687aaad5b3ce268d08401c7f94fcf3a345e7171", "message": "fix conflict", "committedDate": "2020-06-23T03:00:46Z", "type": "commit"}, {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b", "url": "https://github.com/apache/iotdb/commit/2493bcc51d702b6be99b84b0fae53f140469d61b", "message": "exception report", "committedDate": "2020-06-23T03:15:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDkwMQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444014901", "bodyText": "It seems that this function forwardPlan will only be used in processNonPartitionedDataPlan, which will be called only when the type of plan is DeletePlan or DeleteTimeSeriesPlan, so maybe these new code in this function will never be called?", "author": "LebronAl", "createdAt": "2020-06-23T07:23:59Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1667,6 +1710,18 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n         status = forwardPlan(plan, partitionGroup);\n       }\n       if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (plan instanceof InsertPlan", "originalCommit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMjY4OA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444702688", "bodyText": "You are right. Thanks for your reminding. These codes will be moved to TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap, PhysicalPlan plan).", "author": "Ring-k", "createdAt": "2020-06-24T07:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "362b4d00bd18798f3c83c566408735218429d34d", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 8d0315d2c8..9e86012e58 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1710,18 +1732,6 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n         status = forwardPlan(plan, partitionGroup);\n       }\n       if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n-        if (plan instanceof InsertPlan\n-            && status.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n-            && ClusterDescriptor.getInstance().getConfig().isEnableAutoCreateSchema()) {\n-          // try to create timeseries\n-          boolean hasCreate = autoCreateTimeseries((InsertPlan) plan);\n-          if (hasCreate) {\n-            status = forwardPlan(plan, partitionGroup);\n-            continue;\n-          } else {\n-            logger.error(\"{}, Cannot auto create timeseries.\", thisNode);\n-          }\n-        }\n         // execution failed, record the error message\n         errorCodePartitionGroups.add(String.format(\"[%s@%s:%s]\",\n             status.getCode(), partitionGroup.getHeader(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxODYzMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444018632", "bodyText": "maybe you can use processNonPartitionedMetaPlan directly to avoid unnecessary judgement", "author": "LebronAl", "createdAt": "2020-06-23T07:31:08Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,38 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);", "originalCommit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMzEwNQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444703105", "bodyText": "Good idea. Thanks for your suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T07:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxODYzMg=="}], "type": "inlineReview", "revised_code": {"commit": "ec1a35174123572c5a7ef45ecad4086539d2b141", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 8d0315d2c8..8b444cc1c5 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1556,7 +1556,7 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n                   .getConfig().getDefaultStorageGroupLevel());\n           SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n               new Path(storageGroupName));\n-          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          TSStatus setStorageGroupResult = processNonPartitionedMetaPlan(setStorageGroupPlan);\n           if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n             throw new MetadataException(\n                 String.format(\"Status Code: %d, failed to set storage group \",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODU3NQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444028575", "bodyText": "maybe you can use processPartitionedPlan directly to avoid unnecessary judgement", "author": "LebronAl", "createdAt": "2020-06-23T07:48:22Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1739,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "originalCommit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTkyOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929928", "bodyText": "You are right. Thanks.", "author": "Ring-k", "createdAt": "2020-06-24T14:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODU3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "acc18960ae7318bcafa49271f90398eaeca11ff3", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 8d0315d2c8..830f803e01 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1742,7 +1747,7 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n   /**\n    * Create timeseries automatically\n    *\n-   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @param insertPlan, some of the timeseries in it are not created yet\n    * @return true of all uncreated timeseries are created\n    */\n   boolean autoCreateTimeseries(InsertPlan insertPlan) {\n"}}, {"oid": "362b4d00bd18798f3c83c566408735218429d34d", "url": "https://github.com/apache/iotdb/commit/362b4d00bd18798f3c83c566408735218429d34d", "message": "insertPlan backup", "committedDate": "2020-06-24T04:34:03Z", "type": "commit"}, {"oid": "d98656a9b1150d20ba4abf395a715298f6c28766", "url": "https://github.com/apache/iotdb/commit/d98656a9b1150d20ba4abf395a715298f6c28766", "message": "clone", "committedDate": "2020-06-24T04:54:42Z", "type": "commit"}, {"oid": "dfc17a5eefea399f14d423bad50cb8864927690a", "url": "https://github.com/apache/iotdb/commit/dfc17a5eefea399f14d423bad50cb8864927690a", "message": "new error code", "committedDate": "2020-06-24T07:21:18Z", "type": "commit"}, {"oid": "ec1a35174123572c5a7ef45ecad4086539d2b141", "url": "https://github.com/apache/iotdb/commit/ec1a35174123572c5a7ef45ecad4086539d2b141", "message": "executeNonQuery -> processNonPartitionedMetaPlan", "committedDate": "2020-06-24T07:41:18Z", "type": "commit"}, {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "url": "https://github.com/apache/iotdb/commit/c1a9f422e64004228e06f4b4adcdaeb46944fd87", "message": "check storage group already set", "committedDate": "2020-06-24T08:07:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MDc3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444790776", "bodyText": "It would be better to use e (preserve stack traces).", "author": "jt2594838", "createdAt": "2020-06-24T10:13:35Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,39 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = processNonPartitionedMetaPlan(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode() &&\n+          setStorageGroupResult.getCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR.getStatusCode()) {\n+            throw new MetadataException(\n+                String.format(\"Status Code: %d, failed to set storage group \",\n+                    setStorageGroupResult.getCode(), storageGroupName)\n+            );\n+          }\n+          // try to create timeseries\n+          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan)plan);\n+          if(!isAutoCreateTimeseriesSuccess){\n+            throw new MetadataException(\n+                String.format(\"Failed to create timeseries from InsertPlan automatically.\")\n+            );\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.error(\"Failed to set storage group or create timeseries, because {}\", e.getMessage());", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTcwMA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929700", "bodyText": "Thanks for your suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T14:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MDc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "acc18960ae7318bcafa49271f90398eaeca11ff3", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 73d18b147d..830f803e01 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1558,22 +1558,23 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n               new Path(storageGroupName));\n           TSStatus setStorageGroupResult = processNonPartitionedMetaPlan(setStorageGroupPlan);\n           if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode() &&\n-          setStorageGroupResult.getCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR.getStatusCode()) {\n+              setStorageGroupResult.getCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR\n+                  .getStatusCode()) {\n             throw new MetadataException(\n                 String.format(\"Status Code: %d, failed to set storage group \",\n                     setStorageGroupResult.getCode(), storageGroupName)\n             );\n           }\n           // try to create timeseries\n-          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan)plan);\n-          if(!isAutoCreateTimeseriesSuccess){\n+          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan) plan);\n+          if (!isAutoCreateTimeseriesSuccess) {\n             throw new MetadataException(\n                 String.format(\"Failed to create timeseries from InsertPlan automatically.\")\n             );\n           }\n           return executeNonQuery(plan);\n         } catch (MetadataException e) {\n-          logger.error(\"Failed to set storage group or create timeseries, because {}\", e.getMessage());\n+          logger.error(\"Failed to set storage group or create timeseries, because {}\", e);\n         }\n       }\n       logger.error(\"{}: Cannot found storage groups for {}\", name, plan);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjcyOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444792728", "bodyText": "Please refactor this message like the former one to avoid printing too many seriesPaths.", "author": "jt2594838", "createdAt": "2020-06-24T10:17:28Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered {} and other {} paths from {}\", name,\n+            seriesList.get(0), seriesList.get(seriesList.size() - 1), node, e);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        logger.error(\"{}: getting unregistered series list {} is interrupted from {}\", name,\n+            Arrays.toString(seriesList.toArray(new String[0])), node, e);", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTQ3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929476", "bodyText": "Thanks for your reminding.", "author": "Ring-k", "createdAt": "2020-06-24T14:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "acc18960ae7318bcafa49271f90398eaeca11ff3", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 73d18b147d..830f803e01 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1746,7 +1747,7 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n   /**\n    * Create timeseries automatically\n    *\n-   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @param insertPlan, some of the timeseries in it are not created yet\n    * @return true of all uncreated timeseries are created\n    */\n   boolean autoCreateTimeseries(InsertPlan insertPlan) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MzQ3NA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444793474", "bodyText": "I think you should break once a non-null result is returned, and I do not think using a Set is necessary.", "author": "jt2594838", "createdAt": "2020-06-24T10:18:56Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTMyNA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929324", "bodyText": "You are right. Finishing the loop is not necessary.", "author": "Ring-k", "createdAt": "2020-06-24T14:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MzQ3NA=="}], "type": "inlineReview", "revised_code": {"commit": "acc18960ae7318bcafa49271f90398eaeca11ff3", "chunk": "diff --git a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\nindex 73d18b147d..830f803e01 100644\n--- a/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n+++ b/cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java\n\n@@ -1746,7 +1747,7 @@ public class MetaGroupMember extends RaftMember implements TSMetaService.AsyncIf\n   /**\n    * Create timeseries automatically\n    *\n-   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @param insertPlan, some of the timeseries in it are not created yet\n    * @return true of all uncreated timeseries are created\n    */\n   boolean autoCreateTimeseries(InsertPlan insertPlan) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTQxNw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444795417", "bodyText": "I suggest you just add a field of List in PathNotExistException, since concatenating a long string list is time-consuming.\nBesides, please perform a reformat.", "author": "jt2594838", "createdAt": "2020-06-24T10:22:29Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();\n+          }\n+          if(!(curException instanceof PathNotExistException)){\n+            isPathNotExistException = false;\n+            break;\n+          }\n+        }\n+        if(isPathNotExistException){\n+          throw new PathNotExistException(failedPaths.toString());", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyODY0Nw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444928647", "bodyText": "An attribute is added in the PathNotExistExeption. Thanks for your suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T14:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTQxNw=="}], "type": "inlineReview", "revised_code": {"commit": "acc18960ae7318bcafa49271f90398eaeca11ff3", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex 45ded2cd7f..01867b8eb8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -919,9 +919,9 @@ public class PlanExecutor implements IPlanExecutor {\n         List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n         boolean isPathNotExistException = true;\n         for(Exception e : exceptions){\n-          Exception curException = e;\n+          Throwable curException = e;\n           while(curException.getCause() != null){\n-            curException = (Exception) curException.getCause();\n+            curException = curException.getCause();\n           }\n           if(!(curException instanceof PathNotExistException)){\n             isPathNotExistException = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NjIwOQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444796209", "bodyText": "You may just define this as a Throwable so you may avoid the typecast.", "author": "jt2594838", "createdAt": "2020-06-24T10:23:57Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyODA4NA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444928084", "bodyText": "Thanks for yoru suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T14:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NjIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "acc18960ae7318bcafa49271f90398eaeca11ff3", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\nindex 45ded2cd7f..01867b8eb8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n\n@@ -919,9 +919,9 @@ public class PlanExecutor implements IPlanExecutor {\n         List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n         boolean isPathNotExistException = true;\n         for(Exception e : exceptions){\n-          Exception curException = e;\n+          Throwable curException = e;\n           while(curException.getCause() != null){\n-            curException = (Exception) curException.getCause();\n+            curException = curException.getCause();\n           }\n           if(!(curException instanceof PathNotExistException)){\n             isPathNotExistException = false;\n"}}, {"oid": "acc18960ae7318bcafa49271f90398eaeca11ff3", "url": "https://github.com/apache/iotdb/commit/acc18960ae7318bcafa49271f90398eaeca11ff3", "message": "exception message", "committedDate": "2020-06-24T14:34:53Z", "type": "commit"}, {"oid": "10f19941e1e5986189b6fa35c767e69615b8bfa2", "url": "https://github.com/apache/iotdb/commit/10f19941e1e5986189b6fa35c767e69615b8bfa2", "message": "fix conflict", "committedDate": "2020-06-24T14:37:31Z", "type": "commit"}, {"oid": "ef2fd52fa5ef78aea2de64070746ae3b674c711a", "url": "https://github.com/apache/iotdb/commit/ef2fd52fa5ef78aea2de64070746ae3b674c711a", "message": "test", "committedDate": "2020-06-28T07:13:15Z", "type": "commit"}, {"oid": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "url": "https://github.com/apache/iotdb/commit/b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "message": "fix sonar", "committedDate": "2020-06-28T07:26:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzkwMw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r446623903", "bodyText": "Why change this?", "author": "jt2594838", "createdAt": "2020-06-28T09:07:30Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1586,7 +1586,7 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n           }\n           return executeNonQuery(plan);\n         } catch (MetadataException e) {\n-          logger.error(\"Failed to set storage group or create timeseries, because {}\", e);\n+          logger.error(String.format(\"Failed to set storage group or create timeseries, because %s\", e));", "originalCommit": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNjYyMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r446626622", "bodyText": "It was recognized as a bug according to rules of sonar, \"Fewer arguments provided (0) than placeholders specified (1) \".", "author": "Ring-k", "createdAt": "2020-06-28T09:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzkwMw=="}], "type": "inlineReview", "revised_code": null}]}