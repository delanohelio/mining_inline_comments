{"pr_number": 2029, "pr_title": "[IOTDB-825] aggregation by natural month", "pr_createdAt": "2020-11-12T03:59:48Z", "pr_url": "https://github.com/apache/iotdb/pull/2029", "timeline": [{"oid": "c3063f35b0b6a307ac3d1e8176ea451de529f40d", "url": "https://github.com/apache/iotdb/commit/c3063f35b0b6a307ac3d1e8176ea451de529f40d", "message": "group by natural month", "committedDate": "2020-11-12T06:40:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NDYzOQ==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r521874639", "bodyText": "Hi, what is this import for?", "author": "HTHou", "createdAt": "2020-11-12T06:52:41Z", "path": "server/src/test/java/org/apache/iotdb/db/query/executor/GroupByEngineDataSetTest.java", "diffHunk": "@@ -19,9 +19,16 @@\n package org.apache.iotdb.db.query.executor;\n \n \n+import com.sun.xml.internal.ws.api.message.saaj.SaajStaxWriter;", "originalCommit": "c3063f35b0b6a307ac3d1e8176ea451de529f40d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3ODMzOA==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r521878338", "bodyText": "removed. thank you!", "author": "haimeiguo", "createdAt": "2020-11-12T07:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg3NDYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6048bab5676d234de8293bf13662a01cc9385bff", "chunk": "diff --git a/server/src/test/java/org/apache/iotdb/db/query/executor/GroupByEngineDataSetTest.java b/server/src/test/java/org/apache/iotdb/db/query/executor/GroupByEngineDataSetTest.java\nindex b444982166..53abff6632 100644\n--- a/server/src/test/java/org/apache/iotdb/db/query/executor/GroupByEngineDataSetTest.java\n+++ b/server/src/test/java/org/apache/iotdb/db/query/executor/GroupByEngineDataSetTest.java\n\n@@ -19,15 +19,11 @@\n package org.apache.iotdb.db.query.executor;\n \n \n-import com.sun.xml.internal.ws.api.message.saaj.SaajStaxWriter;\n import java.io.IOException;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.time.ZoneId;\n import java.util.ArrayList;\n-\n import java.util.Date;\n-import java.util.List;\n import java.util.TimeZone;\n import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n import org.apache.iotdb.db.query.aggregation.impl.CountAggrResult;\n"}}, {"oid": "6048bab5676d234de8293bf13662a01cc9385bff", "url": "https://github.com/apache/iotdb/commit/6048bab5676d234de8293bf13662a01cc9385bff", "message": "group by natural month", "committedDate": "2020-11-12T07:02:06Z", "type": "forcePushed"}, {"oid": "a29df2301ae6c4e6cc8b579a0ab1a6a598237a1a", "url": "https://github.com/apache/iotdb/commit/a29df2301ae6c4e6cc8b579a0ab1a6a598237a1a", "message": "edit sql reference doc", "committedDate": "2020-11-17T04:05:16Z", "type": "forcePushed"}, {"oid": "b277867cef5777c71823c53b87702136d42913eb", "url": "https://github.com/apache/iotdb/commit/b277867cef5777c71823c53b87702136d42913eb", "message": "edit sql reference doc", "committedDate": "2020-11-17T06:30:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNTIzMA==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r524905230", "bodyText": "define the number to a const variable", "author": "mychaow", "createdAt": "2020-11-17T06:10:40Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java", "diffHunk": "@@ -70,36 +77,69 @@ public GroupByEngineDataSet(QueryContext context, GroupByTimePlan groupByTimePla\n       long intervalNum = (long) Math.ceil(queryRange / (double) slidingStep);\n       curStartTime = slidingStep * (intervalNum - 1) + startTime;\n     }\n-    curEndTime = Math.min(curStartTime + interval, endTime);\n+\n+    //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n+    //now converting them back to integer months\n+    if (isIntervalByMonth) {\n+      interval = interval / 30 / 86400_000L;", "originalCommit": "a29df2301ae6c4e6cc8b579a0ab1a6a598237a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "faa9a275de22d1eacb3e6a96662558d1d76c67c2", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\nindex 496f1da411..9c96c73278 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n\n@@ -78,16 +79,19 @@ public abstract class GroupByEngineDataSet extends QueryDataSet {\n       curStartTime = slidingStep * (intervalNum - 1) + startTime;\n     }\n \n-    //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n-    //now converting them back to integer months\n+\n     if (isIntervalByMonth) {\n-      interval = interval / 30 / 86400_000L;\n+      //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n+      //now converting them back to integer months\n+      interval = interval / msToMonth;\n+      //calculate interval length by natural month based on curStartTime\n+      //ie. startTIme = 1/31, interval = 1mo, curEndTime will be set to 2/29\n       curEndTime = Math.min(curStartTime + calcIntervalByMonth(interval, curStartTime), endTime);\n     } else {\n       curEndTime = Math.min(curStartTime + interval, endTime);\n     }\n     if (isSlidingStepByMonth) {\n-      slidingStep = slidingStep / 30 / 86400_000L;\n+      slidingStep = slidingStep / msToMonth;\n     }\n     this.hasCachedTimeInterval = true;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkxMzM2Mg==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r524913362", "bodyText": "Please add some comments about the implement. You could list some example to explain it.", "author": "mychaow", "createdAt": "2020-11-17T06:35:16Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java", "diffHunk": "@@ -70,36 +77,69 @@ public GroupByEngineDataSet(QueryContext context, GroupByTimePlan groupByTimePla\n       long intervalNum = (long) Math.ceil(queryRange / (double) slidingStep);\n       curStartTime = slidingStep * (intervalNum - 1) + startTime;\n     }\n-    curEndTime = Math.min(curStartTime + interval, endTime);\n+\n+    //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n+    //now converting them back to integer months\n+    if (isIntervalByMonth) {\n+      interval = interval / 30 / 86400_000L;\n+      curEndTime = Math.min(curStartTime + calcIntervalByMonth(interval, curStartTime), endTime);", "originalCommit": "b277867cef5777c71823c53b87702136d42913eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk2MTg4MA==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r524961880", "bodyText": "added. Thank you!", "author": "haimeiguo", "createdAt": "2020-11-17T08:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkxMzM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "faa9a275de22d1eacb3e6a96662558d1d76c67c2", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\nindex 496f1da411..9c96c73278 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n\n@@ -78,16 +79,19 @@ public abstract class GroupByEngineDataSet extends QueryDataSet {\n       curStartTime = slidingStep * (intervalNum - 1) + startTime;\n     }\n \n-    //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n-    //now converting them back to integer months\n+\n     if (isIntervalByMonth) {\n-      interval = interval / 30 / 86400_000L;\n+      //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n+      //now converting them back to integer months\n+      interval = interval / msToMonth;\n+      //calculate interval length by natural month based on curStartTime\n+      //ie. startTIme = 1/31, interval = 1mo, curEndTime will be set to 2/29\n       curEndTime = Math.min(curStartTime + calcIntervalByMonth(interval, curStartTime), endTime);\n     } else {\n       curEndTime = Math.min(curStartTime + interval, endTime);\n     }\n     if (isSlidingStepByMonth) {\n-      slidingStep = slidingStep / 30 / 86400_000L;\n+      slidingStep = slidingStep / msToMonth;\n     }\n     this.hasCachedTimeInterval = true;\n   }\n"}}, {"oid": "6635167799a704cdc9b61c7131a63a014f8a033f", "url": "https://github.com/apache/iotdb/commit/6635167799a704cdc9b61c7131a63a014f8a033f", "message": "edit sql reference doc", "committedDate": "2020-11-17T08:16:10Z", "type": "forcePushed"}, {"oid": "faa9a275de22d1eacb3e6a96662558d1d76c67c2", "url": "https://github.com/apache/iotdb/commit/faa9a275de22d1eacb3e6a96662558d1d76c67c2", "message": "edit sql reference doc", "committedDate": "2020-11-17T11:56:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxNTE4Mg==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r526715182", "bodyText": "I think the logic here should be moved to the enterGroupByTimeClause() function, because only group by time query has the two attributes: isIntervalByMonth and isSlidingStepByMonth .\nAnd if so, isParsingSlidingStep is useless.", "author": "JackieTien97", "createdAt": "2020-11-19T09:32:15Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -1411,6 +1418,16 @@ private Long parseDuration(String durationStr) {\n           i++;\n           unit += durationStr.charAt(i);\n         }\n+        if (unit.toLowerCase().equals(\"mo\")) {\n+          //interval is by month, sliding step by default equals to interval\n+          if (!isParsingSlidingStep) {\n+            queryOp.setIntervalByMonth(true);\n+          }\n+          queryOp.setSlidingStepByMonth(true);\n+        } else if (isParsingSlidingStep) {\n+          //parsing sliding step value, and unit is not by month\n+          queryOp.setSlidingStepByMonth(false);\n+        }", "originalCommit": "faa9a275de22d1eacb3e6a96662558d1d76c67c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyNzg0Ng==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r528527846", "bodyText": "Hi, thank you for your review.\nIn parseDuration clause, it converts the interval and sliding step in milliseconds, also determines the unit for natural month aggregation. If I put the parsing \"mo\" in enterGroupByTimeClause(). i think it will be redoing the same thing.", "author": "haimeiguo", "createdAt": "2020-11-23T08:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxNTE4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a828c187672f4da233949e64e3f98fe4603b5c2d", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java b/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\nindex 8b551f2b81..057e4bca0f 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\n\n@@ -18,1715 +18,51 @@\n  */\n package org.apache.iotdb.db.qp.strategy;\n \n-import static org.apache.iotdb.db.qp.constant.SQLConstant.TIME_PATH;\n-\n-import java.io.File;\n import java.time.ZoneId;\n-import java.util.ArrayList;\n-import java.util.EnumMap;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import org.antlr.v4.runtime.tree.TerminalNode;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.exception.runtime.SQLParserException;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.qp.constant.DatetimeUtils;\n-import org.apache.iotdb.db.qp.constant.SQLConstant;\n-import org.apache.iotdb.db.qp.logical.RootOperator;\n-import org.apache.iotdb.db.qp.logical.crud.BasicFunctionOperator;\n-import org.apache.iotdb.db.qp.logical.crud.DeleteDataOperator;\n-import org.apache.iotdb.db.qp.logical.crud.FilterOperator;\n-import org.apache.iotdb.db.qp.logical.crud.FromOperator;\n-import org.apache.iotdb.db.qp.logical.crud.InOperator;\n-import org.apache.iotdb.db.qp.logical.crud.InsertOperator;\n-import org.apache.iotdb.db.qp.logical.crud.QueryOperator;\n-import org.apache.iotdb.db.qp.logical.crud.SelectOperator;\n-import org.apache.iotdb.db.qp.logical.crud.UpdateOperator;\n-import org.apache.iotdb.db.qp.logical.sys.AlterTimeSeriesOperator;\n-import org.apache.iotdb.db.qp.logical.sys.AlterTimeSeriesOperator.AlterType;\n-import org.apache.iotdb.db.qp.logical.sys.AuthorOperator;\n-import org.apache.iotdb.db.qp.logical.sys.AuthorOperator.AuthorType;\n-import org.apache.iotdb.db.qp.logical.sys.ClearCacheOperator;\n-import org.apache.iotdb.db.qp.logical.sys.CountOperator;\n-import org.apache.iotdb.db.qp.logical.sys.CreateSnapshotOperator;\n-import org.apache.iotdb.db.qp.logical.sys.CreateTimeSeriesOperator;\n-import org.apache.iotdb.db.qp.logical.sys.DataAuthOperator;\n-import org.apache.iotdb.db.qp.logical.sys.DeletePartitionOperator;\n-import org.apache.iotdb.db.qp.logical.sys.DeleteStorageGroupOperator;\n-import org.apache.iotdb.db.qp.logical.sys.DeleteTimeSeriesOperator;\n-import org.apache.iotdb.db.qp.logical.sys.FlushOperator;\n-import org.apache.iotdb.db.qp.logical.sys.LoadConfigurationOperator;\n-import org.apache.iotdb.db.qp.logical.sys.LoadConfigurationOperator.LoadConfigurationOperatorType;\n-import org.apache.iotdb.db.qp.logical.sys.LoadDataOperator;\n-import org.apache.iotdb.db.qp.logical.sys.LoadFilesOperator;\n-import org.apache.iotdb.db.qp.logical.sys.MergeOperator;\n-import org.apache.iotdb.db.qp.logical.sys.MoveFileOperator;\n-import org.apache.iotdb.db.qp.logical.sys.RemoveFileOperator;\n-import org.apache.iotdb.db.qp.logical.sys.SetStorageGroupOperator;\n-import org.apache.iotdb.db.qp.logical.sys.SetTTLOperator;\n-import org.apache.iotdb.db.qp.logical.sys.ShowChildPathsOperator;\n-import org.apache.iotdb.db.qp.logical.sys.ShowDevicesOperator;\n-import org.apache.iotdb.db.qp.logical.sys.ShowMergeStatusOperator;\n-import org.apache.iotdb.db.qp.logical.sys.ShowOperator;\n-import org.apache.iotdb.db.qp.logical.sys.ShowStorageGroupOperator;\n-import org.apache.iotdb.db.qp.logical.sys.ShowTTLOperator;\n-import org.apache.iotdb.db.qp.logical.sys.ShowTimeSeriesOperator;\n-import org.apache.iotdb.db.qp.logical.sys.TracingOperator;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AliasContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AlignByDeviceClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AlterUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AndExpressionContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AsClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AsElementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AttributeClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.AttributeClausesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ConstantContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CountDevicesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CountNodesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CountStorageGroupContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CountTimeseriesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CreateRoleContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CreateSnapshotContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CreateTimeseriesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.CreateUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.DateExpressionContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.DeletePartitionContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.DeleteStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.DeleteStorageGroupContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.DeleteTimeseriesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.DropRoleContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.DropUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FillClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FlushContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FromClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FullMergeContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FullPathContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FunctionAsClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FunctionAsElementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FunctionCallContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.FunctionElementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.GrantRoleContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.GrantRoleToUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.GrantUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.GrantWatermarkEmbeddingContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.GroupByTimeClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.InClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.InsertColumnSpecContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.InsertStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.InsertValuesSpecContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.LastClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.LimitClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListAllRoleOfUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListAllUserOfRoleContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListPrivilegesRoleContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListPrivilegesUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListRoleContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListRolePrivilegesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ListUserPrivilegesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.LoadConfigurationStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.LoadFilesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.LoadStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.MergeContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.MoveFileContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.NodeNameContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.NodeNameWithoutStarContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.OffsetClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.OrExpressionContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.OrderByTimeClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.PredicateContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.PrefixPathContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.PrivilegesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.PropertyContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.PropertyValueContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.RemoveFileContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.RevokeRoleContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.RevokeRoleFromUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.RevokeUserContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.RevokeWatermarkEmbeddingContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.RootOrIdContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SelectElementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SelectStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SetColContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SetStorageGroupContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SetTTLStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowAllTTLStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowChildPathsContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowDevicesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowMergeStatusContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowStorageGroupContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowTTLStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowTimeseriesContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowVersionContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.ShowWhereClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SlimitClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SoffsetClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.StringLiteralContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.SuffixPathContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.TagClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.TimeIntervalContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.TracingOffContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.TracingOnContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.TypeClauseContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.UnsetTTLStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.UpdateStatementContext;\n-import org.apache.iotdb.db.qp.strategy.SqlBaseParser.WhereClauseContext;\n-import org.apache.iotdb.db.query.executor.fill.IFill;\n-import org.apache.iotdb.db.query.executor.fill.LinearFill;\n-import org.apache.iotdb.db.query.executor.fill.PreviousFill;\n-import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n-import org.apache.iotdb.tsfile.common.constant.TsFileConstant;\n-import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n-import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n-import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n-import org.apache.iotdb.tsfile.utils.Pair;\n-import org.apache.iotdb.tsfile.utils.StringContainer;\n+import org.antlr.v4.runtime.CharStream;\n+import org.antlr.v4.runtime.CharStreams;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.atn.PredictionMode;\n+import org.antlr.v4.runtime.misc.ParseCancellationException;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.sql.IoTDBSqlVisitor;\n+import org.apache.iotdb.db.qp.sql.SqlBaseLexer;\n+import org.apache.iotdb.db.qp.sql.SqlBaseParser;\n \n /**\n- * This class is a listener and you can get an operator which is a logical plan.\n+ * LogicalGenerator.\n+ *\n  */\n-public class LogicalGenerator extends SqlBaseBaseListener {\n-\n-  private RootOperator initializedOperator = null;\n-  private ZoneId zoneId;\n-  private int operatorType;\n-  private CreateTimeSeriesOperator createTimeSeriesOperator;\n-  private AlterTimeSeriesOperator alterTimeSeriesOperator;\n-  private InsertOperator insertOp;\n-  private SelectOperator selectOp;\n-  private UpdateOperator updateOp;\n-  private QueryOperator queryOp;\n-  private DeleteDataOperator deleteDataOp;\n-  private boolean isParsingSlidingStep;\n-  private static final String DELETE_RANGE_ERROR_MSG =\n-    \"For delete statement, where clause can only contain atomic expressions like : \" +\n-      \"time > XXX, time <= XXX, or two atomic expressions connected by 'AND'\";\n-\n-\n-  LogicalGenerator(ZoneId zoneId) {\n-    this.zoneId = zoneId;\n-  }\n-\n-  RootOperator getLogicalPlan() {\n-    return initializedOperator;\n-  }\n-\n-  @Override\n-  public void enterCountTimeseries(CountTimeseriesContext ctx) {\n-    super.enterCountTimeseries(ctx);\n-    PrefixPathContext pathContext = ctx.prefixPath();\n-    PartialPath path = (pathContext != null ? parsePrefixPath(pathContext) : new PartialPath(SQLConstant.getSingleRootArray()));\n-    if (ctx.INT() != null) {\n-      initializedOperator = new CountOperator(SQLConstant.TOK_COUNT_NODE_TIMESERIES,\n-          path, Integer.parseInt(ctx.INT().getText()));\n-    } else {\n-      initializedOperator = new CountOperator(SQLConstant.TOK_COUNT_TIMESERIES,\n-          path);\n-    }\n-  }\n-\n-  @Override\n-  public void enterCountDevices(CountDevicesContext ctx) {\n-    super.enterCountDevices(ctx);\n-    PrefixPathContext pathContext = ctx.prefixPath();\n-    PartialPath path = (pathContext != null ? parsePrefixPath(pathContext) : new PartialPath(SQLConstant.getSingleRootArray()));\n-    initializedOperator = new CountOperator(SQLConstant.TOK_COUNT_DEVICES, path);\n-  }\n-\n-  @Override\n-  public void enterCountStorageGroup(CountStorageGroupContext ctx) {\n-    super.enterCountStorageGroup(ctx);\n-    PrefixPathContext pathContext = ctx.prefixPath();\n-    PartialPath path = (pathContext != null ? parsePrefixPath(pathContext) : new PartialPath(SQLConstant.getSingleRootArray()));\n-    initializedOperator = new CountOperator(SQLConstant.TOK_COUNT_STORAGE_GROUP, path);\n-  }\n-\n-  @Override\n-  public void enterFlush(FlushContext ctx) {\n-    super.enterFlush(ctx);\n-    FlushOperator flushOperator = new FlushOperator(SQLConstant.TOK_FLUSH);\n-    if (ctx.booleanClause() != null) {\n-      flushOperator.setSeq(Boolean.parseBoolean(ctx.booleanClause().getText()));\n-    }\n-    if (ctx.prefixPath(0) != null) {\n-      List<PartialPath> storageGroups = new ArrayList<>();\n-      for (PrefixPathContext prefixPathContext : ctx.prefixPath()) {\n-        storageGroups.add(parsePrefixPath(prefixPathContext));\n-      }\n-      flushOperator.setStorageGroupList(storageGroups);\n-    }\n-\n-    initializedOperator = flushOperator;\n-  }\n-\n-  @Override\n-  public void enterTracingOn(TracingOnContext ctx) {\n-    super.enterTracingOn(ctx);\n-    initializedOperator = new TracingOperator(SQLConstant.TOK_TRACING, true);\n-  }\n-\n-  @Override\n-  public void enterTracingOff(TracingOffContext ctx) {\n-    super.enterTracingOff(ctx);\n-    initializedOperator = new TracingOperator(SQLConstant.TOK_TRACING, false);\n-  }\n-\n-  @Override\n-  public void enterMerge(MergeContext ctx) {\n-    super.enterMerge(ctx);\n-    initializedOperator = new MergeOperator(SQLConstant.TOK_MERGE);\n-  }\n-\n-  @Override\n-  public void enterFullMerge(FullMergeContext ctx) {\n-    super.enterFullMerge(ctx);\n-    initializedOperator = new MergeOperator(SQLConstant.TOK_FULL_MERGE);\n-  }\n-\n-  @Override\n-  public void enterClearcache(SqlBaseParser.ClearcacheContext ctx) {\n-    super.enterClearcache(ctx);\n-    initializedOperator = new ClearCacheOperator(SQLConstant.TOK_CLEAR_CACHE);\n-  }\n-\n-  @Override\n-  public void enterCountNodes(CountNodesContext ctx) {\n-    super.enterCountNodes(ctx);\n-    initializedOperator = new CountOperator(SQLConstant.TOK_COUNT_NODES,\n-        parsePrefixPath(ctx.prefixPath()), Integer.parseInt(ctx.INT().getText()));\n-  }\n-\n-  @Override\n-  public void enterShowDevices(ShowDevicesContext ctx) {\n-    super.enterShowDevices(ctx);\n-    if (ctx.prefixPath() != null) {\n-      initializedOperator = new ShowDevicesOperator(SQLConstant.TOK_DEVICES,\n-          parsePrefixPath(ctx.prefixPath()));\n-    } else {\n-      initializedOperator = new ShowDevicesOperator(SQLConstant.TOK_DEVICES,\n-          new PartialPath(SQLConstant.getSingleRootArray()));\n-    }\n-  }\n-\n-  @Override\n-  public void enterShowChildPaths(ShowChildPathsContext ctx) {\n-    super.enterShowChildPaths(ctx);\n-    if (ctx.prefixPath() != null) {\n-      initializedOperator = new ShowChildPathsOperator(SQLConstant.TOK_CHILD_PATHS,\n-          parsePrefixPath(ctx.prefixPath()));\n-    } else {\n-      initializedOperator = new ShowChildPathsOperator(SQLConstant.TOK_CHILD_PATHS,\n-          new PartialPath(SQLConstant.getSingleRootArray()));\n-    }\n-  }\n-\n-  @Override\n-  public void enterShowStorageGroup(ShowStorageGroupContext ctx) {\n-    super.enterShowStorageGroup(ctx);\n-    if (ctx.prefixPath() != null) {\n-      initializedOperator = new ShowStorageGroupOperator(SQLConstant.TOK_STORAGE_GROUP,\n-          parsePrefixPath(ctx.prefixPath()));\n-    } else {\n-      initializedOperator = new ShowStorageGroupOperator(SQLConstant.TOK_STORAGE_GROUP,\n-          new PartialPath(SQLConstant.getSingleRootArray()));\n-    }\n-  }\n-\n-  @Override\n-  public void enterLoadFiles(LoadFilesContext ctx) {\n-    super.enterLoadFiles(ctx);\n-    if (ctx.autoCreateSchema() != null) {\n-      if (ctx.autoCreateSchema().INT() != null) {\n-        initializedOperator = new LoadFilesOperator(\n-            new File(removeStringQuote(ctx.stringLiteral().getText())),\n-            Boolean.parseBoolean(ctx.autoCreateSchema().booleanClause().getText()),\n-            Integer.parseInt(ctx.autoCreateSchema().INT().getText())\n-        );\n-      } else {\n-        initializedOperator = new LoadFilesOperator(\n-            new File(removeStringQuote(ctx.stringLiteral().getText())),\n-            Boolean.parseBoolean(ctx.autoCreateSchema().booleanClause().getText()),\n-            IoTDBDescriptor.getInstance().getConfig().getDefaultStorageGroupLevel()\n-        );\n-      }\n-    } else {\n-      initializedOperator = new LoadFilesOperator(\n-          new File(removeStringQuote(ctx.stringLiteral().getText())),\n-          true,\n-          IoTDBDescriptor.getInstance().getConfig().getDefaultStorageGroupLevel()\n-      );\n-    }\n-  }\n-\n-  @Override\n-  public void enterMoveFile(MoveFileContext ctx) {\n-    super.enterMoveFile(ctx);\n-    initializedOperator = new MoveFileOperator(\n-        new File(removeStringQuote(ctx.stringLiteral(0).getText())),\n-        new File(removeStringQuote(ctx.stringLiteral(1).getText())));\n-  }\n-\n-  @Override\n-  public void enterRemoveFile(RemoveFileContext ctx) {\n-    super.enterRemoveFile(ctx);\n-    initializedOperator = new RemoveFileOperator(\n-        new File(removeStringQuote(ctx.stringLiteral().getText())));\n-  }\n-\n-  @Override\n-  public void enterLoadConfigurationStatement(LoadConfigurationStatementContext ctx) {\n-    super.enterLoadConfigurationStatement(ctx);\n-    if (ctx.GLOBAL() != null) {\n-      initializedOperator = new LoadConfigurationOperator(LoadConfigurationOperatorType.GLOBAL);\n-    } else {\n-      initializedOperator = new LoadConfigurationOperator(LoadConfigurationOperatorType.LOCAL);\n-    }\n-\n-  }\n-\n-  @Override\n-  public void enterShowVersion(ShowVersionContext ctx) {\n-    super.enterShowVersion(ctx);\n-    initializedOperator = new ShowOperator(SQLConstant.TOK_VERSION);\n-  }\n-\n-  @Override\n-  public void enterShowFlushTaskInfo(SqlBaseParser.ShowFlushTaskInfoContext ctx) {\n-    super.enterShowFlushTaskInfo(ctx);\n-    initializedOperator = new ShowOperator(SQLConstant.TOK_FLUSH_TASK_INFO);\n-  }\n-\n-  @Override\n-  public void enterShowTimeseries(ShowTimeseriesContext ctx) {\n-    super.enterShowTimeseries(ctx);\n-    boolean orderByHeat = ctx.LATEST() != null;\n-    if (ctx.prefixPath() != null) {\n-      initializedOperator = new ShowTimeSeriesOperator(SQLConstant.TOK_TIMESERIES,\n-          parsePrefixPath(ctx.prefixPath()), orderByHeat);\n-    } else {\n-      initializedOperator = new ShowTimeSeriesOperator(SQLConstant.TOK_TIMESERIES, new PartialPath(SQLConstant.getSingleRootArray()),\n-          orderByHeat);\n-    }\n-  }\n-\n-  @Override\n-  public void enterCreateTimeseries(CreateTimeseriesContext ctx) {\n-    super.enterCreateTimeseries(ctx);\n-    createTimeSeriesOperator = new CreateTimeSeriesOperator(SQLConstant.TOK_METADATA_CREATE);\n-    operatorType = SQLConstant.TOK_METADATA_CREATE;\n-    createTimeSeriesOperator.setPath(parseFullPath(ctx.fullPath()));\n-  }\n-\n-  @Override\n-  public void enterAlterTimeseries(SqlBaseParser.AlterTimeseriesContext ctx) {\n-    super.enterAlterTimeseries(ctx);\n-    alterTimeSeriesOperator = new AlterTimeSeriesOperator(SQLConstant.TOK_METADATA_ALTER);\n-    operatorType = SQLConstant.TOK_METADATA_ALTER;\n-    alterTimeSeriesOperator.setPath(parseFullPath(ctx.fullPath()));\n-  }\n-\n-  @Override\n-  public void enterAlterClause(SqlBaseParser.AlterClauseContext ctx) {\n-    super.enterAlterClause(ctx);\n-    Map<String, String> alterMap = new HashMap<>();\n-    // rename\n-    if (ctx.RENAME() != null) {\n-      alterTimeSeriesOperator.setAlterType(AlterType.RENAME);\n-      alterMap.put(ctx.beforeName.getText(), ctx.currentName.getText());\n-    } else if (ctx.SET() != null) {\n-      // set\n-      alterTimeSeriesOperator.setAlterType(AlterType.SET);\n-      setMap(ctx, alterMap);\n-    } else if (ctx.DROP() != null) {\n-      // drop\n-      alterTimeSeriesOperator.setAlterType(AlterType.DROP);\n-      for (TerminalNode dropId : ctx.ID()) {\n-        alterMap.put(dropId.getText(), null);\n-      }\n-    } else if (ctx.TAGS() != null) {\n-      // add tag\n-      alterTimeSeriesOperator.setAlterType(AlterType.ADD_TAGS);\n-      setMap(ctx, alterMap);\n-    } else if (ctx.ATTRIBUTES() != null) {\n-      // add attribute\n-      alterTimeSeriesOperator.setAlterType(AlterType.ADD_ATTRIBUTES);\n-      setMap(ctx, alterMap);\n-    } else {\n-      // upsert\n-      alterTimeSeriesOperator.setAlterType(AlterType.UPSERT);\n-    }\n-    alterTimeSeriesOperator.setAlterMap(alterMap);\n-    initializedOperator = alterTimeSeriesOperator;\n-  }\n-\n-  private void setMap(SqlBaseParser.AlterClauseContext ctx, Map<String, String> alterMap) {\n-    List<PropertyContext> tagsList = ctx.property();\n-    if (ctx.property(0) != null) {\n-      for (PropertyContext property : tagsList) {\n-        String value;\n-        if (property.propertyValue().stringLiteral() != null) {\n-          value = removeStringQuote(property.propertyValue().getText());\n-        } else {\n-          value = property.propertyValue().getText();\n-        }\n-        alterMap.put(property.ID().getText(), value);\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public void enterAlias(AliasContext ctx) {\n-    super.enterAlias(ctx);\n-    createTimeSeriesOperator.setAlias(ctx.ID().getText());\n-  }\n-\n-  @Override\n-  public void enterCreateUser(CreateUserContext ctx) {\n-    super.enterCreateUser(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_CREATE,\n-        AuthorOperator.AuthorType.CREATE_USER);\n-    authorOperator.setUserName(ctx.ID().getText());\n-    authorOperator.setPassWord(removeStringQuote(ctx.password.getText()));\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_CREATE;\n-  }\n-\n-  @Override\n-  public void enterCreateRole(CreateRoleContext ctx) {\n-    super.enterCreateRole(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_CREATE,\n-        AuthorOperator.AuthorType.CREATE_ROLE);\n-    authorOperator.setRoleName(ctx.ID().getText());\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_CREATE;\n-  }\n-\n-  @Override\n-  public void enterAlterUser(AlterUserContext ctx) {\n-    super.enterAlterUser(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_UPDATE_USER,\n-        AuthorOperator.AuthorType.UPDATE_USER);\n-    if (ctx.ID() != null) {\n-      authorOperator.setUserName(ctx.ID().getText());\n-    } else {\n-      authorOperator.setUserName(ctx.ROOT().getText());\n-    }\n-    authorOperator.setNewPassword(removeStringQuote(ctx.password.getText()));\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_UPDATE_USER;\n-  }\n-\n-  @Override\n-  public void enterDropUser(DropUserContext ctx) {\n-    super.enterDropUser(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_DROP,\n-        AuthorOperator.AuthorType.DROP_USER);\n-    authorOperator.setUserName(ctx.ID().getText());\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_DROP;\n-  }\n-\n-  @Override\n-  public void enterDropRole(DropRoleContext ctx) {\n-    super.enterDropRole(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_DROP,\n-        AuthorOperator.AuthorType.DROP_ROLE);\n-    authorOperator.setRoleName(ctx.ID().getText());\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_DROP;\n-  }\n-\n-  @Override\n-  public void enterGrantUser(GrantUserContext ctx) {\n-    super.enterGrantUser(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_GRANT,\n-        AuthorOperator.AuthorType.GRANT_USER);\n-    authorOperator.setUserName(ctx.ID().getText());\n-    authorOperator.setPrivilegeList(parsePrivilege(ctx.privileges()));\n-    authorOperator.setNodeNameList(parsePrefixPath(ctx.prefixPath()));\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_GRANT;\n-  }\n-\n-  @Override\n-  public void enterGrantRole(GrantRoleContext ctx) {\n-    super.enterGrantRole(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_GRANT,\n-        AuthorType.GRANT_ROLE);\n-    authorOperator.setRoleName(ctx.ID().getText());\n-    authorOperator.setPrivilegeList(parsePrivilege(ctx.privileges()));\n-    authorOperator.setNodeNameList(parsePrefixPath(ctx.prefixPath()));\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_GRANT;\n-  }\n-\n-  @Override\n-  public void enterRevokeUser(RevokeUserContext ctx) {\n-    super.enterRevokeUser(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_GRANT,\n-        AuthorType.REVOKE_USER);\n-    authorOperator.setUserName(ctx.ID().getText());\n-    authorOperator.setPrivilegeList(parsePrivilege(ctx.privileges()));\n-    authorOperator.setNodeNameList(parsePrefixPath(ctx.prefixPath()));\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_GRANT;\n-  }\n-\n-  @Override\n-  public void enterRevokeRole(RevokeRoleContext ctx) {\n-    super.enterRevokeRole(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_GRANT,\n-        AuthorType.REVOKE_ROLE);\n-    authorOperator.setRoleName(ctx.ID().getText());\n-    authorOperator.setPrivilegeList(parsePrivilege(ctx.privileges()));\n-    authorOperator.setNodeNameList(parsePrefixPath(ctx.prefixPath()));\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_GRANT;\n-  }\n-\n-  @Override\n-  public void enterGrantRoleToUser(GrantRoleToUserContext ctx) {\n-    super.enterGrantRoleToUser(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_GRANT,\n-        AuthorOperator.AuthorType.GRANT_ROLE_TO_USER);\n-    authorOperator.setRoleName(ctx.roleName.getText());\n-    authorOperator.setUserName(ctx.userName.getText());\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_GRANT;\n-  }\n-\n-  @Override\n-  public void enterRevokeRoleFromUser(RevokeRoleFromUserContext ctx) {\n-    super.enterRevokeRoleFromUser(ctx);\n-    AuthorOperator authorOperator = new AuthorOperator(SQLConstant.TOK_AUTHOR_GRANT,\n-        AuthorType.REVOKE_ROLE_FROM_USER);\n-    authorOperator.setRoleName(ctx.roleName.getText());\n-    authorOperator.setUserName(ctx.userName.getText());\n-    initializedOperator = authorOperator;\n-    operatorType = SQLConstant.TOK_AUTHOR_GRANT;\n-  }\n-\n-  @Override\n-  public void enterLoadStatement(LoadStatementContext ctx) {\n-    super.enterLoadStatement(ctx);\n-    if (ctx.prefixPath().nodeName().size() < 3) {\n-      throw new SQLParserException(\"data load command: child count < 3\\n\");\n-    }\n-\n-    String csvPath = ctx.stringLiteral().getText();\n-    StringContainer sc = new StringContainer(TsFileConstant.PATH_SEPARATOR);\n-    List<NodeNameContext> nodeNames = ctx.prefixPath().nodeName();\n-    sc.addTail(ctx.prefixPath().ROOT().getText());\n-    for (NodeNameContext nodeName : nodeNames) {\n-      sc.addTail(nodeName.getText());\n-    }\n-    initializedOperator = new LoadDataOperator(SQLConstant.TOK_DATALOAD,\n-        removeStringQuote(csvPath),\n-        sc.toString());\n-    operatorType = SQLConstant.TOK_DATALOAD;\n-  }\n-\n-  @Override\n-  public void enterGrantWatermarkEmbedding(GrantWatermarkEmbeddingContext ctx) {\n-    super.enterGrantWatermarkEmbedding(ctx);\n-    List<RootOrIdContext> rootOrIdList = ctx.rootOrId();\n-    List<String> users = new ArrayList<>();\n-    for (RootOrIdContext rootOrId : rootOrIdList) {\n-      users.add(rootOrId.getText());\n-    }\n-    initializedOperator = new DataAuthOperator(SQLConstant.TOK_GRANT_WATERMARK_EMBEDDING, users);\n-  }\n-\n-  @Override\n-  public void enterRevokeWatermarkEmbedding(RevokeWatermarkEmbeddingContext ctx) {\n-    super.enterRevokeWatermarkEmbedding(ctx);\n-    List<RootOrIdContext> rootOrIdList = ctx.rootOrId();\n-    List<String> users = new ArrayList<>();\n-    for (RootOrIdContext rootOrId : rootOrIdList) {\n-      users.add(rootOrId.getText());\n-    }\n-    initializedOperator = new DataAuthOperator(SQLConstant.TOK_REVOKE_WATERMARK_EMBEDDING, users);\n-    operatorType = SQLConstant.TOK_REVOKE_WATERMARK_EMBEDDING;\n-  }\n-\n-  @Override\n-  public void enterListUser(ListUserContext ctx) {\n-    super.enterListUser(ctx);\n-    initializedOperator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_USER);\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterListRole(ListRoleContext ctx) {\n-    super.enterListRole(ctx);\n-    initializedOperator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_ROLE);\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterListPrivilegesUser(ListPrivilegesUserContext ctx) {\n-    super.enterListPrivilegesUser(ctx);\n-    AuthorOperator operator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_USER_PRIVILEGE);\n-    operator.setUserName(ctx.rootOrId().getText());\n-    operator.setNodeNameList(parsePrefixPath(ctx.prefixPath()));\n-    initializedOperator = operator;\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterListPrivilegesRole(ListPrivilegesRoleContext ctx) {\n-    super.enterListPrivilegesRole(ctx);\n-    AuthorOperator operator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_ROLE_PRIVILEGE);\n-    operator.setRoleName((ctx.ID().getText()));\n-    operator.setNodeNameList(parsePrefixPath(ctx.prefixPath()));\n-    initializedOperator = operator;\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterListUserPrivileges(ListUserPrivilegesContext ctx) {\n-    super.enterListUserPrivileges(ctx);\n-    AuthorOperator operator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_USER_PRIVILEGE);\n-    operator.setUserName(ctx.rootOrId().getText());\n-    initializedOperator = operator;\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterListRolePrivileges(ListRolePrivilegesContext ctx) {\n-    super.enterListRolePrivileges(ctx);\n-    AuthorOperator operator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_ROLE_PRIVILEGE);\n-    operator.setRoleName(ctx.ID().getText());\n-    initializedOperator = operator;\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterListAllRoleOfUser(ListAllRoleOfUserContext ctx) {\n-    super.enterListAllRoleOfUser(ctx);\n-    AuthorOperator operator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_USER_ROLES);\n-    initializedOperator = operator;\n-    operator.setUserName(ctx.rootOrId().getText());\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterListAllUserOfRole(ListAllUserOfRoleContext ctx) {\n-    super.enterListAllUserOfRole(ctx);\n-    AuthorOperator operator = new AuthorOperator(SQLConstant.TOK_LIST,\n-        AuthorOperator.AuthorType.LIST_ROLE_USERS);\n-    initializedOperator = operator;\n-    operator.setRoleName((ctx.ID().getText()));\n-    operatorType = SQLConstant.TOK_LIST;\n-  }\n-\n-  @Override\n-  public void enterSetTTLStatement(SetTTLStatementContext ctx) {\n-    super.enterSetTTLStatement(ctx);\n-    SetTTLOperator operator = new SetTTLOperator(SQLConstant.TOK_SET);\n-    operator.setStorageGroup(parsePrefixPath(ctx.prefixPath()));\n-    operator.setDataTTL(Long.parseLong(ctx.INT().getText()));\n-    initializedOperator = operator;\n-    operatorType = SQLConstant.TOK_SET;\n-  }\n-\n-  @Override\n-  public void enterUnsetTTLStatement(UnsetTTLStatementContext ctx) {\n-    super.enterUnsetTTLStatement(ctx);\n-    SetTTLOperator operator = new SetTTLOperator(SQLConstant.TOK_UNSET);\n-    operator.setStorageGroup(parsePrefixPath(ctx.prefixPath()));\n-    initializedOperator = operator;\n-    operatorType = SQLConstant.TOK_UNSET;\n-  }\n-\n-  @Override\n-  public void enterShowTTLStatement(ShowTTLStatementContext ctx) {\n-    super.enterShowTTLStatement(ctx);\n-    List<PartialPath> storageGroups = new ArrayList<>();\n-    List<PrefixPathContext> prefixPathList = ctx.prefixPath();\n-    for (PrefixPathContext prefixPath : prefixPathList) {\n-      storageGroups.add(parsePrefixPath(prefixPath));\n-    }\n-    initializedOperator = new ShowTTLOperator(storageGroups);\n-  }\n-\n-  @Override\n-  public void enterShowAllTTLStatement(ShowAllTTLStatementContext ctx) {\n-    super.enterShowAllTTLStatement(ctx);\n-    List<PartialPath> storageGroups = new ArrayList<>();\n-    initializedOperator = new ShowTTLOperator(storageGroups);\n-  }\n-\n-  private String[] parsePrivilege(PrivilegesContext ctx) {\n-    List<StringLiteralContext> privilegeList = ctx.stringLiteral();\n-    List<String> privileges = new ArrayList<>();\n-    for (StringLiteralContext privilege : privilegeList) {\n-      privileges.add(removeStringQuote(privilege.getText()));\n-    }\n-    return privileges.toArray(new String[0]);\n-  }\n-\n-  private String removeStringQuote(String src) {\n-    if (src.charAt(0) == '\\'' && src.charAt(src.length() - 1) == '\\'') {\n-      return src.substring(1, src.length() - 1);\n-    } else if (src.charAt(0) == '\\\"' && src.charAt(src.length() - 1) == '\\\"') {\n-      return src.substring(1, src.length() - 1);\n-    } else {\n-      throw new SQLParserException(\"error format for string with quote:\" + src);\n-    }\n-  }\n-\n-  @Override\n-  public void enterDeleteTimeseries(DeleteTimeseriesContext ctx) {\n-    super.enterDeleteTimeseries(ctx);\n-    List<PartialPath> deletePaths = new ArrayList<>();\n-    List<PrefixPathContext> prefixPaths = ctx.prefixPath();\n-    for (PrefixPathContext prefixPath : prefixPaths) {\n-      deletePaths.add(parsePrefixPath(prefixPath));\n-    }\n-    DeleteTimeSeriesOperator deleteTimeSeriesOperator = new DeleteTimeSeriesOperator(\n-        SQLConstant.TOK_METADATA_DELETE);\n-    deleteTimeSeriesOperator.setDeletePathList(deletePaths);\n-    initializedOperator = deleteTimeSeriesOperator;\n-    operatorType = SQLConstant.TOK_METADATA_DELETE;\n-  }\n-\n-  @Override\n-  public void enterSetStorageGroup(SetStorageGroupContext ctx) {\n-    super.enterSetStorageGroup(ctx);\n-    SetStorageGroupOperator setStorageGroupOperator = new SetStorageGroupOperator(\n-        SQLConstant.TOK_METADATA_SET_FILE_LEVEL);\n-    PartialPath path = parsePrefixPath(ctx.prefixPath());\n-    setStorageGroupOperator.setPath(path);\n-    initializedOperator = setStorageGroupOperator;\n-    operatorType = SQLConstant.TOK_METADATA_SET_FILE_LEVEL;\n-  }\n-\n-  @Override\n-  public void enterDeleteStorageGroup(DeleteStorageGroupContext ctx) {\n-    super.enterDeleteStorageGroup(ctx);\n-    List<PartialPath> deletePaths = new ArrayList<>();\n-    List<PrefixPathContext> prefixPaths = ctx.prefixPath();\n-    for (PrefixPathContext prefixPath : prefixPaths) {\n-      deletePaths.add(parsePrefixPath(prefixPath));\n-    }\n-    DeleteStorageGroupOperator deleteStorageGroupOperator = new DeleteStorageGroupOperator(\n-        SQLConstant.TOK_METADATA_DELETE_FILE_LEVEL);\n-    deleteStorageGroupOperator.setDeletePathList(deletePaths);\n-    initializedOperator = deleteStorageGroupOperator;\n-    operatorType = SQLConstant.TOK_METADATA_DELETE_FILE_LEVEL;\n-  }\n-\n-  @Override\n-  public void enterDeleteStatement(DeleteStatementContext ctx) {\n-    super.enterDeleteStatement(ctx);\n-    operatorType = SQLConstant.TOK_DELETE;\n-    deleteDataOp = new DeleteDataOperator(SQLConstant.TOK_DELETE);\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    List<PrefixPathContext> prefixPaths = ctx.prefixPath();\n-    for (PrefixPathContext prefixPath : prefixPaths) {\n-      PartialPath path = parsePrefixPath(prefixPath);\n-      selectOp.addSelectPath(path);\n-    }\n-    deleteDataOp.setSelectOperator(selectOp);\n-    initializedOperator = deleteDataOp;\n-  }\n-\n-  @Override\n-  public void enterDisableAlign(SqlBaseParser.DisableAlignContext ctx) {\n-    super.enterDisableAlign(ctx);\n-    queryOp.setAlignByTime(false);\n-  }\n-\n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  @Override\n-  public void enterGroupByFillClause(SqlBaseParser.GroupByFillClauseContext ctx) {\n-    super.enterGroupByFillClause(ctx);\n-    queryOp.setGroupByTime(true);\n-    queryOp.setFill(true);\n-    queryOp.setLeftCRightO(ctx.timeInterval().LS_BRACKET() != null);\n-\n-    // parse timeUnit\n-    queryOp.setUnit(parseDuration(ctx.DURATION().getText()));\n-    queryOp.setSlidingStep(queryOp.getUnit());\n-\n-    parseTimeInterval(ctx.timeInterval());\n-\n-    List<TypeClauseContext> list = ctx.typeClause();\n-    Map<TSDataType, IFill> fillTypes = new EnumMap<>(TSDataType.class);\n-    for (TypeClauseContext typeClause : list) {\n-      // group by fill doesn't support linear fill\n-      if (typeClause.linearClause() != null) {\n-        throw new SQLParserException(\"group by fill doesn't support linear fill\");\n-      }\n-      // all type use the same fill way\n-      if (SQLConstant.ALL.equalsIgnoreCase(typeClause.dataType().getText())) {\n-        IFill fill;\n-        if (typeClause.previousUntilLastClause() != null) {\n-          long preRange;\n-          if (typeClause.previousUntilLastClause().DURATION() != null) {\n-            preRange = parseDuration(typeClause.previousUntilLastClause().DURATION().getText());\n-          } else {\n-            preRange = IoTDBDescriptor.getInstance().getConfig().getDefaultFillInterval();\n-          }\n-          fill = new PreviousFill(preRange, true);\n-        } else {\n-          long preRange;\n-          if (typeClause.previousClause().DURATION() != null) {\n-            preRange = parseDuration(typeClause.previousClause().DURATION().getText());\n-          } else {\n-            preRange = IoTDBDescriptor.getInstance().getConfig().getDefaultFillInterval();\n-          }\n-          fill = new PreviousFill(preRange);\n-        }\n-        for (TSDataType tsDataType : TSDataType.values()) {\n-          fillTypes.put(tsDataType, fill.copy());\n-        }\n-        break;\n-      } else {\n-        parseTypeClause(typeClause, fillTypes);\n-      }\n-    }\n-    queryOp.setFill(true);\n-    queryOp.setFillTypes(fillTypes);\n-  }\n-\n-  private void parseTimeInterval(TimeIntervalContext timeInterval) {\n-    long startTime;\n-    long endTime;\n-    if (timeInterval.timeValue(0).INT() != null) {\n-      startTime = Long.parseLong(timeInterval.timeValue(0).INT().getText());\n-    } else if (timeInterval.timeValue(0).dateExpression() != null) {\n-      startTime = parseDateExpression(timeInterval.timeValue(0).dateExpression());\n-    } else {\n-      startTime = parseTimeFormat(timeInterval.timeValue(0).dateFormat().getText());\n-    }\n-    if (timeInterval.timeValue(1).INT() != null) {\n-      endTime = Long.parseLong(timeInterval.timeValue(1).INT().getText());\n-    } else if (timeInterval.timeValue(1).dateExpression() != null) {\n-      endTime = parseDateExpression(timeInterval.timeValue(1).dateExpression());\n-    } else {\n-      endTime = parseTimeFormat(timeInterval.timeValue(1).dateFormat().getText());\n-    }\n-\n-    queryOp.setStartTime(startTime);\n-    queryOp.setEndTime(endTime);\n-    if (startTime >= endTime) {\n-      throw new SQLParserException(\"start time should be smaller than endTime in GroupBy\");\n-    }\n-  }\n-\n-  @Override\n-  public void enterGroupByTimeClause(GroupByTimeClauseContext ctx) {\n-    super.enterGroupByTimeClause(ctx);\n-\n-    queryOp.setGroupByTime(true);\n-    queryOp.setLeftCRightO(ctx.timeInterval().LS_BRACKET() != null);\n-    // parse timeUnit\n-    queryOp.setUnit(parseDuration(ctx.DURATION(0).getText()));\n-    queryOp.setSlidingStep(queryOp.getUnit());\n-    // parse sliding step\n-    if (ctx.DURATION().size() == 2) {\n-      isParsingSlidingStep = true;\n-      queryOp.setSlidingStep(parseDuration(ctx.DURATION(1).getText()));\n-      isParsingSlidingStep = false;\n-      if (queryOp.getSlidingStep() < queryOp.getUnit()) {\n-        throw new SQLParserException(\n-            \"The third parameter sliding step shouldn't be smaller than the second parameter time interval.\");\n-      }\n-      if (queryOp.isIntervalByMonth() && !queryOp.isSlidingStepByMonth()) {\n-        throw new SQLParserException(\n-            \"The unit of sliding step should be set in month.\");\n-      }\n-    }\n-\n-    parseTimeInterval(ctx.timeInterval());\n-\n-    if (ctx.INT() != null) {\n-      queryOp.setLevel(Integer.parseInt(ctx.INT().getText()));\n-    }\n-  }\n-\n-  @Override\n-  public void enterGroupByLevelClause(SqlBaseParser.GroupByLevelClauseContext ctx) {\n-    super.enterGroupByLevelClause(ctx);\n-    queryOp.setGroupByLevel(true);\n-\n-    queryOp.setLevel(Integer.parseInt(ctx.INT().getText()));\n-  }\n-\n-  @Override\n-  public void enterFillClause(FillClauseContext ctx) {\n-    super.enterFillClause(ctx);\n-    FilterOperator filterOperator = queryOp.getFilterOperator();\n-    if (!filterOperator.isLeaf() || filterOperator.getTokenIntType() != SQLConstant.EQUAL) {\n-      throw new SQLParserException(\"Only \\\"=\\\" can be used in fill function\");\n-    }\n-    List<TypeClauseContext> list = ctx.typeClause();\n-    Map<TSDataType, IFill> fillTypes = new EnumMap<>(TSDataType.class);\n-    for (TypeClauseContext typeClause : list) {\n-      parseTypeClause(typeClause, fillTypes);\n-    }\n-    queryOp.setFill(true);\n-    queryOp.setFillTypes(fillTypes);\n-  }\n-\n-  private void parseTypeClause(TypeClauseContext ctx, Map<TSDataType, IFill> fillTypes) {\n-    TSDataType dataType = parseType(ctx.dataType().getText());\n-    if (ctx.linearClause() != null && dataType == TSDataType.TEXT) {\n-      throw new SQLParserException(String.format(\"type %s cannot use %s fill function\"\n-          , dataType, ctx.linearClause().LINEAR().getText()));\n-    }\n-\n-    int defaultFillInterval = IoTDBDescriptor.getInstance().getConfig().getDefaultFillInterval();\n-\n-    if (ctx.linearClause() != null) {  // linear\n-      if (ctx.linearClause().DURATION(0) != null) {\n-        long beforeRange = parseDuration(ctx.linearClause().DURATION(0).getText());\n-        long afterRange = parseDuration(ctx.linearClause().DURATION(1).getText());\n-        fillTypes.put(dataType, new LinearFill(beforeRange, afterRange));\n-      } else {\n-        fillTypes.put(dataType, new LinearFill(defaultFillInterval, defaultFillInterval));\n-      }\n-    } else if (ctx.previousClause() != null) { // previous\n-      if (ctx.previousClause().DURATION() != null) {\n-        long preRange = parseDuration(ctx.previousClause().DURATION().getText());\n-        fillTypes.put(dataType, new PreviousFill(preRange));\n-      } else {\n-        fillTypes.put(dataType, new PreviousFill(defaultFillInterval));\n-      }\n-    } else { // previous until last\n-      if (ctx.previousUntilLastClause().DURATION() != null) {\n-        long preRange = parseDuration(ctx.previousUntilLastClause().DURATION().getText());\n-        fillTypes.put(dataType, new PreviousFill(preRange, true));\n-      } else {\n-        fillTypes.put(dataType, new PreviousFill(defaultFillInterval, true));\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public void enterAlignByDeviceClause(AlignByDeviceClauseContext ctx) {\n-    super.enterAlignByDeviceClause(ctx);\n-    queryOp.setAlignByDevice(true);\n-  }\n-\n-  /**\n-   * parse datatype node.\n-   */\n-  private TSDataType parseType(String datatype) {\n-    String type = datatype.toLowerCase();\n-    switch (type) {\n-      case \"int32\":\n-        return TSDataType.INT32;\n-      case \"int64\":\n-        return TSDataType.INT64;\n-      case \"float\":\n-        return TSDataType.FLOAT;\n-      case \"double\":\n-        return TSDataType.DOUBLE;\n-      case \"boolean\":\n-        return TSDataType.BOOLEAN;\n-      case \"text\":\n-        return TSDataType.TEXT;\n-      default:\n-        throw new SQLParserException(\"not a valid fill type : \" + type);\n-    }\n-  }\n-\n-  @Override\n-  public void enterLimitClause(LimitClauseContext ctx) {\n-    super.enterLimitClause(ctx);\n-    int limit;\n-    try {\n-      limit = Integer.parseInt(ctx.INT().getText());\n-    } catch (NumberFormatException e) {\n-      throw new SQLParserException(\"Out of range. LIMIT <N>: N should be Int32.\");\n-    }\n-    if (limit <= 0) {\n-      throw new SQLParserException(\"LIMIT <N>: N should be greater than 0.\");\n-    }\n-    if (initializedOperator instanceof ShowTimeSeriesOperator) {\n-      ((ShowTimeSeriesOperator) initializedOperator).setLimit(limit);\n-    } else {\n-      queryOp.setRowLimit(limit);\n-    }\n-  }\n-\n-  @Override\n-  public void enterOffsetClause(OffsetClauseContext ctx) {\n-    super.enterOffsetClause(ctx);\n-    int offset;\n-    try {\n-      offset = Integer.parseInt(ctx.INT().getText());\n-    } catch (NumberFormatException e) {\n-      throw new SQLParserException(\n-          \"Out of range. OFFSET <OFFSETValue>: OFFSETValue should be Int32.\");\n-    }\n-    if (offset < 0) {\n-      throw new SQLParserException(\"OFFSET <OFFSETValue>: OFFSETValue should >= 0.\");\n-    }\n-    if (initializedOperator instanceof ShowTimeSeriesOperator) {\n-      ((ShowTimeSeriesOperator) initializedOperator).setOffset(offset);\n-    } else {\n-      queryOp.setRowOffset(offset);\n-    }\n-  }\n-\n-  @Override\n-  public void enterOrderByTimeClause(OrderByTimeClauseContext ctx) {\n-    super.enterOrderByTimeClause(ctx);\n-    queryOp.setColumn(ctx.TIME().getText());\n-    if (ctx.DESC() != null) {\n-      queryOp.setAscending(false);\n-    }\n-  }\n-\n-  @Override\n-  public void enterSlimitClause(SlimitClauseContext ctx) {\n-    super.enterSlimitClause(ctx);\n-    int slimit;\n-    try {\n-      slimit = Integer.parseInt(ctx.INT().getText());\n-    } catch (NumberFormatException e) {\n-      throw new SQLParserException(\n-          \"Out of range. SLIMIT <SN>: SN should be Int32.\");\n-    }\n-    if (slimit <= 0) {\n-      throw new SQLParserException(\"SLIMIT <SN>: SN should be greater than 0.\");\n-    }\n-    queryOp.setSeriesLimit(slimit);\n-  }\n-\n-  @Override\n-  public void enterSoffsetClause(SoffsetClauseContext ctx) {\n-    super.enterSoffsetClause(ctx);\n-    int soffset;\n-    try {\n-      soffset = Integer.parseInt(ctx.INT().getText());\n-    } catch (NumberFormatException e) {\n-      throw new SQLParserException(\n-          \"Out of range. SOFFSET <SOFFSETValue>: SOFFSETValue should be Int32.\");\n-    }\n-    if (soffset < 0) {\n-      throw new SQLParserException(\n-          \"SOFFSET <SOFFSETValue>: SOFFSETValue should >= 0.\");\n-    }\n-    queryOp.setSeriesOffset(soffset);\n-  }\n-\n-  @Override\n-  public void enterInsertColumnSpec(InsertColumnSpecContext ctx) {\n-    super.enterInsertColumnSpec(ctx);\n-    List<NodeNameWithoutStarContext> nodeNamesWithoutStar = ctx.nodeNameWithoutStar();\n-    List<String> measurementList = new ArrayList<>();\n-    for (NodeNameWithoutStarContext nodeNameWithoutStar : nodeNamesWithoutStar) {\n-      String measurement = nodeNameWithoutStar.getText();\n-      measurementList.add(measurement);\n-    }\n-    insertOp.setMeasurementList(measurementList.toArray(new String[0]));\n-  }\n-\n-  @Override\n-  public void enterInsertValuesSpec(InsertValuesSpecContext ctx) {\n-    super.enterInsertValuesSpec(ctx);\n-    long timestamp;\n-    if (ctx.dateFormat() != null) {\n-      timestamp = parseTimeFormat(ctx.dateFormat().getText());\n-    } else {\n-      timestamp = Long.parseLong(ctx.INT().getText());\n-    }\n-    insertOp.setTime(timestamp);\n-    List<String> valueList = new ArrayList<>();\n-    List<ConstantContext> values = ctx.constant();\n-    for (ConstantContext value : values) {\n-      valueList.add(value.getText());\n-    }\n-    insertOp.setValueList(valueList.toArray(new String[0]));\n-    initializedOperator = insertOp;\n-  }\n-\n-  private PartialPath parseFullPath(FullPathContext ctx) {\n-    List<NodeNameWithoutStarContext> nodeNamesWithoutStar = ctx.nodeNameWithoutStar();\n-    String[] path = new String[nodeNamesWithoutStar.size() + 1];\n-    int i = 0;\n-    if (ctx.ROOT() != null) {\n-      path[0] = ctx.ROOT().getText();\n-    }\n-    for (NodeNameWithoutStarContext nodeNameWithoutStar : nodeNamesWithoutStar) {\n-      i++;\n-      path[i] = nodeNameWithoutStar.getText();\n-    }\n-    return new PartialPath(path);\n-  }\n-\n-  @Override\n-  public void enterAttributeClauses(AttributeClausesContext ctx) {\n-    super.enterAttributeClauses(ctx);\n-    final String dataType = ctx.dataType().getChild(0).getText().toUpperCase();\n-    final TSDataType tsDataType = TSDataType.valueOf(dataType);\n-    createTimeSeriesOperator.setDataType(tsDataType);\n-\n-    final IoTDBDescriptor ioTDBDescriptor = IoTDBDescriptor.getInstance();\n-    TSEncoding encoding = ioTDBDescriptor.getDefualtEncodingByType(tsDataType);\n-    if (Objects.nonNull(ctx.encoding())) {\n-      String encodingString = ctx.encoding().getChild(0).getText().toUpperCase();\n-      encoding = TSEncoding.valueOf(encodingString);\n-    }\n-    createTimeSeriesOperator.setEncoding(encoding);\n-\n-    CompressionType compressor;\n-    List<PropertyContext> properties = ctx.property();\n-    if (ctx.compressor() != null) {\n-      compressor = CompressionType.valueOf(ctx.compressor().getText().toUpperCase());\n-    } else {\n-      compressor = TSFileDescriptor.getInstance().getConfig().getCompressor();\n-    }\n-    Map<String, String> props = null;\n-    if (ctx.property(0) != null) {\n-      props = new HashMap<>(properties.size());\n-      for (PropertyContext property : properties) {\n-        props.put(property.ID().getText().toLowerCase(),\n-            property.propertyValue().getText().toLowerCase());\n-      }\n-    }\n-    createTimeSeriesOperator.setCompressor(compressor);\n-    createTimeSeriesOperator.setProps(props);\n-    initializedOperator = createTimeSeriesOperator;\n-  }\n-\n-  @Override\n-  public void enterAliasClause(SqlBaseParser.AliasClauseContext ctx) {\n-    super.enterAliasClause(ctx);\n-    if (alterTimeSeriesOperator != null && ctx.ID() != null) {\n-      alterTimeSeriesOperator.setAlias(ctx.ID().getText());\n-    }\n-  }\n-\n-\n-  @Override\n-  public void enterAttributeClause(AttributeClauseContext ctx) {\n-    super.enterAttributeClause(ctx);\n-    Map<String, String> attributes = extractMap(ctx.property(), ctx.property(0));\n-    if (createTimeSeriesOperator != null) {\n-      createTimeSeriesOperator.setAttributes(attributes);\n-    } else if (alterTimeSeriesOperator != null) {\n-      alterTimeSeriesOperator.setAttributesMap(attributes);\n-    }\n-  }\n-\n-  @Override\n-  public void enterTagClause(TagClauseContext ctx) {\n-    super.enterTagClause(ctx);\n-    Map<String, String> tags = extractMap(ctx.property(), ctx.property(0));\n-    if (createTimeSeriesOperator != null) {\n-      createTimeSeriesOperator.setTags(tags);\n-    } else if (alterTimeSeriesOperator != null) {\n-      alterTimeSeriesOperator.setTagsMap(tags);\n-    }\n-  }\n-\n-  private Map<String, String> extractMap(List<PropertyContext> property2,\n-      PropertyContext property3) {\n-    String value;\n-    Map<String, String> tags = new HashMap<>(property2.size());\n-    if (property3 != null) {\n-      for (PropertyContext property : property2) {\n-        if (property.propertyValue().stringLiteral() != null) {\n-          value = removeStringQuote(property.propertyValue().getText());\n-        } else {\n-          value = property.propertyValue().getText();\n-        }\n-        tags.put(property.ID().getText(), value);\n-      }\n-    }\n-    return tags;\n-  }\n-\n-  @Override\n-  public void enterInsertStatement(InsertStatementContext ctx) {\n-    super.enterInsertStatement(ctx);\n-    insertOp = new InsertOperator(SQLConstant.TOK_INSERT);\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    operatorType = SQLConstant.TOK_INSERT;\n-    selectOp.addSelectPath(parsePrefixPath(ctx.prefixPath()));\n-    insertOp.setSelectOperator(selectOp);\n-  }\n-\n-  @Override\n-  public void enterUpdateStatement(UpdateStatementContext ctx) {\n-    super.enterUpdateStatement(ctx);\n-    updateOp = new UpdateOperator(SQLConstant.TOK_UPDATE);\n-    FromOperator fromOp = new FromOperator(SQLConstant.TOK_FROM);\n-    fromOp.addPrefixTablePath(parsePrefixPath(ctx.prefixPath()));\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    operatorType = SQLConstant.TOK_UPDATE;\n-    initializedOperator = updateOp;\n-  }\n-\n-  @Override\n-  public void enterSelectStatement(SelectStatementContext ctx) {\n-    super.enterSelectStatement(ctx);\n-    operatorType = SQLConstant.TOK_QUERY;\n-    queryOp = new QueryOperator(SQLConstant.TOK_QUERY);\n-    initializedOperator = queryOp;\n-  }\n-\n-  @Override\n-  public void enterFromClause(FromClauseContext ctx) {\n-    super.enterFromClause(ctx);\n-    FromOperator fromOp = new FromOperator(SQLConstant.TOK_FROM);\n-    List<PrefixPathContext> prefixFromPaths = ctx.prefixPath();\n-    for (PrefixPathContext prefixFromPath : prefixFromPaths) {\n-      PartialPath path = parsePrefixPath(prefixFromPath);\n-      fromOp.addPrefixTablePath(path);\n-    }\n-    queryOp.setFromOperator(fromOp);\n-  }\n-\n-  @Override\n-  public void enterFunctionElement(FunctionElementContext ctx) {\n-    super.enterFunctionElement(ctx);\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    List<FunctionCallContext> functionCallContextList = ctx.functionCall();\n-    for (FunctionCallContext functionCallContext : functionCallContextList) {\n-      PartialPath path = parseSuffixPath(functionCallContext.suffixPath());\n-      selectOp.addClusterPath(path, functionCallContext.functionName().getText());\n-    }\n-    queryOp.setSelectOperator(selectOp);\n-  }\n-\n-  @Override\n-  public void enterSelectElement(SelectElementContext ctx) {\n-    super.enterSelectElement(ctx);\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    List<SqlBaseParser.SuffixPathOrConstantContext> suffixPathOrConstants = ctx.suffixPathOrConstant();\n-    for (SqlBaseParser.SuffixPathOrConstantContext suffixPathOrConstant : suffixPathOrConstants) {\n-      if (suffixPathOrConstant.suffixPath() != null) {\n-        PartialPath path = parseSuffixPath(suffixPathOrConstant.suffixPath());\n-        selectOp.addSelectPath(path);\n-      } else {\n-        PartialPath path = new PartialPath(new String[]{suffixPathOrConstant.SINGLE_QUOTE_STRING_LITERAL().getText()});\n-        selectOp.addSelectPath(path);\n-      }\n-    }\n-    queryOp.setSelectOperator(selectOp);\n-  }\n-\n-  @Override\n-  public void enterLastElement(SqlBaseParser.LastElementContext ctx) {\n-    super.enterLastElement(ctx);\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    selectOp.setLastQuery();\n-    LastClauseContext lastClauseContext = ctx.lastClause();\n-    if (lastClauseContext.asClause().size() != 0) {\n-      parseAsClause(lastClauseContext.asClause());\n-    } else {\n-      List<SuffixPathContext> suffixPaths = lastClauseContext.suffixPath();\n-      for (SuffixPathContext suffixPath : suffixPaths) {\n-        PartialPath path = parseSuffixPath(suffixPath);\n-        selectOp.addSelectPath(path);\n-      }\n-    }\n-    queryOp.setSelectOperator(selectOp);\n-  }\n-\n-  @Override\n-  public void enterAsElement(AsElementContext ctx) {\n-    super.enterAsElement(ctx);\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    parseAsClause(ctx.asClause());\n-    queryOp.setSelectOperator(selectOp);\n-  }\n-\n-  public void parseAsClause(List<AsClauseContext> asClauseContexts) {\n-    for (AsClauseContext asClauseContext : asClauseContexts) {\n-      PartialPath path = parseSuffixPath(asClauseContext.suffixPath());\n-      if (asClauseContext.ID() != null) {\n-        path.setTsAlias(asClauseContext.ID().toString());\n-      }\n-      selectOp.addSelectPath(path);\n-    }\n-  }\n-\n-  @Override\n-  public void enterFunctionAsElement(FunctionAsElementContext ctx) {\n-    super.enterFunctionAsElement(ctx);\n-    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n-    List<FunctionAsClauseContext> functionAsClauseContexts = ctx.functionAsClause();\n-    for (FunctionAsClauseContext functionAsClauseContext : functionAsClauseContexts) {\n-      FunctionCallContext functionCallContext = functionAsClauseContext.functionCall();\n-      PartialPath path = parseSuffixPath(functionCallContext.suffixPath());\n-      if (functionAsClauseContext.ID() != null) {\n-        path.setTsAlias(functionAsClauseContext.ID().toString());\n-      }\n-      selectOp.addClusterPath(path, functionCallContext.functionName().getText());\n-    }\n-    queryOp.setSelectOperator(selectOp);\n-  }\n-\n-  @Override\n-  public void enterSetCol(SetColContext ctx) {\n-    super.enterSetCol(ctx);\n-    selectOp.addSelectPath(parseSuffixPath(ctx.suffixPath()));\n-    updateOp.setSelectOperator(selectOp);\n-    updateOp.setValue(ctx.constant().getText());\n-  }\n-\n-\n-  private PartialPath parsePrefixPath(PrefixPathContext ctx) {\n-    List<NodeNameContext> nodeNames = ctx.nodeName();\n-    String[] path = new String[nodeNames.size() + 1];\n-    path[0] = ctx.ROOT().getText();\n-    for (int i = 0; i < nodeNames.size(); i++) {\n-      path[i + 1] = nodeNames.get(i).getText();\n-    }\n-    return new PartialPath(path);\n-  }\n-\n-  /**\n-   * parse duration to time value.\n-   *\n-   * @param durationStr represent duration string like: 12d8m9ns, 1y1mo, etc.\n-   * @return time in milliseconds, microseconds, or nanoseconds depending on the profile\n-   */\n-  private Long parseDuration(String durationStr) {\n-    String timestampPrecision = IoTDBDescriptor.getInstance().getConfig().getTimestampPrecision();\n-\n-    long total = 0;\n-    long tmp = 0;\n-    for (int i = 0; i < durationStr.length(); i++) {\n-      char ch = durationStr.charAt(i);\n-      if (Character.isDigit(ch)) {\n-        tmp *= 10;\n-        tmp += (ch - '0');\n-      } else {\n-        String unit = durationStr.charAt(i) + \"\";\n-        // This is to identify units with two letters.\n-        if (i + 1 < durationStr.length() && !Character.isDigit(durationStr.charAt(i + 1))) {\n-          i++;\n-          unit += durationStr.charAt(i);\n-        }\n-        if (unit.toLowerCase().equals(\"mo\")) {\n-          //interval is by month, sliding step by default equals to interval\n-          if (!isParsingSlidingStep) {\n-            queryOp.setIntervalByMonth(true);\n-          }\n-          queryOp.setSlidingStepByMonth(true);\n-        } else if (isParsingSlidingStep) {\n-          //parsing sliding step value, and unit is not by month\n-          queryOp.setSlidingStepByMonth(false);\n-        }\n-        total += DatetimeUtils\n-            .convertDurationStrToLong(tmp, unit.toLowerCase(), timestampPrecision);\n-        tmp = 0;\n-      }\n-    }\n-    if (total <= 0) {\n-      throw new SQLParserException(\"Interval must more than 0.\");\n-    }\n-    return total;\n-  }\n-\n-  @Override\n-  public void enterWhereClause(WhereClauseContext ctx) {\n-    super.enterWhereClause(ctx);\n-    FilterOperator whereOp = new FilterOperator(SQLConstant.TOK_WHERE);\n-    whereOp.addChildOperator(parseOrExpression(ctx.orExpression()));\n-    switch (operatorType) {\n-      case SQLConstant.TOK_DELETE:\n-        deleteDataOp.setFilterOperator(whereOp.getChildren().get(0));\n-        Pair<Long, Long> timeInterval = parseDeleteTimeInterval(deleteDataOp);\n-        deleteDataOp.setStartTime(timeInterval.left);\n-        deleteDataOp.setEndTime(timeInterval.right);\n-        break;\n-      case SQLConstant.TOK_QUERY:\n-        queryOp.setFilterOperator(whereOp.getChildren().get(0));\n-        break;\n-      case SQLConstant.TOK_UPDATE:\n-        updateOp.setFilterOperator(whereOp.getChildren().get(0));\n-        break;\n-      default:\n-        throw new SQLParserException(\"Where only support select, delete, update.\");\n-    }\n-  }\n-\n-  @Override\n-  public void enterShowWhereClause(ShowWhereClauseContext ctx) {\n-    super.enterShowWhereClause(ctx);\n-\n-    ShowTimeSeriesOperator operator = (ShowTimeSeriesOperator) initializedOperator;\n-    PropertyValueContext propertyValueContext;\n-    if (ctx.containsExpression() != null) {\n-      operator.setContains(true);\n-      propertyValueContext = ctx.containsExpression().propertyValue();\n-      operator.setKey(ctx.containsExpression().ID().getText());\n-    } else {\n-      operator.setContains(false);\n-      propertyValueContext = ctx.property().propertyValue();\n-      operator.setKey(ctx.property().ID().getText());\n-    }\n-    String value;\n-    if (propertyValueContext.stringLiteral() != null) {\n-      value = removeStringQuote(propertyValueContext.getText());\n-    } else {\n-      value = propertyValueContext.getText();\n-    }\n-    operator.setValue(value);\n-  }\n-\n-  private FilterOperator parseOrExpression(OrExpressionContext ctx) {\n-    if (ctx.andExpression().size() == 1) {\n-      return parseAndExpression(ctx.andExpression(0));\n-    }\n-    FilterOperator binaryOp = new FilterOperator(SQLConstant.KW_OR);\n-    if (ctx.andExpression().size() > 2) {\n-      binaryOp.addChildOperator(parseAndExpression(ctx.andExpression(0)));\n-      binaryOp.addChildOperator(parseAndExpression(ctx.andExpression(1)));\n-      for (int i = 2; i < ctx.andExpression().size(); i++) {\n-        FilterOperator op = new FilterOperator(SQLConstant.KW_OR);\n-        op.addChildOperator(binaryOp);\n-        op.addChildOperator(parseAndExpression(ctx.andExpression(i)));\n-        binaryOp = op;\n-      }\n-    } else {\n-      for (AndExpressionContext andExpressionContext : ctx.andExpression()) {\n-        binaryOp.addChildOperator(parseAndExpression(andExpressionContext));\n-      }\n-    }\n-    return binaryOp;\n-  }\n-\n-  private FilterOperator parseAndExpression(AndExpressionContext ctx) {\n-    if (ctx.predicate().size() == 1) {\n-      return parsePredicate(ctx.predicate(0));\n-    }\n-    FilterOperator binaryOp = new FilterOperator(SQLConstant.KW_AND);\n-    int size = ctx.predicate().size();\n-    if (size > 2) {\n-      binaryOp.addChildOperator(parsePredicate(ctx.predicate(0)));\n-      binaryOp.addChildOperator(parsePredicate(ctx.predicate(1)));\n-      for (int i = 2; i < size; i++) {\n-        FilterOperator op = new FilterOperator(SQLConstant.KW_AND);\n-        op.addChildOperator(binaryOp);\n-        op.addChildOperator(parsePredicate(ctx.predicate(i)));\n-        binaryOp = op;\n-      }\n-    } else {\n-      for (PredicateContext predicateContext : ctx.predicate()) {\n-        binaryOp.addChildOperator(parsePredicate(predicateContext));\n-      }\n-    }\n-    return binaryOp;\n-  }\n-\n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  private FilterOperator parsePredicate(PredicateContext ctx) {\n-    if (ctx.OPERATOR_NOT() != null) {\n-      FilterOperator notOp = new FilterOperator(SQLConstant.KW_NOT);\n-      notOp.addChildOperator(parseOrExpression(ctx.orExpression()));\n-      return notOp;\n-    } else if (ctx.LR_BRACKET() != null && ctx.OPERATOR_NOT() == null) {\n-      return parseOrExpression(ctx.orExpression());\n-    } else {\n-      PartialPath path = null;\n-      if (ctx.TIME() != null || ctx.TIMESTAMP() != null) {\n-        path = new PartialPath(SQLConstant.getSingleTimeArray());\n-      }\n-      if (ctx.fullPath() != null) {\n-        path = parseFullPath(ctx.fullPath());\n-      }\n-      if (ctx.suffixPath() != null) {\n-        path = parseSuffixPath(ctx.suffixPath());\n-      }\n-      if (path == null) {\n-        throw new SQLParserException(\"Path is null, please check the sql.\");\n-      }\n-      if (ctx.inClause() != null) {\n-        return parseInOperator(ctx.inClause(), path);\n-      } else {\n-        return parseBasicFunctionOperator(ctx, path);\n-      }\n-    }\n-  }\n-\n-  private FilterOperator parseInOperator(InClauseContext ctx, PartialPath path) {\n-    Set<String> values = new HashSet<>();\n-    boolean not = ctx.OPERATOR_NOT() != null;\n-    for (ConstantContext constant : ctx.constant()) {\n-      if (constant.dateExpression() != null) {\n-        if (!path.equals(TIME_PATH)) {\n-          throw new SQLParserException(path.getFullPath(), \"Date can only be used to time\");\n-        }\n-        values.add(Long.toString(parseDateExpression(constant.dateExpression())));\n-      } else {\n-        values.add(constant.getText());\n-      }\n-    }\n-    return new InOperator(ctx.OPERATOR_IN().getSymbol().getType(), path, not, values);\n-  }\n-\n-  private FilterOperator parseBasicFunctionOperator(PredicateContext ctx, PartialPath path) {\n-    BasicFunctionOperator basic;\n-    if (ctx.constant().dateExpression() != null) {\n-      if (!path.equals(TIME_PATH)) {\n-        throw new SQLParserException(path.getFullPath(), \"Date can only be used to time\");\n-      }\n-      basic = new BasicFunctionOperator(ctx.comparisonOperator().type.getType(), path,\n-          Long.toString(parseDateExpression(ctx.constant().dateExpression())));\n-    } else {\n-      basic = new BasicFunctionOperator(ctx.comparisonOperator().type.getType(), path,\n-          ctx.constant().getText());\n-    }\n-    return basic;\n-  }\n-\n-  private PartialPath parseSuffixPath(SuffixPathContext ctx) {\n-    List<NodeNameContext> nodeNames = ctx.nodeName();\n-    String[] path = new String[nodeNames.size()];\n-    for (int i = 0; i < nodeNames.size(); i++) {\n-      path[i] = nodeNames.get(i).getText();\n-    }\n-    return new PartialPath(path);\n-  }\n-\n-  /**\n-   * parse time expression, which is addition and subtraction expression of duration time, now() or\n-   * DataTimeFormat time. <p> eg. now() + 1d - 2h </p>\n-   */\n-  private Long parseDateExpression(DateExpressionContext ctx) {\n-    long time;\n-    time = parseTimeFormat(ctx.getChild(0).getText());\n-    for (int i = 1; i < ctx.getChildCount(); i = i + 2) {\n-      if (ctx.getChild(i).getText().equals(\"+\")) {\n-        time += parseDuration(ctx.getChild(i + 1).getText());\n-      } else {\n-        time -= parseDuration(ctx.getChild(i + 1).getText());\n-      }\n-    }\n-    return time;\n-  }\n-\n-  /**\n-   * function for parsing time format.\n-   */\n-  long parseTimeFormat(String timestampStr) throws SQLParserException {\n-    if (timestampStr == null || timestampStr.trim().equals(\"\")) {\n-      throw new SQLParserException(\"input timestamp cannot be empty\");\n-    }\n-    long startupNano = IoTDBDescriptor.getInstance().getConfig().getStartUpNanosecond();\n-    if (timestampStr.equalsIgnoreCase(SQLConstant.NOW_FUNC)) {\n-      String timePrecision = IoTDBDescriptor.getInstance().getConfig().getTimestampPrecision();\n-      switch (timePrecision) {\n-        case \"ns\":\n-          return System.currentTimeMillis() * 1000_000\n-              + (System.nanoTime() - startupNano) % 1000_000;\n-        case \"us\":\n-          return System.currentTimeMillis() * 1000\n-              + (System.nanoTime() - startupNano) / 1000 % 1000;\n-        default:\n-          return System.currentTimeMillis();\n-      }\n-    }\n+public class LogicalGenerator {\n+\n+  public LogicalGenerator() { }\n+\n+  public Operator generate(String sql, ZoneId zoneId) throws ParseCancellationException {\n+    IoTDBSqlVisitor ioTDBSqlVisitor = new IoTDBSqlVisitor();\n+    ioTDBSqlVisitor.setZoneId(zoneId);\n+    CharStream charStream1 = CharStreams.fromString(sql);\n+    SqlBaseLexer lexer1 = new SqlBaseLexer(charStream1);\n+    CommonTokenStream tokens1 = new CommonTokenStream(lexer1);\n+    SqlBaseParser parser1 = new SqlBaseParser(tokens1);\n+    parser1.getInterpreter().setPredictionMode(PredictionMode.SLL);\n+    parser1.removeErrorListeners();\n+    parser1.addErrorListener(SQLParseError.INSTANCE);\n+    ParseTree tree;\n     try {\n-      return DatetimeUtils.convertDatetimeStrToLong(timestampStr, zoneId);\n-    } catch (Exception e) {\n-      throw new SQLParserException(String\n-          .format(\"Input time format %s error. \"\n-              + \"Input like yyyy-MM-dd HH:mm:ss, yyyy-MM-ddTHH:mm:ss or \"\n-              + \"refer to user document for more info.\", timestampStr));\n-    }\n-  }\n-\n-  /**\n-   * for delete command, time should only have an end time.\n-   *\n-   * @param operator delete logical plan\n-   */\n-  private Pair<Long, Long> parseDeleteTimeInterval(DeleteDataOperator operator) {\n-    FilterOperator filterOperator = operator.getFilterOperator();\n-    if (!filterOperator.isLeaf() && filterOperator.getTokenIntType() != SQLConstant.KW_AND) {\n-      throw new SQLParserException(\n-          DELETE_RANGE_ERROR_MSG);\n-    }\n-\n-    if (filterOperator.isLeaf()) {\n-      return calcOperatorInterval(filterOperator);\n-    }\n-\n-    List<FilterOperator> children = filterOperator.getChildren();\n-    FilterOperator lOperator = children.get(0);\n-    FilterOperator rOperator = children.get(1);\n-    if (!lOperator.isLeaf() || !rOperator.isLeaf()) {\n-      throw new SQLParserException(\n-          DELETE_RANGE_ERROR_MSG);\n-    }\n-\n-    Pair<Long, Long> leftOpInterval = calcOperatorInterval(lOperator);\n-    Pair<Long, Long> rightOpInterval = calcOperatorInterval(rOperator);\n-    Pair<Long, Long> parsedInterval = new Pair<>(\n-        Math.max(leftOpInterval.left, rightOpInterval.left),\n-        Math.min(leftOpInterval.right, rightOpInterval.right));\n-    if (parsedInterval.left > parsedInterval.right) {\n-      throw new SQLParserException(\n-          \"Invalid delete range: [\" + parsedInterval.left + \", \" + parsedInterval.right + \"]\");\n-    }\n-    return parsedInterval;\n-  }\n-\n-  private Pair<Long, Long> calcOperatorInterval(FilterOperator filterOperator) {\n-    long time = Long.parseLong(((BasicFunctionOperator) filterOperator).getValue());\n-    switch (filterOperator.getTokenIntType()) {\n-      case SQLConstant.LESSTHAN:\n-        return new Pair<>(Long.MIN_VALUE, time - 1);\n-      case SQLConstant.LESSTHANOREQUALTO:\n-        return new Pair<>(Long.MIN_VALUE, time);\n-      case SQLConstant.GREATERTHAN:\n-        return new Pair<>(time + 1, Long.MAX_VALUE);\n-      case SQLConstant.GREATERTHANOREQUALTO:\n-        return new Pair<>(time, Long.MAX_VALUE);\n-      case SQLConstant.EQUAL:\n-        return new Pair<>(time, time);\n-      default:\n-        throw new SQLParserException(\n-            DELETE_RANGE_ERROR_MSG);\n-    }\n-  }\n-\n-  @Override\n-  public void enterShowMergeStatus(ShowMergeStatusContext ctx) {\n-    super.enterShowMergeStatus(ctx);\n-    initializedOperator = new ShowMergeStatusOperator(SQLConstant.TOK_SHOW_MERGE_STATUS);\n-  }\n-\n-  @Override\n-  public void enterDeletePartition(DeletePartitionContext ctx) {\n-    super.enterDeletePartition(ctx);\n-    DeletePartitionOperator deletePartitionOperator = new DeletePartitionOperator(\n-        SQLConstant.TOK_DELETE_PARTITION);\n-    deletePartitionOperator.setStorageGroupName(parsePrefixPath(ctx.prefixPath()));\n-    Set<Long> idSet = new HashSet<>();\n-    for (TerminalNode terminalNode : ctx.INT()) {\n-      idSet.add(Long.parseLong(terminalNode.getText()));\n-    }\n-    deletePartitionOperator.setPartitionIds(idSet);\n-    initializedOperator = deletePartitionOperator;\n-  }\n-\n-  @Override\n-  public void enterCreateSnapshot(CreateSnapshotContext ctx) {\n-    super.enterCreateSnapshot(ctx);\n-    initializedOperator = new CreateSnapshotOperator(SQLConstant.TOK_CREATE_SCHEMA_SNAPSHOT);\n+      tree = parser1.singleStatement();  // STAGE 1\n+    }\n+    catch (Exception ex) {\n+      CharStream charStream2 = CharStreams.fromString(sql);\n+      SqlBaseLexer lexer2 = new SqlBaseLexer(charStream2);\n+      CommonTokenStream tokens2 = new CommonTokenStream(lexer2);\n+      SqlBaseParser parser2 = new SqlBaseParser(tokens2);\n+      parser2.getInterpreter().setPredictionMode(PredictionMode.LL);\n+      parser2.removeErrorListeners();\n+      parser2.addErrorListener(SQLParseError.INSTANCE);\n+      tree = parser2.singleStatement();  // STAGE 2\n+      // if we parse ok, it's LL not SLL\n+    }\n+    return ioTDBSqlVisitor.visit(tree);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxNjI3OQ==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r526716279", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final long msToMonth = 30 * 86400_000L;\n          \n          \n            \n              private static final long MS_T0_MONTH = 30 * 86400_000L;", "author": "JackieTien97", "createdAt": "2020-11-19T09:33:50Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java", "diffHunk": "@@ -43,6 +45,10 @@\n   protected boolean hasCachedTimeInterval;\n \n   protected boolean leftCRightO;\n+  private boolean isIntervalByMonth = false;\n+  private boolean isSlidingStepByMonth = false;\n+  protected int intervalTimes;\n+  private final long msToMonth = 30 * 86400_000L;", "originalCommit": "faa9a275de22d1eacb3e6a96662558d1d76c67c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5MDY5Mg==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r527490692", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final long msToMonth = 30 * 86400_000L;\n          \n          \n            \n              private static final long MS_TO_MONTH = 30 * 86400_000L;\n          \n      \n    \n    \n  \n\n\ud83d\ude02", "author": "HTHou", "createdAt": "2020-11-20T07:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxNjI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a828c187672f4da233949e64e3f98fe4603b5c2d", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\nindex 9c96c73278..242d534a48 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n\n@@ -48,7 +48,7 @@ public abstract class GroupByEngineDataSet extends QueryDataSet {\n   private boolean isIntervalByMonth = false;\n   private boolean isSlidingStepByMonth = false;\n   protected int intervalTimes;\n-  private final long msToMonth = 30 * 86400_000L;\n+  private static final long MS_TO_MONTH = 30 * 86400_000L;\n \n   public GroupByEngineDataSet() {\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczMzc2Nw==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r526733767", "bodyText": "I think you can directly return the calendar.getTimeInMillis() instead of the delta to curStartTime, because it seems that you still add the curStartTime each time you call the calcIntervalByMonth function.\nAnd in this function, it's better to use calendar.setTimeInMillis(curStartTime); instead of startTime, if so the attribute intervalTimes can be deleted.", "author": "JackieTien97", "createdAt": "2020-11-19T09:59:15Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java", "diffHunk": "@@ -70,36 +78,72 @@ public GroupByEngineDataSet(QueryContext context, GroupByTimePlan groupByTimePla\n       long intervalNum = (long) Math.ceil(queryRange / (double) slidingStep);\n       curStartTime = slidingStep * (intervalNum - 1) + startTime;\n     }\n-    curEndTime = Math.min(curStartTime + interval, endTime);\n+\n+\n+    if (isIntervalByMonth) {\n+      //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n+      //now converting them back to integer months\n+      interval = interval / msToMonth;\n+      //calculate interval length by natural month based on curStartTime\n+      //ie. startTIme = 1/31, interval = 1mo, curEndTime will be set to 2/29\n+      curEndTime = Math.min(curStartTime + calcIntervalByMonth(interval, curStartTime), endTime);\n+    } else {\n+      curEndTime = Math.min(curStartTime + interval, endTime);\n+    }\n+    if (isSlidingStepByMonth) {\n+      slidingStep = slidingStep / msToMonth;\n+    }\n     this.hasCachedTimeInterval = true;\n   }\n \n   @Override\n   protected boolean hasNextWithoutConstraint() {\n+    long curSlidingStep = slidingStep;\n+    long curInterval = interval;\n     // has cached\n     if (hasCachedTimeInterval) {\n       return true;\n     }\n \n+    intervalTimes++;\n+    //group by natural month, given startTime recalculate interval and sliding step\n+    if (isIntervalByMonth) {\n+      curInterval = calcIntervalByMonth(intervalTimes * slidingStep + interval, startTime);\n+    }\n+    if (isSlidingStepByMonth) {\n+      curSlidingStep = calcIntervalByMonth(slidingStep * intervalTimes, curStartTime);\n+    }\n+\n     // check if the next interval out of range\n     if (ascending) {\n-      curStartTime += slidingStep;\n+      curStartTime += curSlidingStep;\n       //This is an open interval , [0-100)\n       if (curStartTime >= endTime) {\n         return false;\n       }\n     } else {\n-      curStartTime -= slidingStep;\n+      curStartTime -= curSlidingStep;\n       if (curStartTime < startTime) {\n         return false;\n       }\n     }\n \n     hasCachedTimeInterval = true;\n-    curEndTime = Math.min(curStartTime + interval, endTime);\n+    if (isIntervalByMonth) {\n+      curEndTime = Math.min(startTime + curInterval, endTime);\n+    } else {\n+      curEndTime = Math.min(curStartTime + curInterval, endTime);\n+    }\n     return true;\n   }\n \n+  public long calcIntervalByMonth(long numMonths, long curStartTime) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(startTime);\n+    calendar.add(Calendar.MONTH, (int) (numMonths));\n+    return calendar.getTimeInMillis() - curStartTime;\n+  }\n+", "originalCommit": "faa9a275de22d1eacb3e6a96662558d1d76c67c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUzNTMyNA==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r528535324", "bodyText": "Hi, the calendar is set to the original startTime and uses intervalTImes to calendar.add() in case of dates = 29, 30, 31\nie.\nwhen add one month to 1/31, curStartTime increments to 2/29\nif then set calendar to curStartTime = 2/29, then increments one month, we get curStartTime = 3/29, which is not what we intended. What we want is 1/31, 2/29, 3/30, 4/31 ....\nso I used intervalTimes each time calculating the interval and set calendar to original startTime and add intervalTimes months to startTime to avoid edge cases.", "author": "haimeiguo", "createdAt": "2020-11-23T08:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczMzc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a828c187672f4da233949e64e3f98fe4603b5c2d", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\nindex 9c96c73278..242d534a48 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n\n@@ -76,23 +80,26 @@ public abstract class GroupByEngineDataSet extends QueryDataSet {\n       long queryRange = endTime - startTime;\n       // calculate the total interval number\n       long intervalNum = (long) Math.ceil(queryRange / (double) slidingStep);\n-      curStartTime = slidingStep * (intervalNum - 1) + startTime;\n+      if (isSlidingStepByMonth) {\n+        intervalTimes = (int) intervalNum - 1;\n+        curStartTime = startTime + calcIntervalByMonth(intervalTimes * slidingStep / MS_TO_MONTH, startTime);\n+      } else {\n+        curStartTime = slidingStep * (intervalNum - 1) + startTime;\n+      }\n     }\n \n+    if (isSlidingStepByMonth) {\n+      slidingStep = slidingStep / MS_TO_MONTH;\n+    }\n \n     if (isIntervalByMonth) {\n-      //if is group by months interval and sliding step are calculated in ms by * 30 * 86400_000L\n-      //now converting them back to integer months\n-      interval = interval / msToMonth;\n       //calculate interval length by natural month based on curStartTime\n       //ie. startTIme = 1/31, interval = 1mo, curEndTime will be set to 2/29\n-      curEndTime = Math.min(curStartTime + calcIntervalByMonth(interval, curStartTime), endTime);\n+      curEndTime = Math.min(startTime + calcIntervalByMonth(interval + slidingStep * intervalTimes, startTime), endTime);\n     } else {\n       curEndTime = Math.min(curStartTime + interval, endTime);\n     }\n-    if (isSlidingStepByMonth) {\n-      slidingStep = slidingStep / msToMonth;\n-    }\n+\n     this.hasCachedTimeInterval = true;\n   }\n \n"}}, {"oid": "a828c187672f4da233949e64e3f98fe4603b5c2d", "url": "https://github.com/apache/iotdb/commit/a828c187672f4da233949e64e3f98fe4603b5c2d", "message": "group by descending", "committedDate": "2020-11-27T03:47:33Z", "type": "forcePushed"}, {"oid": "b010445a9fdd263d8869d24de2e3f8e2b512ce4b", "url": "https://github.com/apache/iotdb/commit/b010445a9fdd263d8869d24de2e3f8e2b512ce4b", "message": "group by descending", "committedDate": "2020-11-27T08:04:12Z", "type": "forcePushed"}, {"oid": "6794be549cb49095c9149e688b4ef56c1e29fe21", "url": "https://github.com/apache/iotdb/commit/6794be549cb49095c9149e688b4ef56c1e29fe21", "message": "user guide aggregation by month", "committedDate": "2020-12-08T06:59:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA5Nzk5NQ==", "url": "https://github.com/apache/iotdb/pull/2029#discussion_r538097995", "bodyText": "I just wonder how to set the curStartTime... pls add a Javadoc for this function and the intervalTimes", "author": "qiaojialin", "createdAt": "2020-12-08T07:32:13Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java", "diffHunk": "@@ -68,38 +80,81 @@ public GroupByEngineDataSet(QueryContext context, GroupByTimePlan groupByTimePla\n       long queryRange = endTime - startTime;\n       // calculate the total interval number\n       long intervalNum = (long) Math.ceil(queryRange / (double) slidingStep);\n-      curStartTime = slidingStep * (intervalNum - 1) + startTime;\n+      if (isSlidingStepByMonth) {\n+        intervalTimes = (int) intervalNum - 1;\n+        curStartTime = startTime + calcIntervalByMonth(intervalTimes * slidingStep / MS_TO_MONTH, startTime);\n+      } else {\n+        curStartTime = slidingStep * (intervalNum - 1) + startTime;\n+      }\n+    }\n+\n+    if (isSlidingStepByMonth) {\n+      slidingStep = slidingStep / MS_TO_MONTH;\n+    }\n+\n+    if (isIntervalByMonth) {\n+      //calculate interval length by natural month based on curStartTime\n+      //ie. startTIme = 1/31, interval = 1mo, curEndTime will be set to 2/29\n+      curEndTime = Math.min(startTime + calcIntervalByMonth(interval + slidingStep * intervalTimes, startTime), endTime);\n+    } else {\n+      curEndTime = Math.min(curStartTime + interval, endTime);\n     }\n-    curEndTime = Math.min(curStartTime + interval, endTime);\n+\n     this.hasCachedTimeInterval = true;\n   }\n \n   @Override\n   protected boolean hasNextWithoutConstraint() {\n+    long curSlidingStep = slidingStep;\n+    long curInterval = interval;\n     // has cached\n     if (hasCachedTimeInterval) {\n       return true;\n     }\n \n+    intervalTimes += ascending ? 1 : -1;\n+    //group by natural month, given startTime recalculate interval and sliding step\n+    if (isIntervalByMonth) {\n+      curInterval = calcIntervalByMonth(intervalTimes * slidingStep + interval, startTime);\n+    }\n+    if (isSlidingStepByMonth) {\n+      curSlidingStep = calcIntervalByMonth(slidingStep * intervalTimes, curStartTime);\n+    }\n+\n     // check if the next interval out of range\n     if (ascending) {\n-      curStartTime += slidingStep;\n+      curStartTime += curSlidingStep;\n       //This is an open interval , [0-100)\n       if (curStartTime >= endTime) {\n         return false;\n       }\n     } else {\n-      curStartTime -= slidingStep;\n+      if (isSlidingStepByMonth) {\n+        curStartTime = startTime + calcIntervalByMonth(slidingStep * intervalTimes, startTime);\n+      } else {\n+        curStartTime -= curSlidingStep;\n+      }\n       if (curStartTime < startTime) {\n         return false;\n       }\n     }\n \n     hasCachedTimeInterval = true;\n-    curEndTime = Math.min(curStartTime + interval, endTime);\n+    if (isIntervalByMonth) {\n+      curEndTime = Math.min(startTime + curInterval, endTime);\n+    } else {\n+      curEndTime = Math.min(curStartTime + curInterval, endTime);\n+    }\n     return true;\n   }\n \n+  public long calcIntervalByMonth(long numMonths, long curStartTime) {", "originalCommit": "6794be549cb49095c9149e688b4ef56c1e29fe21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "884445b1691e1433089c04af0c456236ebcfb6ae", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\nindex 242d534a48..1919540fd7 100644\n--- a/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n+++ b/server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByEngineDataSet.java\n\n@@ -66,40 +70,26 @@ public abstract class GroupByEngineDataSet extends QueryDataSet {\n     this.endTime = groupByTimePlan.getEndTime();\n     this.leftCRightO = groupByTimePlan.isLeftCRightO();\n     this.ascending = groupByTimePlan.isAscending();\n-    this.isIntervalByMonth = groupByTimePlan.isIntervalByMonth();\n-    this.isSlidingStepByMonth = groupByTimePlan.isSlidingStepByMonth();\n+    this.isGroupByMonth = groupByTimePlan.isGroupByMonth();\n \n-    if (isIntervalByMonth) {\n-      interval = interval / MS_TO_MONTH;\n-    }\n-\n-    // find the startTime of the first aggregation interval\n     if (ascending) {\n       curStartTime = startTime;\n     } else {\n       long queryRange = endTime - startTime;\n       // calculate the total interval number\n       long intervalNum = (long) Math.ceil(queryRange / (double) slidingStep);\n-      if (isSlidingStepByMonth) {\n-        intervalTimes = (int) intervalNum - 1;\n-        curStartTime = startTime + calcIntervalByMonth(intervalTimes * slidingStep / MS_TO_MONTH, startTime);\n-      } else {\n-        curStartTime = slidingStep * (intervalNum - 1) + startTime;\n-      }\n-    }\n-\n-    if (isSlidingStepByMonth) {\n-      slidingStep = slidingStep / MS_TO_MONTH;\n+      curStartTime = slidingStep * (intervalNum - 1) + startTime;\n     }\n \n-    if (isIntervalByMonth) {\n-      //calculate interval length by natural month based on curStartTime\n-      //ie. startTIme = 1/31, interval = 1mo, curEndTime will be set to 2/29\n-      curEndTime = Math.min(startTime + calcIntervalByMonth(interval + slidingStep * intervalTimes, startTime), endTime);\n+    if (isGroupByMonth) {\n+      //interval and sliding step are calculated in ms by * 30 * 86400_000L by default\n+      //now converting them back to months\n+      interval = interval / 30 / 86400_000L;\n+      slidingStep = slidingStep / 30 / 86400_000L;\n+      curEndTime = Math.min(curStartTime + calcIntervalByMonth(interval, curStartTime), endTime);\n     } else {\n       curEndTime = Math.min(curStartTime + interval, endTime);\n     }\n-\n     this.hasCachedTimeInterval = true;\n   }\n \n"}}, {"oid": "884445b1691e1433089c04af0c456236ebcfb6ae", "url": "https://github.com/apache/iotdb/commit/884445b1691e1433089c04af0c456236ebcfb6ae", "message": "group by natural month", "committedDate": "2020-12-14T07:18:54Z", "type": "commit"}, {"oid": "d624ee8e96d1f785b58057c3b2fed55c96f89f8b", "url": "https://github.com/apache/iotdb/commit/d624ee8e96d1f785b58057c3b2fed55c96f89f8b", "message": "edit sql reference doc", "committedDate": "2020-12-14T07:18:55Z", "type": "commit"}, {"oid": "f37bcd8038b7efdab11e64b56386a1711341dcf3", "url": "https://github.com/apache/iotdb/commit/f37bcd8038b7efdab11e64b56386a1711341dcf3", "message": "group by descending", "committedDate": "2020-12-14T07:20:37Z", "type": "commit"}, {"oid": "33efa4a98bad9fe2b8248edc445920ee210b97a1", "url": "https://github.com/apache/iotdb/commit/33efa4a98bad9fe2b8248edc445920ee210b97a1", "message": "user guide aggregation by month", "committedDate": "2020-12-14T07:20:42Z", "type": "commit"}, {"oid": "f6b24236d32b359df3fb88a9650123dbe54c929c", "url": "https://github.com/apache/iotdb/commit/f6b24236d32b359df3fb88a9650123dbe54c929c", "message": "calc interval, docs", "committedDate": "2020-12-14T07:41:42Z", "type": "forcePushed"}, {"oid": "3d4bf59a03c69601311dea1ea1a6e96ecdbc3f84", "url": "https://github.com/apache/iotdb/commit/3d4bf59a03c69601311dea1ea1a6e96ecdbc3f84", "message": "calc interval, docs", "committedDate": "2020-12-14T07:45:52Z", "type": "forcePushed"}, {"oid": "9f4f3de724850f746a586c173ef329b83bddc9ca", "url": "https://github.com/apache/iotdb/commit/9f4f3de724850f746a586c173ef329b83bddc9ca", "message": "calc interval, docs", "committedDate": "2020-12-14T07:47:36Z", "type": "commit"}, {"oid": "9f4f3de724850f746a586c173ef329b83bddc9ca", "url": "https://github.com/apache/iotdb/commit/9f4f3de724850f746a586c173ef329b83bddc9ca", "message": "calc interval, docs", "committedDate": "2020-12-14T07:47:36Z", "type": "forcePushed"}]}