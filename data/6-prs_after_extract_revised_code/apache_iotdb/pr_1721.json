{"pr_number": 1721, "pr_title": "[IOTDB-868] fix comma bug for mlog", "pr_createdAt": "2020-09-10T09:01:12Z", "pr_url": "https://github.com/apache/iotdb/pull/1721", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxODkyMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486718923", "bodyText": "It seems that this method is only used in tests, maybe we could add comments", "author": "samperson1997", "createdAt": "2020-09-11T01:22:06Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -41,13 +42,26 @@\n   private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private long forcePeriodInMs = 0;\n \n-  public LogWriter(String logFilePath) {\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjEwOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736109", "bodyText": "Yes, I will add some comments.", "author": "mychaow", "createdAt": "2020-09-11T02:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxODkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex c7f6f82650..2c1f0847c6 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n\n@@ -44,6 +44,12 @@ public class LogWriter implements ILogWriter {\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n   private long forcePeriodInMs = 0;\n \n+  /**\n+   * only used by tests\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMTIwOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486721209", "bodyText": "true if and only if the file or directory is successfully deleted\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (oldMLogFile.delete()) {\n          \n          \n            \n                  if (!oldMLogFile.delete()) {", "author": "samperson1997", "createdAt": "2020-09-11T01:30:44Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -203,6 +203,13 @@ public void checkConfig() throws IOException {\n       }\n       // rename tmpLogFile to mlog\n       FileUtils.moveFile(tmpMLogFile, mlogFile);\n+\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);\n+\n+      if (oldMLogFile.delete()) {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjQwMA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736400", "bodyText": "yes, thank you for pointing this out.", "author": "mychaow", "createdAt": "2020-09-11T02:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMTIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex ea83824b55..23b680251b 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n\n@@ -186,66 +186,34 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // need to upgrade from 0.9 to 0.10\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      checkUnClosedTsFileV1();\n-      MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-      upgradePropertiesFile();\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n+    // upgrade from mlog.txt to mlog.bin\n+    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n+    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_OLD_LOG);\n+    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n+      + \".tmp\");\n \n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n+    if (!oldMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n     }\n-    checkProperties();\n-  }\n \n-  /**\n-   * upgrade 0.9 properties to 0.10 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n+    if (!tmpMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n     }\n \n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+    // move mlog.bin.tmp to mlog.bin\n+    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_LOG);\n+    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+      + \".tmp\");\n+    // rename tmpLogFile to mlog\n+    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+    checkProperties();\n   }\n \n-\n   /**\n    * repair 0.10 properties\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzE0NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486723145", "bodyText": "Could we catch FileNotFoundException here so that we won't throw it to other classes?", "author": "samperson1997", "createdAt": "2020-09-11T01:38:30Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -41,13 +42,26 @@\n   private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private long forcePeriodInMs = 0;\n \n-  public LogWriter(String logFilePath) {\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }\n \n-  public LogWriter(File logFile) {\n+  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjkzOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736939", "bodyText": "I think we should throw the exception for it's not normal, because fileoutputstream could create it if not exist.", "author": "mychaow", "createdAt": "2020-09-11T02:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex c7f6f82650..2c1f0847c6 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n\n@@ -44,6 +44,12 @@ public class LogWriter implements ILogWriter {\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n   private long forcePeriodInMs = 0;\n \n+  /**\n+   * only used by tests\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzcyOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486723729", "bodyText": "Replace if statement with switch statement", "author": "samperson1997", "createdAt": "2020-09-11T01:40:36Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java", "diffHunk": "@@ -156,4 +178,20 @@ private void checkShowTimeseries(Statement statement) throws SQLException {\n       Assert.assertEquals(8, cnt);\n     }\n   }\n+\n+  private PhysicalPlan convertFromString(String str) {\n+    String[] words = str.split(\",\");\n+    if (words[0].equals(\"2\")) {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzAxNg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737016", "bodyText": "ok, thanks!", "author": "mychaow", "createdAt": "2020-09-11T02:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 0bde3e92f8..d024346626 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n\n@@ -181,15 +178,16 @@ public class IoTDBCreateSnapshotIT {\n \n   private PhysicalPlan convertFromString(String str) {\n     String[] words = str.split(\",\");\n-    if (words[0].equals(\"2\")) {\n-      return new MeasurementNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n+    switch (words[0]) {\n+      case \"2\":\n+      return new MeasurementMNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n         Integer.parseInt(words[words.length - 1]),\n         new MeasurementSchema(words[1], TSDataType.values()[Integer.parseInt(words[3])],\n           TSEncoding.values()[Integer.parseInt(words[4])], CompressionType.values()[Integer.parseInt(words[5])]\n           ));\n-    } else if (words[0].equals(\"1\")) {\n+      case \"1\":\n       return new StorageGroupMNodePlan(words[1], Long.parseLong(words[2]), Integer.parseInt(words[3]));\n-    } else if (words[0].equals(\"0\")) {\n+      case \"0\":\n       return new MNodePlan(words[1], Integer.parseInt(words[2]));\n     }\n     return null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNTI0NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486725244", "bodyText": "with finally, we could close mLogReader only once", "author": "samperson1997", "createdAt": "2020-09-11T01:45:59Z", "path": "server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java", "diffHunk": "@@ -272,18 +274,25 @@ public SyncStatus checkDataMD5(String md5OfSender) throws TException {\n   private void loadMetadata() {\n     logger.info(\"Start to load metadata in sync process.\");\n     if (currentFile.get().exists()) {\n-      try (BufferedReader br = new BufferedReader(\n-          new java.io.FileReader(currentFile.get()))) {\n-        String metadataOperation;\n-        while ((metadataOperation = br.readLine()) != null) {\n+      MLogReader mLogReader = null;\n+      try {\n+        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);\n+        while (mLogReader.hasNext()) {\n+          PhysicalPlan plan = mLogReader.next();\n           try {\n-            IoTDB.metaManager.operation(metadataOperation);\n-          } catch (IOException | MetadataException e) {\n-            logger.error(\"Can not operate metadata operation {} \", metadataOperation, e);\n+            if (plan == null) {\n+              continue;\n+            }\n+            IoTDB.metaManager.operation(plan);\n+          } catch (Exception e) {\n+            logger.error(\"Can not operate metadata operation {} for err:{}\", plan.getOperatorType(), e);\n           }\n         }\n+        mLogReader.close();\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n+      } finally {\n+        mLogReader.close();", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzA3MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737070", "bodyText": "yes!", "author": "mychaow", "createdAt": "2020-09-11T02:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNTI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\nindex 755a6edbb1..b44374349a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n\n@@ -288,11 +288,12 @@ public class SyncServiceImpl implements SyncService.Iface {\n             logger.error(\"Can not operate metadata operation {} for err:{}\", plan.getOperatorType(), e);\n           }\n         }\n-        mLogReader.close();\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n       } finally {\n-        mLogReader.close();\n+        if (mLogReader != null) {\n+          mLogReader.close();\n+        }\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNjIxMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486726213", "bodyText": "I understand it's convenient to make them extends PhysicalPlan, but I still think it is a little bit strange to make StorageGroupMNode, MNode and MeasurementNode as a plan... How did you consider about it?", "author": "samperson1997", "createdAt": "2020-09-11T01:49:39Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class StorageGroupMNodePlan extends PhysicalPlan {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzM5MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737390", "bodyText": "haha, I will change it. It's a mistake.", "author": "mychaow", "createdAt": "2020-09-11T02:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNjIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 902a8a99f7..95b7229b31 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n\n@@ -30,10 +30,8 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n-public class StorageGroupMNodePlan extends PhysicalPlan {\n-  private String name;\n+public class StorageGroupMNodePlan extends MNodePlan {\n   private long dataTTL;\n-  private int childSize;\n \n   public StorageGroupMNodePlan() {\n     super(false, Operator.OperatorType.STORAGE_GROUP_MNODE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODIzNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486728234", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n          \n          \n            \n              public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {", "author": "samperson1997", "createdAt": "2020-09-11T01:56:48Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.info(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementNodePlan plan = new MeasurementNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..5b258f16ed 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -43,7 +43,7 @@ import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class MLogWriter {\n+public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTc5Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486729796", "bodyText": "Line 190 to line 205 is the part of upgrading v0.9 mlog to v0.10. Since the MetadataConstant.METADATA_LOG has changed, I don't think that upgrading will work correctly. Should we remove that?", "author": "HTHou", "createdAt": "2020-09-11T02:02:29Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -203,6 +203,13 @@ public void checkConfig() throws IOException {\n       }\n       // rename tmpLogFile to mlog\n       FileUtils.moveFile(tmpMLogFile, mlogFile);\n+\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MjY0OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486742648", "bodyText": "yes, it's no meaning.", "author": "mychaow", "createdAt": "2020-09-11T02:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex ea83824b55..23b680251b 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n\n@@ -186,66 +186,34 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // need to upgrade from 0.9 to 0.10\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      checkUnClosedTsFileV1();\n-      MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-      upgradePropertiesFile();\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n+    // upgrade from mlog.txt to mlog.bin\n+    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n+    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_OLD_LOG);\n+    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n+      + \".tmp\");\n \n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n+    if (!oldMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n     }\n-    checkProperties();\n-  }\n \n-  /**\n-   * upgrade 0.9 properties to 0.10 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n+    if (!tmpMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n     }\n \n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+    // move mlog.bin.tmp to mlog.bin\n+    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_LOG);\n+    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+      + \".tmp\");\n+    // rename tmpLogFile to mlog\n+    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+    checkProperties();\n   }\n \n-\n   /**\n    * repair 0.10 properties\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjU4Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736587", "bodyText": "Use try with resource to avoid new sonar code smell..", "author": "HTHou", "createdAt": "2020-09-11T02:28:14Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,55 +1008,74 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n+      root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (BufferedReader br = new BufferedReader(new FileReader(mtreeSnapshot))) {\n-      String s;\n+    MLogReader mlogReader = null;\n+    try {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MjY4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486742681", "bodyText": "Got it!", "author": "mychaow", "createdAt": "2020-09-11T02:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex bbbe2eec01..87d0dcdde3 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n\n@@ -1008,22 +1004,15 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    MLogWriter mLogWriter = null;\n-    try {\n-      mLogWriter = new MLogWriter(snapshotPath);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n       root.serializeTo(mLogWriter);\n-    } finally {\n-      if (mLogWriter != null) {\n-        mLogWriter.close();\n-      }\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    MLogReader mlogReader = null;\n-    try {\n-      mlogReader = new MLogReader(mtreeSnapshot);\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n       Deque<MNode> nodeStack = new ArrayDeque<>();\n       MNode node = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjY4MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736680", "bodyText": "Use try with resource", "author": "HTHou", "createdAt": "2020-09-11T02:28:38Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,55 +1008,74 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n+      root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex bbbe2eec01..87d0dcdde3 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n\n@@ -1008,22 +1004,15 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    MLogWriter mLogWriter = null;\n-    try {\n-      mLogWriter = new MLogWriter(snapshotPath);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n       root.serializeTo(mLogWriter);\n-    } finally {\n-      if (mLogWriter != null) {\n-        mLogWriter.close();\n-      }\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    MLogReader mlogReader = null;\n-    try {\n-      mlogReader = new MLogReader(mtreeSnapshot);\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n       Deque<MNode> nodeStack = new ArrayDeque<>();\n       MNode node = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjgzNg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736836", "bodyText": "Use try with resource", "author": "HTHou", "createdAt": "2020-09-11T02:29:15Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -248,21 +237,32 @@ private int initFromLog(File logFile) throws IOException {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      try (FileReader fr = new FileReader(logFile);\n-          BufferedReader br = new BufferedReader(fr)) {\n-        String cmd;\n-        while ((cmd = br.readLine()) != null) {\n+      MLogReader mLogReader = null;\n+      try {\n+        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 358c1fc0e2..b4812ce2ea 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n\n@@ -237,9 +237,8 @@ public class MManager {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      MLogReader mLogReader = null;\n-      try {\n-        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);\n+      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n+\n         while (mLogReader.hasNext()) {\n           PhysicalPlan plan = null;\n           try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzQ0NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737444", "bodyText": "info -> warn?", "author": "HTHou", "createdAt": "2020-09-11T02:31:27Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.info(\"create schema folder {} failed.\", metadataDir);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..5b258f16ed 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -43,7 +43,7 @@ import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class MLogWriter {\n+public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzc1MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737750", "bodyText": "use try with resource", "author": "HTHou", "createdAt": "2020-09-11T02:32:35Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.info(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementNodePlan plan = new MeasurementNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      MLogWriter mLogWriter = null;\n+      OldMLogReader oldMLogReader = null;\n+      try {\n+        // upgrade from old character log file to new binary mlog\n+        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NDc2Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486764762", "bodyText": "Got it!", "author": "mychaow", "createdAt": "2020-09-11T04:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..5b258f16ed 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -43,7 +43,7 @@ import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class MLogWriter {\n+public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n"}}, {"oid": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "url": "https://github.com/apache/iotdb/commit/6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "message": "fix upgrade mlog bug", "committedDate": "2020-09-11T06:08:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5OTMzNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486799334", "bodyText": "Hi, may I ask why we put operations like serializeMNode to log?", "author": "samperson1997", "createdAt": "2020-09-11T06:24:10Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMDM4MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487030380", "bodyText": "It's snapshot file, not mlog.bin, I just serialize the snapshot and mlog by the same logwriter class. So, the snapshot file has the same format with mlog.bin.", "author": "mychaow", "createdAt": "2020-09-11T13:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5OTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4ODI5OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487388298", "bodyText": "Ah... I understand, it used to be the snapshot file which serializes the MTree. @qiaojialin Do you think it is acceptable?", "author": "samperson1997", "createdAt": "2020-09-12T09:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5OTMzNA=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc2MDE5Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487760193", "bodyText": "larger?", "author": "qiaojialin", "createdAt": "2020-09-14T09:03:14Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -168,6 +168,12 @@\n    */\n   private int walBufferSize = 16 * 1024 * 1024;\n \n+  /**\n+   * Size of log buffer for every MetaData operation. If the size of a MetaData operation plan\n+   * is smaller than this parameter, then the MetaData operation plan will be rejected by MManager.", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\nindex 171172c6fe..9f65aee727 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n\n@@ -164,16 +164,22 @@ public class IoTDBConfig {\n \n   /**\n    * Size of log buffer in each log node(in byte). If WAL is enabled and the size of a insert plan\n-   * is smaller than this parameter, then the insert plan will be rejected by WAL.\n+   * is larger than this parameter, then the insert plan will be rejected by WAL.\n    */\n   private int walBufferSize = 16 * 1024 * 1024;\n \n   /**\n    * Size of log buffer for every MetaData operation. If the size of a MetaData operation plan\n-   * is smaller than this parameter, then the MetaData operation plan will be rejected by MManager.\n+   * is larger than this parameter, then the MetaData operation plan will be rejected by MManager.\n    */\n   private int mlogBufferSize = 64 * 1024;\n \n+  /**\n+   * The cycle when meta log is periodically forced to be written to disk(in milliseconds) If\n+   * set this parameter to 0 it means call outputStream.force(true) after every each insert\n+   */\n+  private long forceMlogPeriodInMs = 100;\n+\n   /**\n    * system base dir, stores all system metadata and wal\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3ODgyNQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487778825", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // if both old mlog and mlog.tmp do not exist, nothing to do\n          \n          \n            \n                // if both old mlog.txt and mlog.bin.tmp do not exist, nothing to do", "author": "qiaojialin", "createdAt": "2020-09-14T09:34:40Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3OTQ1Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487779456", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n          \n          \n            \n                // if both old mlog.txt and mlog.bin.tmp exist, delete mlog.bin.tmp, then do upgrading", "author": "qiaojialin", "createdAt": "2020-09-14T09:35:43Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n+    }\n+\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NTY3NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487785675", "bodyText": "How about puting the offset to the CreateTimeseriesPlan", "author": "qiaojialin", "createdAt": "2020-09-14T09:46:26Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTQzMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489105433", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-16T01:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NTY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NjY1Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487786652", "bodyText": "This is not used", "author": "qiaojialin", "createdAt": "2020-09-14T09:48:01Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n+    }\n+\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n+    if (tmpLogFile.exists()) {\n+      if (!tmpLogFile.delete()) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n+      }\n+    }\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null) {\n+      if (logFile.exists()) {\n+        Files.delete(logFile.toPath());\n+      }\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd) throws IOException, MetadataException {\n+    // see createTimeseries() to get the detailed format of the cmd\n+    String[] args = cmd.trim().split(\",\", -1);\n+    switch (args[0]) {\n+      case MetadataOperationType.CREATE_TIMESERIES:\n+        Map<String, String> props = null;\n+        if (!args[5].isEmpty()) {\n+          String[] keyValues = args[5].split(\"&\");\n+          String[] kv;\n+          props = new HashMap<>();\n+          for (String keyValue : keyValues) {\n+            kv = keyValue.split(\"=\");\n+            props.put(kv[0], kv[1]);\n+          }\n+        }\n+\n+        String alias = null;\n+        if (!args[6].isEmpty()) {\n+          alias = args[6];\n+        }\n+        long offset = -1L;\n+        Map<String, String> tagMap = null;", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxNjM0OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487816349", "bodyText": "Are these codes duplicated with MLogWriter.upgrade() ? Maybe puting them to MLogWriter.upgrade() is better.", "author": "qiaojialin", "createdAt": "2020-09-14T10:40:21Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -186,59 +186,34 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // need to upgrade from 0.9 to 0.10\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      checkUnClosedTsFileV1();\n-      MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-      upgradePropertiesFile();\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n+\n+    // upgrade from mlog.txt to mlog.bin\n+    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n+    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_OLD_LOG);\n+    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (!oldMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n     }\n-    checkProperties();\n-  }\n \n-  /**\n-   * upgrade 0.9 properties to 0.10 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n+    if (!tmpMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n     }\n \n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+    // move mlog.bin.tmp to mlog.bin\n+    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_LOG);\n+    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+      + \".tmp\");\n+    // rename tmpLogFile to mlog\n+    FileUtils.moveFile(tmpMLogFile, mlogFile);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 23b680251b..05bb3090cb 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n\n@@ -189,27 +189,6 @@ public class IoTDBConfigCheck {\n \n     // upgrade from mlog.txt to mlog.bin\n     MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n-    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_OLD_LOG);\n-    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n-    if (!oldMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    if (!tmpMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    // move mlog.bin.tmp to mlog.bin\n-    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_LOG);\n-    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-      + \".tmp\");\n-    // rename tmpLogFile to mlog\n-    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n     checkProperties();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyODEyMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487828123", "bodyText": "If we throw an IOException here, the user will get an empty MTree, they may feel \"lose their data\". I suggest catch all Exceptions when recovering MManager and recover mlog as much as possible. We could print an error stack and fix it later.", "author": "qiaojialin", "createdAt": "2020-09-14T11:03:20Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -248,21 +237,27 @@ private int initFromLog(File logFile) throws IOException {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      try (FileReader fr = new FileReader(logFile);\n-          BufferedReader br = new BufferedReader(fr)) {\n-        String cmd;\n-        while ((cmd = br.readLine()) != null) {\n+      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n+\n+        while (mLogReader.hasNext()) {\n+          PhysicalPlan plan = null;\n           try {\n-            operation(cmd);\n+            plan = mLogReader.next();\n+            if (plan == null) {\n+              continue;\n+            }\n+            operation(plan);\n             idx++;\n           } catch (Exception e) {\n-            logger.error(\"Can not operate cmd {}\", cmd, e);\n+            logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n           }\n         }\n+        logger.debug(\"spend {} ms to deserialize mtree from mlog.bin\",\n+            System.currentTimeMillis() - time);\n+        return idx;\n+      } catch (Exception e) {\n+        throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTY3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489105676", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-16T01:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyODEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex b4812ce2ea..4854bef75c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n\n@@ -258,8 +265,6 @@ public class MManager {\n       } catch (Exception e) {\n         throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n       }\n-    } else if (mtreeSnapshot.exists()) {\n-      throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");\n     } else {\n       return 0;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5OTY2OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487899669", "bodyText": "This is not an unusual case, no need to throw an exception. Please help to remove this.", "author": "qiaojialin", "createdAt": "2020-09-14T13:10:54Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -248,21 +237,27 @@ private int initFromLog(File logFile) throws IOException {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      try (FileReader fr = new FileReader(logFile);\n-          BufferedReader br = new BufferedReader(fr)) {\n-        String cmd;\n-        while ((cmd = br.readLine()) != null) {\n+      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n+\n+        while (mLogReader.hasNext()) {\n+          PhysicalPlan plan = null;\n           try {\n-            operation(cmd);\n+            plan = mLogReader.next();\n+            if (plan == null) {\n+              continue;\n+            }\n+            operation(plan);\n             idx++;\n           } catch (Exception e) {\n-            logger.error(\"Can not operate cmd {}\", cmd, e);\n+            logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n           }\n         }\n+        logger.debug(\"spend {} ms to deserialize mtree from mlog.bin\",\n+            System.currentTimeMillis() - time);\n+        return idx;\n+      } catch (Exception e) {\n+        throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n       }\n-      logger.debug(\"spend {} ms to deserialize mtree from mlog.txt\",\n-          System.currentTimeMillis() - time);\n-      return idx;\n     } else if (mtreeSnapshot.exists()) {\n       throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex b4812ce2ea..4854bef75c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n\n@@ -258,8 +265,6 @@ public class MManager {\n       } catch (Exception e) {\n         throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n       }\n-    } else if (mtreeSnapshot.exists()) {\n-      throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");\n     } else {\n       return 0;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTEzOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487905139", "bodyText": "Add a javadoc indicating for an upgrade from mlog.txt", "author": "qiaojialin", "createdAt": "2020-09-14T13:19:05Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n+    }\n+\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n+    if (tmpLogFile.exists()) {\n+      if (!tmpLogFile.delete()) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n+      }\n+    }\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null) {\n+      if (logFile.exists()) {\n+        Files.delete(logFile.toPath());\n+      }\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd) throws IOException, MetadataException {", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTczOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489105739", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-16T01:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTEzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTU1Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487905556", "bodyText": "rename to MLogTXTReader or add a javadoc :  for reading mlog.txt", "author": "qiaojialin", "createdAt": "2020-09-14T13:19:44Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+\n+\n+public class OldMLogReader implements AutoCloseable {", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\nsimilarity index 93%\nrename from server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java\nrename to server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\nindex 09f45448b7..526c4281ae 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\n\n@@ -28,15 +28,17 @@ import java.io.File;\n import java.io.FileReader;\n import java.io.IOException;\n \n-\n-public class OldMLogReader implements AutoCloseable {\n+/**\n+ * reader for reading mlog.txt\n+ */\n+public class MLogTxtReader implements AutoCloseable {\n   private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);\n \n   private BufferedReader bufferedReader;\n   private File logFile;\n   private String cmd;\n \n-  public OldMLogReader(String schemaDir, String logFileName) throws IOException {\n+  public MLogTxtReader(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n       logger.error(\"no mlog.txt to init MManager.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMjE0NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487912145", "bodyText": "This is not an error case, change this to debug level is better. The case is: Allocate 16MB for buffer and put log into this buffer one by one, In the end, it always trigger the BufferOverflowException, just reseting the buffer is ok.\nHowever, if one log exceeds 16M, this will throw an exception.", "author": "qiaojialin", "createdAt": "2020-09-14T13:28:35Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkwNTM5NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489905394", "bodyText": "yes", "author": "mychaow", "createdAt": "2020-09-17T02:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMjE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDQxNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487914414", "bodyText": "If using a buffer like WAL, we also need a thread to sync the buffer periodically like the forceTask in MultiFileLogNodeManager. Otherwise, the last logs in the buffer will never be persisted.\nOne option is to sync the mlog one by one.", "author": "qiaojialin", "createdAt": "2020-09-14T13:31:14Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkwMzM4Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489903386", "bodyText": "yes, I think maybe we need to call the forceTask periodically. Because FileChannel.force(true) is more costful than bufferedWriter.flush, this will result in performance degradation of metadata operation.", "author": "mychaow", "createdAt": "2020-09-17T02:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDQxNA=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzNjYxMg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487936612", "bodyText": "The XXMNodePlan is almost the same as the XXMNode, the structure is not a problem. But creating or recovering a snapshot may be slower in this way.  Better to test the performance. If the performance does not decrease a lot, this is acceptable. We could test 10M timeseries (10000 device * 1000 measurement)", "author": "qiaojialin", "createdAt": "2020-09-14T13:52:25Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,48 +1004,57 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (BufferedReader br = new BufferedReader(new FileReader(mtreeSnapshot))) {\n-      String s;\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n       Deque<MNode> nodeStack = new ArrayDeque<>();\n       MNode node = null;\n \n-      while ((s = br.readLine()) != null) {\n-        String[] nodeInfo = s.split(\",\");\n-        short nodeType = Short.parseShort(nodeInfo[0]);\n-        if (nodeType == MetadataConstant.STORAGE_GROUP_MNODE_TYPE) {\n-          node = StorageGroupMNode.deserializeFrom(nodeInfo);\n-        } else if (nodeType == MetadataConstant.MEASUREMENT_MNODE_TYPE) {\n-          node = MeasurementMNode.deserializeFrom(nodeInfo);\n-        } else {\n-          node = new MNode(null, nodeInfo[1]);\n-        }\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementMNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkwMzUwMg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489903502", "bodyText": "ok, I will do some tests.", "author": "mychaow", "createdAt": "2020-09-17T02:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzNjYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MTc0Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489981747", "bodyText": "I have done some tests, 1M timeseries,  the cpu cost it almost same.", "author": "mychaow", "createdAt": "2020-09-17T05:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzNjYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "9ea4a4afe6a50de659f5cd324ddc2e2f53b5e1d7", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 87d0dcdde3..f1b2a752cc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n\n@@ -1038,7 +1183,7 @@ public class MTree implements Serializable {\n           if (childrenSize == 0) {\n             nodeStack.push(node);\n           } else {\n-            Map<String, MNode> childrenMap = new LinkedHashMap<>();\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n             for (int i = 0; i < childrenSize; i++) {\n               MNode child = nodeStack.removeFirst();\n               child.setParent(node);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MTExNg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487941116", "bodyText": "Pay attention to force mLogWriter before close it.", "author": "qiaojialin", "createdAt": "2020-09-14T13:56:37Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,48 +1004,57 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ea4a4afe6a50de659f5cd324ddc2e2f53b5e1d7", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 87d0dcdde3..f1b2a752cc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n\n@@ -1038,7 +1183,7 @@ public class MTree implements Serializable {\n           if (childrenSize == 0) {\n             nodeStack.push(node);\n           } else {\n-            Map<String, MNode> childrenMap = new LinkedHashMap<>();\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n             for (int i = 0; i < childrenSize; i++) {\n               MNode child = nodeStack.removeFirst();\n               child.setParent(node);\n"}}, {"oid": "c9db0fef590ec1f27c44d85e850a77f82743a804", "url": "https://github.com/apache/iotdb/commit/c9db0fef590ec1f27c44d85e850a77f82743a804", "message": "fix upgrade mlog bug", "committedDate": "2020-09-22T05:29:53Z", "type": "forcePushed"}, {"oid": "72e188cc3e3d4fe1c4583b176aa1badcad400793", "url": "https://github.com/apache/iotdb/commit/72e188cc3e3d4fe1c4583b176aa1badcad400793", "message": "fix upgrade mlog bug", "committedDate": "2020-09-27T05:34:11Z", "type": "forcePushed"}, {"oid": "9ea4a4afe6a50de659f5cd324ddc2e2f53b5e1d7", "url": "https://github.com/apache/iotdb/commit/9ea4a4afe6a50de659f5cd324ddc2e2f53b5e1d7", "message": "fix upgrade mlog bug", "committedDate": "2020-10-12T07:18:36Z", "type": "forcePushed"}, {"oid": "3fd3e5ac8439ead77f6ae9c486137ce0b28c609f", "url": "https://github.com/apache/iotdb/commit/3fd3e5ac8439ead77f6ae9c486137ce0b28c609f", "message": "fix upgrade mlog bug", "committedDate": "2020-10-12T11:18:25Z", "type": "forcePushed"}, {"oid": "5491c8cc75c2d83192f012a5c2a8329bedeadf81", "url": "https://github.com/apache/iotdb/commit/5491c8cc75c2d83192f012a5c2a8329bedeadf81", "message": "fix upgrade mlog bug", "committedDate": "2020-10-12T11:30:23Z", "type": "forcePushed"}, {"oid": "df0282f1249629b08e83f6e465ac060ff3864a00", "url": "https://github.com/apache/iotdb/commit/df0282f1249629b08e83f6e465ac060ff3864a00", "message": "add mlog parser", "committedDate": "2020-11-18T06:18:23Z", "type": "forcePushed"}, {"oid": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "url": "https://github.com/apache/iotdb/commit/7a5ad6d7312a641efad62a814f07be5ce4aade56", "message": "add mlog parser", "committedDate": "2020-11-20T02:22:04Z", "type": "forcePushed"}, {"oid": "18bb0557753e46238c0a17cd131af13a072eb09c", "url": "https://github.com/apache/iotdb/commit/18bb0557753e46238c0a17cd131af13a072eb09c", "message": "remove some code smell warn", "committedDate": "2020-11-20T03:43:30Z", "type": "forcePushed"}, {"oid": "18db49a9f143f75580454df2a3fb002d63c66a2d", "url": "https://github.com/apache/iotdb/commit/18db49a9f143f75580454df2a3fb002d63c66a2d", "message": "fix some snoar warn", "committedDate": "2020-11-24T01:59:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxMDYwMQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529510601", "bodyText": "ConsoleReader reader is not used in this method : )", "author": "samperson1997", "createdAt": "2020-11-24T12:33:01Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNDE1MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529514151", "bodyText": "It's not recommended to add braces {} here. Maybe we could extract pathList  outside the switch statement?", "author": "samperson1997", "createdAt": "2020-11-24T12:39:26Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (PartialPath partialPath : pathList) {\n+              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n+            }\n+          }", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzEyNw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063127", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-11-25T02:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNDE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNDI0MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529514241", "bodyText": "... so that braces {} could also be omitted here", "author": "samperson1997", "createdAt": "2020-11-24T12:39:34Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (PartialPath partialPath : pathList) {\n+              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (PartialPath partialPath : pathList) {\n+              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n+            }\n+          }", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNTE5Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529515197", "bodyText": "I suggest to define and throw a specific exception. What do you think?", "author": "samperson1997", "createdAt": "2020-11-24T12:41:18Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzE2Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063167", "bodyText": "yes", "author": "mychaow", "createdAt": "2020-11-25T02:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNTQxMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529515413", "bodyText": "... and this Exception could be more specific as well", "author": "samperson1997", "createdAt": "2020-11-24T12:41:38Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNjA0Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529516042", "bodyText": "Remove unused import", "author": "samperson1997", "createdAt": "2020-11-24T12:42:49Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 81e1c538fa..451475b1b0 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n\n@@ -21,7 +21,6 @@ package org.apache.iotdb.db.qp.physical.sys;\n \n import org.apache.iotdb.db.metadata.PartialPath;\n import org.apache.iotdb.db.qp.logical.Operator;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n \n import java.io.DataOutputStream;\n import java.io.IOException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxODkwOA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529518908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);\n          \n          \n            \n              private static final Logger logger = LoggerFactory.getLogger(MLogTxtReader.class);", "author": "samperson1997", "createdAt": "2020-11-24T12:47:41Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+\n+/**\n+ * reader for reading mlog.txt\n+ */\n+public class MLogTxtReader implements AutoCloseable {\n+  private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\nindex 912180c792..022d3bea58 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\n\n@@ -32,7 +32,7 @@ import java.io.IOException;\n  * reader for reading mlog.txt\n  */\n public class MLogTxtReader implements AutoCloseable {\n-  private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);\n+  private static final Logger logger = LoggerFactory.getLogger(MLogTxtReader.class);\n \n   private BufferedReader bufferedReader;\n   private File logFile;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjI3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529522276", "bodyText": "Refactor as below may be more logical:\n        if (childrenSize != 0) {\n            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n            for (int i = 0; i < childrenSize; i++) {\n              MNode child = nodeStack.removeFirst();\n              child.setParent(node);\n              childrenMap.put(child.getName(), child);\n              if (child instanceof MeasurementMNode) {\n                String alias = ((MeasurementMNode) child).getAlias();\n                if (alias != null) {\n                  node.addAlias(alias, child);\n                }\n              }\n            }\n            node.setChildren(childrenMap);\n          }\n          nodeStack.push(node);\n        }", "author": "samperson1997", "createdAt": "2020-11-24T12:53:27Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1262,9 +1214,68 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static MTree deserializeFrom(File mtreeSnapshot) {\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementMNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzI2Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063266", "bodyText": "Good idea!", "author": "mychaow", "createdAt": "2020-11-25T02:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjI3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 5b4bfcd5ac..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n\n@@ -1219,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjg1NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529522854", "bodyText": "Maybe this Exception could be more specific too?", "author": "samperson1997", "createdAt": "2020-11-24T12:54:17Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1262,9 +1214,68 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static MTree deserializeFrom(File mtreeSnapshot) {\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementMNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI0ODkwMQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530248901", "bodyText": "catch all exception", "author": "mychaow", "createdAt": "2020-11-25T10:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 5b4bfcd5ac..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n\n@@ -1219,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529526181", "bodyText": "Do you think it is necessary to delete all these codes (upgradePropertiesFile, checkUnClosedTsFileV2, checkUnClosedTsFileV2InFolders) now? I think this check should be modified before 0.12 is released... Or the users who are using v0.9 and intending to upgrade to master may encounter problems ... @qiaojialin", "author": "samperson1997", "createdAt": "2020-11-24T12:59:42Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,51 +185,16 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0ODQ2MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530048460", "bodyText": "Agree with @samperson1997", "author": "HTHou", "createdAt": "2020-11-25T01:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzA0Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063043", "bodyText": "I think user should upgrade to 0.11, then upgrade to 0.12. So the function is not useful in 0.12.", "author": "mychaow", "createdAt": "2020-11-25T02:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2NjY5MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530066690", "bodyText": "I mean these methods could be left here. I'll modify and reuse these methods when I implement the upgrade tool.  For now, I think it is OK to do not call these methods.", "author": "HTHou", "createdAt": "2020-11-25T02:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI0ODE4Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530248182", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-11-25T10:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n\n@@ -188,7 +188,7 @@ public class IoTDBConfigCheck {\n     // check whether upgrading from v0.9 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MjA0Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530062047", "bodyText": "If there is a comma in the path of a timeseries, the length of args[] will be larger than 8.\nI think adding these lines back is better.\n        if (args.length > 8) {\t\n          String[] tmpArgs = new String[8];\t\n          tmpArgs[0] = args[0];\t\n          int i = 1;\t\n          tmpArgs[1] = \"\";\t\n          for (; i < args.length - 7; i++) {\t\n            tmpArgs[1] += args[i] + \",\";\t\n          }\t\n          tmpArgs[1] += args[i++];\t\n          for (int j = 2; j < 8; j++) {\t\n            tmpArgs[j] = args[i++];\t\n          }\t\n          args = tmpArgs;\t\n        }", "author": "HTHou", "createdAt": "2020-11-25T02:10:21Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n+          try {\n+            mLogWriter.operation(cmd, isSnapshot);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+      }\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+    } else if (tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      try {\n+        Files.delete(Paths.get(tmpLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(oldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + oldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    if (tmpOldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(tmpOldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpOldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n+    if (!isSnapshot) {\n+      operation(cmd);\n+    } else {\n+      PhysicalPlan plan = convertFromString(cmd);\n+      try {\n+        if (plan != null) {\n+          putLog(plan);\n+        }\n+      } catch (BufferOverflowException e) {\n+        throw new IOException(\n+          LOG_TOO_LARGE_INFO, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * upgrade from mlog.txt to mlog.bin\n+   * @param cmd, the old meta operation\n+   * @throws IOException\n+   * @throws MetadataException\n+   */\n+  public void operation(String cmd) throws IOException, MetadataException {\n+    // see createTimeseries() to get the detailed format of the cmd\n+    String[] args = cmd.trim().split(\",\", -1);\n+    switch (args[0]) {\n+      case MetadataOperationType.CREATE_TIMESERIES:", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzY5NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063695", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-11-25T02:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MjA0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -339,11 +339,26 @@ public class MLogWriter implements AutoCloseable {\n    * @throws IOException\n    * @throws MetadataException\n    */\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n+        if (args.length > 8) {\n+          String[] tmpArgs = new String[8];\n+          tmpArgs[0] = args[0];\n+          int i = 1;\n+          tmpArgs[1] = \"\";\n+          for (; i < args.length - 7; i++) {\n+            tmpArgs[1] += args[i] + \",\";\n+          }\n+          tmpArgs[1] += args[i++];\n+          for (int j = 2; j < 8; j++) {\n+            tmpArgs[j] = args[i++];\n+          }\n+          args = tmpArgs;\n+        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2Mjk5NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530062994", "bodyText": "Same reason. Add these lines.\nif (args.length > 2) {\n  StringBuilder tmp = new StringBuilder();\n  for (int i = 1; i < args.length - 1; i++) {\n    tmp.append(args[i]).append(\",\");\t\n  }\t\n  tmp.append(args[args.length - 1]);\t\n  args[1] = tmp.toString();\t\n}", "author": "HTHou", "createdAt": "2020-11-25T02:13:32Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n+          try {\n+            mLogWriter.operation(cmd, isSnapshot);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+      }\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+    } else if (tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      try {\n+        Files.delete(Paths.get(tmpLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(oldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + oldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    if (tmpOldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(tmpOldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpOldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n+    if (!isSnapshot) {\n+      operation(cmd);\n+    } else {\n+      PhysicalPlan plan = convertFromString(cmd);\n+      try {\n+        if (plan != null) {\n+          putLog(plan);\n+        }\n+      } catch (BufferOverflowException e) {\n+        throw new IOException(\n+          LOG_TOO_LARGE_INFO, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * upgrade from mlog.txt to mlog.bin\n+   * @param cmd, the old meta operation\n+   * @throws IOException\n+   * @throws MetadataException\n+   */\n+  public void operation(String cmd) throws IOException, MetadataException {\n+    // see createTimeseries() to get the detailed format of the cmd\n+    String[] args = cmd.trim().split(\",\", -1);\n+    switch (args[0]) {\n+      case MetadataOperationType.CREATE_TIMESERIES:\n+        Map<String, String> props = null;\n+        if (!args[5].isEmpty()) {\n+          String[] keyValues = args[5].split(\"&\");\n+          String[] kv;\n+          props = new HashMap<>();\n+          for (String keyValue : keyValues) {\n+            kv = keyValue.split(\"=\");\n+            props.put(kv[0], kv[1]);\n+          }\n+        }\n+\n+        String alias = null;\n+        if (!args[6].isEmpty()) {\n+          alias = args[6];\n+        }\n+        long offset = -1L;\n+        if (!args[7].isEmpty()) {\n+          offset = Long.parseLong(args[7]);\n+        }\n+\n+        CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n+            TSDataType.deserialize(Short.parseShort(args[2])),\n+            TSEncoding.deserialize(Short.parseShort(args[3])),\n+            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n+        plan.setTagOffset(offset);\n+\n+        createTimeseries(plan);\n+        break;\n+      case MetadataOperationType.DELETE_TIMESERIES:", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -339,11 +339,26 @@ public class MLogWriter implements AutoCloseable {\n    * @throws IOException\n    * @throws MetadataException\n    */\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n+        if (args.length > 8) {\n+          String[] tmpArgs = new String[8];\n+          tmpArgs[0] = args[0];\n+          int i = 1;\n+          tmpArgs[1] = \"\";\n+          for (; i < args.length - 7; i++) {\n+            tmpArgs[1] += args[i] + \",\";\n+          }\n+          tmpArgs[1] += args[i++];\n+          for (int j = 2; j < 8; j++) {\n+            tmpArgs[j] = args[i++];\n+          }\n+          args = tmpArgs;\n+        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2NDAyOA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530064028", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n          \n          \n            \n                  logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"", "author": "HTHou", "createdAt": "2020-11-25T02:17:04Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,51 +185,16 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n\n@@ -188,7 +188,7 @@ public class IoTDBConfigCheck {\n     // check whether upgrading from v0.9 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0NjQyMQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530146421", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n          \n          \n            \n                CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,", "author": "HTHou", "createdAt": "2020-11-25T07:03:31Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -77,7 +77,8 @@ public String toString() {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES\n-    , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\nindex 267faccb50..13e3749309 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n\n@@ -77,7 +77,7 @@ public abstract class Operator {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n     CHANGE_TAG_OFFSET, CHANGE_ALIAS, MNODE,\n     MEASUREMENT_MNODE, STORAGE_GROUP_MNODE;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MTc1MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531981750", "bodyText": "Remove unused import", "author": "samperson1997", "createdAt": "2020-11-28T07:24:47Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.DeleteFailedException;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwNTU5Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532305597", "bodyText": "fixed", "author": "mychaow", "createdAt": "2020-11-30T01:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MTc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -21,7 +21,6 @@ package org.apache.iotdb.db.metadata.logfile;\n import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n-import org.apache.iotdb.db.exception.metadata.DeleteFailedException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.metadata.MetadataConstant;\n import org.apache.iotdb.db.metadata.MetadataOperationType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4Mzk5OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531983998", "bodyText": "Remove unused import", "author": "samperson1997", "createdAt": "2020-11-28T07:27:44Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.DeleteFailedException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -21,7 +21,6 @@ package org.apache.iotdb.db.metadata.logfile;\n import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n-import org.apache.iotdb.db.exception.metadata.DeleteFailedException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.metadata.MetadataConstant;\n import org.apache.iotdb.db.metadata.MetadataOperationType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4NDg3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531984876", "bodyText": "Remove unused import", "author": "samperson1997", "createdAt": "2020-11-28T07:28:48Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 1300693d92..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4NDk5OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531984999", "bodyText": "Remove unused import", "author": "samperson1997", "createdAt": "2020-11-28T07:28:59Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 1300693d92..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n\n@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk5MjMzNw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531992337", "bodyText": "Remove this line", "author": "samperson1997", "createdAt": "2020-11-28T07:38:36Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java", "diffHunk": "@@ -269,6 +267,7 @@ public void testRestartEndTime()\n       };\n       int cnt = 0;\n       try (ResultSet resultSet = statement.getResultSet()) {\n+        System.out.println(resultSet.toString());", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\nindex e2f6513ee7..9f643c69bd 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n\n@@ -267,7 +266,6 @@ public class IoTDBRestartIT {\n       };\n       int cnt = 0;\n       try (ResultSet resultSet = statement.getResultSet()) {\n-        System.out.println(resultSet.toString());\n         while (resultSet.next()) {\n           String result = resultSet.getString(TIMESTAMP_STR) + \",\" + resultSet.getString(2);\n           assertEquals(exp[cnt], result);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNDM2Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532004363", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n          \n          \n            \n                  Set<PhysicalPlan> d0Plans = new HashSet<>(6);", "author": "samperson1997", "createdAt": "2020-11-28T08:17:53Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java", "diffHunk": "@@ -71,35 +78,52 @@ public void createSnapshotTest() throws ClassNotFoundException {\n \n       // create snapshot\n       statement.execute(\"CREATE SNAPSHOT FOR SCHEMA\");\n-      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot\");\n+      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot.bin\");\n \n       // test snapshot file exists\n       Assert.assertTrue(snapshotFile.exists());\n \n       // test snapshot content correct\n-      Set<String> e1 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,2,2,1,,-1,0\",\n-          \"2,s2,,3,2,1,,-1,0\", \"2,s3,,5,0,1,,-1,0\", \"2,s4,,0,0,1,,-1,0\"));\n-      Set<String> e2 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,5,0,1,,-1,0\",\n-          \"2,s2,,0,0,1,,-1,0\"));\n-\n-      try (BufferedReader br = new BufferedReader(new FileReader(snapshotFile))) {\n-        for (int i = 0; i < 5; ++i) {\n-          String actual = br.readLine();\n-          Assert.assertTrue(e1.removeIf(candidate -> candidate.equals(actual)));\n-        }\n-        Assert.assertTrue(e1.isEmpty());\n+      String[] exp = new String[]{\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,2,2,1,,-1,0\",\n+        \"2,s2,,3,2,1,,-1,0\",\n+        \"2,s3,,5,0,1,,-1,0\",\n+        \"2,s4,,0,0,1,,-1,0\",\n+        \"1,d0,9223372036854775807,5\",\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,5,0,1,,-1,0\",\n+        \"2,s2,,0,0,1,,-1,0\",\n+        \"1,d1,9223372036854775807,3\",\n+        \"0,vehicle,2\",\n+        \"0,root,1\"\n+      };\n \n-        Assert.assertEquals(\"1,d0,9223372036854775807,5\", br.readLine());\n+      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 73ff187ad9..e52ea00d93 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n\n@@ -99,12 +99,12 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d0Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d0Plans.add(MLogWriter.convertFromString(exp[i]));\n       }\n \n-      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d1Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d1Plans.add(MLogWriter.convertFromString(exp[i+6]));\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNDM3MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532004370", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n          \n          \n            \n                  Set<PhysicalPlan> d1Plans = new HashSet<>(6);", "author": "samperson1997", "createdAt": "2020-11-28T08:18:03Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java", "diffHunk": "@@ -71,35 +78,52 @@ public void createSnapshotTest() throws ClassNotFoundException {\n \n       // create snapshot\n       statement.execute(\"CREATE SNAPSHOT FOR SCHEMA\");\n-      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot\");\n+      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot.bin\");\n \n       // test snapshot file exists\n       Assert.assertTrue(snapshotFile.exists());\n \n       // test snapshot content correct\n-      Set<String> e1 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,2,2,1,,-1,0\",\n-          \"2,s2,,3,2,1,,-1,0\", \"2,s3,,5,0,1,,-1,0\", \"2,s4,,0,0,1,,-1,0\"));\n-      Set<String> e2 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,5,0,1,,-1,0\",\n-          \"2,s2,,0,0,1,,-1,0\"));\n-\n-      try (BufferedReader br = new BufferedReader(new FileReader(snapshotFile))) {\n-        for (int i = 0; i < 5; ++i) {\n-          String actual = br.readLine();\n-          Assert.assertTrue(e1.removeIf(candidate -> candidate.equals(actual)));\n-        }\n-        Assert.assertTrue(e1.isEmpty());\n+      String[] exp = new String[]{\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,2,2,1,,-1,0\",\n+        \"2,s2,,3,2,1,,-1,0\",\n+        \"2,s3,,5,0,1,,-1,0\",\n+        \"2,s4,,0,0,1,,-1,0\",\n+        \"1,d0,9223372036854775807,5\",\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,5,0,1,,-1,0\",\n+        \"2,s2,,0,0,1,,-1,0\",\n+        \"1,d1,9223372036854775807,3\",\n+        \"0,vehicle,2\",\n+        \"0,root,1\"\n+      };\n \n-        Assert.assertEquals(\"1,d0,9223372036854775807,5\", br.readLine());\n+      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      for (int i = 0; i < 6; i++) {\n+        d0Plans.add(MLogWriter.convertFromString(exp[i]));\n+      }\n+\n+      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 73ff187ad9..e52ea00d93 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n\n@@ -99,12 +99,12 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d0Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d0Plans.add(MLogWriter.convertFromString(exp[i]));\n       }\n \n-      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d1Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d1Plans.add(MLogWriter.convertFromString(exp[i+6]));\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNDk5Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532004993", "bodyText": "You can add @TestOnly for this method", "author": "samperson1997", "createdAt": "2020-11-28T08:25:14Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -38,16 +38,34 @@\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n   private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private long forcePeriodInMs = 0;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * only used by tests\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 4d39671863..e85e08ab1d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n\n@@ -43,11 +44,11 @@ public class LogWriter implements ILogWriter {\n   private long forcePeriodInMs = 0;\n \n   /**\n-   * only used by tests\n    * @param logFilePath\n    * @param forcePeriodInMs\n    * @throws FileNotFoundException\n    */\n+  @TestOnly\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNjk0OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532006948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * only for test\n          \n          \n            \n               */\n          \n          \n            \n              public void flushAllMlogForTest() throws IOException {\n          \n          \n            \n              @TestOnly\n          \n          \n            \n              public void flushAllMlogForTest() throws IOException {", "author": "samperson1997", "createdAt": "2020-11-28T08:49:19Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1680,6 +1647,13 @@ public TimeValuePair getLastCache(PartialPath seriesPath) {\n     return null;\n   }\n \n+  /**\n+   * only for test\n+   */\n+  public void flushAllMlogForTest() throws IOException {", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex f13ed7a4d5..23f64db273 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n\n@@ -1647,9 +1657,7 @@ public class MManager {\n     return null;\n   }\n \n-  /**\n-   * only for test\n-   */\n+  @TestOnly\n   public void flushAllMlogForTest() throws IOException {\n     logWriter.close();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIyOTM5Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r537229396", "bodyText": "do we need to upgrade grom 0.11 to 0.12?", "author": "qiaojialin", "createdAt": "2020-12-07T04:50:35Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,27 +185,23 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {", "originalCommit": "5e68450a813c60198cfa99b799ac6f02e039428e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..9d7efd1c86 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n\n@@ -185,23 +185,33 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n+  @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n-    throws IOException {\n+      throws IOException {\n     // create an empty tmpPropertiesFile\n     if (tmpPropertiesFile.createNewFile()) {\n       logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n"}}, {"oid": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "url": "https://github.com/apache/iotdb/commit/c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "message": "fix some sonar warn", "committedDate": "2020-12-07T07:07:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzMjM4Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r538032383", "bodyText": "from <=0.10 to 0.12", "author": "qiaojialin", "createdAt": "2020-12-08T04:48:30Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,27 +185,24 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12", "originalCommit": "3cd0707d05163af2f0b0a725b88ec65a75617262", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 97e32f555b..9d7efd1c86 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n\n@@ -185,24 +185,33 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n-    throws IOException {\n+      throws IOException {\n     // create an empty tmpPropertiesFile\n     if (tmpPropertiesFile.createNewFile()) {\n       logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n"}}, {"oid": "61c6f6d47b087075554ed4f3636d4990a6da4395", "url": "https://github.com/apache/iotdb/commit/61c6f6d47b087075554ed4f3636d4990a6da4395", "message": "catch exception", "committedDate": "2020-12-11T01:48:42Z", "type": "forcePushed"}, {"oid": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "url": "https://github.com/apache/iotdb/commit/cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "message": "[IOTDB-868] fix comma bug for mlog", "committedDate": "2020-12-14T01:42:47Z", "type": "commit"}, {"oid": "7799fbede947fca9a49d61ce1be81cf359701bf7", "url": "https://github.com/apache/iotdb/commit/7799fbede947fca9a49d61ce1be81cf359701bf7", "message": "fix upgrade mlog bug", "committedDate": "2020-12-14T01:42:47Z", "type": "commit"}, {"oid": "6b7bedc50ce23dac41fedfd29b143e11285794af", "url": "https://github.com/apache/iotdb/commit/6b7bedc50ce23dac41fedfd29b143e11285794af", "message": "add mlog parser", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "68e460eeaea122e42f73efa2b6d15016ed3b3624", "url": "https://github.com/apache/iotdb/commit/68e460eeaea122e42f73efa2b6d15016ed3b3624", "message": "fix sonar warning", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "url": "https://github.com/apache/iotdb/commit/55ebf5b2b1d169250eeba5a250f6c257549c37f1", "message": "remove some code smell warn", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "url": "https://github.com/apache/iotdb/commit/f03a6c296b2e70c83d91c306f67dee49a1826a5f", "message": "fix some snoar warn", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "url": "https://github.com/apache/iotdb/commit/d71acfea25b58daa9ae506a738ed5ebff4d006ca", "message": "fix some bug", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "url": "https://github.com/apache/iotdb/commit/95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "message": "remove some unused import", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "url": "https://github.com/apache/iotdb/commit/bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "message": "fix some sonar warn", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "92930ca36dbeb586f2be035f297eef6e4041162b", "url": "https://github.com/apache/iotdb/commit/92930ca36dbeb586f2be035f297eef6e4041162b", "message": "replace system.out with logger", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "68564cfa6b7de09a689fc1e884fdc6e62fc787d3", "url": "https://github.com/apache/iotdb/commit/68564cfa6b7de09a689fc1e884fdc6e62fc787d3", "message": "add some suppresswarning", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "546d870f06f004873bf639aca53c53c0ff69d4ae", "url": "https://github.com/apache/iotdb/commit/546d870f06f004873bf639aca53c53c0ff69d4ae", "message": "remove unused pom", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "c76cb3eb323ec320cc7b257caa530bc85e17be82", "url": "https://github.com/apache/iotdb/commit/c76cb3eb323ec320cc7b257caa530bc85e17be82", "message": "add upgrade system.properties", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "31fa1e063c9e41a81ed4f0977707279e80866710", "url": "https://github.com/apache/iotdb/commit/31fa1e063c9e41a81ed4f0977707279e80866710", "message": "fixed 0.11", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "103f13a13536f0385c67bb3a4d94116ed4e9bd19", "url": "https://github.com/apache/iotdb/commit/103f13a13536f0385c67bb3a4d94116ed4e9bd19", "message": "catch exception", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "a415549bef189fec0b8239387b99721b0c8749ce", "url": "https://github.com/apache/iotdb/commit/a415549bef189fec0b8239387b99721b0c8749ce", "message": "catch closeInterruptException", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "a415549bef189fec0b8239387b99721b0c8749ce", "url": "https://github.com/apache/iotdb/commit/a415549bef189fec0b8239387b99721b0c8749ce", "message": "catch closeInterruptException", "committedDate": "2020-12-14T01:42:49Z", "type": "forcePushed"}, {"oid": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "url": "https://github.com/apache/iotdb/commit/67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "message": "fix code smell", "committedDate": "2020-12-14T01:52:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNTEyNw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542125127", "bodyText": "make this consistent with iotdb-engine.properties?", "author": "qiaojialin", "createdAt": "2020-12-14T05:40:55Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -204,12 +204,18 @@\n \n   /**\n    * Size of log buffer in each log node(in byte). If WAL is enabled and the size of a insert plan\n-   * is smaller than this parameter, then the insert plan will be rejected by WAL.\n+   * is larger than this parameter, then the insert plan will be rejected by WAL.\n    */\n   private int walBufferSize = 16 * 1024 * 1024;\n \n   private int estimatedSeriesSize = 300;\n \n+  /**\n+   * Size of log buffer for every MetaData operation. If the size of a MetaData operation plan\n+   * is larger than this parameter, then the MetaData operation plan will be rejected by MManager.\n+   */\n+  private int mlogBufferSize = 1024 * 1024;", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1Mjg4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542152881", "bodyText": "There is not a thread to do the periodic Channel.force(true) for MLogWriter, is this meet our expectation?\n\nNot\uff0cjust when we use thread pool to write, and we call shutdown to interrupt the thread, see this\nhttps://stackoverflow.com/questions/1161297/why-are-we-getting-closedbyinterruptexception-from-filechannel-map-in-java-1-6", "author": "mychaow", "createdAt": "2020-12-14T07:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNTEyNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNjI5Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542126296", "bodyText": "this is always true, said by idea..", "author": "qiaojialin", "createdAt": "2020-12-14T05:44:30Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -18,36 +18,59 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1MzU3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542153576", "bodyText": "yes, but I think add a check is not redundancy", "author": "mychaow", "createdAt": "2020-12-14T07:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNjI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 1d21dfff7a..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n\n@@ -57,20 +57,16 @@ public class LogWriter implements ILogWriter {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNjM0NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542126345", "bodyText": "this is always true, said by idea..", "author": "qiaojialin", "createdAt": "2020-12-14T05:44:37Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -18,36 +18,59 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }\n \n-  public LogWriter(File logFile) {\n+  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 1d21dfff7a..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n\n@@ -57,20 +57,16 @@ public class LogWriter implements ILogWriter {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNzI5OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542127299", "bodyText": "The function of this field is the same with a boolean", "author": "qiaojialin", "createdAt": "2020-12-14T05:47:37Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ab52b4e895..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -65,7 +65,7 @@ public class MLogWriter implements AutoCloseable {\n   private LogWriter logWriter;\n   private int logNum;\n   private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n-  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+  private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyOTUyNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542129524", "bodyText": "The actual usage of  'forcePeriodInMs' parameter is a boolean 'forceAtEachWrite'", "author": "qiaojialin", "createdAt": "2020-12-14T05:54:36Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -18,36 +18,59 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }\n \n-  public LogWriter(File logFile) {\n+  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2OTU0MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542169540", "bodyText": "Not that, wal use this to optimize the performance after hundreds  of milliseconds.", "author": "mychaow", "createdAt": "2020-12-14T07:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyOTUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 1d21dfff7a..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n\n@@ -57,20 +57,16 @@ public class LogWriter implements ILogWriter {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzNDY4Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542134686", "bodyText": "The forcePeriodInMs is differenet between clear() and constructor.", "author": "qiaojialin", "createdAt": "2020-12-14T06:10:19Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n+          try {\n+            mLogWriter.operation(cmd, isSnapshot);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+      }\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+    } else if (tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      try {\n+        Files.delete(Paths.get(tmpLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(String.format(DELETE_FAILED_FORMAT, tmpLogFile, e.getMessage()));\n+      }\n+    }\n+\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(oldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(String.format(DELETE_FAILED_FORMAT, oldLogFile, e.getMessage()));\n+      }\n+    }\n+\n+    if (tmpOldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(tmpOldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(String.format(DELETE_FAILED_FORMAT, tmpOldLogFile, e.getMessage()));\n+      }\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MDg4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542170881", "bodyText": "yes,  it's a mistake.", "author": "mychaow", "createdAt": "2020-12-14T07:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzNDY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ab52b4e895..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -65,7 +65,7 @@ public class MLogWriter implements AutoCloseable {\n   private LogWriter logWriter;\n   private int logNum;\n   private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n-  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+  private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODM2Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542138366", "bodyText": "what is this file for?  I do not see the generation of this file..", "author": "qiaojialin", "createdAt": "2020-12-14T06:21:28Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MTg3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542171876", "bodyText": "when we upgrade, maybe we will find the old temp mlog file, so we need to delete it or rename it to the old mlog.txt", "author": "mychaow", "createdAt": "2020-12-14T07:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "chunk": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ab52b4e895..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n\n@@ -65,7 +65,7 @@ public class MLogWriter implements AutoCloseable {\n   private LogWriter logWriter;\n   private int logNum;\n   private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n-  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+  private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MTk4NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542141985", "bodyText": "This could be removed, the operator is only generated in SQL parser.", "author": "qiaojialin", "createdAt": "2020-12-14T06:31:45Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -77,7 +77,8 @@ public String toString() {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES\n-    , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CHANGE_TAG_OFFSET, CHANGE_ALIAS, MNODE,\n+    MEASUREMENT_MNODE, STORAGE_GROUP_MNODE;", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzE2MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542173160", "bodyText": "I use them to unify the wal and mlog, for deserializing the log.", "author": "mychaow", "createdAt": "2020-12-14T07:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MTk4NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "url": "https://github.com/apache/iotdb/commit/06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "message": "fix clear bug", "committedDate": "2020-12-14T07:51:59Z", "type": "commit"}, {"oid": "13d32ddd336ef4e9b0948f301ca46df9347bdd11", "url": "https://github.com/apache/iotdb/commit/13d32ddd336ef4e9b0948f301ca46df9347bdd11", "message": "unify the conf", "committedDate": "2020-12-14T09:29:24Z", "type": "commit"}, {"oid": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "url": "https://github.com/apache/iotdb/commit/4c71885c26b9fe995efe5660cb24beb8981bd8d5", "message": "change long to boolean", "committedDate": "2020-12-14T09:52:03Z", "type": "commit"}]}