{"pr_number": 5509, "pr_title": "GEODE-8491: Do not store dropped events in stopped primary gateway se\u2026", "pr_createdAt": "2020-09-14T04:28:41Z", "pr_url": "https://github.com/apache/geode/pull/5509", "timeline": [{"oid": "6b677a62da11d45f3bd00a381fc85f45756b6bb9", "url": "https://github.com/apache/geode/commit/6b677a62da11d45f3bd00a381fc85f45756b6bb9", "message": "GEODE-8491: Do not store dropped events in stopped primary gateway sender when possible\n\nInstead of storing dropped events in tmpDroppedEvents to later send batch\nremoval messages when the primary gateway sender is not started, try to send\nthe batch removal message when the event to be dropped is received.\nThat way, when the sender is stopped for a long time and there are events\ncoming, the memory of the AbstractGatewaySender will not grow with entries\nin the tmpDroppedEvents member.\n\nIn order to send the batch removal message directly, the eventProcessor for\nthe AbstractGatewaySender must have been created.\nIf it is not yet created because the sender was created with manual start\nset to true, while receiving events to be dropped, they will be stored in\ntmpDroppedEvents as there is no other choice. Nevertheless,\nin order to consume less memory, the event stored could be a simplified event\ncontaining only the necessary information to handle it.", "committedDate": "2020-09-14T07:23:17Z", "type": "commit"}, {"oid": "6b677a62da11d45f3bd00a381fc85f45756b6bb9", "url": "https://github.com/apache/geode/commit/6b677a62da11d45f3bd00a381fc85f45756b6bb9", "message": "GEODE-8491: Do not store dropped events in stopped primary gateway sender when possible\n\nInstead of storing dropped events in tmpDroppedEvents to later send batch\nremoval messages when the primary gateway sender is not started, try to send\nthe batch removal message when the event to be dropped is received.\nThat way, when the sender is stopped for a long time and there are events\ncoming, the memory of the AbstractGatewaySender will not grow with entries\nin the tmpDroppedEvents member.\n\nIn order to send the batch removal message directly, the eventProcessor for\nthe AbstractGatewaySender must have been created.\nIf it is not yet created because the sender was created with manual start\nset to true, while receiving events to be dropped, they will be stored in\ntmpDroppedEvents as there is no other choice. Nevertheless,\nin order to consume less memory, the event stored could be a simplified event\ncontaining only the necessary information to handle it.", "committedDate": "2020-09-14T07:23:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTMyNg==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488039326", "bodyText": "Again, don't clone a new event. In the new code change, the \"else\" will only be executed in very very small time windows.\nYou have proved that when the sender is shutdown, the eventProcessor will be kept. So enqueue will not go to the \"else\". We will never worry about the tmpDroppedEvents become too big.", "author": "gesterzhou", "createdAt": "2020-09-14T15:49:10Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java", "diffHunk": "@@ -1118,6 +1115,24 @@ public void distribute(EnumListenerEvent operation, EntryEventImpl event,\n     }\n   }\n \n+  private void recordDroppedEvent(EntryEventImpl event) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    if (this.eventProcessor != null) {\n+      this.eventProcessor.registerEventDroppedInPrimaryQueue(event);\n+    } else {\n+      // Add empty event so that in case the event stays for long in\n+      // tmpDroppedEvents it takes as little space as possible.\n+      // No need to have all the contents of the event for a dropped one.\n+      EntryEventImpl emptyEvent = new EntryEventImpl(event.getKey(), false);", "originalCommit": "6b677a62da11d45f3bd00a381fc85f45756b6bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA1MjEzOQ==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488052139", "bodyText": "ok. I will remove it.\nAnyway, if the gateway sender is created with manualStart=true then the eventProcessor will not be yet instantiated. In that case, and until the gateway sender is started we could see dropped events put in tmpDroppedEvents. It cannot be guaranteed that it will be a small time window.", "author": "albertogpz", "createdAt": "2020-09-14T16:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjE3Mw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r496146173", "bodyText": "For this part, it's unnecessary to enhance registerEventDroppedInPrimaryQueue() since it's used for a very small window (sender is restarting).\nI feel your previous solution is good enough.", "author": "gesterzhou", "createdAt": "2020-09-28T18:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java b/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java\nindex 8a6e9821f2..e2d29dc560 100644\n--- a/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java\n+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java\n\n@@ -1120,13 +1120,7 @@ public abstract class AbstractGatewaySender implements InternalGatewaySender, Di\n     if (this.eventProcessor != null) {\n       this.eventProcessor.registerEventDroppedInPrimaryQueue(event);\n     } else {\n-      // Add empty event so that in case the event stays for long in\n-      // tmpDroppedEvents it takes as little space as possible.\n-      // No need to have all the contents of the event for a dropped one.\n-      EntryEventImpl emptyEvent = new EntryEventImpl(event.getKey(), false);\n-      emptyEvent.setRegion(event.getRegion());\n-      emptyEvent.setTailKey(event.getTailKey());\n-      tmpDroppedEvents.add(emptyEvent);\n+      tmpDroppedEvents.add(event);\n       if (isDebugEnabled) {\n         logger.debug(\"added to tmpDroppedEvents event: {}\", event);\n       }\n"}}, {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "url": "https://github.com/apache/geode/commit/fcc1967afb0469d8c6fd38492c9de9ec71fff627", "message": "GEODE-8491: Remove cloning of dropped event before putting it in tmpDroppedEvents", "committedDate": "2020-09-14T16:02:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzMDg0MA==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488130840", "bodyText": "The IDE warnings here can be resolved by using List<AsyncInvocation<Void>>.", "author": "DonalEvans", "createdAt": "2020-09-14T18:17:05Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -1646,6 +1646,20 @@ public static void resumeSender(String senderId) {\n     }\n   }\n \n+  public static void stopSenderInVMsAsync(String senderId, VM... vms) {\n+    List<AsyncInvocation> tasks = new LinkedList<>();\n+    for (VM vm : vms) {\n+      tasks.add(vm.invokeAsync(() -> stopSender(senderId)));\n+    }\n+    for (AsyncInvocation invocation : tasks) {", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java\nindex cfc5b2cde8..883b31398e 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java\n\n@@ -1647,7 +1647,7 @@ public class WANTestBase extends DistributedTestCase {\n   }\n \n   public static void stopSenderInVMsAsync(String senderId, VM... vms) {\n-    List<AsyncInvocation> tasks = new LinkedList<>();\n+    List<AsyncInvocation<Void>> tasks = new LinkedList<>();\n     for (VM vm : vms) {\n       tasks.add(vm.invokeAsync(() -> stopSender(senderId)));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNDg4Nw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488134887", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "author": "DonalEvans", "createdAt": "2020-09-14T18:24:18Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\nindex 75ed63d372..62c57a301e 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n\n@@ -370,7 +370,7 @@ public class ParallelWANPropagationLoopBackDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNTA4Ng==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488135086", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "author": "DonalEvans", "createdAt": "2020-09-14T18:24:42Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\nindex 75ed63d372..62c57a301e 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n\n@@ -370,7 +370,7 @@ public class ParallelWANPropagationLoopBackDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MDI2Nw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488140267", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "author": "DonalEvans", "createdAt": "2020-09-14T18:34:10Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\nindex 75ed63d372..62c57a301e 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n\n@@ -370,7 +370,7 @@ public class ParallelWANPropagationLoopBackDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MTM5Mg==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488141392", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "author": "DonalEvans", "createdAt": "2020-09-14T18:36:05Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\nindex 75ed63d372..62c57a301e 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n\n@@ -370,7 +370,7 @@ public class ParallelWANPropagationLoopBackDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MTY3MQ==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488141671", "bodyText": "An exception is never thrown from this method, so this can be removed.", "author": "DonalEvans", "createdAt": "2020-09-14T18:36:35Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\nindex 75ed63d372..62c57a301e 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n\n@@ -370,7 +370,7 @@ public class ParallelWANPropagationLoopBackDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MjEwMw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488142103", "bodyText": "An exception is never thrown from this method, so this can be removed.", "author": "DonalEvans", "createdAt": "2020-09-14T18:37:26Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify tmpDroppedEvents is 0 at site-ny\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 1000));\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+\n+    // verify the secondary's queues are drained at site-ny\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped primary gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop one instance of the sender in NY simultaneously\n+   * Start the stopped instance of the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedPrimarySenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\nindex 75ed63d372..62c57a301e 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java\n\n@@ -370,7 +370,7 @@ public class ParallelWANPropagationLoopBackDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NTc0MQ==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488145741", "bodyText": "An exception is never thrown from this method, so this \"throws\" can be removed.", "author": "DonalEvans", "createdAt": "2020-09-14T18:44:10Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\nindex 09a390e7a2..e928ea5cf8 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n\n@@ -310,7 +310,7 @@ public class SerialWANPropagationsFeatureDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzA4Ng==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147086", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "author": "DonalEvans", "createdAt": "2020-09-14T18:46:39Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\nindex 09a390e7a2..e928ea5cf8 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n\n@@ -310,7 +310,7 @@ public class SerialWANPropagationsFeatureDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzEwNw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147107", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "author": "DonalEvans", "createdAt": "2020-09-14T18:46:41Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\nindex 09a390e7a2..e928ea5cf8 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n\n@@ -310,7 +310,7 @@ public class SerialWANPropagationsFeatureDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzM1NA==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147354", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "author": "DonalEvans", "createdAt": "2020-09-14T18:47:10Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\nindex 09a390e7a2..e928ea5cf8 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n\n@@ -310,7 +310,7 @@ public class SerialWANPropagationsFeatureDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzQ3Mw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147473", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "author": "DonalEvans", "createdAt": "2020-09-14T18:47:22Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\nindex 09a390e7a2..e928ea5cf8 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n\n@@ -310,7 +310,7 @@ public class SerialWANPropagationsFeatureDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzcxOQ==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147719", "bodyText": "An exception is never thrown from this method, so this \"throws\" can be removed.", "author": "DonalEvans", "createdAt": "2020-09-14T18:47:51Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\nindex 09a390e7a2..e928ea5cf8 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n\n@@ -310,7 +310,7 @@ public class SerialWANPropagationsFeatureDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0ODA1MQ==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488148051", "bodyText": "An exception is never thrown from this method, so this \"throws\" can be removed.", "author": "DonalEvans", "createdAt": "2020-09-14T18:48:28Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify tmpDroppedEvents is 0 at site-ny\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 1000));\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+\n+    // verify the secondary's queues are drained at site-ny\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped primary gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop one instance of the sender in NY simultaneously\n+   * Start the stopped instance of the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedPrimarySenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\nindex 09a390e7a2..e928ea5cf8 100644\n--- a/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n+++ b/geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java\n\n@@ -310,7 +310,7 @@ public class SerialWANPropagationsFeatureDUnitTest extends WANTestBase {\n    * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n    */\n   @Test\n-  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() {\n     Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n     Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1MjU0OA==", "url": "https://github.com/apache/geode/pull/5509#discussion_r488152548", "bodyText": "This line could be moved to immediately before the if (isDebugEnabled) check so that it's only executed if necessary rather than unnecessarily in the case that this.eventProcessor != null evaluates to true.", "author": "DonalEvans", "createdAt": "2020-09-14T18:56:27Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java", "diffHunk": "@@ -1118,6 +1115,18 @@ public void distribute(EnumListenerEvent operation, EntryEventImpl event,\n     }\n   }\n \n+  private void recordDroppedEvent(EntryEventImpl event) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();", "originalCommit": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java b/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java\nindex e2d29dc560..071974d22e 100644\n--- a/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java\n+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java\n\n@@ -1116,12 +1116,11 @@ public abstract class AbstractGatewaySender implements InternalGatewaySender, Di\n   }\n \n   private void recordDroppedEvent(EntryEventImpl event) {\n-    final boolean isDebugEnabled = logger.isDebugEnabled();\n     if (this.eventProcessor != null) {\n       this.eventProcessor.registerEventDroppedInPrimaryQueue(event);\n     } else {\n       tmpDroppedEvents.add(event);\n-      if (isDebugEnabled) {\n+      if (logger.isDebugEnabled()) {\n         logger.debug(\"added to tmpDroppedEvents event: {}\", event);\n       }\n     }\n"}}, {"oid": "aa901e3db98277d940ef3d049b46dd0835f35b30", "url": "https://github.com/apache/geode/commit/aa901e3db98277d940ef3d049b46dd0835f35b30", "message": "GEODE-8491: Some code cleanup after review", "committedDate": "2020-09-15T07:08:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTQ1Mw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r489081453", "bodyText": "In ConcurrentParallelGatewaySenderEventProcessor.registerEventDroppedInPrimaryQueue instead of calling sendQueueRemovalMesssageForDroppedEvent to send a ParallelQueueRemovalMessage inline, can you call ParallelGatewaySenderQueue.addRemovedEvent and let the BatchRemovalThread handle sending the message?\nSomething like:\n...\nint bucketId = PartitionedRegionHelper.getHashKey((EntryOperation) droppedEvent);\nboolean isPrimary = prQ.getRegionAdvisor().getBucketAdvisor(bucketId).isPrimary();\nif (isPrimary) {\n  long shadowKey = droppedEvent.getTailKey();\n  ParallelGatewaySenderQueue pgsq = (ParallelGatewaySenderQueue) cpgsq.getQueueByBucket(bucketId);\n  pgsq.addRemovedEvent(prQ, bucketId, shadowKey);\n  this.sender.getStatistics().incEventsDroppedDueToPrimarySenderNotRunning();\n...\n``\nI didn't try this, but it seems like it should work.\n\nI'm not sure if the same idea would work for SerialGatewaySenderEventProcessor.sendBatchDestroyOperationForDroppedEvent since it has a different implementation.\n\nbtw - sendQueueRemovalMesssageForDroppedEvent has an extra 's'.", "author": "boglesby", "createdAt": "2020-09-15T23:54:01Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java", "diffHunk": "@@ -1118,6 +1115,17 @@ public void distribute(EnumListenerEvent operation, EntryEventImpl event,\n     }\n   }\n \n+  private void recordDroppedEvent(EntryEventImpl event) {\n+    if (this.eventProcessor != null) {\n+      this.eventProcessor.registerEventDroppedInPrimaryQueue(event);", "originalCommit": "aa901e3db98277d940ef3d049b46dd0835f35b30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5NTU1OQ==", "url": "https://github.com/apache/geode/pull/5509#discussion_r489395559", "bodyText": "@boglesby I have made the change you have proposed for the parallel gateway sender case. You can check it in the new commit. Nevertheless, this change it requires that the BatchRemoval thread is not shutdown when the gateway sender is stopped. Is there any problem with not stopping the BatchRemoval thread when the sender is stopped?\nRegarding the SerialGatewaySender, I think I found a way of doing it which consists of changing the following call in SerialGatewaySenderEventProcessor.registerEventDroppedInPrimaryQueue():\nthis.processors.get(index).sendBatchDestroyOperationForDroppedEvent(droppedEvent, index);\nto this one:\nthis.processors.get(index).sendBatchDestroyOperationForDroppedEvent(droppedEvent, index);\nAnd adding the following method to SerialGatewaySenderQueue:\npublic void addRemovedEvent(EntryEventImpl droppedEvent) { lock.writeLock().lock(); lastDispatchedKey = droppedEvent.getTailKey(); notifyAll(); lock.writeLock().unlock(); }\nThe problem is that I did not find any test case to verify that it worked correctly. I ran the tests in SerialWANPropagationsFeatureDUnitTest and it did not matter if I used the original solution, the new solution or even removed the sending of batch destroy operation. I looks as if it were not necessary. That's why I did not dare to add the change. Any idea?", "author": "albertogpz", "createdAt": "2020-09-16T12:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU2NTU4OA==", "url": "https://github.com/apache/geode/pull/5509#discussion_r489565588", "bodyText": "Oh, I didn't think about the BatchRemoval thread not being there. I'm not really sure the consequences of keeping that thread around. I just seems better for performance to not send a message on every operation, and instead batch them up. Maybe the behavior can be something like: If that cache is closing, stop the BRM; otherwise keep it around to process these messages.", "author": "boglesby", "createdAt": "2020-09-16T16:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI3MDExMw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r490270113", "bodyText": "How could I know if the cache is closing from inside the stop method of the ParallelGatewaySender? Is there a way?", "author": "albertogpz", "createdAt": "2020-09-17T14:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA4MDQ1OQ==", "url": "https://github.com/apache/geode/pull/5509#discussion_r492080459", "bodyText": "@boglesby I reverted the change about letting the batch removal thread remove the dropped events because I did not find a way to stop the thread when the cache was closing.\n@boglesby and @gesterzhou , could you please approve the PR if you are ok with the changes? Otherwise, please let me know what else should be changed.", "author": "albertogpz", "createdAt": "2020-09-21T14:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEzODAyMw==", "url": "https://github.com/apache/geode/pull/5509#discussion_r495138023", "bodyText": "@boglesby and @gesterzhou, friendly reminder :-)", "author": "albertogpz", "createdAt": "2020-09-25T17:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTQ1Mw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "142b7aa3a71a97cf13d27072cf43068a86c2a839", "url": "https://github.com/apache/geode/commit/142b7aa3a71a97cf13d27072cf43068a86c2a839", "message": "GEODE-8491: Call removeEvent instead of sending batch removal message directly for ParallelGatewaySender", "committedDate": "2020-09-16T08:32:49Z", "type": "commit"}, {"oid": "c5af588b8df1b9af8d7b54bc3d2381f2ed49765a", "url": "https://github.com/apache/geode/commit/c5af588b8df1b9af8d7b54bc3d2381f2ed49765a", "message": "Revert \"GEODE-8491: Call removeEvent instead of sending batch removal message directly for ParallelGatewaySender\"\n\nThis reverts commit 142b7aa3a71a97cf13d27072cf43068a86c2a839.", "committedDate": "2020-09-21T12:06:27Z", "type": "commit"}]}