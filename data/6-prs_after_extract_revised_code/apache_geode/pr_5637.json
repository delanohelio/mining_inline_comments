{"pr_number": 5637, "pr_title": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector", "pr_createdAt": "2020-10-17T14:54:26Z", "pr_url": "https://github.com/apache/geode/pull/5637", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517706539", "bodyText": "Is this replacement of & necessary?", "author": "jchen21", "createdAt": "2020-11-05T00:14:20Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+\n+import org.junit.Rule;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class CacheXmlJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzAzMA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153030", "bodyText": "When expanding Java system properties like <jndi-binding ... connection-url=\"${TestDataSourceUrl}\"> in cache.xml and the connection string contains '?' such as jdbc:mysql://localhost:3306?user=root&useSSL=false, if the connection string is not escaped, an error will occur when connecting to the database.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxOTI4OQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520019289", "bodyText": "\ud83d\udc4d", "author": "jchen21", "createdAt": "2020-11-09T18:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\nindex f346b0dcd1..17fe5e6362 100644\n--- a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n+++ b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n\n@@ -15,21 +15,81 @@\n package org.apache.geode.connectors.jdbc;\n \n import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n \n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n import org.junit.Rule;\n+import org.junit.Test;\n import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n \n import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n \n-public class CacheXmlJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n \n   @Rule\n   public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n \n-  @Override\n-  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n-      throws Exception {\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName) {\n     String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n     System.setProperty(\"TestDataSourceUrl\", url);\n     InternalCache cache =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517713217", "bodyText": "To create region, data store and mapping etc, I would recommend using GfshRule and execute gfsh commands, instead of calling the internal functions that implement the gfsh commands.", "author": "jchen21", "createdAt": "2020-11-05T00:36:40Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/GfshJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.configuration.JndiBindingsType;\n+import org.apache.geode.cache.configuration.RegionConfig;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingFunction;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunction;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.configuration.RegionType;\n+import org.apache.geode.management.internal.cli.commands.CreateJndiBindingCommand;\n+import org.apache.geode.management.internal.cli.functions.CreateJndiBindingFunction;\n+import org.apache.geode.management.internal.cli.functions.CreateRegionFunctionArgs;\n+import org.apache.geode.management.internal.cli.functions.RegionCreateFunction;\n+import org.apache.geode.management.internal.configuration.converters.RegionConverter;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+\n+public class GfshJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\").create();\n+    Set<DistributedMember> targetMembers = findMembers(cache, null, null);\n+\n+    CliFunctionResult createRegionFuncResult = executeCreateRegionFunction(targetMembers);", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzA5NQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153095", "bodyText": "I understand that it is recommended to use GfshRule.\nWith this change, I would like to achieve the same behavior in gfsh command and cache.xml.\nSo I have implimented JdbcMappingIntegrationTest class to standardize tests.\nI have used the internal functions because some parts of GfshRule can not verify in case of errors.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4OTE5NA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520089194", "bodyText": "This is an integration test, which tests the behavior of gfsh commands from a user's point view. I don't think this test should use internal functions of specific gfsh command's implementation. The users should not worry about the gfsh implementation.\nAnd I don't recommend using a lot of System.out.println in the tests. Is that for debugging purpose?\nIf you have to use internal functions, I would recommend testing them in a unit test, or some other integration test or dunit that specifically test a specific gfsh command.  You said you use the internal functions because some parts of GfshRule can not verify in case of errors. Can you give a specific example?", "author": "jchen21", "createdAt": "2020-11-09T20:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzNzYwNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520637605", "bodyText": "OK, I will try to implement the test using gfsh commands.", "author": "masaki-yamakawa", "createdAt": "2020-11-10T15:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDc1MQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884751", "bodyText": "I tried to implement the test using GfshRule, but I couldn't do it because I use cache.getService(JdbcConnectorService.class) to get the implementation of JdbcConnectorService to verify FieldMapping, and GfshRule does not allow it.\nAnd I would like to make the condition setting part and the verification part of CacheXmlJdbcMappingIntegrationTest and GfshXmlJdbcMappingIntegrationTest common.\nSo I plan one of the following.\n\nChange the GfshJdbcMappingIntegrationTest to FunctionJdbcMappingIntegrationTest.\nRemove GfshJdbcMappingIntegrationTest. (I can use the describe jdbc-mapping command to verify it, but I don't think I should do that because it would reduce maintainability and make it difficult to commonize tests.)", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI3MzQxNA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r554273414", "bodyText": "If you want to use gfsh and verify the field mapping, CreateMappingCommandDUnitTest has some good examples which use GfshCommandRule (not GfshRule though). You can see if you would like add some more tests there. Typically, a DUnit is used for testing that involves gfsh commands. In the DUnit, you create a cluster with locator and server(s) and execute the gfsh commands.\nUsing the functions that implement a specific gfsh command in integration tests is discouraged. That is not what an integration test should do.", "author": "jchen21", "createdAt": "2021-01-09T01:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzMzI0Nw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555133247", "bodyText": "I removed GfshJdbcMappingIntegrationTest because I no longer need to impliment it.", "author": "masaki-yamakawa", "createdAt": "2021-01-11T15:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/GfshJdbcMappingIntegrationTest.java b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/GfshJdbcMappingIntegrationTest.java\ndeleted file mode 100644\nindex 63cd27afab..0000000000\n--- a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/GfshJdbcMappingIntegrationTest.java\n+++ /dev/null\n\n@@ -1,208 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n- * agreements. See the NOTICE file distributed with this work for additional information regarding\n- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n- * copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package org.apache.geode.connectors.jdbc;\n-\n-import java.lang.reflect.Constructor;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Set;\n-\n-import org.apache.geode.cache.CacheFactory;\n-import org.apache.geode.cache.configuration.JndiBindingsType;\n-import org.apache.geode.cache.configuration.RegionConfig;\n-import org.apache.geode.cache.execute.Function;\n-import org.apache.geode.cache.execute.ResultCollector;\n-import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingFunction;\n-import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunction;\n-import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n-import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n-import org.apache.geode.distributed.DistributedMember;\n-import org.apache.geode.internal.cache.InternalCache;\n-import org.apache.geode.management.configuration.RegionType;\n-import org.apache.geode.management.internal.cli.commands.CreateJndiBindingCommand;\n-import org.apache.geode.management.internal.cli.functions.CreateJndiBindingFunction;\n-import org.apache.geode.management.internal.cli.functions.CreateRegionFunctionArgs;\n-import org.apache.geode.management.internal.cli.functions.RegionCreateFunction;\n-import org.apache.geode.management.internal.configuration.converters.RegionConverter;\n-import org.apache.geode.management.internal.functions.CliFunctionResult;\n-import org.apache.geode.management.internal.util.ManagementUtils;\n-\n-public class GfshJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n-\n-  @Override\n-  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n-      throws Exception {\n-    InternalCache cache =\n-        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\").create();\n-    Set<DistributedMember> targetMembers = findMembers(cache, null, null);\n-\n-    CliFunctionResult createRegionFuncResult = executeCreateRegionFunction(targetMembers);\n-    System.out.println(\"createRegionFuncResult=\" + createRegionFuncResult);\n-\n-    CliFunctionResult createDataStoreFuncResult =\n-        executeCreateJndiBindingFunction(targetMembers, dbRule.getConnectionUrl());\n-    System.out.println(\"createDataStoreFuncArgs=\" + createDataStoreFuncResult);\n-\n-    CliFunctionResult createMappingFuncResult =\n-        executeCreateMappingFunction(Employee.class.getName(), targetMembers);\n-    System.out.println(\"createMappingFuncResult=\" + createMappingFuncResult);\n-\n-    return cache;\n-  }\n-\n-  @Override\n-  protected InternalCache createCacheAndCreateJdbcMappingWithWrongDataSource(\n-      String cacheXmlTestName) throws Exception {\n-    InternalCache cache =\n-        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\").create();\n-    Set<DistributedMember> targetMembers = findMembers(cache, null, null);\n-\n-    CliFunctionResult createRegionFuncResult = executeCreateRegionFunction(targetMembers);\n-    System.out.println(\"createRegionFuncResult=\" + createRegionFuncResult);\n-\n-    CliFunctionResult createDataStoreFuncResult =\n-        executeCreateJndiBindingFunction(targetMembers, \"jdbc:mysql://localhost/test\");\n-    System.out.println(\"createDataStoreFuncArgs=\" + createDataStoreFuncResult);\n-\n-    CliFunctionResult createMappingFuncResult =\n-        executeCreateMappingFunction(Employee.class.getName(), targetMembers);\n-    System.out.println(\"createMappingFuncResult=\" + createMappingFuncResult);\n-\n-    return cache;\n-  }\n-\n-  @Override\n-  protected InternalCache createCacheAndCreateJdbcMappingWithWrongPdxName(String cacheXmlTestName)\n-      throws Exception {\n-    InternalCache cache =\n-        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\").create();\n-    Set<DistributedMember> targetMembers = findMembers(cache, null, null);\n-\n-    CliFunctionResult createRegionFuncResult = executeCreateRegionFunction(targetMembers);\n-    System.out.println(\"createRegionFuncResult=\" + createRegionFuncResult);\n-\n-    CliFunctionResult createDataStoreFuncResult =\n-        executeCreateJndiBindingFunction(targetMembers, dbRule.getConnectionUrl());\n-    System.out.println(\"createDataStoreFuncArgs=\" + createDataStoreFuncResult);\n-\n-    CliFunctionResult createMappingFuncResult =\n-        executeCreateMappingFunction(\"org.apache.geode.connectors.jdbc.NoPdx\", targetMembers);\n-    System.out.println(\"createMappingFuncResult=\" + createMappingFuncResult);\n-\n-    return cache;\n-  }\n-\n-  private Set<DistributedMember> findMembers(InternalCache cache, String[] groups,\n-      String[] members) {\n-    return ManagementUtils.findMembers(groups, members, cache);\n-  }\n-\n-  private CliFunctionResult executeFunction(Function<?> function, Object args,\n-      Set<DistributedMember> targetMembers) {\n-    ResultCollector<?, ?> rc = ManagementUtils.executeFunction(function, args, targetMembers);\n-    List<CliFunctionResult> results = CliFunctionResult.cleanResults((List<?>) rc.getResult());\n-    return results.size() > 0 ? results.get(0) : null;\n-  }\n-\n-  private CliFunctionResult executeCreateRegionFunction(Set<DistributedMember> targetMembers) {\n-    RegionConfig regionConfig = new RegionConfig();\n-    regionConfig.setName(REGION_NAME);\n-    regionConfig.setType(RegionType.REPLICATE);\n-    regionConfig.setRegionAttributes(\n-        new RegionConverter().createRegionAttributesByType(RegionType.REPLICATE.name()));\n-    CreateRegionFunctionArgs createRegionFuncArgs =\n-        new CreateRegionFunctionArgs(REGION_NAME, regionConfig, false);\n-    CliFunctionResult createRegionFuncResult =\n-        executeFunction(RegionCreateFunction.INSTANCE, createRegionFuncArgs, targetMembers);\n-    return createRegionFuncResult;\n-  }\n-\n-  private CliFunctionResult executeCreateJndiBindingFunction(Set<DistributedMember> targetMembers,\n-      String connectionUrl) {\n-    JndiBindingsType.JndiBinding jndiConfig = new JndiBindingsType.JndiBinding();\n-    jndiConfig.setConnectionUrl(connectionUrl);\n-    jndiConfig.setJndiName(DATA_SOURCE_NAME);\n-    jndiConfig.setType(CreateJndiBindingCommand.DATASOURCE_TYPE.SIMPLE.getType());\n-    Object[] createDataStoreFuncArgs = new Object[] {jndiConfig, true};\n-    CliFunctionResult createDataStoreFuncResult =\n-        executeFunction(new CreateJndiBindingFunction(), createDataStoreFuncArgs, targetMembers);\n-    return createDataStoreFuncResult;\n-  }\n-\n-  private CliFunctionResult executeCreateMappingFunction(String pdxClassName,\n-      Set<DistributedMember> targetMembers) throws Exception {\n-    RegionMapping mapping = new RegionMapping(REGION_NAME, pdxClassName,\n-        REGION_TABLE_NAME, DATA_SOURCE_NAME, \"id\", null, null);\n-    Object[] createMappingPreconditionCheckFuncArgs = new Object[] {mapping, null, null};\n-    CliFunctionResult createMappingPreconditionCheckFuncResult = executeFunction(\n-        new CreateMappingPreconditionCheckFunction(), createMappingPreconditionCheckFuncArgs,\n-        Collections.singleton(targetMembers.iterator().next()));\n-    System.out.println(\n-        \"createMappingPreconditionCheckFuncResult=\" + createMappingPreconditionCheckFuncResult);\n-\n-    if (createMappingPreconditionCheckFuncResult.isSuccessful()) {\n-      Object[] preconditionOutput =\n-          (Object[]) createMappingPreconditionCheckFuncResult.getResultObject();\n-      String computedIds = (String) preconditionOutput[0];\n-      if (computedIds != null) {\n-        mapping.setIds(computedIds);\n-      }\n-      @SuppressWarnings(\"unchecked\")\n-      List<FieldMapping> fieldMappings = (ArrayList<FieldMapping>) preconditionOutput[1];\n-      for (FieldMapping fieldMapping : fieldMappings) {\n-        mapping.addFieldMapping(fieldMapping);\n-      }\n-    } else {\n-      if (createMappingPreconditionCheckFuncResult.getResultObject() instanceof Exception) {\n-        throw (Exception) createMappingPreconditionCheckFuncResult.getResultObject();\n-      }\n-      throw new RuntimeException();\n-    }\n-\n-    Object[] createMappingFuncArgs = new Object[] {mapping, true};\n-    Constructor<CreateMappingFunction> constructor =\n-        CreateMappingFunction.class.getDeclaredConstructor();\n-    constructor.setAccessible(true);\n-    CreateMappingFunction createMappingFunction = constructor.newInstance();\n-    CliFunctionResult createMappingFuncResult =\n-        executeFunction(createMappingFunction, createMappingFuncArgs, targetMembers);\n-    return createMappingFuncResult;\n-  }\n-\n-  @Override\n-  protected String getConnectWrongDataSourceMessage() {\n-    return String.format(\n-        \"JDBC data-source named \\\"%s\\\" not found. Create it with gfsh 'create data-source --pooled --name=%s'.\",\n-        DATA_SOURCE_NAME, DATA_SOURCE_NAME);\n-  }\n-\n-  @Override\n-  protected Class<?> getPdxNotExistsExceptionClass() {\n-    return JdbcConnectorException.class;\n-  }\n-\n-  @Override\n-  protected String getPdxNotExistsMessage() {\n-    return \"The pdx class \\\"org.apache.geode.connectors.jdbc.NoPdx\\\" could not be loaded because: java.lang.ClassNotFoundException: org.apache.geode.connectors.jdbc.NoPdx\";\n-  }\n-\n-  @Override\n-  public void mappingFailureWhenFieldMappingAndTableMetaDataUnMatch() throws Exception {}\n-\n-  @Override\n-  public void mappingSuccessWhenPdxFieldAndTableMetaDataUnMatchButFieldMappingMatch()\n-      throws Exception {}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719407", "bodyText": "Why this class has to be public?", "author": "jchen21", "createdAt": "2020-11-05T00:57:21Z", "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1142,7 +1142,7 @@ public void createMappingWithExistingQueueFails() {\n             + \" must not already exist.\");\n   }\n \n-  private static class Employee implements PdxSerializable {\n+  public static class Employee implements PdxSerializable {", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzE4MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153180", "bodyText": "In the test, CreatemappingPreconditionCheckFunction is called and executed on several JVMs(Distributed members).\nIn this Function, PDX class such as Employee is instantiated, so I need to be able to access this class even if it runs on another JVM.\nIf it is in private scope, the following exceptions will be thrown\n[error 2020/11/07 12:08:19.411 JST <Function Execution Processor2> tid=69] Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName because it did not have a public zero arg constructor. Details: java.lang.IllegalAccessException: Class org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl can not access a member of class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName with modifiers \"public\"\norg.apache.geode.connectors.jdbc.JdbcConnectorException: Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName because it did not have a public zero arg constructor. Details: java.lang.IllegalAccessException: Class org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl can not access a member of class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName with modifiers \"public\"\n    at org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl.createInstance(JdbcConnectorServiceImpl.java:361)\n    at org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl.generatePdxTypeForClass(JdbcConnectorServiceImpl.java:334)\n    at org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl.getPdxTypeForClass(JdbcConnectorServiceImpl.java:320)\n    at org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunction.executeFunction(CreateMappingPreconditionCheckFunction.java:74)\n    at org.apache.geode.management.cli.CliFunction.execute(CliFunction.java:37)\n    ...\n\nOther similar tests like CreateMapingCommandForProxyRegionDUnitTest are also public scope.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI3MDg5Mw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r554270893", "bodyText": "On the surface, it seems a trivial change from private to public, in order to fix the exception.  However, under the hood, it is doing unnecessary serialization and deserialization of the Employee class. Because getPdxTypeForClass(), generatePdxTypeForClass()  and createInstance() are moved from CreateMappingPreconditionCheckFunction to JdbcConnectorServiceImpl, which is probably because you want to use these methods in RegionMappingConfiguration.\nI would recommend keeping getPdxTypeForClass(), generatePdxTypeForClass()  and createInstance() in CreateMappingPreconditionCheckFunction. And in RegionMappingConfiguration, implement similar methods. Though it looks like duplicating the code, it does avoid unnecessary serialization and deserialization of user defined classes like Employee, which is more important.\nAnd I don't think adding more methods to JdbcConnectorService is necessary. e.g. createDefaultFieldMapping() is something you want to automatically achieve for the users, so it is not necessary be exposed as an API. Just put it as a private method in RegionMappingConfiguration should be good. The same reason applies for getTableMetaDataView() and getPdxTypeForClass.  Basically, keep JdbcConnectorService unchanged.", "author": "jchen21", "createdAt": "2021-01-09T01:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzMjU2OQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555132569", "bodyText": "Thank you for your detailed explanation. I have reverted the CreateMappingPreconditionCheckFunction and JdbcConnectorService to the original source code. And I have implemented similar methods in RegionMappingConfiguration.", "author": "masaki-yamakawa", "createdAt": "2021-01-11T15:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java b/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\nindex 33a3de9ea1..57c58c1243 100644\n--- a/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\n+++ b/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\n\n@@ -1142,7 +1142,7 @@ public class CreateMappingCommandDUnitTest {\n             + \" must not already exist.\");\n   }\n \n-  public static class Employee implements PdxSerializable {\n+  private static class Employee implements PdxSerializable {\n \n     private String id;\n     private String name;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY1Mg==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719652", "bodyText": "Why this class has to be public?", "author": "jchen21", "createdAt": "2020-11-05T00:58:09Z", "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1185,7 +1185,7 @@ public void fromData(PdxReader reader) {\n     }\n   }\n \n-  private static class EmployeeNumeric implements PdxSerializerObject {\n+  public static class EmployeeNumeric implements PdxSerializerObject {", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzI0OA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153248", "bodyText": "The reason is the same as previous one.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java b/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\nindex 33a3de9ea1..57c58c1243 100644\n--- a/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\n+++ b/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\n\n@@ -1185,7 +1185,7 @@ public class CreateMappingCommandDUnitTest {\n     }\n   }\n \n-  public static class EmployeeNumeric implements PdxSerializerObject {\n+  private static class EmployeeNumeric implements PdxSerializerObject {\n \n     private String id;\n     private String name;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY4Mw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719683", "bodyText": "Why this class has to be public?", "author": "jchen21", "createdAt": "2020-11-05T00:58:16Z", "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1234,7 +1234,7 @@ void setRefid(long refid) {\n     }\n   }\n \n-  private static class IdAndName implements PdxSerializable {\n+  public static class IdAndName implements PdxSerializable {", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzI1Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153256", "bodyText": "The reason is the same as previous one.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java b/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\nindex 33a3de9ea1..57c58c1243 100644\n--- a/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\n+++ b/geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java\n\n@@ -1234,7 +1234,7 @@ public class CreateMappingCommandDUnitTest {\n     }\n   }\n \n-  public static class IdAndName implements PdxSerializable {\n+  private static class IdAndName implements PdxSerializable {\n \n     private String id;\n     private String name;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517721135", "bodyText": "The data source has nothing to do with table metadata or region name. I recommend removing this line of error message.", "author": "jchen21", "createdAt": "2020-11-05T01:03:12Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java", "diffHunk": "@@ -210,4 +224,152 @@ private TableMetaDataView getTableMetaDataView(RegionMapping regionMapping,\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n+\n+  @Override\n+  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzMxMg==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153312", "bodyText": "The data source is used to get the table metadata.\nI would like to confirm your suggestion.\nYour suggestion is the following, right?\nif (dataSource == null) {\n//  throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n//      + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n  throw new JdbcConnectorException();\n}", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMzU4OA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520023588", "bodyText": "I was trying to say:\nif (dataSource == null) {\n      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName());\n}\n\nIf you would like to provide more information,\nif (dataSource == null) {\n      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getTableName() + \"\\\"\");\n}\n\nNote that it is regionMapping.getTableName(), not regionMapping.getRegionName().", "author": "jchen21", "createdAt": "2020-11-09T18:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzNzg3Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520637876", "bodyText": "Thank you.\nI would like to fix it as you suggested.", "author": "masaki-yamakawa", "createdAt": "2020-11-10T15:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDE0OA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884148", "bodyText": "I have fixed it.", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java\nindex 6e6b5a936d..cd28c72a38 100644\n--- a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java\n+++ b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java\n\n@@ -224,152 +210,4 @@ public class JdbcConnectorServiceImpl implements JdbcConnectorService {\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n-\n-  @Override\n-  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n-    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n-    if (dataSource == null) {\n-      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n-          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n-    }\n-    return getTableMetaDataView(regionMapping, dataSource);\n-  }\n-\n-  @Override\n-  public List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n-      PdxType pdxType) {\n-    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n-    if (dataSource == null) {\n-      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n-          + \"\\\" found when creating mapping \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n-    }\n-    try (Connection connection = dataSource.getConnection()) {\n-      TableMetaDataView tableMetaData = getTableMetaDataView(regionMapping, dataSource);\n-      return createDefaultFieldMapping(regionMapping, pdxType, tableMetaData);\n-    } catch (SQLException e) {\n-      throw JdbcConnectorException.createException(e);\n-    }\n-  }\n-\n-  @Override\n-  public List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n-      PdxType pdxType, TableMetaDataView tableMetaDataView) {\n-\n-    // TODO the table name returned in tableMetaData may be different than\n-    // the table name specified on the command line at this point.\n-    // Do we want to update the region mapping to hold the \"real\" table name\n-    List<FieldMapping> fieldMappings = new ArrayList<>();\n-    Set<String> columnNames = tableMetaDataView.getColumnNames();\n-    if (columnNames.size() != pdxType.getFieldCount()) {\n-      throw new JdbcConnectorException(\n-          \"The table and pdx class must have the same number of columns/fields. But the table has \"\n-              + columnNames.size()\n-              + \" columns and the pdx class has \" + pdxType.getFieldCount() + \" fields.\");\n-    }\n-    List<PdxField> pdxFields = pdxType.getFields();\n-    for (String jdbcName : columnNames) {\n-      boolean isNullable = tableMetaDataView.isColumnNullable(jdbcName);\n-      JDBCType jdbcType = tableMetaDataView.getColumnDataType(jdbcName);\n-      FieldMapping fieldMapping =\n-          createFieldMapping(jdbcName, jdbcType.getName(), isNullable, pdxFields);\n-      fieldMappings.add(fieldMapping);\n-    }\n-    return fieldMappings;\n-  }\n-\n-  private FieldMapping createFieldMapping(String jdbcName, String jdbcType, boolean jdbcNullable,\n-      List<PdxField> pdxFields) {\n-    String pdxName = null;\n-    String pdxType = null;\n-    for (PdxField pdxField : pdxFields) {\n-      if (pdxField.getFieldName().equals(jdbcName)) {\n-        pdxName = pdxField.getFieldName();\n-        pdxType = pdxField.getFieldType().name();\n-        break;\n-      }\n-    }\n-    if (pdxName == null) {\n-      // look for one inexact match\n-      for (PdxField pdxField : pdxFields) {\n-        if (pdxField.getFieldName().equalsIgnoreCase(jdbcName)) {\n-          if (pdxName != null) {\n-            throw new JdbcConnectorException(\n-                \"More than one PDX field name matched the column name \\\"\" + jdbcName + \"\\\"\");\n-          }\n-          pdxName = pdxField.getFieldName();\n-          pdxType = pdxField.getFieldType().name();\n-        }\n-      }\n-    }\n-    if (pdxName == null) {\n-      throw new JdbcConnectorException(\n-          \"No PDX field name matched the column name \\\"\" + jdbcName + \"\\\"\");\n-    }\n-    return new FieldMapping(pdxName, pdxType, jdbcName, jdbcType, jdbcNullable);\n-  }\n-\n-  @Override\n-  public PdxType getPdxTypeForClass(Cache cache, Class<?> clazz) {\n-    InternalCache internalCache = (InternalCache) cache;\n-    TypeRegistry typeRegistry = internalCache.getPdxRegistry();\n-\n-    PdxType result = typeRegistry.getExistingTypeForClass(clazz);\n-    if (result != null) {\n-      return result;\n-    }\n-    return generatePdxTypeForClass(internalCache, typeRegistry, clazz);\n-  }\n-\n-  /**\n-   * Generates and returns a PdxType for the given class.\n-   * The generated PdxType is also stored in the TypeRegistry.\n-   *\n-   * @param cache used to generate pdx type\n-   * @param clazz the class to generate a PdxType for\n-   * @return the generated PdxType\n-   * @throws JdbcConnectorException if a PdxType can not be generated\n-   */\n-  PdxType generatePdxTypeForClass(InternalCache cache, TypeRegistry typeRegistry,\n-      Class<?> clazz) {\n-    Object object = createInstance(clazz);\n-    try {\n-      cache.registerPdxMetaData(object);\n-    } catch (SerializationException ex) {\n-      String className = clazz.getName();\n-      ReflectionBasedAutoSerializer serializer =\n-          getReflectionBasedAutoSerializer(\"\\\\Q\" + className + \"\\\\E\");\n-      PdxWriter writer = createPdxWriter(typeRegistry, object);\n-      boolean result = serializer.toData(object, writer);\n-      if (!result) {\n-        throw new JdbcConnectorException(\n-            \"Could not generate a PdxType using the ReflectionBasedAutoSerializer for the class  \"\n-                + clazz.getName() + \" after failing to register pdx metadata due to \"\n-                + ex.getMessage() + \". Check the server log for details.\");\n-      }\n-    }\n-    // serialization will leave the type in the registry\n-    return typeRegistry.getExistingTypeForClass(clazz);\n-  }\n-\n-  private Object createInstance(Class<?> clazz) {\n-    try {\n-      Constructor<?> ctor = clazz.getConstructor();\n-      return ctor.newInstance(new Object[] {});\n-    } catch (NoSuchMethodException | SecurityException | InstantiationException\n-        | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n-      throw new JdbcConnectorException(\n-          \"Could not generate a PdxType for the class \" + clazz.getName()\n-              + \" because it did not have a public zero arg constructor. Details: \" + ex);\n-    }\n-  }\n-\n-  // unit test mocks this method\n-  ReflectionBasedAutoSerializer getReflectionBasedAutoSerializer(String className) {\n-    return new ReflectionBasedAutoSerializer(className);\n-  }\n-\n-  // unit test mocks this method\n-  PdxWriter createPdxWriter(TypeRegistry typeRegistry, Object object) {\n-    return new PdxWriterImpl(typeRegistry, object, new PdxOutputStream());\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTIxMQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517721211", "bodyText": "The data source has nothing to do with table metadata or region name. I recommend removing this line of error message.", "author": "jchen21", "createdAt": "2020-11-05T01:03:28Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java", "diffHunk": "@@ -210,4 +224,152 @@ private TableMetaDataView getTableMetaDataView(RegionMapping regionMapping,\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n+\n+  @Override\n+  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n+    }\n+    return getTableMetaDataView(regionMapping, dataSource);\n+  }\n+\n+  @Override\n+  public List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n+      PdxType pdxType) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when creating mapping \\\"\" + regionMapping.getRegionName() + \"\\\"\");", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDE5Mw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884193", "bodyText": "I have fixed it.", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTIxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java\nindex 6e6b5a936d..cd28c72a38 100644\n--- a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java\n+++ b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java\n\n@@ -224,152 +210,4 @@ public class JdbcConnectorServiceImpl implements JdbcConnectorService {\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n-\n-  @Override\n-  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n-    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n-    if (dataSource == null) {\n-      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n-          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n-    }\n-    return getTableMetaDataView(regionMapping, dataSource);\n-  }\n-\n-  @Override\n-  public List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n-      PdxType pdxType) {\n-    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n-    if (dataSource == null) {\n-      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n-          + \"\\\" found when creating mapping \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n-    }\n-    try (Connection connection = dataSource.getConnection()) {\n-      TableMetaDataView tableMetaData = getTableMetaDataView(regionMapping, dataSource);\n-      return createDefaultFieldMapping(regionMapping, pdxType, tableMetaData);\n-    } catch (SQLException e) {\n-      throw JdbcConnectorException.createException(e);\n-    }\n-  }\n-\n-  @Override\n-  public List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n-      PdxType pdxType, TableMetaDataView tableMetaDataView) {\n-\n-    // TODO the table name returned in tableMetaData may be different than\n-    // the table name specified on the command line at this point.\n-    // Do we want to update the region mapping to hold the \"real\" table name\n-    List<FieldMapping> fieldMappings = new ArrayList<>();\n-    Set<String> columnNames = tableMetaDataView.getColumnNames();\n-    if (columnNames.size() != pdxType.getFieldCount()) {\n-      throw new JdbcConnectorException(\n-          \"The table and pdx class must have the same number of columns/fields. But the table has \"\n-              + columnNames.size()\n-              + \" columns and the pdx class has \" + pdxType.getFieldCount() + \" fields.\");\n-    }\n-    List<PdxField> pdxFields = pdxType.getFields();\n-    for (String jdbcName : columnNames) {\n-      boolean isNullable = tableMetaDataView.isColumnNullable(jdbcName);\n-      JDBCType jdbcType = tableMetaDataView.getColumnDataType(jdbcName);\n-      FieldMapping fieldMapping =\n-          createFieldMapping(jdbcName, jdbcType.getName(), isNullable, pdxFields);\n-      fieldMappings.add(fieldMapping);\n-    }\n-    return fieldMappings;\n-  }\n-\n-  private FieldMapping createFieldMapping(String jdbcName, String jdbcType, boolean jdbcNullable,\n-      List<PdxField> pdxFields) {\n-    String pdxName = null;\n-    String pdxType = null;\n-    for (PdxField pdxField : pdxFields) {\n-      if (pdxField.getFieldName().equals(jdbcName)) {\n-        pdxName = pdxField.getFieldName();\n-        pdxType = pdxField.getFieldType().name();\n-        break;\n-      }\n-    }\n-    if (pdxName == null) {\n-      // look for one inexact match\n-      for (PdxField pdxField : pdxFields) {\n-        if (pdxField.getFieldName().equalsIgnoreCase(jdbcName)) {\n-          if (pdxName != null) {\n-            throw new JdbcConnectorException(\n-                \"More than one PDX field name matched the column name \\\"\" + jdbcName + \"\\\"\");\n-          }\n-          pdxName = pdxField.getFieldName();\n-          pdxType = pdxField.getFieldType().name();\n-        }\n-      }\n-    }\n-    if (pdxName == null) {\n-      throw new JdbcConnectorException(\n-          \"No PDX field name matched the column name \\\"\" + jdbcName + \"\\\"\");\n-    }\n-    return new FieldMapping(pdxName, pdxType, jdbcName, jdbcType, jdbcNullable);\n-  }\n-\n-  @Override\n-  public PdxType getPdxTypeForClass(Cache cache, Class<?> clazz) {\n-    InternalCache internalCache = (InternalCache) cache;\n-    TypeRegistry typeRegistry = internalCache.getPdxRegistry();\n-\n-    PdxType result = typeRegistry.getExistingTypeForClass(clazz);\n-    if (result != null) {\n-      return result;\n-    }\n-    return generatePdxTypeForClass(internalCache, typeRegistry, clazz);\n-  }\n-\n-  /**\n-   * Generates and returns a PdxType for the given class.\n-   * The generated PdxType is also stored in the TypeRegistry.\n-   *\n-   * @param cache used to generate pdx type\n-   * @param clazz the class to generate a PdxType for\n-   * @return the generated PdxType\n-   * @throws JdbcConnectorException if a PdxType can not be generated\n-   */\n-  PdxType generatePdxTypeForClass(InternalCache cache, TypeRegistry typeRegistry,\n-      Class<?> clazz) {\n-    Object object = createInstance(clazz);\n-    try {\n-      cache.registerPdxMetaData(object);\n-    } catch (SerializationException ex) {\n-      String className = clazz.getName();\n-      ReflectionBasedAutoSerializer serializer =\n-          getReflectionBasedAutoSerializer(\"\\\\Q\" + className + \"\\\\E\");\n-      PdxWriter writer = createPdxWriter(typeRegistry, object);\n-      boolean result = serializer.toData(object, writer);\n-      if (!result) {\n-        throw new JdbcConnectorException(\n-            \"Could not generate a PdxType using the ReflectionBasedAutoSerializer for the class  \"\n-                + clazz.getName() + \" after failing to register pdx metadata due to \"\n-                + ex.getMessage() + \". Check the server log for details.\");\n-      }\n-    }\n-    // serialization will leave the type in the registry\n-    return typeRegistry.getExistingTypeForClass(clazz);\n-  }\n-\n-  private Object createInstance(Class<?> clazz) {\n-    try {\n-      Constructor<?> ctor = clazz.getConstructor();\n-      return ctor.newInstance(new Object[] {});\n-    } catch (NoSuchMethodException | SecurityException | InstantiationException\n-        | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n-      throw new JdbcConnectorException(\n-          \"Could not generate a PdxType for the class \" + clazz.getName()\n-              + \" because it did not have a public zero arg constructor. Details: \" + ex);\n-    }\n-  }\n-\n-  // unit test mocks this method\n-  ReflectionBasedAutoSerializer getReflectionBasedAutoSerializer(String className) {\n-    return new ReflectionBasedAutoSerializer(className);\n-  }\n-\n-  // unit test mocks this method\n-  PdxWriter createPdxWriter(TypeRegistry typeRegistry, Object object) {\n-    return new PdxWriterImpl(typeRegistry, object, new PdxOutputStream());\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODAzNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517728035", "bodyText": "Since its implementation is just one line, why not inline it?", "author": "jchen21", "createdAt": "2020-11-05T01:27:09Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java", "diffHunk": "@@ -62,4 +77,17 @@ private void createRegionMapping(JdbcConnectorService service,\n       throw new InternalGemFireException(e);\n     }\n   }\n+\n+  private Class<?> loadPdxClass(String className) {\n+    try {\n+      return loadClass(className);", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzM1MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153350", "bodyText": "I have fixed this part.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEwMTA5Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520101096", "bodyText": "\ud83d\udc4d", "author": "jchen21", "createdAt": "2020-11-09T20:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java\nindex 72f7ae7f86..b8c7cbf5a0 100644\n--- a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java\n+++ b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java\n\n@@ -78,16 +97,157 @@ public class RegionMappingConfiguration implements Extension<Region<?, ?>> {\n     }\n   }\n \n+  protected List<FieldMapping> createDefaultFieldMapping(PdxType pdxType) {\n+    DataSource dataSource = getDataSource(mapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + mapping.getDataSourceName()\n+          + \"\\\" found when creating default field mapping\");\n+    }\n+    TableMetaDataManager manager = getTableMetaDataManager();\n+    try (Connection connection = dataSource.getConnection()) {\n+      TableMetaDataView tableMetaData = manager.getTableMetaDataView(connection, mapping);\n+      return createDefaultFieldMapping(pdxType, tableMetaData);\n+    } catch (SQLException e) {\n+      throw JdbcConnectorException.createException(e);\n+    }\n+  }\n+\n+  private List<FieldMapping> createDefaultFieldMapping(PdxType pdxType,\n+      TableMetaDataView tableMetaDataView) {\n+\n+    // TODO the table name returned in tableMetaData may be different than\n+    // the table name specified on the command line at this point.\n+    // Do we want to update the region mapping to hold the \"real\" table name\n+    List<FieldMapping> fieldMappings = new ArrayList<>();\n+    Set<String> columnNames = tableMetaDataView.getColumnNames();\n+    if (columnNames.size() != pdxType.getFieldCount()) {\n+      throw new JdbcConnectorException(\n+          \"The table and pdx class must have the same number of columns/fields. But the table has \"\n+              + columnNames.size()\n+              + \" columns and the pdx class has \" + pdxType.getFieldCount() + \" fields.\");\n+    }\n+    List<PdxField> pdxFields = pdxType.getFields();\n+    for (String jdbcName : columnNames) {\n+      boolean isNullable = tableMetaDataView.isColumnNullable(jdbcName);\n+      JDBCType jdbcType = tableMetaDataView.getColumnDataType(jdbcName);\n+      FieldMapping fieldMapping =\n+          createFieldMapping(jdbcName, jdbcType.getName(), isNullable, pdxFields);\n+      fieldMappings.add(fieldMapping);\n+    }\n+    return fieldMappings;\n+  }\n+\n+  private FieldMapping createFieldMapping(String jdbcName, String jdbcType, boolean jdbcNullable,\n+      List<PdxField> pdxFields) {\n+    String pdxName = null;\n+    String pdxType = null;\n+    for (PdxField pdxField : pdxFields) {\n+      if (pdxField.getFieldName().equals(jdbcName)) {\n+        pdxName = pdxField.getFieldName();\n+        pdxType = pdxField.getFieldType().name();\n+        break;\n+      }\n+    }\n+    if (pdxName == null) {\n+      // look for one inexact match\n+      for (PdxField pdxField : pdxFields) {\n+        if (pdxField.getFieldName().equalsIgnoreCase(jdbcName)) {\n+          if (pdxName != null) {\n+            throw new JdbcConnectorException(\n+                \"More than one PDX field name matched the column name \\\"\" + jdbcName + \"\\\"\");\n+          }\n+          pdxName = pdxField.getFieldName();\n+          pdxType = pdxField.getFieldType().name();\n+        }\n+      }\n+    }\n+    if (pdxName == null) {\n+      throw new JdbcConnectorException(\n+          \"No PDX field name matched the column name \\\"\" + jdbcName + \"\\\"\");\n+    }\n+    return new FieldMapping(pdxName, pdxType, jdbcName, jdbcType, jdbcNullable);\n+  }\n+\n+  protected PdxType getPdxTypeForClass(Cache cache, Class<?> clazz) {\n+    InternalCache internalCache = (InternalCache) cache;\n+    TypeRegistry typeRegistry = internalCache.getPdxRegistry();\n+\n+    PdxType result = typeRegistry.getExistingTypeForClass(clazz);\n+    if (result != null) {\n+      return result;\n+    }\n+    return generatePdxTypeForClass(internalCache, typeRegistry, clazz);\n+  }\n+\n+  /**\n+   * Generates and returns a PdxType for the given class.\n+   * The generated PdxType is also stored in the TypeRegistry.\n+   *\n+   * @param cache used to generate pdx type\n+   * @param clazz the class to generate a PdxType for\n+   * @return the generated PdxType\n+   * @throws JdbcConnectorException if a PdxType can not be generated\n+   */\n+  PdxType generatePdxTypeForClass(InternalCache cache, TypeRegistry typeRegistry,\n+      Class<?> clazz) {\n+    Object object = createInstance(clazz);\n+    try {\n+      cache.registerPdxMetaData(object);\n+    } catch (SerializationException ex) {\n+      String className = clazz.getName();\n+      ReflectionBasedAutoSerializer serializer =\n+          getReflectionBasedAutoSerializer(\"\\\\Q\" + className + \"\\\\E\");\n+      PdxWriter writer = createPdxWriter(typeRegistry, object);\n+      boolean result = serializer.toData(object, writer);\n+      if (!result) {\n+        throw new JdbcConnectorException(\n+            \"Could not generate a PdxType using the ReflectionBasedAutoSerializer for the class  \"\n+                + clazz.getName() + \" after failing to register pdx metadata due to \"\n+                + ex.getMessage() + \". Check the server log for details.\");\n+      }\n+    }\n+    // serialization will leave the type in the registry\n+    return typeRegistry.getExistingTypeForClass(clazz);\n+  }\n+\n+  private Object createInstance(Class<?> clazz) {\n+    try {\n+      Constructor<?> ctor = clazz.getConstructor();\n+      return ctor.newInstance(new Object[] {});\n+    } catch (NoSuchMethodException | SecurityException | InstantiationException\n+        | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n+      throw new JdbcConnectorException(\n+          \"Could not generate a PdxType for the class \" + clazz.getName()\n+              + \" because it did not have a public zero arg constructor. Details: \" + ex);\n+    }\n+  }\n+\n   private Class<?> loadPdxClass(String className) {\n     try {\n-      return loadClass(className);\n+      return ClassPathLoader.getLatest().forName(className);\n     } catch (ClassNotFoundException ex) {\n       throw new JdbcConnectorException(\n           \"The pdx class \\\"\" + className + \"\\\" could not be loaded because: \" + ex);\n     }\n   }\n \n-  private Class<?> loadClass(String className) throws ClassNotFoundException {\n-    return ClassPathLoader.getLatest().forName(className);\n+  // unit test mocks this method\n+  DataSource getDataSource(String dataSourceName) {\n+    return JNDIInvoker.getDataSource(dataSourceName);\n+  }\n+\n+  // unit test mocks this method\n+  ReflectionBasedAutoSerializer getReflectionBasedAutoSerializer(String className) {\n+    return new ReflectionBasedAutoSerializer(className);\n+  }\n+\n+  // unit test mocks this method\n+  PdxWriter createPdxWriter(TypeRegistry typeRegistry, Object object) {\n+    return new PdxWriterImpl(typeRegistry, object, new PdxOutputStream());\n+  }\n+\n+  // unit test mocks this method\n+  TableMetaDataManager getTableMetaDataManager() {\n+    return new TableMetaDataManager();\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517731786", "bodyText": "Why this test is removed?", "author": "jchen21", "createdAt": "2020-11-05T01:39:59Z", "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -172,16 +168,6 @@ public void executeFunctionThrowsIfDataSourceDoesNotExist() {\n             + DATA_SOURCE_NAME + \"'.\");\n   }\n \n-  @Test", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzM4MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153380", "bodyText": "I changed CreateMappingPreconditionCheckFunction class to use JdbcConnectorService.getTableMetaDataView(regionMapping).\nThis test covered by JdbcConnectorServiceTest.getTableMetaDataViewThrowsExceptionWhenGetConnectionHasSqlException.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNjY3MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520036670", "bodyText": "\ud83d\udc4d", "author": "jchen21", "createdAt": "2020-11-09T18:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java\nindex 2439176c5e..d7390e8a36 100644\n--- a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java\n+++ b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java\n\n@@ -168,6 +172,16 @@ public class CreateMappingPreconditionCheckFunctionTest {\n             + DATA_SOURCE_NAME + \"'.\");\n   }\n \n+  @Test\n+  public void executeFunctionThrowsIfDataSourceGetConnectionThrows() throws SQLException {\n+    String reason = \"connection failed\";\n+    when(dataSource.getConnection()).thenThrow(new SQLException(reason));\n+\n+    Throwable throwable = catchThrowable(() -> function.executeFunction(context));\n+\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(reason);\n+  }\n+\n   @Test\n   public void executeFunctionThrowsIfClassNotFound() throws ClassNotFoundException {\n     ClassNotFoundException ex = new ClassNotFoundException(\"class not found\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517734241", "bodyText": "Some functions of CreateMappingPreconditionCheckFunction are moved to JdbcConnectorServiceImpl. So if you remove this test here, there should be similar test coverage added in JdbcConnectorServiceTest. In JdbcConnectorServiceTest there are some tests that test ReflectionBasedAutoSerializer. However, those tests don't verify FieldMapping like this test.", "author": "jchen21", "createdAt": "2020-11-05T01:48:12Z", "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -306,45 +292,10 @@ public void executeFunctionThrowsGivenPdxSerializableWithNoZeroArgConstructor()\n             \"Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg because it did not have a public zero arg constructor. Details: java.lang.NoSuchMethodException: org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg.<init>()\");\n   }\n \n-  @Test", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzQxNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153415", "bodyText": "As you mentioned, I have moved some methods.\nIn addition, I have reduced the the particle size of the test.\nThe corresponding test for executionFuncationGivenNonPdxUsesReflectionBasedAutoSerializer is JdbcConnectorServiceTest.getPdxTypeForClassSucceedsWithGivenNonPdxUsesReflectionBasedAutoSerializer.\nThis test verify the PdxType. And then, the PdxType is specified to createDefaultFieldMapping to create the FieldMapping.\ncreateDefaultFieldMapping is tested with JdbcConnectorServiceTest.createDefaultFieldMappingXXX, which verify the FieldMapping at this level.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA1NzQwNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520057405", "bodyText": "I understand that. However, none of the JdbcConnectorServiceTest.createDefaultFieldMapping* uses ReflectionBasedAutoSerializer. Although those tests do verify the field mapping. I expect there is some test that uses ReflectionBasedAutoSerializer and verifies the field mapping as well, like the test deleted below.", "author": "jchen21", "createdAt": "2020-11-09T19:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzODQyNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520638425", "bodyText": "I will add the test using the ReflectionBasedAutoSerializer and verify the field mapping.", "author": "masaki-yamakawa", "createdAt": "2020-11-10T15:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDU3MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884570", "bodyText": "I have added mappingSuccessWhenFieldMappingsAreOmittedWithNonSerializedClass test method that uses ReflectionBasedAutoSerializer to JdbcMappingIntegrationTest", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java\nindex 2439176c5e..d7390e8a36 100644\n--- a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java\n+++ b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java\n\n@@ -292,10 +306,45 @@ public class CreateMappingPreconditionCheckFunctionTest {\n             \"Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg because it did not have a public zero arg constructor. Details: java.lang.NoSuchMethodException: org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg.<init>()\");\n   }\n \n+  @Test\n+  public void executeFunctionGivenNonPdxUsesReflectionBasedAutoSerializer() {\n+    Set<String> columnNames = new LinkedHashSet<>(singletonList(\"col1\"));\n+    when(tableMetaDataView.getColumnNames()).thenReturn(columnNames);\n+    when(tableMetaDataView.isColumnNullable(\"col1\")).thenReturn(false);\n+    when(tableMetaDataView.getColumnDataType(\"col1\")).thenReturn(JDBCType.DATE);\n+    PdxField pdxField1 = mock(PdxField.class);\n+    when(pdxField1.getFieldName()).thenReturn(\"COL1\");\n+    when(pdxField1.getFieldType()).thenReturn(FieldType.LONG);\n+    when(pdxType.getFieldCount()).thenReturn(1);\n+    when(pdxType.getFields()).thenReturn(singletonList(pdxField1));\n+    when(typeRegistry.getExistingTypeForClass(PdxClassDummy.class)).thenReturn(null)\n+        .thenReturn(pdxType);\n+    String domainClassNameInAutoSerializer = \"\\\\Q\" + PdxClassDummy.class.getName() + \"\\\\E\";\n+    ReflectionBasedAutoSerializer reflectionedBasedAutoSerializer =\n+        mock(ReflectionBasedAutoSerializer.class);\n+    PdxWriter pdxWriter = mock(PdxWriter.class);\n+    when(reflectionedBasedAutoSerializer.toData(any(), same(pdxWriter))).thenReturn(true);\n+    doReturn(reflectionedBasedAutoSerializer).when(function)\n+        .getReflectionBasedAutoSerializer(domainClassNameInAutoSerializer);\n+    doReturn(pdxWriter).when(function).createPdxWriter(same(typeRegistry), any());\n+    SerializationException ex = new SerializationException(\"test\");\n+    doThrow(ex).when(cache).registerPdxMetaData(any());\n+\n+    CliFunctionResult result = function.executeFunction(context);\n+\n+    assertThat(result.isSuccessful()).isTrue();\n+    verify(function).getReflectionBasedAutoSerializer(domainClassNameInAutoSerializer);\n+    ArrayList<FieldMapping> fieldsMappings = getFieldMappings(result);\n+    assertThat(fieldsMappings).hasSize(1);\n+    assertThat(fieldsMappings.get(0))\n+        .isEqualTo(\n+            new FieldMapping(\"COL1\", FieldType.LONG.name(), \"col1\", JDBCType.DATE.name(), false));\n+  }\n+\n   @SuppressWarnings(\"unchecked\")\n-  private List<FieldMapping> getFieldMappings(CliFunctionResult result) {\n+  private ArrayList<FieldMapping> getFieldMappings(CliFunctionResult result) {\n     Object[] outputs = (Object[]) result.getResultObject();\n-    return (List<FieldMapping>) outputs[1];\n+    return (ArrayList<FieldMapping>) outputs[1];\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzODczNg==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520038736", "bodyText": "Minor pick. I would recommend some error message for the SQLException, e.g.\n String reason = \"connection failed\";\t\n    when(dataSource.getConnection()).thenThrow(new SQLException(reason));\n\nThe the error message in the next few lines would be Exception thrown while connecting to datasource \\\"dataSource\\\": connection failed, instead of Exception thrown while connecting to datasource \\\"dataSource\\\": null", "author": "jchen21", "createdAt": "2020-11-09T18:49:18Z", "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceTest.java", "diffHunk": "@@ -216,4 +249,213 @@ public void validateMappingSucceedsWithCompositeKeys() {\n     when(mapping.getIds()).thenReturn(KEY_COLUMN_NAME + \",\" + COMPOSITE_KEY_COLUMN_NAME);\n     service.validateMapping(mapping);\n   }\n+\n+  @Test\n+  public void getTableMetaDataViewSucceeds() {\n+    TableMetaDataView result = service.getTableMetaDataView(mapping);\n+    assertThat(result).isEqualTo(view);\n+    verify(manager).getTableMetaDataView(connection, mapping);\n+  }\n+\n+  @Test\n+  public void getTableMetaDataViewThrowsExceptionWhenDataSourceDoesNotExist() {\n+    doReturn(null).when(service).getDataSource(DATA_SOURCE_NAME);\n+    Throwable throwable = catchThrowable(() -> service.getTableMetaDataView(mapping));\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n+        String.format(\"No datasource \\\"%s\\\" found when getting table meta data \\\"%s\\\"\",\n+            mapping.getDataSourceName(), mapping.getRegionName()));\n+  }\n+\n+  @Test\n+  public void getTableMetaDataViewThrowsExceptionWhenGetConnectionHasSqlException()\n+      throws SQLException {\n+    when(dataSource.getConnection()).thenThrow(SQLException.class);", "originalCommit": "7fc1417ec80c177e4cb46add831dfdfc4c99224f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg5MDM2MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523890360", "bodyText": "Thank you for your recommendation. I have fixed it.", "author": "masaki-yamakawa", "createdAt": "2020-11-16T04:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzODczNg=="}], "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceTest.java b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceTest.java\nindex 31454c8e49..baf4b58602 100644\n--- a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceTest.java\n+++ b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceTest.java\n\n@@ -249,213 +216,4 @@ public class JdbcConnectorServiceTest {\n     when(mapping.getIds()).thenReturn(KEY_COLUMN_NAME + \",\" + COMPOSITE_KEY_COLUMN_NAME);\n     service.validateMapping(mapping);\n   }\n-\n-  @Test\n-  public void getTableMetaDataViewSucceeds() {\n-    TableMetaDataView result = service.getTableMetaDataView(mapping);\n-    assertThat(result).isEqualTo(view);\n-    verify(manager).getTableMetaDataView(connection, mapping);\n-  }\n-\n-  @Test\n-  public void getTableMetaDataViewThrowsExceptionWhenDataSourceDoesNotExist() {\n-    doReturn(null).when(service).getDataSource(DATA_SOURCE_NAME);\n-    Throwable throwable = catchThrowable(() -> service.getTableMetaDataView(mapping));\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        String.format(\"No datasource \\\"%s\\\" found when getting table meta data \\\"%s\\\"\",\n-            mapping.getDataSourceName(), mapping.getRegionName()));\n-  }\n-\n-  @Test\n-  public void getTableMetaDataViewThrowsExceptionWhenGetConnectionHasSqlException()\n-      throws SQLException {\n-    when(dataSource.getConnection()).thenThrow(SQLException.class);\n-    Throwable throwable = catchThrowable(() -> service.getTableMetaDataView(mapping));\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        \"Exception thrown while connecting to datasource \\\"dataSource\\\": null\");\n-    verify(connection, never()).close();\n-  }\n-\n-  @Test\n-  public void createDefaultFieldMappingSucceedsWithExactMatchPdxFields() {\n-    List<FieldMapping> fieldsMappings = service.createDefaultFieldMapping(mapping, pdxType);\n-\n-    assertThat(fieldsMappings).hasSize(2);\n-    assertThat(fieldsMappings).contains(\n-        new FieldMapping(\"id\", FieldType.INT.name(), \"id\", JDBCType.INTEGER.name(), false));\n-    assertThat(fieldsMappings).contains(\n-        new FieldMapping(\"name\", FieldType.STRING.name(), \"name\", JDBCType.VARCHAR.name(), true));\n-  }\n-\n-  @Test\n-  public void createDefaultFieldMappingSucceedsWithIgnoreCaseMatchPdxFields() {\n-    when(pdxType.getFieldCount()).thenReturn(2);\n-    PdxField field1 = mock(PdxField.class);\n-    when(field1.getFieldName()).thenReturn(\"ID\");\n-    when(field1.getFieldType()).thenReturn(FieldType.INT);\n-    PdxField field2 = mock(PdxField.class);\n-    when(field2.getFieldName()).thenReturn(\"NAME\");\n-    when(field2.getFieldType()).thenReturn(FieldType.STRING);\n-    List<PdxField> pdxFields = Arrays.asList(field1, field2);\n-    when(pdxType.getFields()).thenReturn(pdxFields);\n-\n-    List<FieldMapping> fieldsMappings = service.createDefaultFieldMapping(mapping, pdxType);\n-\n-    assertThat(fieldsMappings).hasSize(2);\n-    assertThat(fieldsMappings).contains(\n-        new FieldMapping(\"ID\", FieldType.INT.name(), \"id\", JDBCType.INTEGER.name(), false));\n-    assertThat(fieldsMappings).contains(\n-        new FieldMapping(\"NAME\", FieldType.STRING.name(), \"name\", JDBCType.VARCHAR.name(), true));\n-  }\n-\n-  @Test\n-  public void createDefaultFieldMappingThrowsExceptionWhenGivenUnMatchPdxFieldName() {\n-    when(pdxType.getFieldCount()).thenReturn(2);\n-    PdxField field1 = mock(PdxField.class);\n-    when(field1.getFieldName()).thenReturn(\"id\");\n-    when(field1.getFieldType()).thenReturn(FieldType.INT);\n-    PdxField field2 = mock(PdxField.class);\n-    when(field2.getFieldName()).thenReturn(\"nameString\");\n-    when(field2.getFieldType()).thenReturn(FieldType.STRING);\n-    List<PdxField> pdxFields = Arrays.asList(field1, field2);\n-    when(pdxType.getFields()).thenReturn(pdxFields);\n-\n-    Throwable throwable = catchThrowable(() -> service.createDefaultFieldMapping(mapping, pdxType));\n-\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        String.format(\"No PDX field name matched the column name \\\"%s\\\"\",\n-            VALUE_COLUMN_NAME));\n-  }\n-\n-  @Test\n-  public void createDefaultFieldMappingThrowsExceptionWhenGivenDuplicatePdxFieldName() {\n-    when(pdxType.getFieldCount()).thenReturn(2);\n-    PdxField field1 = mock(PdxField.class);\n-    when(field1.getFieldName()).thenReturn(\"id\");\n-    when(field1.getFieldType()).thenReturn(FieldType.INT);\n-    PdxField field2 = mock(PdxField.class);\n-    when(field2.getFieldName()).thenReturn(\"NAME\");\n-    when(field2.getFieldType()).thenReturn(FieldType.STRING);\n-    PdxField field3 = mock(PdxField.class);\n-    when(field3.getFieldName()).thenReturn(\"Name\");\n-    when(field3.getFieldType()).thenReturn(FieldType.STRING);\n-    List<PdxField> pdxFields = Arrays.asList(field2, field3, field1);\n-    when(pdxType.getFields()).thenReturn(pdxFields);\n-\n-    Throwable throwable = catchThrowable(() -> service.createDefaultFieldMapping(mapping, pdxType));\n-\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        String.format(\"More than one PDX field name matched the column name \\\"%s\\\"\",\n-            VALUE_COLUMN_NAME));\n-  }\n-\n-  @Test\n-  public void createDefaultFieldMappingThrowsExceptionWhenDataSourceDoesNotExist() {\n-    doReturn(null).when(service).getDataSource(DATA_SOURCE_NAME);\n-    Throwable throwable = catchThrowable(() -> service.createDefaultFieldMapping(mapping, pdxType));\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        String.format(\"No datasource \\\"%s\\\" found when creating mapping \\\"%s\\\"\",\n-            mapping.getDataSourceName(), mapping.getRegionName()));\n-  }\n-\n-  @Test\n-  public void createDefaultFieldMappingThrowsExceptionWhenGetConnectionHasSqlException()\n-      throws SQLException {\n-    when(dataSource.getConnection()).thenThrow(SQLException.class);\n-    Throwable throwable = catchThrowable(() -> service.createDefaultFieldMapping(mapping, pdxType));\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class);\n-    verify(connection, never()).close();\n-  }\n-\n-  @Test\n-  public void createDefaultFieldMappingThrowsExceptionWhenGivenExistingPdxTypeWithWrongNumberOfFields() {\n-    doReturn(3).when(pdxType).getFieldCount();\n-    Throwable throwable = catchThrowable(() -> service.createDefaultFieldMapping(mapping, pdxType));\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        String.format(\n-            \"The table and pdx class must have the same number of columns/fields. But the table has %d columns and the pdx class has %d fields.\",\n-            view.getColumnNames().size(), pdxType.getFieldCount()));\n-  }\n-\n-  @Test\n-  public void getPdxTypeForClassSucceedsWithExistingPdxType() {\n-    when(typeRegistry.getExistingTypeForClass(PdxClassDummy.class)).thenReturn(pdxType);\n-\n-    PdxType result = service.getPdxTypeForClass(cache, PdxClassDummy.class);\n-    verify(service, never()).generatePdxTypeForClass(cache, typeRegistry, PdxClassDummy.class);\n-    assertThat(result).isEqualTo(pdxType);\n-  }\n-\n-  @Test\n-  public void getPdxTypeForClassSucceedsWithGeneratingPdxType() {\n-    when(typeRegistry.getExistingTypeForClass(PdxClassDummy.class)).thenReturn(null)\n-        .thenReturn(pdxType);\n-\n-    PdxType result = service.getPdxTypeForClass(cache, PdxClassDummy.class);\n-    verify(service, times(1)).generatePdxTypeForClass(cache, typeRegistry, PdxClassDummy.class);\n-    verify(cache, times(1)).registerPdxMetaData(any());\n-    assertThat(result).isEqualTo(pdxType);\n-  }\n-\n-  @Test\n-  public void getPdxTypeForClassSucceedsWithGivenNonPdxUsesReflectionBasedAutoSerializer() {\n-    when(typeRegistry.getExistingTypeForClass(PdxClassDummy.class)).thenReturn(null)\n-        .thenReturn(pdxType);\n-\n-    SerializationException ex = new SerializationException(\"test\");\n-    doThrow(ex).when(cache).registerPdxMetaData(any());\n-\n-    ReflectionBasedAutoSerializer serializer = mock(ReflectionBasedAutoSerializer.class);\n-    PdxWriter pdxWriter = mock(PdxWriter.class);\n-    String domainClassNameInAutoSerializer = \"\\\\Q\" + PdxClassDummy.class.getName() + \"\\\\E\";\n-    doReturn(serializer).when(service)\n-        .getReflectionBasedAutoSerializer(domainClassNameInAutoSerializer);\n-    doReturn(pdxWriter).when(service).createPdxWriter(same(typeRegistry), any());\n-    when(serializer.toData(any(), same(pdxWriter))).thenReturn(true);\n-\n-    PdxType result = service.getPdxTypeForClass(cache, PdxClassDummy.class);\n-    verify(service, times(1)).generatePdxTypeForClass(cache, typeRegistry, PdxClassDummy.class);\n-    verify(cache, times(1)).registerPdxMetaData(any());\n-    verify(service, times(1)).getReflectionBasedAutoSerializer(domainClassNameInAutoSerializer);\n-    assertThat(result).isEqualTo(pdxType);\n-  }\n-\n-  @Test\n-  public void getPdxTypeForClassThrowsExceptionWhenGivenPdxRegistrationFailsAndReflectionBasedAutoSerializer() {\n-    when(typeRegistry.getExistingTypeForClass(PdxClassDummy.class)).thenReturn(null);\n-\n-    SerializationException ex = new SerializationException(\"test\");\n-    doThrow(ex).when(cache).registerPdxMetaData(any());\n-\n-    ReflectionBasedAutoSerializer serializer = mock(ReflectionBasedAutoSerializer.class);\n-    PdxWriter pdxWriter = mock(PdxWriter.class);\n-    String domainClassNameInAutoSerializer = \"\\\\Q\" + PdxClassDummy.class.getName() + \"\\\\E\";\n-    doReturn(serializer).when(service)\n-        .getReflectionBasedAutoSerializer(domainClassNameInAutoSerializer);\n-    doReturn(pdxWriter).when(service).createPdxWriter(same(typeRegistry), any());\n-    when(serializer.toData(any(), same(pdxWriter))).thenReturn(false);\n-\n-    Throwable throwable =\n-        catchThrowable(() -> service.getPdxTypeForClass(cache, PdxClassDummy.class));\n-    verify(service, times(1)).generatePdxTypeForClass(cache, typeRegistry, PdxClassDummy.class);\n-    verify(cache, times(1)).registerPdxMetaData(any());\n-    verify(service, times(1)).getReflectionBasedAutoSerializer(domainClassNameInAutoSerializer);\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        String.format(\n-            \"Could not generate a PdxType using the ReflectionBasedAutoSerializer for the class  %s after failing to register pdx metadata due to %s. Check the server log for details.\",\n-            PdxClassDummy.class.getName(), ex.getMessage()));\n-  }\n-\n-  @Test\n-  public void getPdxTypeForClassThrowsExceptionWhenGivenPdxSerializableWithNoZeroArgConstructor() {\n-    Throwable throwable =\n-        catchThrowable(() -> service.getPdxTypeForClass(cache, PdxClassDummyNoZeroArg.class));\n-    verify(service, times(1)).generatePdxTypeForClass(cache, typeRegistry,\n-        PdxClassDummyNoZeroArg.class);\n-    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n-        String.format(\n-            \"Could not generate a PdxType for the class %s because it did not have a public zero arg constructor.\",\n-            PdxClassDummyNoZeroArg.class.getName()));\n-  }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxODYzOQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555418639", "bodyText": "This is a bug. I believe the string in the quote should be WrongPdxName instead of NoPdxName. There is no such file CacheXmlJdbcMappingIntegrationTest.NoPdxName.cache.xml. So the actual error is something like FileNotFoundException returned by getXmlFileForTest(). And the assertion at line 241 and 242 doesn't really catch the bug.", "author": "jchen21", "createdAt": "2021-01-12T00:09:04Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongDataSource(\n+      String cacheXmlTestName) throws Exception {\n+    System.setProperty(\"TestDataSourceUrl\", \"jdbc:mysql://localhost/test\");\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongPdxName(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private String getXmlFileForTest(String testName) {\n+    return createTempFileFromResource(getClass(),\n+        getClassSimpleName() + \".\" + testName + \".cache.xml\").getAbsolutePath();\n+  }\n+\n+  private String getClassSimpleName() {\n+    return getClass().getSimpleName();\n+  }\n+\n+  private void createEmployeeTable() throws Exception {\n+    statement.execute(\"Create Table \" + REGION_TABLE_NAME\n+        + \" (id varchar(10) primary key not null, name varchar(10), age int)\");\n+  }\n+\n+  private void createEmployeeTableWithColumnNamesWithUnderscores() throws Exception {\n+    statement.execute(\"Create Table \" + REGION_TABLE_NAME\n+        + \" (id varchar(10) primary key not null, _name varchar(10), _age int)\");\n+  }\n+\n+  private List<FieldMapping> getEmployeeTableFieldMappings() {\n+    List<FieldMapping> fieldMappings = Arrays.asList(\n+        new FieldMapping(\"id\", FieldType.STRING.name(), \"id\", JDBCType.VARCHAR.name(), false),\n+        new FieldMapping(\"name\", FieldType.STRING.name(), \"name\", JDBCType.VARCHAR.name(), true),\n+        new FieldMapping(\"age\", FieldType.INT.name(), \"age\", JDBCType.INTEGER.name(), true));\n+    return fieldMappings;\n+  }\n+\n+  private List<FieldMapping> getEmployeeTableColumnNameWithUnderscoresFieldMappings() {\n+    List<FieldMapping> fieldMappings = Arrays.asList(\n+        new FieldMapping(\"id\", FieldType.STRING.name(), \"id\", JDBCType.VARCHAR.name(), false),\n+        new FieldMapping(\"name\", FieldType.STRING.name(), \"_name\", JDBCType.VARCHAR.name(), true),\n+        new FieldMapping(\"age\", FieldType.INT.name(), \"_age\", JDBCType.INTEGER.name(), true));\n+    return fieldMappings;\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreExists() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMapping(\"FieldMappings\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(Employee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreOmitted() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMapping(\"NoFieldMappings\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(Employee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreOmittedWithNonSerializedClass() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+        \"NoFieldMappingsWithNonSerializedClass\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(NonSerializedEmployee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenConnectWrongDataSource() {\n+    Throwable throwable =\n+        catchThrowable(() -> createCacheAndCreateJdbcMappingWithWrongDataSource(\"NoFieldMappings\"));\n+\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class)\n+        .hasMessage(String.format(\"No datasource \\\"%s\\\" found when creating default field mapping\",\n+            DATA_SOURCE_NAME));\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenTableNotExists() {\n+    Throwable throwable = catchThrowable(() -> createCacheAndCreateJdbcMapping(\"NoFieldMappings\"));\n+\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class)\n+        .hasMessage(String.format(\"No table was found that matches \\\"%s\\\"\", REGION_TABLE_NAME));\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenPdxNotExists() throws Exception {\n+    createEmployeeTable();\n+\n+    Throwable throwable =\n+        catchThrowable(() -> createCacheAndCreateJdbcMappingWithWrongPdxName(\"NoPdxName\"));", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\nindex 014fb79da2..17fe5e6362 100644\n--- a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n+++ b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n\n@@ -89,8 +89,7 @@ public class CacheXmlJdbcMappingIntegrationTest {\n     }\n   }\n \n-  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n-      throws Exception {\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName) {\n     String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n     System.setProperty(\"TestDataSourceUrl\", url);\n     InternalCache cache =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNTk3Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555435976", "bodyText": "This is method implementation is exactly the same as createCacheAndCreateJdbcMapping(). The only difference is the method name. So how about just using createCacheAndCreateJdbcMapping()?", "author": "jchen21", "createdAt": "2021-01-12T00:50:24Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongDataSource(\n+      String cacheXmlTestName) throws Exception {\n+    System.setProperty(\"TestDataSourceUrl\", \"jdbc:mysql://localhost/test\");\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongPdxName(String cacheXmlTestName)", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\nindex 014fb79da2..17fe5e6362 100644\n--- a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n+++ b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n\n@@ -89,8 +89,7 @@ public class CacheXmlJdbcMappingIntegrationTest {\n     }\n   }\n \n-  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n-      throws Exception {\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName) {\n     String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n     System.setProperty(\"TestDataSourceUrl\", url);\n     InternalCache cache =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNjQwMw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555436403", "bodyText": "This throws Exception can be removed. The same for line 93, 109 and 119.", "author": "jchen21", "createdAt": "2021-01-12T00:52:02Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\nindex 014fb79da2..17fe5e6362 100644\n--- a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n+++ b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n\n@@ -89,8 +89,7 @@ public class CacheXmlJdbcMappingIntegrationTest {\n     }\n   }\n \n-  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n-      throws Exception {\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName) {\n     String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n     System.setProperty(\"TestDataSourceUrl\", url);\n     InternalCache cache =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNjY3NQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555436675", "bodyText": "I would recommend inline this one-line implementation for readability of code.", "author": "jchen21", "createdAt": "2021-01-12T00:52:54Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\nindex 014fb79da2..17fe5e6362 100644\n--- a/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n+++ b/geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java\n\n@@ -89,8 +89,7 @@ public class CacheXmlJdbcMappingIntegrationTest {\n     }\n   }\n \n-  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n-      throws Exception {\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName) {\n     String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n     System.setProperty(\"TestDataSourceUrl\", url);\n     InternalCache cache =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ0MTc5MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555441790", "bodyText": "The regionMapping argument is not used, and can be removed.", "author": "jchen21", "createdAt": "2021-01-12T01:09:37Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java", "diffHunk": "@@ -62,4 +96,159 @@ private void createRegionMapping(JdbcConnectorService service,\n       throw new InternalGemFireException(e);\n     }\n   }\n+\n+  protected List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n+      PdxType pdxType) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when creating default field mapping\");\n+    }\n+    TableMetaDataManager manager = getTableMetaDataManager();\n+    try (Connection connection = dataSource.getConnection()) {\n+      TableMetaDataView tableMetaData = manager.getTableMetaDataView(connection, regionMapping);\n+      return createDefaultFieldMapping(regionMapping, pdxType, tableMetaData);\n+    } catch (SQLException e) {\n+      throw JdbcConnectorException.createException(e);\n+    }\n+  }\n+\n+  private List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "chunk": "diff --git a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java\nindex 57d9521a33..b8c7cbf5a0 100644\n--- a/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java\n+++ b/geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java\n\n@@ -97,24 +97,23 @@ public class RegionMappingConfiguration implements Extension<Region<?, ?>> {\n     }\n   }\n \n-  protected List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n-      PdxType pdxType) {\n-    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+  protected List<FieldMapping> createDefaultFieldMapping(PdxType pdxType) {\n+    DataSource dataSource = getDataSource(mapping.getDataSourceName());\n     if (dataSource == null) {\n-      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + mapping.getDataSourceName()\n           + \"\\\" found when creating default field mapping\");\n     }\n     TableMetaDataManager manager = getTableMetaDataManager();\n     try (Connection connection = dataSource.getConnection()) {\n-      TableMetaDataView tableMetaData = manager.getTableMetaDataView(connection, regionMapping);\n-      return createDefaultFieldMapping(regionMapping, pdxType, tableMetaData);\n+      TableMetaDataView tableMetaData = manager.getTableMetaDataView(connection, mapping);\n+      return createDefaultFieldMapping(pdxType, tableMetaData);\n     } catch (SQLException e) {\n       throw JdbcConnectorException.createException(e);\n     }\n   }\n \n-  private List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n-      PdxType pdxType, TableMetaDataView tableMetaDataView) {\n+  private List<FieldMapping> createDefaultFieldMapping(PdxType pdxType,\n+      TableMetaDataView tableMetaDataView) {\n \n     // TODO the table name returned in tableMetaData may be different than\n     // the table name specified on the command line at this point.\n"}}, {"oid": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "url": "https://github.com/apache/geode/commit/5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "message": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector\n\nUse the default mapping when using the Simple JDBC Connector in cache.xml and without the field-mapping tag", "committedDate": "2021-01-14T22:31:08Z", "type": "commit"}, {"oid": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "url": "https://github.com/apache/geode/commit/5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "message": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector\n\nUse the default mapping when using the Simple JDBC Connector in cache.xml and without the field-mapping tag", "committedDate": "2021-01-14T22:31:08Z", "type": "forcePushed"}, {"oid": "fd326746ef0778a781af03d103bfba662bae2ea8", "url": "https://github.com/apache/geode/commit/fd326746ef0778a781af03d103bfba662bae2ea8", "message": "Merge branch 'develop' into feature/GEODE-8626", "committedDate": "2021-06-12T11:34:00Z", "type": "commit"}, {"oid": "e29918ce27e172859148f24f59f59e59e0b18f91", "url": "https://github.com/apache/geode/commit/e29918ce27e172859148f24f59f59e59e0b18f91", "message": "Move some methods of CreateMappingPreconditionCheckFunction class to JdbcConnectorServiceImpl class", "committedDate": "2021-06-13T08:05:10Z", "type": "commit"}]}