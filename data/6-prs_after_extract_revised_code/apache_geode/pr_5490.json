{"pr_number": 5490, "pr_title": "GEODE-8467: server fails to notify of a ForcedDisconnect and fails to tear down the cache", "pr_createdAt": "2020-08-31T20:18:37Z", "pr_url": "https://github.com/apache/geode/pull/5490", "timeline": [{"oid": "6fa7e3f3965e6c449cbb1982e092eba0f594eec2", "url": "https://github.com/apache/geode/commit/6fa7e3f3965e6c449cbb1982e092eba0f594eec2", "message": "GEODE-8467: server fails to notify of a ForcedDisconnect and fails to tear down the cache\n\nCatch exceptions that occur during XML generation and disable auto\nreconnect.\n\nEnsure that the DisconnectThread is launched by placing it in a\n\"finally\" block.", "committedDate": "2020-08-31T20:14:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NzIxMw==", "url": "https://github.com/apache/geode/pull/5490#discussion_r480467213", "bodyText": "I guess it's ok to not rethrow the Throwable here. saveConfg() is called from two places in GMSMembership:\n\nManagerImpl.forceDisconnect()\nrequestMemberRemoval()\n\nIn both those cases it looks like setDisableAutoReconnect(true) will set us on a permanent shutdown path. Since we've logged the Throwable here we've fulfilled our obligation to inform the operator.", "author": "Bill", "createdAt": "2020-08-31T23:17:41Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -1177,34 +1178,53 @@ public MeterRegistry getMeterRegistry() {\n \n   @Override\n   public void saveCacheXmlForReconnect() {\n-    // there are two versions of this method so it can be unit-tested\n-    boolean sharedConfigEnabled = getDistributionManager().getConfig().getUseSharedConfiguration();\n+    prepareForReconnect((pw) -> CacheXmlGenerator.generate((Cache) this, pw, false));\n+  }\n \n-    if (!Boolean.getBoolean(GEMFIRE_PREFIX + \"autoReconnect-useCacheXMLFile\")\n-        && !sharedConfigEnabled) {\n-      try {\n-        logger.info(\"generating XML to rebuild the cache after reconnect completes\");\n-        StringPrintWriter pw = new StringPrintWriter();\n-        CacheXmlGenerator.generate((Cache) this, pw, false);\n-        String cacheXML = pw.toString();\n-        getCacheConfig().setCacheXMLDescription(cacheXML);\n-        logger.info(\"XML generation completed: {}\", cacheXML);\n-      } catch (CancelException e) {\n-        logger.info(\"Unable to generate XML description for reconnect of cache due to exception\",\n-            e);\n-      }\n-    } else if (sharedConfigEnabled && !getCacheServers().isEmpty()) {\n-      // we need to retain a cache-server description if this JVM was started by gfsh\n-      List<CacheServerCreation> list = new ArrayList<>(getCacheServers().size());\n-      for (Object o : getCacheServers()) {\n-        CacheServerImpl cs = (CacheServerImpl) o;\n-        if (cs.isDefaultServer()) {\n-          CacheServerCreation bsc = new CacheServerCreation(this, cs);\n-          list.add(bsc);\n+\n+  /**\n+   * Testable version of saveCacheXmlForReconnect() that allows us to inject an XML generator\n+   *\n+   * @param xmlGenerator a consumer of a PrintWriter that generates a description of the Cache\n+   */\n+  protected void prepareForReconnect(Consumer<PrintWriter> xmlGenerator) {\n+    boolean sharedConfigEnabled =\n+        getInternalDistributedSystem().getConfig().getUseSharedConfiguration();\n+\n+    try {\n+      if (!Boolean.getBoolean(GEMFIRE_PREFIX + \"autoReconnect-useCacheXMLFile\")\n+          && !sharedConfigEnabled) {\n+        try {\n+          logger.info(\"generating XML to rebuild the cache after reconnect completes\");\n+          StringPrintWriter pw = new StringPrintWriter();\n+          xmlGenerator.accept(pw);\n+          String cacheXML = pw.toString();\n+          getCacheConfig().setCacheXMLDescription(cacheXML);\n+          logger.info(\"XML generation completed: {}\", cacheXML);\n+        } catch (CancelException e) {\n+          logger.info(\"Unable to generate XML description for reconnect of cache due to exception\",\n+              e);\n         }\n+      } else if (sharedConfigEnabled && !getCacheServers().isEmpty()) {\n+        // we need to retain a cache-server description if this JVM was started by gfsh\n+        logger.info(\"saving cache server configuration for use with the cluster-configuration \"\n+            + \"service on reconnect\");\n+        List<CacheServerCreation> list = new ArrayList<>(getCacheServers().size());\n+        for (Object o : getCacheServers()) {\n+          CacheServerImpl cs = (CacheServerImpl) o;\n+          if (cs.isDefaultServer()) {\n+            CacheServerCreation bsc = new CacheServerCreation(this, cs);\n+            list.add(bsc);\n+          }\n+        }\n+        getCacheConfig().setCacheServerCreation(list);\n+        logger.info(\"cache server configuration saved\");\n       }\n-      getCacheConfig().setCacheServerCreation(list);\n-      logger.info(\"CacheServer configuration saved\");\n+    } catch (Throwable throwable) {\n+      logger.info(\"Saving of cache configuration for auto-reconnect has failed.  \"\n+          + \"Auto-reconnect will be disabled since the cache cannot be rebuilt.\", throwable);\n+      getInternalDistributedSystem().getConfig().setDisableAutoReconnect(true);\n+", "originalCommit": "6fa7e3f3965e6c449cbb1982e092eba0f594eec2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}