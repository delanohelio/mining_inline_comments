{"pr_number": 4568, "pr_title": "Geode-7600-3", "pr_createdAt": "2020-01-07T17:31:20Z", "pr_url": "https://github.com/apache/geode/pull/4568", "timeline": [{"oid": "9709fc2cf61fdba5f656704237c09d59470bfdbf", "url": "https://github.com/apache/geode/commit/9709fc2cf61fdba5f656704237c09d59470bfdbf", "message": "GEODE-7600-3: Further cleanup\n\n- Wait and sleep removal\n- Removing deprecated API calls", "committedDate": "2020-01-08T01:40:14Z", "type": "forcePushed"}, {"oid": "2aa5bf8ee5b04d15ab2fc891916e237fb1b402be", "url": "https://github.com/apache/geode/commit/2aa5bf8ee5b04d15ab2fc891916e237fb1b402be", "message": "GEODE-7600-3: Further cleanup\n\n- Wait and sleep removal\n- Removing deprecated API calls", "committedDate": "2020-01-08T17:45:01Z", "type": "forcePushed"}, {"oid": "081f876c91f3d8ba6e25919ff3376357068a0cab", "url": "https://github.com/apache/geode/commit/081f876c91f3d8ba6e25919ff3376357068a0cab", "message": "GEODE-7600-3 Cleanup", "committedDate": "2020-01-09T17:10:44Z", "type": "forcePushed"}, {"oid": "120ae192912de0dbf293798330d96bf3ba879345", "url": "https://github.com/apache/geode/commit/120ae192912de0dbf293798330d96bf3ba879345", "message": "GEODE-7600-3: Further cleanup\n- Comparable is generic so it can be typed this fixed an assert.\n- Wait and sleep removal\n- Removing deprecated API calls", "committedDate": "2020-01-10T17:40:30Z", "type": "forcePushed"}, {"oid": "779cbe39dac2c7bd8ce76024f1d08228f448bafc", "url": "https://github.com/apache/geode/commit/779cbe39dac2c7bd8ce76024f1d08228f448bafc", "message": "GEODE-7600-3: Further cleanup\n- Comparable is generic so it can be typed this fixed an assert.\n- Wait and sleep removal\n- Removing deprecated API calls", "committedDate": "2020-01-11T00:41:57Z", "type": "forcePushed"}, {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "url": "https://github.com/apache/geode/commit/9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "message": "GEODE-7600-3: Further cleanup\n- Comparable is generic so it can be typed this fixed an assert.\n- Wait and sleep removal\n- Removing deprecated API calls", "committedDate": "2020-01-15T19:17:05Z", "type": "commit"}, {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "url": "https://github.com/apache/geode/commit/9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "message": "GEODE-7600-3: Further cleanup\n- Comparable is generic so it can be typed this fixed an assert.\n- Wait and sleep removal\n- Removing deprecated API calls", "committedDate": "2020-01-15T19:17:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5NjEyNA==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368096124", "bodyText": "Remember to remove these logger statements containing MLH", "author": "kirklund", "createdAt": "2020-01-17T19:20:38Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -2720,8 +2677,10 @@ public void run2() throws CacheException {\n     });\n \n     vm2.invoke(\"Verify destroy propagate\", () -> {\n-      Region<Object, Object> region = getRootRegion().getSubregion(name);\n-      await().until(() -> region == null);\n+      await().until(() -> {\n+        logger.info(\"MLH region = \" + getRootRegion().getSubregion(name));", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\nindex 087b7c40d9..764eec8981 100755\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\n\n@@ -2677,10 +2677,7 @@ public class ConnectionPoolDUnitTest extends JUnit4CacheTestCase {\n     });\n \n     vm2.invoke(\"Verify destroy propagate\", () -> {\n-      await().until(() -> {\n-        logger.info(\"MLH region = \" + getRootRegion().getSubregion(name));\n-        return getRootRegion().getSubregion(name) == null;\n-      });\n+      await().until(() -> getRootRegion().getSubregion(name) == null);\n     });\n \n     vm0.invoke(\"Stop CacheServer\", () -> stopBridgeServer(getCache()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5Njk0OA==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368096948", "bodyText": "I think this test will run into same thing I hit with another test. There's a brief window in which getRegion may throw RegionDestroyedException before it starts returning null:\nawait().ignoreException(RegionDestroyedException.class).until(() -> \n    getCache().getRegion(drName) == null);", "author": "kirklund", "createdAt": "2020-01-17T19:22:34Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -3207,7 +3149,7 @@ public void test028DynamicRegionCreation() {\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n \n-      await().pollInterval(100, MILLISECONDS).until(() -> getCache().getRegion(drName) == null);\n+      await().until(() -> getCache().getRegion(drName) == null);", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNjExNQ==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368126115", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5Njk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\nindex 087b7c40d9..764eec8981 100755\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\n\n@@ -3149,8 +3146,8 @@ public class ConnectionPoolDUnitTest extends JUnit4CacheTestCase {\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n \n-      await().until(() -> getCache().getRegion(drName) == null);\n-\n+      await().ignoreException(RegionDestroyedException.class)\n+          .until(() -> getCache().getRegion(drName) == null);\n       assertThat(getCache().getRegion(drName)).isNull();\n     });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5NzIyMw==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368097223", "bodyText": "Add ignoreException(RegionDestroyedException.class)", "author": "kirklund", "createdAt": "2020-01-17T19:23:17Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -3217,13 +3159,11 @@ public void test028DynamicRegionCreation() {\n       Region<Object, Object> r = getRootRegion(name);\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n-      await().pollInterval(100, MILLISECONDS).until(() -> getCache().getRegion(drName) == null);\n+      await().until(() -> getCache().getRegion(drName) == null);", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNjk3NA==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368126974", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5NzIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\nindex 087b7c40d9..764eec8981 100755\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java\n\n@@ -3159,7 +3156,8 @@ public class ConnectionPoolDUnitTest extends JUnit4CacheTestCase {\n       Region<Object, Object> r = getRootRegion(name);\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n-      await().until(() -> getCache().getRegion(drName) == null);\n+      await().ignoreException(RegionDestroyedException.class)\n+          .until(() -> getCache().getRegion(drName) == null);\n \n       Throwable thrown =\n           catchThrowable(() -> DynamicRegionFactory.get().destroyDynamicRegion(drName));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5OTM2OQ==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368099369", "bodyText": "I recommend changing any sort of loop containing a sleep into an await call:\nawait().ignoreException(RegionDestroyedException.class).until(() ->\n    ccregion.isDestroyed() && ccregion.getRegionEntry(key) != null);", "author": "kirklund", "createdAt": "2020-01-17T19:28:07Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -147,129 +146,118 @@ public void testConcurrentOpWithGII() {\n     VM vm2 = VM.getVM(2);\n \n     // create some destroyed entries so the GC service is populated\n-    SerializableCallable create = new SerializableCallable(\"create region\") {\n-      @Override\n-      public Object call() {\n-        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-        CCRegion = (LocalRegion) f.create(name);\n-        return CCRegion.getDistributionManager().getDistributionManagerId();\n-      }\n-    };\n     // do conflicting update() and destroy() on the region. We want the update() to\n     // be sent with a message and the destroy() to be transferred in the initial image\n     // and be the value that we want to keep\n-    vm1.invoke(create);\n+    vm1.invoke(\"create region\", () -> {\n+      RegionFactory f1 = getCache().createRegionFactory(getRegionAttributes());\n+      CCRegion = (LocalRegion) f1.create(name);\n+      return CCRegion.getDistributionManager().getDistributionManagerId();\n+    });\n \n     AsyncInvocation partialCreate =\n-        vm2.invokeAsync(new SerializableCallable<Object>(\"create region with stall\") {\n-          @Override\n-          public Object call() {\n-            final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-            RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n-            InitialImageOperation.VMOTION_DURING_GII = true;\n-            // this will stall region creation at the point of asking for an initial image\n-            VMotionObserverHolder.setInstance(new VMotionObserver() {\n-              @Override\n-              public void vMotionBeforeCQRegistration() {}\n-\n-              @Override\n-              public void vMotionBeforeRegisterInterest() {}\n-\n-              @Override\n-              public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n-                InitialImageOperation.VMOTION_DURING_GII = false;\n-                final InitializationLevel oldLevel =\n-                    LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n-                LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n-                try {\n-                  // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n-                  // happen\n-                  while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                    try {\n-                      Thread.sleep(1000);\n-                    } catch (InterruptedException e) {\n-                      return;\n-                    }\n+        vm2.invokeAsync(\"create region with stall\", () -> {\n+\n+          final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+          RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n+          InitialImageOperation.VMOTION_DURING_GII = true;\n+          // this will stall region creation at the point of asking for an initial image\n+          VMotionObserverHolder.setInstance(new VMotionObserver() {\n+            @Override\n+            public void vMotionBeforeCQRegistration() {}\n+\n+            @Override\n+            public void vMotionBeforeRegisterInterest() {}\n+\n+            @Override\n+            public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n+              InitialImageOperation.VMOTION_DURING_GII = false;\n+              final InitializationLevel oldLevel =\n+                  LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n+              LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n+              try {\n+                // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n+                // happen\n+                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNzUxMw==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368127513", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5OTM2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\nindex 4ce93b4e61..1f5baca217 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\n\n@@ -178,13 +176,8 @@ public class DistributedAckRegionCCEDUnitTest extends DistributedAckRegionDUnitT\n               try {\n                 // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n                 // happen\n-                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                  try {\n-                    Thread.sleep(1000);\n-                  } catch (InterruptedException e) {\n-                    return;\n-                  }\n-                }\n+                await().ignoreException(RegionDestroyedException.class)\n+                    .until(() -> ccregion.isDestroyed() || ccregion.getRegionEntry(key) != null);\n               } finally {\n                 LocalRegion.setThreadInitLevelRequirement(oldLevel);\n               }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDM2MQ==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368100361", "bodyText": "Delete any catch block with a fail and let the test throw UnknownHostException.", "author": "kirklund", "createdAt": "2020-01-17T19:30:13Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -147,129 +146,118 @@ public void testConcurrentOpWithGII() {\n     VM vm2 = VM.getVM(2);\n \n     // create some destroyed entries so the GC service is populated\n-    SerializableCallable create = new SerializableCallable(\"create region\") {\n-      @Override\n-      public Object call() {\n-        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-        CCRegion = (LocalRegion) f.create(name);\n-        return CCRegion.getDistributionManager().getDistributionManagerId();\n-      }\n-    };\n     // do conflicting update() and destroy() on the region. We want the update() to\n     // be sent with a message and the destroy() to be transferred in the initial image\n     // and be the value that we want to keep\n-    vm1.invoke(create);\n+    vm1.invoke(\"create region\", () -> {\n+      RegionFactory f1 = getCache().createRegionFactory(getRegionAttributes());\n+      CCRegion = (LocalRegion) f1.create(name);\n+      return CCRegion.getDistributionManager().getDistributionManagerId();\n+    });\n \n     AsyncInvocation partialCreate =\n-        vm2.invokeAsync(new SerializableCallable<Object>(\"create region with stall\") {\n-          @Override\n-          public Object call() {\n-            final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-            RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n-            InitialImageOperation.VMOTION_DURING_GII = true;\n-            // this will stall region creation at the point of asking for an initial image\n-            VMotionObserverHolder.setInstance(new VMotionObserver() {\n-              @Override\n-              public void vMotionBeforeCQRegistration() {}\n-\n-              @Override\n-              public void vMotionBeforeRegisterInterest() {}\n-\n-              @Override\n-              public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n-                InitialImageOperation.VMOTION_DURING_GII = false;\n-                final InitializationLevel oldLevel =\n-                    LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n-                LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n-                try {\n-                  // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n-                  // happen\n-                  while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                    try {\n-                      Thread.sleep(1000);\n-                    } catch (InterruptedException e) {\n-                      return;\n-                    }\n+        vm2.invokeAsync(\"create region with stall\", () -> {\n+\n+          final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+          RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n+          InitialImageOperation.VMOTION_DURING_GII = true;\n+          // this will stall region creation at the point of asking for an initial image\n+          VMotionObserverHolder.setInstance(new VMotionObserver() {\n+            @Override\n+            public void vMotionBeforeCQRegistration() {}\n+\n+            @Override\n+            public void vMotionBeforeRegisterInterest() {}\n+\n+            @Override\n+            public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n+              InitialImageOperation.VMOTION_DURING_GII = false;\n+              final InitializationLevel oldLevel =\n+                  LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n+              LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n+              try {\n+                // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n+                // happen\n+                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n+                  try {\n+                    Thread.sleep(1000);\n+                  } catch (InterruptedException e) {\n+                    return;\n                   }\n-                } finally {\n-                  LocalRegion.setThreadInitLevelRequirement(oldLevel);\n                 }\n+              } finally {\n+                LocalRegion.setThreadInitLevelRequirement(oldLevel);\n               }\n-            });\n-            try {\n-              CCRegion = (LocalRegion) f.create(name);\n-              // at this point we should have received the update op and then the GII, which should\n-              // overwrite\n-              // the conflicting update op\n-              assertThat(CCRegion.containsKey(key))\n-                  .describedAs(\"entry was destroyed by initial image transfer\")\n-                  .isFalse();\n-            } finally {\n-              InitialImageOperation.VMOTION_DURING_GII = false;\n             }\n-            return null;\n-          }\n-        });\n-    vm1.invoke(new SerializableRunnable(\"create conflicting events\") {\n-      @Override\n-      public void run() {\n-        // wait for the other to come on line\n-        long waitEnd = System.currentTimeMillis() + 45000;\n-        DistributionAdvisor adv = ((DistributedRegion) CCRegion).getCacheDistributionAdvisor();\n-        while (System.currentTimeMillis() < waitEnd && adv.adviseGeneric().isEmpty()) {\n+          });\n           try {\n-            Thread.sleep(1000);\n-          } catch (InterruptedException e) {\n-            return;\n+            CCRegion = (LocalRegion) f.create(name);\n+            // at this point we should have received the update op and then the GII, which should\n+            // overwrite the conflicting update op\n+            assertThat(CCRegion.containsKey(key))\n+                .describedAs(\"entry was destroyed by initial image transfer\")\n+                .isFalse();\n+          } finally {\n+            InitialImageOperation.VMOTION_DURING_GII = false;\n           }\n-        }\n-        assertThat(adv.adviseGeneric())\n-            .withFailMessage(\"other member never came on line\")\n-            .isNotEmpty();\n-\n-        DistributedCacheOperation.LOSS_SIMULATION_RATIO = 200.0; // inhibit all messaging\n-        try {\n-          CCRegion.put(\"mykey\", \"initialValue\");\n-          CCRegion.destroy(\"mykey\");\n-        } finally {\n-          DistributedCacheOperation.LOSS_SIMULATION_RATIO = 0.0;\n-        }\n+          return null;\n+        });\n \n-        // generate a fake version tag for the message\n-        final VersionStamp versionStamp = CCRegion.getRegionEntry(key).getVersionStamp();\n-        VersionTag<InternalDistributedMember> tag =\n-            (VersionTag<InternalDistributedMember>) versionStamp.asVersionTag();\n-        // create a fake member ID that will be < mine and lose a concurrency check\n-        MemberData nm =\n-            CCRegion.getDistributionManager().getDistributionManagerId().getMemberData();\n-        InternalDistributedMember mbr = null;\n+    vm1.invoke(\"create conflicting events\", () -> {\n+      // wait for the other to come on line\n+      long waitEnd = System.currentTimeMillis() + 45000;\n+      DistributionAdvisor adv = ((DistributedRegion) CCRegion).getCacheDistributionAdvisor();\n+      while (System.currentTimeMillis() < waitEnd && adv.adviseGeneric().isEmpty()) {\n         try {\n-          mbr = new InternalDistributedMember(nm.getInetAddress().getCanonicalHostName(),\n-              nm.getMembershipPort() - 1, \"fake_id\", \"fake_id_ustring\",\n-              ClusterDistributionManager.NORMAL_DM_TYPE, null, null);\n-          tag.setMemberID(mbr);\n-        } catch (UnknownHostException e) {\n-          fail(\"could not create member id: \", e);\n+          Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+          return;\n         }\n+      }\n+      assertThat(adv.adviseGeneric())\n+          .withFailMessage(\"other member never came on line\")\n+          .isNotEmpty();\n+\n+      DistributedCacheOperation.LOSS_SIMULATION_RATIO = 200.0; // inhibit all messaging\n+      try {\n+        CCRegion.put(\"mykey\", \"initialValue\");\n+        CCRegion.destroy(\"mykey\");\n+      } finally {\n+        DistributedCacheOperation.LOSS_SIMULATION_RATIO = 0.0;\n+      }\n \n-        // generate an event to distribute that contains the fake version tag\n-        EntryEventImpl event =\n-            EntryEventImpl.create(CCRegion, Operation.UPDATE, key, false, mbr, true, false);\n-        event.setNewValue(\"newValue\");\n-        event.setVersionTag(tag);\n-\n-        // this should update the controller's cache with the updated value but leave this cache\n-        // alone\n-        DistributedCacheOperation op = new UpdateOperation(event, tag.getVersionTimeStamp());\n-        op.distribute();\n-        event.release();\n+      // generate a fake version tag for the message\n+      final VersionStamp versionStamp = CCRegion.getRegionEntry(key).getVersionStamp();\n+      VersionTag<InternalDistributedMember> tag =\n+          (VersionTag<InternalDistributedMember>) versionStamp.asVersionTag();\n+      // create a fake member ID that will be < mine and lose a concurrency check\n+      MemberData nm =\n+          CCRegion.getDistributionManager().getDistributionManagerId().getMemberData();\n+      InternalDistributedMember mbr = null;\n+      try {\n+        mbr = new InternalDistributedMember(nm.getInetAddress().getCanonicalHostName(),\n+            nm.getMembershipPort() - 1, \"fake_id\", \"fake_id_ustring\",\n+            ClusterDistributionManager.NORMAL_DM_TYPE, null, null);\n+        tag.setMemberID(mbr);\n+      } catch (UnknownHostException e) {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNzgwMw==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368127803", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDM2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\nindex 4ce93b4e61..1f5baca217 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\n\n@@ -178,13 +176,8 @@ public class DistributedAckRegionCCEDUnitTest extends DistributedAckRegionDUnitT\n               try {\n                 // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n                 // happen\n-                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                  try {\n-                    Thread.sleep(1000);\n-                  } catch (InterruptedException e) {\n-                    return;\n-                  }\n-                }\n+                await().ignoreException(RegionDestroyedException.class)\n+                    .until(() -> ccregion.isDestroyed() || ccregion.getRegionEntry(key) != null);\n               } finally {\n                 LocalRegion.setThreadInitLevelRequirement(oldLevel);\n               }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDk1Nw==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368100957", "bodyText": "Delete this catch block and change the methods to throws Exception.", "author": "kirklund", "createdAt": "2020-01-17T19:31:37Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -312,63 +299,47 @@ public void testTombstoneExpirationRace() {\n     VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n-        try {\n-          RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-          CCRegion = (LocalRegion) f.create(name);\n-          CCRegion.put(\"cckey0\", \"ccvalue\");\n-          CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n-        } catch (CacheException ex) {\n-          ex.printStackTrace();\n-          fail(\"While creating region \", ex);\n-        }\n+        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n+        CCRegion = (LocalRegion) f.create(name);\n+        CCRegion.put(\"cckey0\", \"ccvalue\");\n+        CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4;\n       }\n     };\n \n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its modification time to be\n-        // older\n-        // than the tombstone GC interval. This means it could be in the process of being reaped by\n-        // distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertThat(tag.getEntryVersion()).isGreaterThan(1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-\n-          fail(\"region was mysteriously cleared during unit testing \", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its modification time to be\n+      // older than the tombstone GC interval. This means it could be in the process of being\n+      // reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertThat(tag.getEntryVersion()).isGreaterThan(1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyODExOA==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368128118", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\nindex 4ce93b4e61..1f5baca217 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java\n\n@@ -321,12 +306,8 @@ public class DistributedAckRegionCCEDUnitTest extends DistributedAckRegionDUnitT\n       tag.setVersionTimeStamp(\n           System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n       entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-      try {\n-        entry.makeTombstone(CCRegion, tag);\n-      } catch (RegionClearedException e) {\n+      entry.makeTombstone(CCRegion, tag);\n \n-        fail(\"region was mysteriously cleared during unit testing \", e);\n-      }\n     });\n     // now remove the entry on vm0, simulating that it initiated a GC, and perform a CREATE with a\n     // new version number\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTgxMg==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368101812", "bodyText": "Optional: Delete this catch block. CacheException is a RuntimeException so it doesn't even requires a throws clause.", "author": "kirklund", "createdAt": "2020-01-17T19:33:41Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyOTYyNA==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368129624", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTgxMg=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\nindex 79a435f7c9..fcd0e1eee2 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\n\n@@ -155,17 +152,12 @@ public class GlobalRegionCCEDUnitTest extends GlobalRegionDUnitTest {\n     SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n-        try {\n-          RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-          CCRegion = (LocalRegion) f.create(name);\n-\n-          // noinspection OverwrittenKey\n-          CCRegion.put(\"cckey0\", \"ccvalue\");\n-          // noinspection OverwrittenKey\n-          CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n-        } catch (CacheException ex) {\n-          fail(\"While creating region\", ex);\n-        }\n+        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n+        CCRegion = (LocalRegion) f.create(name);\n+        // noinspection OverwrittenKey\n+        CCRegion.put(\"cckey0\", \"ccvalue\");\n+        // noinspection OverwrittenKey\n+        CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n       }\n     };\n     vm0.invoke(\"Create Region\", createRegion);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTkzNg==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368101936", "bodyText": "Another catch block to delete.", "author": "kirklund", "createdAt": "2020-01-17T19:34:00Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {\n           fail(\"While creating region\", ex);\n         }\n       }\n     };\n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its\n-        // modification time to be older than the tombstone GC interval. This\n-        // means it could be in the process of being reaped by distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertTrue(tag.getEntryVersion() > 1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-          fail(\"region was mysteriously cleared during unit testing\", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its\n+      // modification time to be older than the tombstone GC interval. This\n+      // means it could be in the process of being reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertTrue(tag.getEntryVersion() > 1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyOTgwMg==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368129802", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\nindex 79a435f7c9..fcd0e1eee2 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\n\n@@ -155,17 +152,12 @@ public class GlobalRegionCCEDUnitTest extends GlobalRegionDUnitTest {\n     SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n-        try {\n-          RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-          CCRegion = (LocalRegion) f.create(name);\n-\n-          // noinspection OverwrittenKey\n-          CCRegion.put(\"cckey0\", \"ccvalue\");\n-          // noinspection OverwrittenKey\n-          CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n-        } catch (CacheException ex) {\n-          fail(\"While creating region\", ex);\n-        }\n+        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n+        CCRegion = (LocalRegion) f.create(name);\n+        // noinspection OverwrittenKey\n+        CCRegion.put(\"cckey0\", \"ccvalue\");\n+        // noinspection OverwrittenKey\n+        CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n       }\n     };\n     vm0.invoke(\"Create Region\", createRegion);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjE2Nw==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368102167", "bodyText": "Replace this if and fail block with an assertion:\nassertThat(CCRegion.getRegionEntry(\"ckey0\")).isNull();", "author": "kirklund", "createdAt": "2020-01-17T19:34:39Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {\n           fail(\"While creating region\", ex);\n         }\n       }\n     };\n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its\n-        // modification time to be older than the tombstone GC interval. This\n-        // means it could be in the process of being reaped by distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertTrue(tag.getEntryVersion() > 1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-          fail(\"region was mysteriously cleared during unit testing\", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its\n+      // modification time to be older than the tombstone GC interval. This\n+      // means it could be in the process of being reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertTrue(tag.getEntryVersion() > 1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {\n+        fail(\"region was mysteriously cleared during unit testing\", e);\n       }\n     });\n     // now remove the entry on vm0, simulating that it initiated a GC, and\n     // perform a CREATE with a new version number\n-    vm0.invoke(localDestroyRunnable);\n-    vm1.invoke(new SerializableRunnable(\"Check that the create() was applied\") {\n-      @Override\n-      public void run() {\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        assertThat(entry.getVersionStamp().getEntryVersion()).isEqualTo(1);\n+    vm0.invoke(\"Locally destroy the entry and do a create that will be propagated with v1\", () -> {\n+      CCRegion.getRegionMap().removeEntry(\"cckey0\", CCRegion.getRegionEntry(\"cckey0\"), true);\n+      if (CCRegion.getRegionEntry(\"ckey0\") != null) {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzMDM3Nw==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368130377", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:49:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\nindex 79a435f7c9..fcd0e1eee2 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java\n\n@@ -155,17 +152,12 @@ public class GlobalRegionCCEDUnitTest extends GlobalRegionDUnitTest {\n     SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n-        try {\n-          RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-          CCRegion = (LocalRegion) f.create(name);\n-\n-          // noinspection OverwrittenKey\n-          CCRegion.put(\"cckey0\", \"ccvalue\");\n-          // noinspection OverwrittenKey\n-          CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n-        } catch (CacheException ex) {\n-          fail(\"While creating region\", ex);\n-        }\n+        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n+        CCRegion = (LocalRegion) f.create(name);\n+        // noinspection OverwrittenKey\n+        CCRegion.put(\"cckey0\", \"ccvalue\");\n+        // noinspection OverwrittenKey\n+        CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n       }\n     };\n     vm0.invoke(\"Create Region\", createRegion);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjc4NA==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368102784", "bodyText": "I don't think the code can ever reach lines 116 or 117", "author": "kirklund", "createdAt": "2020-01-17T19:36:12Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -71,71 +71,58 @@\n    */\n   @Test\n   public void testIncompatibleSubregions() throws CacheException {\n-\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n-\n     // Scope.DISTRIBUTED_NO_ACK is illegal if there is any other cache\n     // in the distributed system that has the same region with\n     // Scope.GLOBAL\n \n     final String name = this.getUniqueName() + \"-GLOBAL\";\n-    vm0.invoke(new SerializableRunnable(\"Create GLOBAL Region\") {\n-      @Override\n-      public void run() {\n-        try {\n-          createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL region\", ex);\n-        }\n-        assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\").getAttributes().getScope().isGlobal())\n-            .isTrue();\n+    vm0.invoke(\"Create GLOBAL Region\", () -> {\n+      try {\n+        createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n+      } catch (CacheException ex) {\n+        fail(\"While creating GLOBAL region\", ex);\n       }\n+      assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\").getAttributes().getScope().isGlobal())\n+          .isTrue();\n     });\n \n-    vm1.invoke(new SerializableRunnable(\"Create NO ACK Region\") {\n-      @Override\n-      public void run() {\n+    vm1.invoke(\"Create NO ACK Region\", () -> {\n+      try {\n+        RegionFactory<Object, Object> factory =\n+            getCache().createRegionFactory(getRegionAttributes());\n+        factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n         try {\n-          RegionFactory<Object, Object> factory =\n-              getCache().createRegionFactory(getRegionAttributes());\n-          factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n-          try {\n-            assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n-            createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n-\n-            fail(\"Should have thrown an IllegalStateException\");\n-          } catch (IllegalStateException ignored) {\n-            // pass...\n-          }\n+          assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n+          createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n \n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL Region\", ex);\n+          fail(\"Should have thrown an IllegalStateException\");\n+        } catch (IllegalStateException ignored) {\n+          // pass...\n         }\n+\n+      } catch (CacheException ex) {\n+        fail(\"While creating GLOBAL Region\", ex);\n       }\n     });\n \n-    vm1.invoke(new SerializableRunnable(\"Create ACK Region\") {\n-      @Override\n-      public void run() {\n+    vm1.invoke(\"Create ACK Region\", () -> {\n+      try {\n+        RegionFactory<Object, Object> factory =\n+            getCache().createRegionFactory(getRegionAttributes());\n+        factory.setScope(Scope.DISTRIBUTED_ACK);\n         try {\n-          RegionFactory<Object, Object> factory =\n-              getCache().createRegionFactory(getRegionAttributes());\n-          factory.setScope(Scope.DISTRIBUTED_ACK);\n-          try {\n-            Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n-            fail(\"Should have thrown an IllegalStateException\");\n-            factory.createSubregion(rootRegion, name);\n-            fail(\"Should have thrown an IllegalStateException\");\n-\n-          } catch (IllegalStateException ex) {\n-            // pass...\n-            assertThat(getRootRegion()).isNull();\n-          }\n-\n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL Region\", ex);\n+          Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n+          fail(\"Should have thrown an IllegalStateException\");\n+          factory.createSubregion(rootRegion, name);", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzMDYyOQ==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368130629", "bodyText": "true. Deleted.", "author": "mhansonp", "createdAt": "2020-01-17T20:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\nindex 75196462fa..9538e52c65 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n\n@@ -77,52 +76,35 @@ public class GlobalRegionDUnitTest extends MultiVMRegionTestCase {\n \n     final String name = this.getUniqueName() + \"-GLOBAL\";\n     vm0.invoke(\"Create GLOBAL Region\", () -> {\n-      try {\n-        createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n-      } catch (CacheException ex) {\n-        fail(\"While creating GLOBAL region\", ex);\n-      }\n+      createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n       assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\").getAttributes().getScope().isGlobal())\n           .isTrue();\n     });\n \n     vm1.invoke(\"Create NO ACK Region\", () -> {\n+      RegionFactory<Object, Object> factory =\n+          getCache().createRegionFactory(getRegionAttributes());\n+      factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n       try {\n-        RegionFactory<Object, Object> factory =\n-            getCache().createRegionFactory(getRegionAttributes());\n-        factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n-        try {\n-          assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n-          createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n-\n-          fail(\"Should have thrown an IllegalStateException\");\n-        } catch (IllegalStateException ignored) {\n-          // pass...\n-        }\n+        assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n+        createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n \n-      } catch (CacheException ex) {\n-        fail(\"While creating GLOBAL Region\", ex);\n+        fail(\"Should have thrown an IllegalStateException\");\n+      } catch (IllegalStateException ignored) {\n+        // pass...\n       }\n     });\n \n     vm1.invoke(\"Create ACK Region\", () -> {\n+      RegionFactory<Object, Object> factory =\n+          getCache().createRegionFactory(getRegionAttributes());\n+      factory.setScope(Scope.DISTRIBUTED_ACK);\n       try {\n-        RegionFactory<Object, Object> factory =\n-            getCache().createRegionFactory(getRegionAttributes());\n-        factory.setScope(Scope.DISTRIBUTED_ACK);\n-        try {\n-          Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n-          fail(\"Should have thrown an IllegalStateException\");\n-          factory.createSubregion(rootRegion, name);\n-          fail(\"Should have thrown an IllegalStateException\");\n-\n-        } catch (IllegalStateException ex) {\n-          // pass...\n-          assertThat(getRootRegion()).isNull();\n-        }\n-\n-      } catch (CacheException ex) {\n-        fail(\"While creating GLOBAL Region\", ex);\n+        Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n+        fail(\"Should have thrown an IllegalStateException\");\n+      } catch (IllegalStateException ex) {\n+        // pass...\n+        assertThat(getRootRegion()).isNull();\n       }\n     });\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMzc4MQ==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368103781", "bodyText": "Optional: We should try to replace all testing Threads like these with use of ExecutorServiceRule. Spinning up our own Thread should be considered deprecated and replaced with Executors. The ExecutorServiceRule will report a failure if any thread is left running after the test or if any of these threads threw anything.", "author": "kirklund", "createdAt": "2020-01-17T19:38:41Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\nindex 75196462fa..9538e52c65 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n\n@@ -210,41 +192,33 @@ public class GlobalRegionDUnitTest extends MultiVMRegionTestCase {\n           Thread thread = new Thread(group, () -> {\n             try {\n               final Random rand = new Random(System.identityHashCode(this));\n-              try {\n-                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                for (int j = 0; j < incrementsPerThread; j++) {\n-                  Thread.sleep(rand.nextInt(30) + 30);\n+              Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+              for (int j = 0; j < incrementsPerThread; j++) {\n+                Thread.sleep(rand.nextInt(30) + 30);\n \n-                  Lock lock = region.getDistributedLock(key);\n-                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+                Lock lock = region.getDistributedLock(key);\n+                assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n \n-                  Integer value = region.get(key);\n-                  Integer oldValue = value;\n-                  if (value == null) {\n-                    value = 1;\n+                Integer value = region.get(key);\n+                Integer oldValue = value;\n+                if (value == null) {\n+                  value = 1;\n \n-                  } else {\n-                    Integer v = value;\n-                    value = v + 1;\n-                  }\n-\n-                  assertThat(oldValue).isEqualTo(region.get(key));\n-                  region.put(key, value);\n-                  assertThat(value).isEqualTo(region.get(key));\n-\n-                  lock.unlock();\n+                } else {\n+                  Integer v = value;\n+                  value = v + 1;\n                 }\n \n-              } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                  | CacheWriterException | TimeoutException ex) {\n-                fail(\"While incrementing\", ex);\n+                assertThat(oldValue).isEqualTo(region.get(key));\n+                region.put(key, value);\n+                assertThat(value).isEqualTo(region.get(key));\n+\n+                lock.unlock();\n               }\n-            } catch (VirtualMachineError e) {\n-              throw e;\n-            } catch (Throwable t) {\n-              logger\n-                  .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+            } catch (InterruptedException interruptedException) {\n+              fail(\"interrupted\", interruptedException);\n             }\n+\n           }, \"Incrementer \" + i1);\n           threads[i1] = thread;\n           thread.start();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDExNw==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368104117", "bodyText": "Optional: Delete all catch blocks that catch Error or Throwable.", "author": "kirklund", "createdAt": "2020-01-17T19:39:31Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {\n+            try {\n+              final Random rand = new Random(System.identityHashCode(this));\n               try {\n-                final Random rand = new Random(System.identityHashCode(this));\n-                try {\n-                  Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                  for (int j = 0; j < incrementsPerThread; j++) {\n-                    Thread.sleep(rand.nextInt(30) + 30);\n-\n-                    Lock lock = region.getDistributedLock(key);\n-                    assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n-\n-                    Integer value = region.get(key);\n-                    Integer oldValue = value;\n-                    if (value == null) {\n-                      value = 1;\n-\n-                    } else {\n-                      Integer v = value;\n-                      value = v + 1;\n-                    }\n-\n-                    assertThat(oldValue).isEqualTo(region.get(key));\n-                    region.put(key, value);\n-                    assertThat(value).isEqualTo(region.get(key));\n-\n-                    lock.unlock();\n+                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+                for (int j = 0; j < incrementsPerThread; j++) {\n+                  Thread.sleep(rand.nextInt(30) + 30);\n+\n+                  Lock lock = region.getDistributedLock(key);\n+                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+\n+                  Integer value = region.get(key);\n+                  Integer oldValue = value;\n+                  if (value == null) {\n+                    value = 1;\n+\n+                  } else {\n+                    Integer v = value;\n+                    value = v + 1;\n                   }\n \n-                } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                    | CacheWriterException | TimeoutException ex) {\n-                  fail(\"While incrementing\", ex);\n+                  assertThat(oldValue).isEqualTo(region.get(key));\n+                  region.put(key, value);\n+                  assertThat(value).isEqualTo(region.get(key));\n+\n+                  lock.unlock();\n                 }\n-              } catch (VirtualMachineError e) {\n-                throw e;\n-              } catch (Throwable t) {\n-                logger\n-                    .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+\n+              } catch (IllegalStateException | InterruptedException | CacheLoaderException\n+                  | CacheWriterException | TimeoutException ex) {\n+                fail(\"While incrementing\", ex);\n               }\n+            } catch (VirtualMachineError e) {", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzMjcwMg==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368132702", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T20:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDExNw=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\nindex 75196462fa..9538e52c65 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n\n@@ -210,41 +192,33 @@ public class GlobalRegionDUnitTest extends MultiVMRegionTestCase {\n           Thread thread = new Thread(group, () -> {\n             try {\n               final Random rand = new Random(System.identityHashCode(this));\n-              try {\n-                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                for (int j = 0; j < incrementsPerThread; j++) {\n-                  Thread.sleep(rand.nextInt(30) + 30);\n+              Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+              for (int j = 0; j < incrementsPerThread; j++) {\n+                Thread.sleep(rand.nextInt(30) + 30);\n \n-                  Lock lock = region.getDistributedLock(key);\n-                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+                Lock lock = region.getDistributedLock(key);\n+                assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n \n-                  Integer value = region.get(key);\n-                  Integer oldValue = value;\n-                  if (value == null) {\n-                    value = 1;\n+                Integer value = region.get(key);\n+                Integer oldValue = value;\n+                if (value == null) {\n+                  value = 1;\n \n-                  } else {\n-                    Integer v = value;\n-                    value = v + 1;\n-                  }\n-\n-                  assertThat(oldValue).isEqualTo(region.get(key));\n-                  region.put(key, value);\n-                  assertThat(value).isEqualTo(region.get(key));\n-\n-                  lock.unlock();\n+                } else {\n+                  Integer v = value;\n+                  value = v + 1;\n                 }\n \n-              } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                  | CacheWriterException | TimeoutException ex) {\n-                fail(\"While incrementing\", ex);\n+                assertThat(oldValue).isEqualTo(region.get(key));\n+                region.put(key, value);\n+                assertThat(value).isEqualTo(region.get(key));\n+\n+                lock.unlock();\n               }\n-            } catch (VirtualMachineError e) {\n-              throw e;\n-            } catch (Throwable t) {\n-              logger\n-                  .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+            } catch (InterruptedException interruptedException) {\n+              fail(\"interrupted\", interruptedException);\n             }\n+\n           }, \"Incrementer \" + i1);\n           threads[i1] = thread;\n           thread.start();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDIxMQ==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368104211", "bodyText": "Optional: Remove catch block containing fail and add throws clause to method(s).", "author": "kirklund", "createdAt": "2020-01-17T19:39:44Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {\n+            try {\n+              final Random rand = new Random(System.identityHashCode(this));\n               try {\n-                final Random rand = new Random(System.identityHashCode(this));\n-                try {\n-                  Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                  for (int j = 0; j < incrementsPerThread; j++) {\n-                    Thread.sleep(rand.nextInt(30) + 30);\n-\n-                    Lock lock = region.getDistributedLock(key);\n-                    assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n-\n-                    Integer value = region.get(key);\n-                    Integer oldValue = value;\n-                    if (value == null) {\n-                      value = 1;\n-\n-                    } else {\n-                      Integer v = value;\n-                      value = v + 1;\n-                    }\n-\n-                    assertThat(oldValue).isEqualTo(region.get(key));\n-                    region.put(key, value);\n-                    assertThat(value).isEqualTo(region.get(key));\n-\n-                    lock.unlock();\n+                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+                for (int j = 0; j < incrementsPerThread; j++) {\n+                  Thread.sleep(rand.nextInt(30) + 30);\n+\n+                  Lock lock = region.getDistributedLock(key);\n+                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+\n+                  Integer value = region.get(key);\n+                  Integer oldValue = value;\n+                  if (value == null) {\n+                    value = 1;\n+\n+                  } else {\n+                    Integer v = value;\n+                    value = v + 1;\n                   }\n \n-                } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                    | CacheWriterException | TimeoutException ex) {\n-                  fail(\"While incrementing\", ex);\n+                  assertThat(oldValue).isEqualTo(region.get(key));\n+                  region.put(key, value);\n+                  assertThat(value).isEqualTo(region.get(key));\n+\n+                  lock.unlock();\n                 }\n-              } catch (VirtualMachineError e) {\n-                throw e;\n-              } catch (Throwable t) {\n-                logger\n-                    .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+\n+              } catch (IllegalStateException | InterruptedException | CacheLoaderException", "originalCommit": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzNTE3Ng==", "url": "https://github.com/apache/geode/pull/4568#discussion_r368135176", "bodyText": "done", "author": "mhansonp", "createdAt": "2020-01-17T21:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDIxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "648f86c4744d65bf83425156d4753abcd6425c7f", "chunk": "diff --git a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\nindex 75196462fa..9538e52c65 100644\n--- a/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n+++ b/geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java\n\n@@ -210,41 +192,33 @@ public class GlobalRegionDUnitTest extends MultiVMRegionTestCase {\n           Thread thread = new Thread(group, () -> {\n             try {\n               final Random rand = new Random(System.identityHashCode(this));\n-              try {\n-                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                for (int j = 0; j < incrementsPerThread; j++) {\n-                  Thread.sleep(rand.nextInt(30) + 30);\n+              Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+              for (int j = 0; j < incrementsPerThread; j++) {\n+                Thread.sleep(rand.nextInt(30) + 30);\n \n-                  Lock lock = region.getDistributedLock(key);\n-                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+                Lock lock = region.getDistributedLock(key);\n+                assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n \n-                  Integer value = region.get(key);\n-                  Integer oldValue = value;\n-                  if (value == null) {\n-                    value = 1;\n+                Integer value = region.get(key);\n+                Integer oldValue = value;\n+                if (value == null) {\n+                  value = 1;\n \n-                  } else {\n-                    Integer v = value;\n-                    value = v + 1;\n-                  }\n-\n-                  assertThat(oldValue).isEqualTo(region.get(key));\n-                  region.put(key, value);\n-                  assertThat(value).isEqualTo(region.get(key));\n-\n-                  lock.unlock();\n+                } else {\n+                  Integer v = value;\n+                  value = v + 1;\n                 }\n \n-              } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                  | CacheWriterException | TimeoutException ex) {\n-                fail(\"While incrementing\", ex);\n+                assertThat(oldValue).isEqualTo(region.get(key));\n+                region.put(key, value);\n+                assertThat(value).isEqualTo(region.get(key));\n+\n+                lock.unlock();\n               }\n-            } catch (VirtualMachineError e) {\n-              throw e;\n-            } catch (Throwable t) {\n-              logger\n-                  .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+            } catch (InterruptedException interruptedException) {\n+              fail(\"interrupted\", interruptedException);\n             }\n+\n           }, \"Incrementer \" + i1);\n           threads[i1] = thread;\n           thread.start();\n"}}, {"oid": "648f86c4744d65bf83425156d4753abcd6425c7f", "url": "https://github.com/apache/geode/commit/648f86c4744d65bf83425156d4753abcd6425c7f", "message": "Addressing comments on code", "committedDate": "2020-01-21T17:27:29Z", "type": "commit"}]}