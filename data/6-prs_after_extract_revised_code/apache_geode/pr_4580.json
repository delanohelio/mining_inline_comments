{"pr_number": 4580, "pr_title": "GEODE-5407: Fix JMXMBeanReconnectDUnitTest", "pr_createdAt": "2020-01-09T23:09:50Z", "pr_url": "https://github.com/apache/geode/pull/4580", "timeline": [{"oid": "66525f917335c00125368c7570871bc6ac4242b5", "url": "https://github.com/apache/geode/commit/66525f917335c00125368c7570871bc6ac4242b5", "message": "GEODE-5407: Fix JMXMBeanReconnectDUnitTest\n\nRewrite test with standard Geode and JMX APIs.\n\nUse Awaitility consistently before validating GemFire MXBeans.", "committedDate": "2020-01-09T23:23:31Z", "type": "forcePushed"}, {"oid": "49936e93909e467884e015b57149bdbdbe5c10cf", "url": "https://github.com/apache/geode/commit/49936e93909e467884e015b57149bdbdbe5c10cf", "message": "GEODE-5407: Fix JMXMBeanReconnectDUnitTest\n\n* Rewrite test with standard Geode and JMX APIs\n* Use CountDownLatch instead of Blackboard\n* Use SharedErrorCollector for remote listener errors\n* Always consistently use Awaitility before checking GemFire MXBeans\n\nCo-authored-by: Ivan Godwin <igodwin@pivotal.io>", "committedDate": "2020-01-09T23:23:56Z", "type": "forcePushed"}, {"oid": "cb6463bff5bdc1b60e4e292a084cb5e3698a9b5f", "url": "https://github.com/apache/geode/commit/cb6463bff5bdc1b60e4e292a084cb5e3698a9b5f", "message": "GEODE-5407: Fix JMXMBeanReconnectDUnitTest\n\n* Rewrite test with standard Geode and JMX APIs\n* Use CountDownLatch instead of Blackboard\n* Use SharedErrorCollector for remote listener errors\n* Always consistently use Awaitility before checking GemFire MXBeans\n\nCo-authored-by: Ivan Godwin <igodwin@pivotal.io>", "committedDate": "2020-01-10T23:07:12Z", "type": "forcePushed"}, {"oid": "51b88a57b537f19876bc90edfdf3b067163b8d85", "url": "https://github.com/apache/geode/commit/51b88a57b537f19876bc90edfdf3b067163b8d85", "message": "GEODE-5407: Fix JMXMBeanReconnectDUnitTest\n\n* Rewrite test with standard Geode and JMX APIs\n* Use CountDownLatch instead of Blackboard\n* Use SharedErrorCollector for remote listener errors\n* Always consistently use Awaitility before checking GemFire MXBeans\n\nCo-authored-by: Ivan Godwin <igodwin@pivotal.io>", "committedDate": "2020-01-10T23:10:40Z", "type": "commit"}, {"oid": "51b88a57b537f19876bc90edfdf3b067163b8d85", "url": "https://github.com/apache/geode/commit/51b88a57b537f19876bc90edfdf3b067163b8d85", "message": "GEODE-5407: Fix JMXMBeanReconnectDUnitTest\n\n* Rewrite test with standard Geode and JMX APIs\n* Use CountDownLatch instead of Blackboard\n* Use SharedErrorCollector for remote listener errors\n* Always consistently use Awaitility before checking GemFire MXBeans\n\nCo-authored-by: Ivan Godwin <igodwin@pivotal.io>", "committedDate": "2020-01-10T23:10:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk4ODI1OA==", "url": "https://github.com/apache/geode/pull/4580#discussion_r365988258", "bodyText": "Is this change to default still required? It looks like we are overriding for each implementation of ReconnectListener.", "author": "igodwin", "createdAt": "2020-01-13T19:33:48Z", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/InternalDistributedSystem.java", "diffHunk": "@@ -2212,15 +2212,20 @@ public Properties getSecurityProperties() {\n      * @param oldSystem the old DS, which is in a partially disconnected state and cannot be used\n      *        for messaging\n      */\n-    void reconnecting(InternalDistributedSystem oldSystem);\n+    default void reconnecting(InternalDistributedSystem oldSystem) {", "originalCommit": "51b88a57b537f19876bc90edfdf3b067163b8d85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA2MjAxMw==", "url": "https://github.com/apache/geode/pull/4580#discussion_r366062013", "bodyText": "It's not required but I think it's a good addition. This is an internal listener, so we're not impacting any users. Adding default just means that implementers (tests) can implement just the method(s) it needs to instead of including empty impl methods.", "author": "kirklund", "createdAt": "2020-01-13T22:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk4ODI1OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA2Mjg2Mw==", "url": "https://github.com/apache/geode/pull/4580#discussion_r366062863", "bodyText": "@igodwin Here's one of the implementations of ReconnectListener in the new test which doesn't implement both methods. If we remove default, then this impl would have to provide an empty impl of onReconnect.", "author": "kirklund", "createdAt": "2020-01-13T22:27:50Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanReconnectDUnitTest.java", "diffHunk": "@@ -156,47 +341,51 @@ public void testLocalBeans_MaintainLocatorAndCrashServer() {\n    * All MBeans not related to the killed member should remain the same when a member is killed.\n    */\n   @Test\n-  public void testRemoteBeanKnowledge_MaintainServerAndCrashLocator() throws IOException {\n-    // check that the initial state is good\n-    List<ObjectName> initialL1Beans = jmxConToLocator1.getGemfireFederatedBeans();\n-    List<ObjectName> initialL2Beans = jmxConToLocator2.getGemfireFederatedBeans();\n-    assertThat(initialL1Beans).containsExactlyElementsOf(initialL2Beans).hasSize(NUM_REMOTE_BEANS);\n-\n-    // calculate the expected list for use once the locator has crashed\n-    List<ObjectName> expectedIntermediateBeanList = initialL1Beans.stream()\n-        .filter(excludingBeansFor(\"locator-0\")).collect(toList());\n-\n-    // crash the locator\n-    locator1.forceDisconnect(TIMEOUT, TimeUnit.MILLISECONDS, RECONNECT_MAILBOX);\n-\n-    // wait for the locator's crash to federate to the remaining locator\n-    List<ObjectName> intermediateL2Beans = new ArrayList<>();\n-    await().untilAsserted(() -> {\n-      intermediateL2Beans.clear();\n-      intermediateL2Beans.addAll(jmxConToLocator2.getGemfireFederatedBeans());\n-\n-      assertThat(intermediateL2Beans)\n-          .containsExactlyElementsOf(expectedIntermediateBeanList)\n-          .hasSameSizeAs(expectedIntermediateBeanList);\n+  public void locatorMXBeansOnOtherLocatorAreRestoredAfterCrashedLocatorReturns() {\n+    locator1VM.invoke(() -> {\n+      RECONNECT_LATCH.set(new CountDownLatch(1));\n+\n+      addReconnectListener(new ReconnectListener() {", "originalCommit": "51b88a57b537f19876bc90edfdf3b067163b8d85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ4MTI1NQ==", "url": "https://github.com/apache/geode/pull/4580#discussion_r366481255", "bodyText": "There are a lot of collapsible lambdas. I presume you intentionally did not collapse them for readability.", "author": "mhansonp", "createdAt": "2020-01-14T17:45:37Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanReconnectDUnitTest.java", "diffHunk": "@@ -36,117 +54,284 @@\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n \n-import org.apache.geode.cache.Cache;\n-import org.apache.geode.management.internal.SystemManagementService;\n-import org.apache.geode.test.awaitility.GeodeAwaitility;\n-import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n-import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.CancelException;\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem.ReconnectListener;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.api.MemberDisconnectedException;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.dunit.rules.SharedErrorCollector;\n import org.apache.geode.test.junit.categories.JMXTest;\n-import org.apache.geode.test.junit.rules.ConcurrencyRule;\n import org.apache.geode.test.junit.rules.GfshCommandRule;\n-import org.apache.geode.test.junit.rules.MBeanServerConnectionRule;\n-\n-@Category({JMXTest.class})\n-public class JMXMBeanReconnectDUnitTest {\n-  private static final String REGION_PATH = \"/test-region-1\";\n-  private static final String RECONNECT_MAILBOX = \"reconnectReady\";\n-  private static final int SERVER_COUNT = 2;\n-  private static final int NUM_REMOTE_BEANS = 19;\n-  private static final int NUM_LOCATOR_BEANS = 8;\n-  private static final int NUM_SERVER_BEANS = 3;\n-  private static final long TIMEOUT = GeodeAwaitility.getTimeout().getValueInMS();\n-\n-  private MemberVM locator1, locator2, server1;\n+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+@Category(JMXTest.class)\n+@SuppressWarnings(\"serial\")\n+public class JMXMBeanReconnectDUnitTest implements Serializable {\n+\n+  private static final long TIMEOUT_MILLIS = getTimeout().getValueInMS();\n+\n+  private static final AtomicReference<CountDownLatch> RECONNECT_LATCH =\n+      new AtomicReference<>(new CountDownLatch(0));\n+  private static final AtomicReference<CountDownLatch> RECONNECTED_LATCH =\n+      new AtomicReference<>(new CountDownLatch(0));\n+\n+  private static LocatorLauncher locatorLauncher;\n+  private static ServerLauncher serverLauncher;\n+\n+  private VM locator1VM;\n+  private VM locator2VM;\n+  private VM serverVM;\n+\n+  private String locator1Name;\n+  private String locator2Name;\n+  private String serverName;\n+  private String locators;\n+  private int locator1Port;\n+  private int locator2Port;\n+  private int locator1JmxPort;\n+  private int locator2JmxPort;\n+  private Set<ObjectName> serverMXBeans;\n+  private Set<ObjectName> mxbeansOnLocator1;\n+  private Set<ObjectName> mxbeansOnLocator2;\n \n   @Rule\n-  public ClusterStartupRule lsRule = new ClusterStartupRule();\n+  public DistributedRule distributedRule = new DistributedRule();\n \n   @Rule\n-  public GfshCommandRule gfsh = new GfshCommandRule();\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n \n-  private MBeanServerConnectionRule jmxConToLocator1;\n-  private MBeanServerConnectionRule jmxConToLocator2;\n+  @Rule\n+  public SharedErrorCollector errorCollector = new SharedErrorCollector();\n \n   @Rule\n-  public ConcurrencyRule concurrencyRule = new ConcurrencyRule();\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n \n   @Before\n-  public void before() throws Exception {\n-    locator1 = lsRule.startLocatorVM(0);\n-    locator2 = lsRule.startLocatorVM(1, locator1.getPort());\n-\n-    server1 = lsRule.startServerVM(2, locator1.getPort());\n-    // start an extra server to have more MBeans, but we don't need to use it in these tests\n-    lsRule.startServerVM(3, locator1.getPort());\n+  public void setUp() throws Exception {\n+    locator1VM = getVM(1);\n+    locator2VM = getVM(2);\n+    serverVM = getVM(0);\n+\n+    locator1Name = \"locator1\";\n+    locator2Name = \"locator2\";\n+    serverName = \"server1\";\n+    File locator1Dir = temporaryFolder.newFolder(locator1Name);\n+    File locator2Dir = temporaryFolder.newFolder(locator2Name);\n+    File serverDir = temporaryFolder.newFolder(serverName);\n+\n+    int[] port = getRandomAvailableTCPPorts(4);\n+    locator1Port = port[0];\n+    locator2Port = port[1];\n+    locator1JmxPort = port[2];\n+    locator2JmxPort = port[3];\n+    locators = \"localhost[\" + locator1Port + \"];localhost[\" + locator2Port;\n+\n+    locator1VM.invoke(\n+        () -> startLocator(locator1Name, locator1Dir, locator1Port, locator1JmxPort, locators));\n+    locator2VM.invoke(\n+        () -> startLocator(locator2Name, locator2Dir, locator2Port, locator2JmxPort, locators));\n+\n+    serverVM.invoke(() -> startServer(serverName, serverDir, locators));\n+\n+    gfsh.connectAndVerify(locator1JmxPort, PortType.jmxManager);\n+\n+    String regionName = \"region1\";\n+    String createRegionCommand = \"create region --type=REPLICATE --name=\" + SEPARATOR + regionName;\n+    gfsh.executeAndAssertThat(createRegionCommand).statusIsSuccess();\n+\n+    addIgnoredException(CacheClosedException.class);\n+    addIgnoredException(CancelException.class);\n+    addIgnoredException(DistributedSystemDisconnectedException.class);\n+    addIgnoredException(ForcedDisconnectException.class);\n+    addIgnoredException(MemberDisconnectedException.class);\n+    addIgnoredException(\"Possible loss of quorum\");\n+\n+    serverMXBeans = serverVM.invoke(() -> {\n+      await().untilAsserted(() -> {\n+        assertThat(getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null))\n+            .containsAll(expectedMXBeansOnServer());\n+      });\n+      return getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null);\n+    });\n \n-    gfsh.connectAndVerify(locator1);\n-    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + REGION_PATH\n-        + \" --enable-statistics=true\").statusIsSuccess();\n+    mxbeansOnLocator1 = locator1VM.invoke(() -> {", "originalCommit": "51b88a57b537f19876bc90edfdf3b067163b8d85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}