{"pr_number": 4899, "pr_title": "GEODE-7945: Replace Map with ConcurrentMap for GemFireCacheImpl.rootRegions", "pr_createdAt": "2020-04-02T19:49:35Z", "pr_url": "https://github.com/apache/geode/pull/4899", "timeline": [{"oid": "da4c36c7b470bd18a50a246f47049ddbcd4df595", "url": "https://github.com/apache/geode/commit/da4c36c7b470bd18a50a246f47049ddbcd4df595", "message": "GEODE-7945: Replace Map with ConcurrentMap for GemFireCacheImpl.rootRegions\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-02T19:46:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwMTMxMQ==", "url": "https://github.com/apache/geode/pull/4899#discussion_r402601311", "bodyText": "This code no longer looks correct. The synchronization made this thread safe.\nWithout the sync you need to just call a method on rootRegions once.\nI think you just want to do this: return rootRegions.remove(regionName, rootRgn);", "author": "dschneider-pivotal", "createdAt": "2020-04-02T21:17:23Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -3438,16 +3436,16 @@ public boolean getCopyOnRead() {\n \n   @Override\n   public boolean removeRoot(InternalRegion rootRgn) {\n-    synchronized (rootRegions) {\n-      String regionName = rootRgn.getName();\n-      InternalRegion found = rootRegions.get(regionName);\n-      if (found == rootRgn) {\n-        InternalRegion previous = rootRegions.remove(regionName);\n-        Assert.assertTrue(previous == rootRgn);\n-        return true;\n-      }\n-      return false;\n+\n+    String regionName = rootRgn.getName();\n+    InternalRegion found = rootRegions.get(regionName);\n+    if (found == rootRgn) {", "originalCommit": "da4c36c7b470bd18a50a246f47049ddbcd4df595", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91de61e84be80af1ad76a2e6e52242f71b0baf56", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\nindex 37177f8120..3294b0a2cf 100755\n--- a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n\n@@ -3438,13 +3433,7 @@ public class GemFireCacheImpl implements InternalCache, InternalClientCache, Has\n   public boolean removeRoot(InternalRegion rootRgn) {\n \n     String regionName = rootRgn.getName();\n-    InternalRegion found = rootRegions.get(regionName);\n-    if (found == rootRgn) {\n-      InternalRegion previous = rootRegions.remove(regionName);\n-      Assert.assertTrue(previous == rootRgn);\n-      return true;\n-    }\n-    return false;\n+    return rootRegions.remove(regionName, rootRgn);\n \n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwMzI2NA==", "url": "https://github.com/apache/geode/pull/4899#discussion_r402603264", "bodyText": "This does not look thread safe. Instead of calling get and then remove you need a single call.\nHere I think you want: rootRegions.remove(name, region);", "author": "dschneider-pivotal", "createdAt": "2020-04-02T21:21:17Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -2997,12 +2995,12 @@ public void validatePoolFactory(PoolFactory poolFactory) {\n           } finally {\n             // clean up if initialize fails for any reason\n             setRegionByPath(region.getFullPath(), null);\n-            synchronized (rootRegions) {\n-              Region rootRegion = rootRegions.get(name);\n-              if (rootRegion == region) {\n-                rootRegions.remove(name);\n-              }\n+\n+            Region rootRegion = rootRegions.get(name);", "originalCommit": "da4c36c7b470bd18a50a246f47049ddbcd4df595", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91de61e84be80af1ad76a2e6e52242f71b0baf56", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\nindex 37177f8120..3294b0a2cf 100755\n--- a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n\n@@ -2995,12 +2995,7 @@ public class GemFireCacheImpl implements InternalCache, InternalClientCache, Has\n           } finally {\n             // clean up if initialize fails for any reason\n             setRegionByPath(region.getFullPath(), null);\n-\n-            Region rootRegion = rootRegions.get(name);\n-            if (rootRegion == region) {\n-              rootRegions.remove(name);\n-            }\n-\n+            rootRegions.remove(name, region);\n           }\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNDg4Ng==", "url": "https://github.com/apache/geode/pull/4899#discussion_r402604886", "bodyText": "This does not look thread safe. I don't think we want to do a get followed by a put here. This allows two threads to both see null on the get and then they both create it and the last one wins. Maybe a single call of computeIfAbsent instead of the get+put is what you want here", "author": "dschneider-pivotal", "createdAt": "2020-04-02T21:24:36Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -2905,45 +2904,44 @@ public void validatePoolFactory(PoolFactory poolFactory) {\n         getCancelCriterion().checkCancelInProgress(null);\n \n         Future<InternalRegion> future = null;\n-        synchronized (rootRegions) {\n-          region = rootRegions.get(name);\n-          if (region != null) {\n-            throw new RegionExistsException(region);\n-          }\n-          // check for case where a root region is being reinitialized\n-          // and we didn't find a region, i.e. the new region is about to be created\n \n-          if (!isReInitCreate) {\n-            String fullPath = Region.SEPARATOR + name;\n-            future = reinitializingRegions.get(fullPath);\n-          }\n-          if (future == null) {\n-            if (internalRegionArgs.getInternalMetaRegion() != null) {\n-              region = internalRegionArgs.getInternalMetaRegion();\n-            } else if (isPartitionedRegion) {\n-              region = new PartitionedRegion(name, attrs, null, this, internalRegionArgs,\n-                  statisticsClock, ColocationLoggerFactory.create());\n+        region = rootRegions.get(name);\n+        if (region != null) {\n+          throw new RegionExistsException(region);\n+        }\n+        // check for case where a root region is being reinitialized\n+        // and we didn't find a region, i.e. the new region is about to be created\n+\n+        if (!isReInitCreate) {\n+          String fullPath = Region.SEPARATOR + name;\n+          future = reinitializingRegions.get(fullPath);\n+        }\n+        if (future == null) {\n+          if (internalRegionArgs.getInternalMetaRegion() != null) {\n+            region = internalRegionArgs.getInternalMetaRegion();\n+          } else if (isPartitionedRegion) {\n+            region = new PartitionedRegion(name, attrs, null, this, internalRegionArgs,\n+                statisticsClock, ColocationLoggerFactory.create());\n+          } else {\n+            // Abstract region depends on the default pool existing so lazily initialize it\n+            // if necessary.\n+            if (Objects.equals(attrs.getPoolName(), DEFAULT_POOL_NAME)) {\n+              determineDefaultPool();\n+            }\n+            if (attrs.getScope().isLocal()) {\n+              region =\n+                  new LocalRegion(name, attrs, null, this, internalRegionArgs, statisticsClock);\n             } else {\n-              // Abstract region depends on the default pool existing so lazily initialize it\n-              // if necessary.\n-              if (Objects.equals(attrs.getPoolName(), DEFAULT_POOL_NAME)) {\n-                determineDefaultPool();\n-              }\n-              if (attrs.getScope().isLocal()) {\n-                region =\n-                    new LocalRegion(name, attrs, null, this, internalRegionArgs, statisticsClock);\n-              } else {\n-                region = new DistributedRegion(name, attrs, null, this, internalRegionArgs,\n-                    statisticsClock);\n-              }\n+              region = new DistributedRegion(name, attrs, null, this, internalRegionArgs,\n+                  statisticsClock);\n             }\n+          }\n \n-            rootRegions.put(name, region);\n-            if (isReInitCreate) {\n-              regionReinitialized(region);\n-            }\n-            break;\n+          rootRegions.put(name, region);", "originalCommit": "da4c36c7b470bd18a50a246f47049ddbcd4df595", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b8692b9143f34ecd0189adf743e8ae18f6352b0d", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\nindex 37177f8120..b2a198f4c1 100755\n--- a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n\n@@ -2904,46 +2903,46 @@ public class GemFireCacheImpl implements InternalCache, InternalClientCache, Has\n         getCancelCriterion().checkCancelInProgress(null);\n \n         Future<InternalRegion> future = null;\n+        synchronized (rootRegions) {\n+          region = rootRegions.get(name);\n+          if (region != null) {\n+            throw new RegionExistsException(region);\n+          }\n+          // check for case where a root region is being reinitialized\n+          // and we didn't find a region, i.e. the new region is about to be created\n \n-        region = rootRegions.get(name);\n-        if (region != null) {\n-          throw new RegionExistsException(region);\n-        }\n-        // check for case where a root region is being reinitialized\n-        // and we didn't find a region, i.e. the new region is about to be created\n-\n-        if (!isReInitCreate) {\n-          String fullPath = Region.SEPARATOR + name;\n-          future = reinitializingRegions.get(fullPath);\n-        }\n-        if (future == null) {\n-          if (internalRegionArgs.getInternalMetaRegion() != null) {\n-            region = internalRegionArgs.getInternalMetaRegion();\n-          } else if (isPartitionedRegion) {\n-            region = new PartitionedRegion(name, attrs, null, this, internalRegionArgs,\n-                statisticsClock, ColocationLoggerFactory.create());\n-          } else {\n-            // Abstract region depends on the default pool existing so lazily initialize it\n-            // if necessary.\n-            if (Objects.equals(attrs.getPoolName(), DEFAULT_POOL_NAME)) {\n-              determineDefaultPool();\n-            }\n-            if (attrs.getScope().isLocal()) {\n-              region =\n-                  new LocalRegion(name, attrs, null, this, internalRegionArgs, statisticsClock);\n+          if (!isReInitCreate) {\n+            String fullPath = Region.SEPARATOR + name;\n+            future = reinitializingRegions.get(fullPath);\n+          }\n+          if (future == null) {\n+            if (internalRegionArgs.getInternalMetaRegion() != null) {\n+              region = internalRegionArgs.getInternalMetaRegion();\n+            } else if (isPartitionedRegion) {\n+              region = new PartitionedRegion(name, attrs, null, this, internalRegionArgs,\n+                  statisticsClock, ColocationLoggerFactory.create());\n             } else {\n-              region = new DistributedRegion(name, attrs, null, this, internalRegionArgs,\n-                  statisticsClock);\n+              // Abstract region depends on the default pool existing so lazily initialize it\n+              // if necessary.\n+              if (Objects.equals(attrs.getPoolName(), DEFAULT_POOL_NAME)) {\n+                determineDefaultPool();\n+              }\n+              if (attrs.getScope().isLocal()) {\n+                region =\n+                    new LocalRegion(name, attrs, null, this, internalRegionArgs, statisticsClock);\n+              } else {\n+                region = new DistributedRegion(name, attrs, null, this, internalRegionArgs,\n+                    statisticsClock);\n+              }\n             }\n-          }\n \n-          rootRegions.put(name, region);\n-          if (isReInitCreate) {\n-            regionReinitialized(region);\n+            rootRegions.put(name, region);\n+            if (isReInitCreate) {\n+              regionReinitialized(region);\n+            }\n+            break;\n           }\n-          break;\n         }\n-\n         boolean interrupted = Thread.interrupted();\n         try {\n           throw new RegionExistsException(future.get());\n"}}, {"oid": "91de61e84be80af1ad76a2e6e52242f71b0baf56", "url": "https://github.com/apache/geode/commit/91de61e84be80af1ad76a2e6e52242f71b0baf56", "message": "Replace Map.get and remove with remove\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-03T00:57:44Z", "type": "commit"}, {"oid": "94035a6f242839ec52bf0836b98209bde8b53f59", "url": "https://github.com/apache/geode/commit/94035a6f242839ec52bf0836b98209bde8b53f59", "message": "Remove unnecessary import\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-06T17:26:06Z", "type": "commit"}, {"oid": "b8692b9143f34ecd0189adf743e8ae18f6352b0d", "url": "https://github.com/apache/geode/commit/b8692b9143f34ecd0189adf743e8ae18f6352b0d", "message": "Revert the removed synchronized block\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-06T18:11:25Z", "type": "commit"}, {"oid": "1c4734fc50cdd02ce9eb44a4807ff00e13dc51f3", "url": "https://github.com/apache/geode/commit/1c4734fc50cdd02ce9eb44a4807ff00e13dc51f3", "message": "Fix the typo in log messages\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-07T18:53:15Z", "type": "commit"}, {"oid": "6e2f035af72a60baccf13aa4c85e4628ccbaf202", "url": "https://github.com/apache/geode/commit/6e2f035af72a60baccf13aa4c85e4628ccbaf202", "message": "Correct misleading log message\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-07T18:54:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA3OTc5NA==", "url": "https://github.com/apache/geode/pull/4899#discussion_r405079794", "bodyText": "I see no reason for continuing to have this method make a copy of \"rootRegions.values()\". All it does with \"rootRegionValues\" is an iteration. So now that you have changed to a ConcurrentMap, I think you can safely get rid of \"rootRegionValues\" and down on line 2194 do this: for (InternalRegion lr: rootRegions.values())", "author": "dschneider-pivotal", "createdAt": "2020-04-07T20:06:43Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -2176,9 +2175,8 @@ public void close(String reason, Throwable systemFailureCause, boolean keepAlive\n           prepareDiskStoresForClose();\n \n           List<InternalRegion> rootRegionValues;\n-          synchronized (rootRegions) {\n-            rootRegionValues = new ArrayList<>(rootRegions.values());\n-          }\n+\n+          rootRegionValues = new ArrayList<>(rootRegions.values());", "originalCommit": "6e2f035af72a60baccf13aa4c85e4628ccbaf202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyOTIzNg==", "url": "https://github.com/apache/geode/pull/4899#discussion_r405129236", "bodyText": "If we do for (InternalRegion lr : rootRegions.vales()), other threads may change rootRegions while the for loop is still in progress. Since each for iteration evaluates rootRegions.values(), the resulting behavior could be different than the original behavior, which iterates over a snapshot of rootRegions. The new behavior is still valid though.", "author": "jchen21", "createdAt": "2020-04-07T21:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA3OTc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1NTc3MA==", "url": "https://github.com/apache/geode/pull/4899#discussion_r405155770", "bodyText": "I you think about what you are doing now when you make the copy, it is actually iterating over the values to copy them into your ArrayList; without any type of lock. Basically ConcurrentMap gives you a Set that you can safely iterate without locking. It may change but you would only notice this if you did something like iterate it twice and compared the first iteration to the second. Since all this code does is a simple iteration you don't need to make a copy to be safe. It is not going to break the code; but you are wasting some memory and cpu and possibly making future coders think you need to make a copy to be safe :-)", "author": "dschneider-pivotal", "createdAt": "2020-04-07T22:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA3OTc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1NjUwMA==", "url": "https://github.com/apache/geode/pull/4899#discussion_r405156500", "bodyText": "By the way, each iteration does not evaluate rootRegion.values(). Values is called once and the result is iterated. Each iteration gets the next value from the Set that values() returned.", "author": "dschneider-pivotal", "createdAt": "2020-04-07T22:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA3OTc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "d58266e5bef46beca1f79c6488bea6dd35591f35", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\nindex b2a198f4c1..1fd0d63b64 100755\n--- a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java\n\n@@ -2174,10 +2174,6 @@ public class GemFireCacheImpl implements InternalCache, InternalClientCache, Has\n \n           prepareDiskStoresForClose();\n \n-          List<InternalRegion> rootRegionValues;\n-\n-          rootRegionValues = new ArrayList<>(rootRegions.values());\n-\n           Operation op;\n           if (forcedDisconnect) {\n             op = Operation.FORCED_DISCONNECT;\n"}}, {"oid": "d58266e5bef46beca1f79c6488bea6dd35591f35", "url": "https://github.com/apache/geode/commit/d58266e5bef46beca1f79c6488bea6dd35591f35", "message": "Remove unnecessary copy of rootRegions values\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-07T22:39:07Z", "type": "commit"}, {"oid": "84afd1c942957124fefdd1364b5189f21cbdf5b4", "url": "https://github.com/apache/geode/commit/84afd1c942957124fefdd1364b5189f21cbdf5b4", "message": "spotlessApply\n\nAuthored-by: Jianxia Chen <jchen21@apache.org>", "committedDate": "2020-04-08T00:24:34Z", "type": "commit"}, {"oid": "417015c397a3496caae45de60c04b3e9ff98e146", "url": "https://github.com/apache/geode/commit/417015c397a3496caae45de60c04b3e9ff98e146", "message": "Revert \"Correct misleading log message\"\n\nThis reverts commit 6e2f035af72a60baccf13aa4c85e4628ccbaf202.", "committedDate": "2020-04-08T23:47:56Z", "type": "commit"}]}