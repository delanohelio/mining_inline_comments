{"pr_number": 5536, "pr_title": "GEODE-8520: GCStatsMonitor should sum up all the GC stats to get the \u2026", "pr_createdAt": "2020-09-22T22:43:56Z", "pr_url": "https://github.com/apache/geode/pull/5536", "timeline": [{"oid": "6cee04b359920f6e152069e5a0ed80d55bbedbe5", "url": "https://github.com/apache/geode/commit/6cee04b359920f6e152069e5a0ed80d55bbedbe5", "message": "GEODE-8520: GCStatsMonitor should sum up all the GC stats to get the total GC count and GC time.", "committedDate": "2020-09-22T22:43:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5MzIzMQ==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493093231", "bodyText": "Why did we switch from getCollections and getCollectionTime to the string based approach?", "author": "mhansonp", "createdAt": "2020-09-22T23:42:24Z", "path": "geode-core/src/test/java/org/apache/geode/management/bean/stats/MemberLevelStatsTest.java", "diffHunk": "@@ -339,6 +342,41 @@ public void testRegionCounters() {\n     assertThat(memberMBeanBridge.getTotalPrimaryBucketCount()).isZero();\n   }\n \n+  @Test\n+  public void testVMStats() {\n+    Statistics[] realStats = statisticsManager.findStatisticsByType(VMStats50.getGCType());\n+    long[] totals = modifyStatsAndReturnTotalCountAndTime(10, 2500, realStats);\n+    memberMBeanBridge.addVMStats(statSampler.getVMStats());\n+    assertThat(memberMBeanBridge.getGarbageCollectionCount()).isEqualTo(totals[0]);\n+    assertThat(memberMBeanBridge.getGarbageCollectionTime()).isEqualTo(totals[1]);\n+\n+    long[] newTotals = modifyStatsAndReturnTotalCountAndTime(20, 3500, realStats);\n+    sampleStats();\n+    assertThat(memberMBeanBridge.getGarbageCollectionCount()).isEqualTo(newTotals[0]);\n+    assertThat(memberMBeanBridge.getGarbageCollectionTime()).isEqualTo(newTotals[1]);\n+  }\n+\n+  private long[] modifyStatsAndReturnTotalCountAndTime(\n+      long baseCount, long baseTime,\n+      Statistics[] modifiedStats) {\n+    long[] totalCountAndTime = {0, 0};\n+    for (Statistics gcStat : modifiedStats) {\n+      StatisticDescriptor[] statistics = gcStat.getType().getStatistics();", "originalCommit": "6cee04b359920f6e152069e5a0ed80d55bbedbe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1MzcxNQ==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493153715", "bodyText": "those two methods are removed from the GCMonitor. They were package protected anyway, no usage besides this tests. production code is using getStatistics method.", "author": "jinmeiliao", "createdAt": "2020-09-23T02:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5MzIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MjMyNA==", "url": "https://github.com/apache/geode/pull/5536#discussion_r494472324", "bodyText": "Thanks!", "author": "mhansonp", "createdAt": "2020-09-24T16:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5MzIzMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczODM2OQ==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493738369", "bodyText": "I think you should either reference a constant instead of referencing \"collections\" and \"collectionTime\" in multiple classes or go back to using methods such as getCollections().", "author": "kirklund", "createdAt": "2020-09-23T16:43:31Z", "path": "geode-core/src/test/java/org/apache/geode/management/bean/stats/MemberLevelStatsTest.java", "diffHunk": "@@ -339,6 +342,41 @@ public void testRegionCounters() {\n     assertThat(memberMBeanBridge.getTotalPrimaryBucketCount()).isZero();\n   }\n \n+  @Test\n+  public void testVMStats() {\n+    Statistics[] realStats = statisticsManager.findStatisticsByType(VMStats50.getGCType());\n+    long[] totals = modifyStatsAndReturnTotalCountAndTime(10, 2500, realStats);\n+    memberMBeanBridge.addVMStats(statSampler.getVMStats());\n+    assertThat(memberMBeanBridge.getGarbageCollectionCount()).isEqualTo(totals[0]);\n+    assertThat(memberMBeanBridge.getGarbageCollectionTime()).isEqualTo(totals[1]);\n+\n+    long[] newTotals = modifyStatsAndReturnTotalCountAndTime(20, 3500, realStats);\n+    sampleStats();\n+    assertThat(memberMBeanBridge.getGarbageCollectionCount()).isEqualTo(newTotals[0]);\n+    assertThat(memberMBeanBridge.getGarbageCollectionTime()).isEqualTo(newTotals[1]);\n+  }\n+\n+  private long[] modifyStatsAndReturnTotalCountAndTime(\n+      long baseCount, long baseTime,\n+      Statistics[] modifiedStats) {\n+    long[] totalCountAndTime = {0, 0};\n+    for (Statistics gcStat : modifiedStats) {\n+      StatisticDescriptor[] statistics = gcStat.getType().getStatistics();\n+      for (StatisticDescriptor d : statistics) {\n+        if (\"collections\".equals(d.getName())) {", "originalCommit": "6cee04b359920f6e152069e5a0ed80d55bbedbe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczOTY1NQ==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493739655", "bodyText": "Using += on a volatile field is not thread safe. I recommend changing collections and collectionTime to be AtomicLong instances. Then you can use incrementAndGet() instead of +=. Even if multiple threads do not currently invoke this method, maybe they will in the future.", "author": "kirklund", "createdAt": "2020-09-23T16:45:35Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java", "diffHunk": "@@ -39,69 +39,71 @@\n  * @see org.apache.geode.management.internal.beans.stats.MBeanStatsMonitor\n  */\n public class GCStatsMonitor extends MBeanStatsMonitor {\n+  // this class uses these volatile variables to make sure reads are reading the latest values\n+  // it is not using the parent's siteMap which is not volatile to keep the stats values.\n   private volatile long collections = 0;\n   private volatile long collectionTime = 0;\n \n-  long getCollections() {\n-    return collections;\n-  }\n-\n-  long getCollectionTime() {\n-    return collectionTime;\n-  }\n-\n   public GCStatsMonitor(String name) {\n     super(name);\n   }\n \n-  void decreasePrevValues(Map<String, Number> statsMap) {\n-    collections -= statsMap.getOrDefault(StatsKey.VM_GC_STATS_COLLECTIONS, 0).longValue();\n-    collectionTime -= statsMap.getOrDefault(StatsKey.VM_GC_STATS_COLLECTION_TIME, 0).longValue();\n-  }\n-\n-  void increaseStats(String name, Number value) {\n-    if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n-      collections += value.longValue();\n-      return;\n-    }\n-\n-    if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n-      collectionTime += value.longValue();\n-      return;\n+  @Override\n+  // this will be called multiple times with different collector's stats\n+  public void addStatisticsToMonitor(Statistics stats) {\n+    monitor.addListener(this);// if already listener is added this will be a no-op\n+    monitor.addStatistics(stats);\n+\n+    // stats map should keep the sum of all the GC stats\n+    StatisticDescriptor[] descriptors = stats.getType().getStatistics();\n+    for (StatisticDescriptor d : descriptors) {\n+      String name = d.getName();\n+      Number value = stats.get(d);\n+      if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n+        collections += value.longValue();", "originalCommit": "6cee04b359920f6e152069e5a0ed80d55bbedbe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2MTc4MQ==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493961781", "bodyText": "Not using += anymore.", "author": "jinmeiliao", "createdAt": "2020-09-23T23:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczOTY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "90154e662daa1d58ae2023c36d129e4b6de25fb6", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\nindex 96d6761f17..050f72407e 100644\n--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\n+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\n\n@@ -40,29 +45,49 @@ import org.apache.geode.internal.statistics.StatisticsNotification;\n  */\n public class GCStatsMonitor extends MBeanStatsMonitor {\n   // this class uses these volatile variables to make sure reads are reading the latest values\n-  // it is not using the parent's siteMap which is not volatile to keep the stats values.\n-  private volatile long collections = 0;\n-  private volatile long collectionTime = 0;\n+  // it is not using the parent's siteMap\n+  // this stores each stat's uniqueId and its collection count\n+  private volatile Map<Long, Number> collections;\n+\n+  // this stors eaech stat's uniqueId and its collectionTime\n+  private volatile Map<Long, Number> collectionTime;\n \n   public GCStatsMonitor(String name) {\n-    super(name);\n+    this(name, new ValueMonitor());\n+  }\n+\n+  @VisibleForTesting\n+  public GCStatsMonitor(String name, ValueMonitor valueMonitor) {\n+    super(name, valueMonitor);\n+    collections = new HashMap<>();\n+    collectionTime = new HashMap<>();\n+  }\n+\n+  long getCollections() {\n+    return collections.values().stream().mapToLong(Number::longValue).sum();\n+  }\n+\n+  long getCollectionTime() {\n+    return collectionTime.values().stream().mapToLong(Number::longValue).sum();\n   }\n \n   @Override\n-  // this will be called multiple times with different collector's stats\n+  // this will be called multiple times initially with different collector's stats\n   public void addStatisticsToMonitor(Statistics stats) {\n     monitor.addListener(this);// if already listener is added this will be a no-op\n     monitor.addStatistics(stats);\n \n-    // stats map should keep the sum of all the GC stats\n     StatisticDescriptor[] descriptors = stats.getType().getStatistics();\n     for (StatisticDescriptor d : descriptors) {\n       String name = d.getName();\n       Number value = stats.get(d);\n+      if (value == null) {\n+        continue;\n+      }\n       if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n-        collections += value.longValue();\n+        collections.put(stats.getUniqueId(), value);\n       } else if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n-        collectionTime += value.longValue();\n+        collectionTime.put(stats.getUniqueId(), value);\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MTcyMg==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493761722", "bodyText": "I think a notification includes only those stats whose values have changed. If that's correct, what we're summing here is only the changed GC stats, not all of the GC stats. This will work only if we're absolutely certain that every stat will change on every sample.\nSee ValueMonitor.monitorStatistics(), which builds the notification only from updated stats.\nSee SampleCollector.sample(), which adds a stats to the updated stats list only if the value of the stat changed from the previous sample.", "author": "demery-pivotal", "createdAt": "2020-09-23T17:21:35Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java", "diffHunk": "@@ -39,69 +39,71 @@\n  * @see org.apache.geode.management.internal.beans.stats.MBeanStatsMonitor\n  */\n public class GCStatsMonitor extends MBeanStatsMonitor {\n+  // this class uses these volatile variables to make sure reads are reading the latest values\n+  // it is not using the parent's siteMap which is not volatile to keep the stats values.\n   private volatile long collections = 0;\n   private volatile long collectionTime = 0;\n \n-  long getCollections() {\n-    return collections;\n-  }\n-\n-  long getCollectionTime() {\n-    return collectionTime;\n-  }\n-\n   public GCStatsMonitor(String name) {\n     super(name);\n   }\n \n-  void decreasePrevValues(Map<String, Number> statsMap) {\n-    collections -= statsMap.getOrDefault(StatsKey.VM_GC_STATS_COLLECTIONS, 0).longValue();\n-    collectionTime -= statsMap.getOrDefault(StatsKey.VM_GC_STATS_COLLECTION_TIME, 0).longValue();\n-  }\n-\n-  void increaseStats(String name, Number value) {\n-    if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n-      collections += value.longValue();\n-      return;\n-    }\n-\n-    if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n-      collectionTime += value.longValue();\n-      return;\n+  @Override\n+  // this will be called multiple times with different collector's stats\n+  public void addStatisticsToMonitor(Statistics stats) {\n+    monitor.addListener(this);// if already listener is added this will be a no-op\n+    monitor.addStatistics(stats);\n+\n+    // stats map should keep the sum of all the GC stats\n+    StatisticDescriptor[] descriptors = stats.getType().getStatistics();\n+    for (StatisticDescriptor d : descriptors) {\n+      String name = d.getName();\n+      Number value = stats.get(d);\n+      if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n+        collections += value.longValue();\n+      } else if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n+        collectionTime += value.longValue();\n+      }\n     }\n   }\n \n   @Override\n   public Number getStatistic(String statName) {\n     if (statName.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n-      return getCollections();\n+      return collections;\n     }\n \n     if (statName.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n-      return getCollectionTime();\n+      return collectionTime;\n     }\n-\n     return 0;\n   }\n \n   @Override\n   public void handleNotification(StatisticsNotification notification) {\n-    decreasePrevValues(statsMap);\n-\n+    // sum up all the count and all the time in the stats included in this notification\n+    long totalCount = 0;\n+    long totalTime = 0;\n     for (StatisticId statId : notification) {\n       StatisticDescriptor descriptor = statId.getStatisticDescriptor();\n       String name = descriptor.getName();\n       Number value;\n-\n       try {\n         value = notification.getValue(statId);\n       } catch (StatisticNotFoundException e) {\n         value = 0;\n       }\n-\n       log(name, value);\n-      increaseStats(name, value);\n-      statsMap.put(name, value);\n+      if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n+        totalCount += value.longValue();\n+      }\n+\n+      else if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n+        totalTime += value.longValue();\n+      }\n     }\n+\n+    collections = totalCount;\n+    collectionTime = totalTime;\n   }", "originalCommit": "6cee04b359920f6e152069e5a0ed80d55bbedbe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2NDcwNw==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493764707", "bodyText": "Please write unit tests for GCSTatsMonitor directly, rather than testing only through MemberLevelStatsTest.", "author": "demery-pivotal", "createdAt": "2020-09-23T17:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgyMTA3MQ==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493821071", "bodyText": "I think a notification includes only those stats whose values have changed. If that's correct, what we're summing here is only the changed GC stats, not all of the GC stats. This will work only if we're absolutely certain that every stat will change on every sample.\nSee ValueMonitor.monitorStatistics(), which builds the notification only from updated stats.\nSee SampleCollector.sample(), which adds a stats to the updated stats list only if the value of the stat changed from the previous sample.\n\nthen what would those count/time mean though. It's not right to report just a single one of them. It's not right to sum them up either then....", "author": "jinmeiliao", "createdAt": "2020-09-23T18:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgyMjI5Ng==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493822296", "bodyText": "Please write unit tests for GCSTatsMonitor directly, rather than testing only through MemberLevelStatsTest.\n\nthe unit test will be just like the MemberLevelStatsTest, only by mocking all those variables.", "author": "jinmeiliao", "createdAt": "2020-09-23T18:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0NDY2Ng==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493844666", "bodyText": "then what would those count/time mean though. It's not right to report just a single one of them. It's not right to sum them up either then....\n\nThe stats notification stuff is specifically designed to report only changes. As a result, old gen and new gen CGs are almost always reported independently (unless they both happen to change during a single sample).\nI think that's why the old code was doing the weird stuff. It was trying to track the previous value for each kind of GC, so that when a new value arrived, it could add in just the change in that kind of GC. Decrementing and incrementing was a puzzling way to do that, but that was the goal.\nHere's a way that seems simpler to me than decrementing/incrementing. I'll use collections as an example, but it's the same for collectionTime.\n\nCreate a map that records the latest value for each GC type.\nCreate a field that records the sum of values for all types. This is what gets reported via getCollections()\nWhen a new kind of GC is added via addStatisticsToMonitor()\u2026\n\nStore the initial value for that GC type in the map.\nSum the values of all GC types in the map, and store the sum in the field.\n\n\nWhen a notification arrives\u2026\n\nStore the new value for that GC type in the map.\nSum the values of all GC types in the map, and store the sum in the field.", "author": "demery-pivotal", "createdAt": "2020-09-23T19:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MzE1MQ==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493853151", "bodyText": "Let me correct my terminology a bit\u2026 I keep saying \"GC type,\" and that's not the right distinction. What distinguishes one batch of GC stats from another is which GarbageCollectorMXBean the values come from. I think (but I'm not sure) that each GC bean reports about a particular memory space.\nSo where I say \"GC type,\" a better term might be \"memory space\".", "author": "demery-pivotal", "createdAt": "2020-09-23T19:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5NjEzNg==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493896136", "bodyText": "then what would those count/time mean though. It's not right to report just a single one of them. It's not right to sum them up either then....\n\nThe stats notification stuff is specifically designed to report only changes. As a result, old gen and new gen CGs are almost always reported independently (unless they both happen to change during a single sample).\nI think that's why the old code was doing the weird stuff. It was trying to track the previous value for each kind of GC, so that when a new value arrived, it could add in just the change in that kind of GC. Decrementing and incrementing was a puzzling way to do that, but that was the goal.\nHere's a way that seems simpler to me than decrementing/incrementing. I'll use collections as an example, but it's the same for collectionTime.\n\n\nCreate a map that records the latest value for each GC type.\n\n\nCreate a field that records the sum of values for all types. This is what gets reported via getCollections()\n\n\nWhen a new kind of GC is added via addStatisticsToMonitor()\u2026\n\nStore the initial value for that GC type in the map.\nSum the values of all GC types in the map, and store the sum in the field.\n\n\n\nWhen a notification arrives\u2026\n\nStore the new value for that GC type in the map.\nSum the values of all GC types in the map, and store the sum in the field.\n\n\n\n\nYes, this sounds like a better idea. I will implement it.", "author": "jinmeiliao", "createdAt": "2020-09-23T21:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MTcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "90154e662daa1d58ae2023c36d129e4b6de25fb6", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\nindex 96d6761f17..050f72407e 100644\n--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\n+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\n\n@@ -40,29 +45,49 @@ import org.apache.geode.internal.statistics.StatisticsNotification;\n  */\n public class GCStatsMonitor extends MBeanStatsMonitor {\n   // this class uses these volatile variables to make sure reads are reading the latest values\n-  // it is not using the parent's siteMap which is not volatile to keep the stats values.\n-  private volatile long collections = 0;\n-  private volatile long collectionTime = 0;\n+  // it is not using the parent's siteMap\n+  // this stores each stat's uniqueId and its collection count\n+  private volatile Map<Long, Number> collections;\n+\n+  // this stors eaech stat's uniqueId and its collectionTime\n+  private volatile Map<Long, Number> collectionTime;\n \n   public GCStatsMonitor(String name) {\n-    super(name);\n+    this(name, new ValueMonitor());\n+  }\n+\n+  @VisibleForTesting\n+  public GCStatsMonitor(String name, ValueMonitor valueMonitor) {\n+    super(name, valueMonitor);\n+    collections = new HashMap<>();\n+    collectionTime = new HashMap<>();\n+  }\n+\n+  long getCollections() {\n+    return collections.values().stream().mapToLong(Number::longValue).sum();\n+  }\n+\n+  long getCollectionTime() {\n+    return collectionTime.values().stream().mapToLong(Number::longValue).sum();\n   }\n \n   @Override\n-  // this will be called multiple times with different collector's stats\n+  // this will be called multiple times initially with different collector's stats\n   public void addStatisticsToMonitor(Statistics stats) {\n     monitor.addListener(this);// if already listener is added this will be a no-op\n     monitor.addStatistics(stats);\n \n-    // stats map should keep the sum of all the GC stats\n     StatisticDescriptor[] descriptors = stats.getType().getStatistics();\n     for (StatisticDescriptor d : descriptors) {\n       String name = d.getName();\n       Number value = stats.get(d);\n+      if (value == null) {\n+        continue;\n+      }\n       if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n-        collections += value.longValue();\n+        collections.put(stats.getUniqueId(), value);\n       } else if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n-        collectionTime += value.longValue();\n+        collectionTime.put(stats.getUniqueId(), value);\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjY5Mg==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493856692", "bodyText": "The addStatisticsToMonitor method ignores the descriptors other than VM_GC_STATS_COLLECTIONS and VM_GC_STATS_COLLECTION_TIME. Can we guarantee that there is no other descriptor?", "author": "jchen21", "createdAt": "2020-09-23T19:53:42Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java", "diffHunk": "@@ -39,69 +39,71 @@\n  * @see org.apache.geode.management.internal.beans.stats.MBeanStatsMonitor\n  */\n public class GCStatsMonitor extends MBeanStatsMonitor {\n+  // this class uses these volatile variables to make sure reads are reading the latest values\n+  // it is not using the parent's siteMap which is not volatile to keep the stats values.\n   private volatile long collections = 0;\n   private volatile long collectionTime = 0;\n \n-  long getCollections() {\n-    return collections;\n-  }\n-\n-  long getCollectionTime() {\n-    return collectionTime;\n-  }\n-\n   public GCStatsMonitor(String name) {\n     super(name);\n   }\n \n-  void decreasePrevValues(Map<String, Number> statsMap) {\n-    collections -= statsMap.getOrDefault(StatsKey.VM_GC_STATS_COLLECTIONS, 0).longValue();\n-    collectionTime -= statsMap.getOrDefault(StatsKey.VM_GC_STATS_COLLECTION_TIME, 0).longValue();\n-  }\n-\n-  void increaseStats(String name, Number value) {\n-    if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n-      collections += value.longValue();\n-      return;\n-    }\n-\n-    if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n-      collectionTime += value.longValue();\n-      return;\n+  @Override\n+  // this will be called multiple times with different collector's stats\n+  public void addStatisticsToMonitor(Statistics stats) {", "originalCommit": "6cee04b359920f6e152069e5a0ed80d55bbedbe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5MDUzMA==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493890530", "bodyText": "Those are currently the only two descriptors in the GC statistics type, and the only two values reported by GarbageCollectorMXBean (the ultimate source of the values). If another descriptor were to be added to the statistics type in the future, we'd want to review it before deciding how GCStatsMonitor should handle it. So I think it's appropriate to ignore any descriptors we don't recognize.", "author": "demery-pivotal", "createdAt": "2020-09-23T20:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5NjQzNg==", "url": "https://github.com/apache/geode/pull/5536#discussion_r493896436", "bodyText": "I think we are only interested in these two.", "author": "jinmeiliao", "createdAt": "2020-09-23T21:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "90154e662daa1d58ae2023c36d129e4b6de25fb6", "chunk": "diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\nindex 96d6761f17..050f72407e 100644\n--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\n+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitor.java\n\n@@ -40,29 +45,49 @@ import org.apache.geode.internal.statistics.StatisticsNotification;\n  */\n public class GCStatsMonitor extends MBeanStatsMonitor {\n   // this class uses these volatile variables to make sure reads are reading the latest values\n-  // it is not using the parent's siteMap which is not volatile to keep the stats values.\n-  private volatile long collections = 0;\n-  private volatile long collectionTime = 0;\n+  // it is not using the parent's siteMap\n+  // this stores each stat's uniqueId and its collection count\n+  private volatile Map<Long, Number> collections;\n+\n+  // this stors eaech stat's uniqueId and its collectionTime\n+  private volatile Map<Long, Number> collectionTime;\n \n   public GCStatsMonitor(String name) {\n-    super(name);\n+    this(name, new ValueMonitor());\n+  }\n+\n+  @VisibleForTesting\n+  public GCStatsMonitor(String name, ValueMonitor valueMonitor) {\n+    super(name, valueMonitor);\n+    collections = new HashMap<>();\n+    collectionTime = new HashMap<>();\n+  }\n+\n+  long getCollections() {\n+    return collections.values().stream().mapToLong(Number::longValue).sum();\n+  }\n+\n+  long getCollectionTime() {\n+    return collectionTime.values().stream().mapToLong(Number::longValue).sum();\n   }\n \n   @Override\n-  // this will be called multiple times with different collector's stats\n+  // this will be called multiple times initially with different collector's stats\n   public void addStatisticsToMonitor(Statistics stats) {\n     monitor.addListener(this);// if already listener is added this will be a no-op\n     monitor.addStatistics(stats);\n \n-    // stats map should keep the sum of all the GC stats\n     StatisticDescriptor[] descriptors = stats.getType().getStatistics();\n     for (StatisticDescriptor d : descriptors) {\n       String name = d.getName();\n       Number value = stats.get(d);\n+      if (value == null) {\n+        continue;\n+      }\n       if (name.equals(StatsKey.VM_GC_STATS_COLLECTIONS)) {\n-        collections += value.longValue();\n+        collections.put(stats.getUniqueId(), value);\n       } else if (name.equals(StatsKey.VM_GC_STATS_COLLECTION_TIME)) {\n-        collectionTime += value.longValue();\n+        collectionTime.put(stats.getUniqueId(), value);\n       }\n     }\n   }\n"}}, {"oid": "90154e662daa1d58ae2023c36d129e4b6de25fb6", "url": "https://github.com/apache/geode/commit/90154e662daa1d58ae2023c36d129e4b6de25fb6", "message": "change the implementation of GCStatsMonitor", "committedDate": "2020-09-23T23:53:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTA0MA==", "url": "https://github.com/apache/geode/pull/5536#discussion_r494449040", "bodyText": "This way of specifying return values unnecessarily couples the test to the current implementation\u2014it insists that the implementation must call stats.get(sd) this many times, and in this specific order.\nOn this line and the two later ones, it would be better to associate each value with the appropriate statistic descriptor, the way the other test does.", "author": "demery-pivotal", "createdAt": "2020-09-24T16:22:13Z", "path": "geode-core/src/test/java/org/apache/geode/management/internal/beans/stats/GCStatsMonitorTest.java", "diffHunk": "@@ -33,16 +45,94 @@\n \n   @Before\n   public void setUp() {\n-    gcStatsMonitor = new GCStatsMonitor(testName.getMethodName());\n+    ValueMonitor valueMonitor = mock(ValueMonitor.class);\n+    gcStatsMonitor = new GCStatsMonitor(testName.getMethodName(), valueMonitor);\n+\n     assertThat(gcStatsMonitor).isNotNull();\n-    assertThat(gcStatsMonitor.getStatistic(\"collections\")).isEqualTo(0L);\n-    assertThat(gcStatsMonitor.getStatistic(\"collectionTime\")).isEqualTo(0L);\n+    assertThat(gcStatsMonitor.getCollections()).isEqualTo(0L);\n+    assertThat(gcStatsMonitor.getCollectionTime()).isEqualTo(0L);\n   }\n \n   @Test\n   public void getStatisticShouldReturnZeroForUnknownStatistics() {\n     assertThat(gcStatsMonitor.getStatistic(\"unknownStatistic\")).isEqualTo(0);\n   }\n \n+  @Test\n+  public void addStatsToMonitor() throws Exception {\n+    Statistics stats = mock(Statistics.class);\n+    when(stats.getUniqueId()).thenReturn(11L);\n+    StatisticDescriptor d1 = mock(StatisticDescriptor.class);\n+    when(d1.getName()).thenReturn(StatsKey.VM_GC_STATS_COLLECTIONS);\n+    StatisticDescriptor d2 = mock(StatisticDescriptor.class);\n+    when(d2.getName()).thenReturn(StatsKey.VM_GC_STATS_COLLECTION_TIME);\n+    StatisticDescriptor[] descriptors = {d1, d2};\n+    StatisticsType type = mock(StatisticsType.class);\n+    when(stats.getType()).thenReturn(type);\n+    when(type.getStatistics()).thenReturn(descriptors);\n+\n+    when(stats.get(any(StatisticDescriptor.class))).thenReturn(8L, 300L);", "originalCommit": "90154e662daa1d58ae2023c36d129e4b6de25fb6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}