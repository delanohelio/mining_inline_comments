{"pr_number": 4682, "pr_title": "GEODE-7778: Add PUBLISH, SUBSCRIBE and UNSUBSCRIBE Redis commands", "pr_createdAt": "2020-02-07T19:06:58Z", "pr_url": "https://github.com/apache/geode/pull/4682", "timeline": [{"oid": "d8924a8105294286fc38cb6f2a8e602df512382e", "url": "https://github.com/apache/geode/commit/d8924a8105294286fc38cb6f2a8e602df512382e", "message": "GEODE-7778: Add PUBLISH, SUBSCRIBE and UNSUBSCRIBE Redis commands\n\nCo-authored-by: Jens Deppe <jdeppe@pivotal.io>\nCo-authored-by: Prasath Durairaj <vdurairaj@pivotal.io>\nCo-authored-by: Murtuza Boxwala <mboxwala@pivotal.io>\nCo-authored-by: Sarah Abbey <sabbey@pivotal.io>\nCo-authored-by: John Hutchison <jhutchison@pivotal.io>\nCo-authored-by: Ray Ingles <ringles@pivotal.io>", "committedDate": "2020-02-07T20:18:17Z", "type": "commit"}, {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e", "url": "https://github.com/apache/geode/commit/d8924a8105294286fc38cb6f2a8e602df512382e", "message": "GEODE-7778: Add PUBLISH, SUBSCRIBE and UNSUBSCRIBE Redis commands\n\nCo-authored-by: Jens Deppe <jdeppe@pivotal.io>\nCo-authored-by: Prasath Durairaj <vdurairaj@pivotal.io>\nCo-authored-by: Murtuza Boxwala <mboxwala@pivotal.io>\nCo-authored-by: Sarah Abbey <sabbey@pivotal.io>\nCo-authored-by: John Hutchison <jhutchison@pivotal.io>\nCo-authored-by: Ray Ingles <ringles@pivotal.io>", "committedDate": "2020-02-07T20:18:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjE3Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377316172", "bodyText": "Does this mean that every RedisAdapter will have a PubSub instance, even if it is not required?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:06:22Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -86,6 +88,11 @@ public KeyRegistrar getKeyRegistrar() {\n   }\n \n   private KeyRegistrar keyRegistrar;\n+  private PubSub pubSub;", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNjA3MA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377736070", "bodyText": "Only one PubSub is created for the lifetime of the adapter. Each ExecutionContextHandler receives a reference to it.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T16:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjE3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\nindex 5701569577..99ec2542fb 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\n\n@@ -87,8 +87,8 @@ public class ExecutionHandlerContext extends ChannelInboundHandlerAdapter {\n     return keyRegistrar;\n   }\n \n-  private KeyRegistrar keyRegistrar;\n-  private PubSub pubSub;\n+  private final KeyRegistrar keyRegistrar;\n+  private final PubSub pubSub;\n \n   public PubSub getPubSub() {\n     return pubSub;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjgyNw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377316827", "bodyText": "Why would this not be an Interface? Then at least there is the ability that one could have another implementation of this, without tightly coupling the code.", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:07:44Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNzA4Nw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377737087", "bodyText": "I think that would definitely be a good thing if we find there is a need for multiple implementations. For now it's just a concrete class.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T16:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0NDUwMg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377744502", "bodyText": "Can we then just add an interface and an implementation... It is easier to do this BEFORE rather than after. Also it makes it easier to achieve loose coupling.", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T16:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2MzY2Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r378363662", "bodyText": "Done", "author": "jdeppe-pivotal", "createdAt": "2020-02-12T16:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjgyNw=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxOTE5Mw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377319193", "bodyText": "Is this timeout an SLA or just best guess? What happens if a message takes 2s to send, is that bad? Maybe a timeout that can be either configured or maybe a little more lenient?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:12:40Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {\n+  public final Client client;\n+  public final String channel;\n+  private ExecutionHandlerContext context;\n+\n+  public Subscriber(Client client, String channel,\n+      ExecutionHandlerContext context) {\n+\n+    this.client = client;\n+    this.channel = channel;\n+    this.context = context;\n+  }\n+\n+  public boolean isEqualTo(String channel, Client client) {\n+    return channel.equals(this.channel) && client.equals(this.client);\n+  }\n+\n+  public boolean publishMessage(String channel, String message) {\n+    ByteBuf messageByteBuffer;\n+    try {\n+      messageByteBuffer = Coder.getArrayResponse(context.getByteBufAllocator(),\n+          Arrays.asList(\"message\", channel, message));\n+    } catch (CoderException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    ChannelFutureListener channelFutureListener = future -> latch.countDown();\n+\n+    ChannelFuture channelFuture =\n+        context.writeToChannelWithListener(messageByteBuffer, channelFutureListener);\n+\n+    try {\n+      latch.await(1, TimeUnit.SECONDS);", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTkwOA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377845908", "bodyText": "Fixed code", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T19:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxOTE5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\nindex 80d9a8ffe4..91f63298b7 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n\n@@ -17,21 +17,21 @@\n package org.apache.geode.redis.internal;\n \n import java.util.Arrays;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n \n class Subscriber {\n+  private static final Logger logger = LogService.getLogger();\n   public final Client client;\n   public final String channel;\n   private ExecutionHandlerContext context;\n \n-  public Subscriber(Client client, String channel,\n-      ExecutionHandlerContext context) {\n-\n+  public Subscriber(Client client, String channel, ExecutionHandlerContext context) {\n     this.client = client;\n     this.channel = channel;\n     this.context = context;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMDg2Nw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377320867", "bodyText": "what is s here? I don't have an IDE to tell me what this is supposed to be", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:16:16Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTEwOQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321109", "bodyText": "s = subscriber?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:16:44Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTE1Nw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321157", "bodyText": "s = subscriber?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:16:51Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));\n+    }\n+\n+    private List<Subscriber> findSubscribers(Client client) {\n+      return subscribers.stream().filter((s) -> s.client.equals(client))", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTE4OQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321189", "bodyText": "s = subscriber?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:16:56Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));\n+    }\n+\n+    private List<Subscriber> findSubscribers(Client client) {\n+      return subscribers.stream().filter((s) -> s.client.equals(client))\n+          .collect(Collectors.toList());\n+    }\n+\n+    private List<Subscriber> findSubscribers(String channel) {\n+      return subscribers.stream().filter((s) -> s.channel.equals(channel))", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTU0MQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321541", "bodyText": "Seems we are lacking some consistency... Here we specifically name the param subscriber, but higher up we just call it s", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:17:43Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));\n+    }\n+\n+    private List<Subscriber> findSubscribers(Client client) {\n+      return subscribers.stream().filter((s) -> s.client.equals(client))\n+          .collect(Collectors.toList());\n+    }\n+\n+    private List<Subscriber> findSubscribers(String channel) {\n+      return subscribers.stream().filter((s) -> s.channel.equals(channel))\n+          .collect(Collectors.toList());\n+    }\n+\n+    public void add(Subscriber subscriber) {\n+      this.subscribers.add(subscriber);\n+    }\n+\n+    public void remove(String channel, Client client) {\n+      this.subscribers.removeIf((subscriber) -> subscriber.isEqualTo(channel, client));", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMjA5Mw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377322093", "bodyText": "Maybe some JavaDoc here.. what is this class and why do we care....", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:18:55Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNjE0OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377326148", "bodyText": "Why not a LinkedList if every operation is a \"iterate\" over all entries. No benefit to using ArrayList if you don't use the indexing or ordering.", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:27:27Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2MzUxNw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377763517", "bodyText": "We're coding to the interface and not the concrete class. It could easily be changed if the need arises.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T16:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNjE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NzM2OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377767368", "bodyText": "ArrayLists create heavier constructs under the hood, regardless of \"I'm coding against that interface\". All I'm asking is, given that you know you will never use  indexing, would a LinkedList not suffice?", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T16:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNjE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNjY4Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377336682", "bodyText": "I wonder if one should expose the PubSub world here... maybe have the context have a publish method, which then delegates to the internal PubSub. To me it is a little like feature envy... Where instead of having the ExecutionHandlerContext handle the publish, we first have to know that there is a PubSub and then ask it to do work  -- https://refactoring.guru/smells/feature-envy", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:49:02Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.Executor;\n+\n+public class PublishExecutor implements Executor {\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    byte[] channelName = command.getProcessedCommand().get(1);\n+    byte[] message = command.getProcessedCommand().get(2);\n+    long publishCount = context.getPubSub().publish(new String(channelName), new String(message));", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NTgzNA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377765834", "bodyText": "It's a good point. We realize that context is very overloaded right now and we're planning on refactoring in the future.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T16:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNjY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c8288e0fb38289a1fe6a8b36c1a1348fb3e0b75d", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java\nindex 8098d69d63..0f8b585f51 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java\n\n@@ -15,19 +15,30 @@\n \n package org.apache.geode.redis.internal.executor.pubsub;\n \n+import java.util.List;\n+\n import io.netty.buffer.ByteBuf;\n \n import org.apache.geode.redis.internal.Coder;\n import org.apache.geode.redis.internal.Command;\n import org.apache.geode.redis.internal.ExecutionHandlerContext;\n import org.apache.geode.redis.internal.Executor;\n+import org.apache.geode.redis.internal.RedisConstants.ArityDef;\n \n public class PublishExecutor implements Executor {\n+\n+\n   @Override\n   public void executeCommand(Command command, ExecutionHandlerContext context) {\n-    byte[] channelName = command.getProcessedCommand().get(1);\n-    byte[] message = command.getProcessedCommand().get(2);\n-    long publishCount = context.getPubSub().publish(new String(channelName), new String(message));\n+    List<byte[]> args = command.getProcessedCommand();\n+    if (args.size() != 3) {\n+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ArityDef.PUBLISH));\n+      return;\n+    }\n+\n+    String channelName = new String(args.get(1));\n+    String message = new String(args.get(2));\n+    long publishCount = context.getPubSub().publish(channelName, message);\n \n     writeResponse(command, context, publishCount);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzI2Mw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337263", "bodyText": "See same comment on the PublishExecutor. I don't think we should expose the PubSub here.", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:50:17Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class SubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    ArrayList<ArrayList<Object>> items = new ArrayList<>();\n+    for (int i = 1; i < command.getProcessedCommand().size(); i++) {\n+      ArrayList<Object> item = new ArrayList<>();\n+      byte[] channelName = command.getProcessedCommand().get(i);\n+      long subscribedChannels =\n+          context.getPubSub().subscribe(new String(channelName), context, context.getClient());", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NjA3OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377766078", "bodyText": "Ditto above.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T16:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java\nindex d4f656cb17..769babc6a5 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java\n\n@@ -18,7 +18,9 @@ package org.apache.geode.redis.internal.executor.pubsub;\n import java.util.ArrayList;\n \n import io.netty.buffer.ByteBuf;\n+import org.apache.logging.log4j.Logger;\n \n+import org.apache.geode.logging.internal.log4j.api.LogService;\n import org.apache.geode.redis.internal.Coder;\n import org.apache.geode.redis.internal.CoderException;\n import org.apache.geode.redis.internal.Command;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzU5OQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337599", "bodyText": "See above in PublishExecutor and SubscribeExecutor", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:50:59Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class UnsubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    byte[] channelName = command.getProcessedCommand().get(1);\n+    long subscriptionCount =\n+        context.getPubSub().unsubscribe(new String(channelName), context.getClient());", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NjE3Ng==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377766176", "bodyText": "Same ditto", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T16:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java\nindex 609a4fe13e..55abad4da1 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java\n\n@@ -18,7 +18,9 @@ package org.apache.geode.redis.internal.executor.pubsub;\n import java.util.ArrayList;\n \n import io.netty.buffer.ByteBuf;\n+import org.apache.logging.log4j.Logger;\n \n+import org.apache.geode.logging.internal.log4j.api.LogService;\n import org.apache.geode.redis.internal.Coder;\n import org.apache.geode.redis.internal.CoderException;\n import org.apache.geode.redis.internal.Command;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzgxMg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337812", "bodyText": "Maybe have a logger?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:51:26Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class UnsubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    byte[] channelName = command.getProcessedCommand().get(1);\n+    long subscriptionCount =\n+        context.getPubSub().unsubscribe(new String(channelName), context.getClient());\n+\n+    ArrayList<Object> items = new ArrayList<>();\n+    items.add(\"unsubscribe\");\n+    items.add(channelName);\n+    items.add(subscriptionCount);\n+    ByteBuf response = null;\n+    try {\n+      response = Coder.getArrayResponse(context.getByteBufAllocator(), items);\n+    } catch (CoderException e) {\n+      e.printStackTrace();", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java\nindex 609a4fe13e..55abad4da1 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java\n\n@@ -18,7 +18,9 @@ package org.apache.geode.redis.internal.executor.pubsub;\n import java.util.ArrayList;\n \n import io.netty.buffer.ByteBuf;\n+import org.apache.logging.log4j.Logger;\n \n+import org.apache.geode.logging.internal.log4j.api.LogService;\n import org.apache.geode.redis.internal.Coder;\n import org.apache.geode.redis.internal.CoderException;\n import org.apache.geode.redis.internal.Command;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzkyNQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337925", "bodyText": "Maybe have a logger?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:51:37Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class SubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    ArrayList<ArrayList<Object>> items = new ArrayList<>();\n+    for (int i = 1; i < command.getProcessedCommand().size(); i++) {\n+      ArrayList<Object> item = new ArrayList<>();\n+      byte[] channelName = command.getProcessedCommand().get(i);\n+      long subscribedChannels =\n+          context.getPubSub().subscribe(new String(channelName), context, context.getClient());\n+\n+      item.add(\"subscribe\");\n+      item.add(channelName);\n+      item.add(subscribedChannels);\n+\n+      items.add(item);\n+    }\n+\n+    writeResponse(command, context, items);\n+  }\n+\n+  private void writeResponse(Command command, ExecutionHandlerContext context,\n+      ArrayList<ArrayList<Object>> items) {\n+    ByteBuf bigResponse = context.getByteBufAllocator().buffer();\n+    items.forEach(item -> {\n+      ByteBuf response = null;\n+      try {\n+        response = Coder.getArrayResponse(context.getByteBufAllocator(), item);\n+      } catch (CoderException e) {\n+        e.printStackTrace();", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java\nindex d4f656cb17..769babc6a5 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java\n\n@@ -18,7 +18,9 @@ package org.apache.geode.redis.internal.executor.pubsub;\n import java.util.ArrayList;\n \n import io.netty.buffer.ByteBuf;\n+import org.apache.logging.log4j.Logger;\n \n+import org.apache.geode.logging.internal.log4j.api.LogService;\n import org.apache.geode.redis.internal.Coder;\n import org.apache.geode.redis.internal.CoderException;\n import org.apache.geode.redis.internal.Command;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTA3Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339072", "bodyText": "Maybe add Comparable onto the class. Then one does not have to go outside of \"standard\" Java conventions, but creating a isEqualTo method", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:53:55Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Mjk0Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377772942", "bodyText": "I don't think that will work since Comparable only uses a single type and isEqualTo requires multiple types.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NjcyOQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377776729", "bodyText": "Yes thank you. I do see that now.", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T17:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\nindex 80d9a8ffe4..91f63298b7 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n\n@@ -17,21 +17,21 @@\n package org.apache.geode.redis.internal;\n \n import java.util.Arrays;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n \n class Subscriber {\n+  private static final Logger logger = LogService.getLogger();\n   public final Client client;\n   public final String channel;\n   private ExecutionHandlerContext context;\n \n-  public Subscriber(Client client, String channel,\n-      ExecutionHandlerContext context) {\n-\n+  public Subscriber(Client client, String channel, ExecutionHandlerContext context) {\n     this.client = client;\n     this.channel = channel;\n     this.context = context;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTQzMw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339433", "bodyText": "Is this thread safe?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:54:41Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisCommandType.java", "diffHunk": "@@ -2595,6 +2598,69 @@ public RedisDataType getDataType() {\n     }\n   },\n \n+  /***************************************\n+   ********** Publish Subscribe **********\n+   ***************************************/\n+  /**\n+   * SUBSCRIBE channel...\n+   * <p>\n+   * subscribe to channel\n+   */\n+  SUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {\n+      if (executor == null) {\n+        executor = new SubscribeExecutor();\n+      }\n+      return executor;\n+    }\n+\n+    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n+\n+    @Override\n+    public RedisDataType getDataType() {\n+      return this.dataType;\n+    }\n+  },\n+  PUBLISH {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzgxNQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377777815", "bodyText": "Not really, but since this pattern is used throughout all the commands I think it would be better to make that change in a separate PR and cover all the commands.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3OTU0OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377779548", "bodyText": "Could we please raise one and address accordingly", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T17:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTQzMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTQ2OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339468", "bodyText": "Is this thread safe?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:54:45Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisCommandType.java", "diffHunk": "@@ -2595,6 +2598,69 @@ public RedisDataType getDataType() {\n     }\n   },\n \n+  /***************************************\n+   ********** Publish Subscribe **********\n+   ***************************************/\n+  /**\n+   * SUBSCRIBE channel...\n+   * <p>\n+   * subscribe to channel\n+   */\n+  SUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzkwOA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377777908", "bodyText": "Ditto", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTQ2OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTUyMA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339520", "bodyText": "Is this thread safe?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:54:52Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisCommandType.java", "diffHunk": "@@ -2595,6 +2598,69 @@ public RedisDataType getDataType() {\n     }\n   },\n \n+  /***************************************\n+   ********** Publish Subscribe **********\n+   ***************************************/\n+  /**\n+   * SUBSCRIBE channel...\n+   * <p>\n+   * subscribe to channel\n+   */\n+  SUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {\n+      if (executor == null) {\n+        executor = new SubscribeExecutor();\n+      }\n+      return executor;\n+    }\n+\n+    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n+\n+    @Override\n+    public RedisDataType getDataType() {\n+      return this.dataType;\n+    }\n+  },\n+  PUBLISH {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {\n+      if (executor == null) {\n+        executor = new PublishExecutor();\n+      }\n+      return executor;\n+    }\n+\n+    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n+\n+    @Override\n+    public RedisDataType getDataType() {\n+      return this.dataType;\n+    }\n+  },\n+  UNSUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Nzk3Ng==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377777976", "bodyText": "Ditto", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTUyMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM0MDE5NQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377340195", "bodyText": "Maybe make this final, if you are going through all the effort of constructor initialization and private", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T21:56:19Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -86,6 +88,11 @@ public KeyRegistrar getKeyRegistrar() {\n   }\n \n   private KeyRegistrar keyRegistrar;\n+  private PubSub pubSub;", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\nindex 5701569577..99ec2542fb 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\n\n@@ -87,8 +87,8 @@ public class ExecutionHandlerContext extends ChannelInboundHandlerAdapter {\n     return keyRegistrar;\n   }\n \n-  private KeyRegistrar keyRegistrar;\n-  private PubSub pubSub;\n+  private final KeyRegistrar keyRegistrar;\n+  private final PubSub pubSub;\n \n   public PubSub getPubSub() {\n     return pubSub;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MTg0Mw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377351843", "bodyText": "Maybe treat the final String.valueof(d) as the else then at least it seams one have thought of all the combinations.", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:21:14Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java", "diffHunk": "@@ -436,16 +452,18 @@ public static String bytesToString(byte[] bytes) {\n   }\n \n   public static String doubleToString(double d) {\n-    if (d == Double.POSITIVE_INFINITY)\n+    if (d == Double.POSITIVE_INFINITY) {\n       return \"Infinity\";\n-    else if (d == Double.NEGATIVE_INFINITY)\n+    } else if (d == Double.NEGATIVE_INFINITY) {\n       return \"-Infinity\";\n+    }\n     return String.valueOf(d);", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java\nindex 463f3ec1cc..db4e9b7dac 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java\n\n@@ -454,9 +454,11 @@ public class Coder {\n   public static String doubleToString(double d) {\n     if (d == Double.POSITIVE_INFINITY) {\n       return \"Infinity\";\n-    } else if (d == Double.NEGATIVE_INFINITY) {\n+    }\n+    if (d == Double.NEGATIVE_INFINITY) {\n       return \"-Infinity\";\n     }\n+\n     return String.valueOf(d);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MTkzNg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377351936", "bodyText": "What about strings with \"whitespaces\"?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:21:27Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java", "diffHunk": "@@ -436,16 +452,18 @@ public static String bytesToString(byte[] bytes) {\n   }\n \n   public static String doubleToString(double d) {\n-    if (d == Double.POSITIVE_INFINITY)\n+    if (d == Double.POSITIVE_INFINITY) {\n       return \"Infinity\";\n-    else if (d == Double.NEGATIVE_INFINITY)\n+    } else if (d == Double.NEGATIVE_INFINITY) {\n       return \"-Infinity\";\n+    }\n     return String.valueOf(d);\n   }\n \n   public static byte[] stringToBytes(String string) {\n-    if (string == null || string.equals(\"\"))\n+    if (string == null || string.equals(\"\")) {", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java\nindex 463f3ec1cc..db4e9b7dac 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java\n\n@@ -454,9 +454,11 @@ public class Coder {\n   public static String doubleToString(double d) {\n     if (d == Double.POSITIVE_INFINITY) {\n       return \"Infinity\";\n-    } else if (d == Double.NEGATIVE_INFINITY) {\n+    }\n+    if (d == Double.NEGATIVE_INFINITY) {\n       return \"-Infinity\";\n     }\n+\n     return String.valueOf(d);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1NDc4OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377354788", "bodyText": "Why do we need to expose the PubSub externally?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:27:41Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -86,6 +88,11 @@ public KeyRegistrar getKeyRegistrar() {\n   }\n \n   private KeyRegistrar keyRegistrar;\n+  private PubSub pubSub;\n+\n+  public PubSub getPubSub() {\n+    return pubSub;\n+  }", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4MzE1OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377783158", "bodyText": "It is used by the various Executors that deal with pub/sub. Once ExecutionContextHandler is refactored, this should not be necessary.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1NDc4OA=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\nindex 5701569577..99ec2542fb 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java\n\n@@ -87,8 +87,8 @@ public class ExecutionHandlerContext extends ChannelInboundHandlerAdapter {\n     return keyRegistrar;\n   }\n \n-  private KeyRegistrar keyRegistrar;\n-  private PubSub pubSub;\n+  private final KeyRegistrar keyRegistrar;\n+  private final PubSub pubSub;\n \n   public PubSub getPubSub() {\n     return pubSub;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MTU3OQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377361579", "bodyText": "why is this package protected and not private? or even private final?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:43:21Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MjA3OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377362078", "bodyText": "Everywhere where there are collections, streams are used. Why not here? Why not a collect function? Consistency...", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:44:25Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MjYzNg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377362636", "bodyText": "I think this might be a little fragile. What happens if there are NOT 2 entries or even 0... What if there are no arguments and it is null?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:45:54Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NDQyMQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377794421", "bodyText": "This function call is fairly tightly controlled - higher level calling methods should already ensure correct parameterization.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MjYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NzYxMg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377797612", "bodyText": "Can I quote you on this? Can we please add validation BEFORE invoking.", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T17:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MjYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1MDQ1Ng==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377950456", "bodyText": "Added validation", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T22:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MjYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTAxMw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377365013", "bodyText": "Why explicitly call registerPublishFunction if this can be done inside the constructor? Why is this method even required?", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:51:27Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java", "diffHunk": "@@ -730,4 +740,11 @@ private static String getLogLevel(String arg) {\n     }\n     return logLevel;\n   }\n+\n+  private PubSub createPubSub() {\n+    PubSub pubSub = new PubSub();\n+    pubSub.registerPublishFunction();", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NjM3OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377796378", "bodyText": "It ensures that the PubSub instance is fully constructed before use - since the Function requires a reference to it.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NzE3NA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377797174", "bodyText": "Let me rephrase, given that there are no dependencies as input parameters, the registering of Functions can happen at construction time.", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T17:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM3NzQ4Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r378377482", "bodyText": "Done", "author": "jdeppe-pivotal", "createdAt": "2020-02-12T16:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "a07a25fb88692daadb37b0caef2e9da2454faa7a", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java b/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java\nindex 9b501ed235..43cf1c52ae 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java\n\n@@ -742,7 +743,7 @@ public class GeodeRedisServer {\n   }\n \n   private PubSub createPubSub() {\n-    PubSub pubSub = new PubSub();\n+    PubSubImpl pubSub = new PubSubImpl();\n     pubSub.registerPublishFunction();\n     return pubSub;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTcxNw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377365717", "bodyText": "This initialization could have been done on line 263, where the field is declared.", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:53:06Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java", "diffHunk": "@@ -446,6 +449,7 @@ private void initializeRedis() {\n         throw assErr;\n       }\n       this.keyRegistrar = new KeyRegistrar(redisMetaData);\n+      this.pubSub = createPubSub();", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NzMxNA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377797314", "bodyText": "That is true.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T17:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTM3OQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377921379", "bodyText": "But I don't see any immediate value in changing it.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T21:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMDMxMA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377930310", "bodyText": "Also, you can use new PubSub as the registerFunction can (and should) be called in the constructor of PubSub otherwise one is exposing knowledge that does not need to be exposed.", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T22:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "0eaf5c7e151dae6d5d6574e459d62bf5046cf76b", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java b/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java\nindex 9b501ed235..75a7e6a2bf 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java\n\n@@ -449,7 +450,7 @@ public class GeodeRedisServer {\n         throw assErr;\n       }\n       this.keyRegistrar = new KeyRegistrar(redisMetaData);\n-      this.pubSub = createPubSub();\n+      this.pubSub = new PubSubImpl();\n       this.regionCache = new RegionProvider(stringsRegion, hLLRegion, this.keyRegistrar,\n           expirationFutures, expirationExecutor, this.DEFAULT_REGION_TYPE);\n       redisMetaData.put(REDIS_META_DATA_REGION, RedisDataType.REDIS_PROTECTED);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODA0Ng==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377368046", "bodyText": "This is very inefficient. First iterate over all subscribers to see if there is a match. Then iterate over all subscribers again to return a count. Maybe one can findSubscribers if count = 0 then add other wise return count", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T22:58:49Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMTg0Ng==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377811846", "bodyText": "I'm not sure I understand. We need to know two things:\n1 - has a client already subscribed to a channel\n2 - how many subscriptions a client currently has\nIn order to address both of these concerns, the findSubscribers method would probably need to be inlined which seems like it would be less readable.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T18:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyODA0Ng==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377828046", "bodyText": "You are correct.\nThat said.. What is the max number of Pub/Sub combinations we can expect? How does this approach scale?\nMaybe two maps <channel,List> and <client,List> ?", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T18:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1MDk0OA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377950948", "bodyText": "Could we leave optimization until it's actually determined that it is needed?", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T23:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1NTI4NQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377955285", "bodyText": "I agree, premature optimization.... But I'd be interested in what the \"normal\" usage on this would be. Maybe we add a load testing ticket on this, to see what load this construct can take. Is it 100's or 1000's or even 10,000's...\nBut I think it would be good to understand when it will slow down / break.", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T23:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODYzOA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377368638", "bodyText": "Are we concerned about thread safety here or not? Because, if we would have done a count of all subscribers before adding, then we don't have to iterate all subscribers again just to in all reality do previousCount + 1", "author": "kohlmu-pivotal", "createdAt": "2020-02-10T23:00:22Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNTA0Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377815042", "bodyText": "I think that's just a different approach - also valid, but just different....", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T18:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\nindex ef56ad0413..c1cd2c6dd5 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java\n\n@@ -26,23 +26,25 @@ import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.FunctionService;\n import org.apache.geode.cache.execute.ResultCollector;\n \n+/**\n+ * Central class that manages publish and subscribe functionality. Since Redis subscriptions\n+ * require a persistent connection we need to have a way to track the existing clients that are\n+ * expecting to receive published messages.\n+ */\n public class PubSub {\n   public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n \n   Subscribers subscribers = new Subscribers();\n \n   public long publish(String channel, String message) {\n-    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+    ResultCollector<String[], List<Long>> subscriberCountCollector = FunctionService\n         .onMembers()\n         .setArguments(new String[] {channel, message})\n         .execute(REDIS_PUB_SUB_FUNCTION_ID);\n \n-    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n-    long totalSubscribers = 0;\n-    for (long subscriberCount : subscriberCounts) {\n-      totalSubscribers += subscriberCount;\n-    }\n-    return totalSubscribers;\n+    List<Long> subscriberCounts = subscriberCountCollector.getResult();\n+\n+    return subscriberCounts.stream().mapToLong(x -> x).sum();\n   }\n \n   public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377777589", "bodyText": "There is no null checking happening. Can we really assume that the input channel and client are non-null?", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T17:14:49Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {\n+  public final Client client;\n+  public final String channel;\n+  private ExecutionHandlerContext context;\n+\n+  public Subscriber(Client client, String channel,\n+      ExecutionHandlerContext context) {\n+\n+    this.client = client;\n+    this.channel = channel;\n+    this.context = context;\n+  }\n+\n+  public boolean isEqualTo(String channel, Client client) {\n+    return channel.equals(this.channel) && client.equals(this.client);", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNzYzMg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377817632", "bodyText": "Null checking is handled by the respective equals methods.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T18:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxODI4NQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377818285", "bodyText": "So, you can 100% guarantee that the fields are ALWAYS non-null?", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T18:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxODk0OQ==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377818949", "bodyText": "another approach is that the equals method is this.channel.equals(channel. This way the constructor can ensure that the instance channel field is non-null AND your isEqualsTo is null-safe", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T18:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0OTMyMw==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377849323", "bodyText": "Yes, you're correct.", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T19:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4MzE5MA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r378383190", "bodyText": "This implementation is not \"optimal\". If you makes sure the channel and client on the Subscriber is non-null, then your isEqualsTo method implementation changes. Then the comparison this.channel.equals(channel) && this.client.equals(client) is cleaner. There is no requirement to continually check if the method parameters are non-null, because it does not matter.", "author": "kohlmu-pivotal", "createdAt": "2020-02-12T16:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODYyMA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r378538620", "bodyText": "Fixed", "author": "jdeppe-pivotal", "createdAt": "2020-02-12T22:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\nindex 80d9a8ffe4..91f63298b7 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n\n@@ -17,21 +17,21 @@\n package org.apache.geode.redis.internal;\n \n import java.util.Arrays;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n \n class Subscriber {\n+  private static final Logger logger = LogService.getLogger();\n   public final Client client;\n   public final String channel;\n   private ExecutionHandlerContext context;\n \n-  public Subscriber(Client client, String channel,\n-      ExecutionHandlerContext context) {\n-\n+  public Subscriber(Client client, String channel, ExecutionHandlerContext context) {\n     this.client = client;\n     this.channel = channel;\n     this.context = context;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3ODkyOA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377778928", "bodyText": "Would we not prefer a checked exception here?", "author": "kohlmu-pivotal", "createdAt": "2020-02-11T17:17:13Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {\n+  public final Client client;\n+  public final String channel;\n+  private ExecutionHandlerContext context;\n+\n+  public Subscriber(Client client, String channel,\n+      ExecutionHandlerContext context) {\n+\n+    this.client = client;\n+    this.channel = channel;\n+    this.context = context;\n+  }\n+\n+  public boolean isEqualTo(String channel, Client client) {\n+    return channel.equals(this.channel) && client.equals(this.client);\n+  }\n+\n+  public boolean publishMessage(String channel, String message) {\n+    ByteBuf messageByteBuffer;\n+    try {\n+      messageByteBuffer = Coder.getArrayResponse(context.getByteBufAllocator(),\n+          Arrays.asList(\"message\", channel, message));\n+    } catch (CoderException e) {\n+      throw new RuntimeException(e);", "originalCommit": "d8924a8105294286fc38cb6f2a8e602df512382e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMDk2Ng==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377920966", "bodyText": "Removed this exception in favor of returning null", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T21:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3ODkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1MTE3Mg==", "url": "https://github.com/apache/geode/pull/4682#discussion_r377951172", "bodyText": "Removed the exception in favor of an explicit return", "author": "jdeppe-pivotal", "createdAt": "2020-02-11T23:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3ODkyOA=="}], "type": "inlineReview", "revised_code": {"commit": "547191f996beea67696b13d926b9d7fbbf55e932", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\nindex 80d9a8ffe4..91f63298b7 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java\n\n@@ -17,21 +17,21 @@\n package org.apache.geode.redis.internal;\n \n import java.util.Arrays;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n \n class Subscriber {\n+  private static final Logger logger = LogService.getLogger();\n   public final Client client;\n   public final String channel;\n   private ExecutionHandlerContext context;\n \n-  public Subscriber(Client client, String channel,\n-      ExecutionHandlerContext context) {\n-\n+  public Subscriber(Client client, String channel, ExecutionHandlerContext context) {\n     this.client = client;\n     this.channel = channel;\n     this.context = context;\n"}}, {"oid": "547191f996beea67696b13d926b9d7fbbf55e932", "url": "https://github.com/apache/geode/commit/547191f996beea67696b13d926b9d7fbbf55e932", "message": "Address review comments", "committedDate": "2020-02-11T19:19:11Z", "type": "commit"}, {"oid": "35b874e592ad485ab3000bcf2c685cd2086b6941", "url": "https://github.com/apache/geode/commit/35b874e592ad485ab3000bcf2c685cd2086b6941", "message": "More review updates", "committedDate": "2020-02-11T19:26:29Z", "type": "commit"}, {"oid": "c8288e0fb38289a1fe6a8b36c1a1348fb3e0b75d", "url": "https://github.com/apache/geode/commit/c8288e0fb38289a1fe6a8b36c1a1348fb3e0b75d", "message": "Add validation to publish call", "committedDate": "2020-02-11T22:58:34Z", "type": "commit"}, {"oid": "a07a25fb88692daadb37b0caef2e9da2454faa7a", "url": "https://github.com/apache/geode/commit/a07a25fb88692daadb37b0caef2e9da2454faa7a", "message": "Change PubSub to an interface", "committedDate": "2020-02-12T16:23:29Z", "type": "commit"}, {"oid": "0eaf5c7e151dae6d5d6574e459d62bf5046cf76b", "url": "https://github.com/apache/geode/commit/0eaf5c7e151dae6d5d6574e459d62bf5046cf76b", "message": "Make pub/sub fn registration internal", "committedDate": "2020-02-12T16:45:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4NDEzOA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r378384138", "bodyText": "Feature envy. Can we please change.", "author": "kohlmu-pivotal", "createdAt": "2020-02-12T16:58:13Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.List;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.Executor;\n+import org.apache.geode.redis.internal.RedisConstants.ArityDef;\n+\n+public class PublishExecutor implements Executor {\n+\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    List<byte[]> args = command.getProcessedCommand();\n+    if (args.size() != 3) {\n+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ArityDef.PUBLISH));\n+      return;\n+    }\n+\n+    String channelName = new String(args.get(1));\n+    String message = new String(args.get(2));\n+    long publishCount = context.getPubSub().publish(channelName, message);", "originalCommit": "0eaf5c7e151dae6d5d6574e459d62bf5046cf76b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5OTY3NA==", "url": "https://github.com/apache/geode/pull/4682#discussion_r378399674", "bodyText": "I've raised GEODE-7793 (Refactor ExecutionHandlerContext to avoid 'feature-envy') to address this.", "author": "jdeppe-pivotal", "createdAt": "2020-02-12T17:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4NDEzOA=="}], "type": "inlineReview", "revised_code": null}]}