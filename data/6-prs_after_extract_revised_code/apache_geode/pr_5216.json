{"pr_number": 5216, "pr_title": "GEODE-8303: refactor Redis (String)SetExecutor", "pr_createdAt": "2020-06-04T23:06:08Z", "pr_url": "https://github.com/apache/geode/pull/5216", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODM0MQ==", "url": "https://github.com/apache/geode/pull/5216#discussion_r435618341", "bodyText": "Please convert this back to SECONDS.toMillis(expirationTimeLong). It is a standard part of the jdk and makes clear what units we are converting from and to.", "author": "dschneider-pivotal", "createdAt": "2020-06-04T23:50:06Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;", "originalCommit": "d52ff497d17a27652a5bdc573b49474e446c7a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTMyOA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r436079328", "bodyText": "makes sense-  rebase oversight.  done", "author": "jhutchison", "createdAt": "2020-06-05T18:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODM0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 0832cd8bfb..97da787c5f 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -42,32 +43,32 @@ public class SetExecutor extends StringExecutor {\n     ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n       setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n-\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n   }\n \n-\n   private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n     return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxOTMxNA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r435619314", "bodyText": "This is not the correct exception here. You actually have an integer but the parameter was not one of EX or PX. I wold argue that you should not even pass expirationParameter into this method. Let the caller that knows he is EX convert the value returned from this method to milliseconds. So less responsibility for this method.", "author": "dschneider-pivotal", "createdAt": "2020-06-04T23:53:52Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;\n+    } else if (!expirationParameter.equals(\"PX\")) {\n+      throw new IllegalArgumentException(ERROR_NOT_INTEGER);", "originalCommit": "d52ff497d17a27652a5bdc573b49474e446c7a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NzYxNA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r436187614", "bodyText": "pulled this logic apart-  thanks", "author": "jhutchison", "createdAt": "2020-06-05T22:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxOTMxNA=="}], "type": "inlineReview", "revised_code": {"commit": "929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 0832cd8bfb..97da787c5f 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -42,32 +43,32 @@ public class SetExecutor extends StringExecutor {\n     ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n       setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n-\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n   }\n \n-\n   private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n     return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMTc0Mw==", "url": "https://github.com/apache/geode/pull/5216#discussion_r435621743", "bodyText": "consider having a method called getNextParameter(\"PX\") which would do the indexOf, the size check and the get and return it. Then this type of code could look like:\nif (optionalParametersStrings.contains(\"PX\")) {\nString expirationTime = getNextParameter(optionalParametersStrings, \"PX\");", "author": "dschneider-pivotal", "createdAt": "2020-06-05T00:02:57Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");", "originalCommit": "d52ff497d17a27652a5bdc573b49474e446c7a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NzQ2Ng==", "url": "https://github.com/apache/geode/pull/5216#discussion_r436187466", "bodyText": "done - thanks", "author": "jhutchison", "createdAt": "2020-06-05T22:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMTc0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 0832cd8bfb..97da787c5f 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -42,32 +43,32 @@ public class SetExecutor extends StringExecutor {\n     ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n       setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n-\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n   }\n \n-\n   private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n     return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NjEwMA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r436056100", "bodyText": "This could be simplified to:\nkeepTTL = optionalParametersStrings.contains(\"KEEPTL\");", "author": "jdeppe-pivotal", "createdAt": "2020-06-05T17:18:13Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }", "originalCommit": "d52ff497d17a27652a5bdc573b49474e446c7a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTU2NA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r436079564", "bodyText": "thanks. done", "author": "jhutchison", "createdAt": "2020-06-05T18:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NjEwMA=="}], "type": "inlineReview", "revised_code": {"commit": "929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 0832cd8bfb..97da787c5f 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -42,32 +43,32 @@ public class SetExecutor extends StringExecutor {\n     ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n       setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n-\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n   }\n \n-\n   private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n     return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n"}}, {"oid": "929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "url": "https://github.com/apache/geode/commit/929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "message": "refactor SetExecutor", "committedDate": "2020-06-10T18:30:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NDgzOQ==", "url": "https://github.com/apache/geode/pull/5216#discussion_r438454839", "bodyText": "Change \"KEEPTL\" to \"KEEPTTL\"", "author": "dschneider-pivotal", "createdAt": "2020-06-10T23:06:56Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");", "originalCommit": "3d1ac779762f879de28bbee4a8f9ad0803357b7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1MzEzOA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r439053138", "bodyText": "thanks- I'll look into why no test caught this...", "author": "jhutchison", "createdAt": "2020-06-11T20:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NDgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 97da787c5f..13c471da33 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -34,7 +34,7 @@ public class SetExecutor extends StringExecutor {\n   private final String SUCCESS = \"OK\";\n \n   @Override\n-  public RedisResponse executeCommandWithResponse(Command command,\n+  public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n \n     ByteArrayWrapper keyToSet = command.getKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NTc2MQ==", "url": "https://github.com/apache/geode/pull/5216#discussion_r438455761", "bodyText": "change \"KEEPTL\" to \"KEEPTTL\"", "author": "dschneider-pivotal", "createdAt": "2020-06-10T23:09:50Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");", "originalCommit": "3d1ac779762f879de28bbee4a8f9ad0803357b7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NTQzMg==", "url": "https://github.com/apache/geode/pull/5216#discussion_r439055432", "bodyText": "same", "author": "jhutchison", "createdAt": "2020-06-11T20:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NTc2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 97da787c5f..13c471da33 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -34,7 +34,7 @@ public class SetExecutor extends StringExecutor {\n   private final String SUCCESS = \"OK\";\n \n   @Override\n-  public RedisResponse executeCommandWithResponse(Command command,\n+  public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n \n     ByteArrayWrapper keyToSet = command.getKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NzU5NA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r438457594", "bodyText": "I don't like that we now call parseLong twice. Once in isANumber and once in parseExpirationTime. Just have parseExpirationTime handle NumberFormatException and throw IllegalArgumentException(ERROR_NOT_INTEGER)", "author": "dschneider-pivotal", "createdAt": "2020-06-10T23:15:44Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);", "originalCommit": "3d1ac779762f879de28bbee4a8f9ad0803357b7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODI0MA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r439078240", "bodyText": "(see below)", "author": "jhutchison", "createdAt": "2020-06-11T21:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NzU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 97da787c5f..13c471da33 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -34,7 +34,7 @@ public class SetExecutor extends StringExecutor {\n   private final String SUCCESS = \"OK\";\n \n   @Override\n-  public RedisResponse executeCommandWithResponse(Command command,\n+  public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n \n     ByteArrayWrapper keyToSet = command.getKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1Nzc3Nw==", "url": "https://github.com/apache/geode/pull/5216#discussion_r438457777", "bodyText": "The old code used ERROR_NOT_INTEGER if it was not a number. You have changed that to ERROR_SYNTAX", "author": "dschneider-pivotal", "createdAt": "2020-06-10T23:16:19Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);", "originalCommit": "3d1ac779762f879de28bbee4a8f9ad0803357b7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTc4NA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r439065784", "bodyText": "you're right-  just checked native redis.  I'll look into lack of test here, too", "author": "jhutchison", "createdAt": "2020-06-11T20:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1Nzc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 97da787c5f..13c471da33 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -34,7 +34,7 @@ public class SetExecutor extends StringExecutor {\n   private final String SUCCESS = \"OK\";\n \n   @Override\n-  public RedisResponse executeCommandWithResponse(Command command,\n+  public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n \n     ByteArrayWrapper keyToSet = command.getKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODc3NQ==", "url": "https://github.com/apache/geode/pull/5216#discussion_r438458775", "bodyText": "I think it would be better to do this in the caller that does this for EX. Then you don't need to pass expirationParameter to this method. Its job is just parsing.", "author": "dschneider-pivotal", "createdAt": "2020-06-10T23:19:46Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);\n+      return true;\n+    } catch (NumberFormatException e) {\n+      return false;\n+    }\n+  }\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String timeUntilExpiration) {\n+\n+    long millisecondsUntilExpirationLong =\n+        Long.parseLong(timeUntilExpiration);\n+\n+    if (expirationParameter.equals(\"EX\")) {", "originalCommit": "3d1ac779762f879de28bbee4a8f9ad0803357b7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MDM4Nw==", "url": "https://github.com/apache/geode/pull/5216#discussion_r439070387", "bodyText": "ok-  done (when commit arrives)", "author": "jhutchison", "createdAt": "2020-06-11T21:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 97da787c5f..13c471da33 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -34,7 +34,7 @@ public class SetExecutor extends StringExecutor {\n   private final String SUCCESS = \"OK\";\n \n   @Override\n-  public RedisResponse executeCommandWithResponse(Command command,\n+  public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n \n     ByteArrayWrapper keyToSet = command.getKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDEwOA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r438460108", "bodyText": "so actually it parses the long three times! If you are going to do it here then you should have it also fill a HashMap whose keys are the option that expects a number and whose value is the number. Then this could be used later instead of parsing again.", "author": "dschneider-pivotal", "createdAt": "2020-06-10T23:24:13Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {", "originalCommit": "3d1ac779762f879de28bbee4a8f9ad0803357b7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODE3NA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r439078174", "bodyText": "thanks for catching that done (in forthcoming commit)", "author": "jhutchison", "createdAt": "2020-06-11T21:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\nindex 97da787c5f..13c471da33 100755\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java\n\n@@ -34,7 +34,7 @@ public class SetExecutor extends StringExecutor {\n   private final String SUCCESS = \"OK\";\n \n   @Override\n-  public RedisResponse executeCommandWithResponse(Command command,\n+  public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n \n     ByteArrayWrapper keyToSet = command.getKey();\n"}}, {"oid": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "url": "https://github.com/apache/geode/commit/d732d3182b9bf82b303a6d835fe611b40f56e31d", "message": "add additional changes in setExecutor suggested in review", "committedDate": "2020-06-11T22:08:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NzM5MQ==", "url": "https://github.com/apache/geode/pull/5216#discussion_r440347391", "bodyText": "The changes here look like an incorrect merge perhaps.", "author": "jdeppe-pivotal", "createdAt": "2020-06-15T17:54:06Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java", "diffHunk": "@@ -16,34 +16,35 @@\n \n package org.apache.geode.redis.internal.executor.key;\n \n-import static org.apache.geode.redis.internal.RedisConstants.ERROR_NO_SUCH_KEY;\n-\n import java.util.List;\n \n+import org.apache.geode.redis.internal.RedisConstants;\n import org.apache.geode.redis.internal.data.ByteArrayWrapper;\n import org.apache.geode.redis.internal.executor.AbstractExecutor;\n-import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Coder;\n import org.apache.geode.redis.internal.netty.Command;\n import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n \n public class RenameExecutor extends AbstractExecutor {\n-\n   @Override\n-  public RedisResponse executeCommand(Command command,\n-      ExecutionHandlerContext context) {\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {", "originalCommit": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MzIxMA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r440443210", "bodyText": "looking into it-  thx", "author": "jhutchison", "createdAt": "2020-06-15T20:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NzM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb8aecfa37b3d69213218765cf6f0315f8cdb463", "chunk": "diff --git a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java\nindex f78cc77f36..abfc320680 100644\n--- a/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java\n+++ b/geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java\n\n@@ -16,35 +16,34 @@\n \n package org.apache.geode.redis.internal.executor.key;\n \n+import static org.apache.geode.redis.internal.RedisConstants.ERROR_NO_SUCH_KEY;\n+\n import java.util.List;\n \n-import org.apache.geode.redis.internal.RedisConstants;\n import org.apache.geode.redis.internal.data.ByteArrayWrapper;\n import org.apache.geode.redis.internal.executor.AbstractExecutor;\n-import org.apache.geode.redis.internal.netty.Coder;\n+import org.apache.geode.redis.internal.executor.RedisResponse;\n import org.apache.geode.redis.internal.netty.Command;\n import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n \n public class RenameExecutor extends AbstractExecutor {\n+\n   @Override\n-  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+  public RedisResponse executeCommand(Command command,\n+      ExecutionHandlerContext context) {\n     List<ByteArrayWrapper> commandElems = command.getProcessedCommandWrappers();\n     ByteArrayWrapper key = command.getKey();\n     ByteArrayWrapper newKey = commandElems.get(2);\n     RedisKeyCommands redisKeyCommands = getRedisKeyCommands(context);\n \n     if (key.equals(newKey)) {\n-      command.setResponse(Coder.getSimpleStringResponse(context.getByteBufAllocator(), \"OK\"));\n-      return;\n+      return RedisResponse.string(\"OK\");\n     }\n \n     if (!redisKeyCommands.rename(key, newKey)) {\n-      command.setResponse(\n-          Coder.getErrorResponse(context.getByteBufAllocator(),\n-              RedisConstants.ERROR_NO_SUCH_KEY));\n-      return;\n+      return RedisResponse.error(ERROR_NO_SUCH_KEY);\n     }\n \n-    command.setResponse(Coder.getSimpleStringResponse(context.getByteBufAllocator(), \"OK\"));\n+    return RedisResponse.string(\"OK\");\n   }\n }\n"}}, {"oid": "27bda5ccf373665dccee5dfa10fd17bb4eb8ef4a", "url": "https://github.com/apache/geode/commit/27bda5ccf373665dccee5dfa10fd17bb4eb8ef4a", "message": "add additional changes in setExecutor suggested in review", "committedDate": "2020-06-15T20:51:53Z", "type": "forcePushed"}, {"oid": "bb8aecfa37b3d69213218765cf6f0315f8cdb463", "url": "https://github.com/apache/geode/commit/bb8aecfa37b3d69213218765cf6f0315f8cdb463", "message": "correct merge error", "committedDate": "2020-06-17T17:47:14Z", "type": "forcePushed"}, {"oid": "b43c69b645b9547b836907c3de0b498d73f53646", "url": "https://github.com/apache/geode/commit/b43c69b645b9547b836907c3de0b498d73f53646", "message": "resolve merge conflict", "committedDate": "2020-06-18T18:24:35Z", "type": "forcePushed"}, {"oid": "a445d1550e80682e969ab8770b7f9ce88924779d", "url": "https://github.com/apache/geode/commit/a445d1550e80682e969ab8770b7f9ce88924779d", "message": "add requested test; change code to make test pass", "committedDate": "2020-06-19T23:11:57Z", "type": "forcePushed"}, {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206", "url": "https://github.com/apache/geode/commit/2026a5f7bab748cc1f4daef606276ff2e868f206", "message": "add requested test; change code to make test pass", "committedDate": "2020-06-22T18:36:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMTY0Nw==", "url": "https://github.com/apache/geode/pull/5216#discussion_r445111647", "bodyText": "It looks like you may have actually brought StringsIntegrationTest back to life. I think it has been removed from develop and split up into multiple, command focused tests. We now have a SetIntegrationTest so amy tests for SET that you added to this class should now be added to it instead.", "author": "dschneider-pivotal", "createdAt": "2020-06-24T19:09:42Z", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java", "diffHunk": "@@ -0,0 +1,1637 @@\n+/*", "originalCommit": "2026a5f7bab748cc1f4daef606276ff2e868f206", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwNTEwOQ==", "url": "https://github.com/apache/geode/pull/5216#discussion_r445205109", "bodyText": "whoops.  thanks-  moved Jen's earlier changes into the  SetsIntegrationTest and deleted StringsIntegrationTest", "author": "jhutchison", "createdAt": "2020-06-24T22:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMTY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6962ca222c835a6d59fafc9d6447c19d35f22fd6", "chunk": "diff --git a/geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java b/geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java\ndeleted file mode 100755\nindex caaf72f945..0000000000\n--- a/geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java\n+++ /dev/null\n\n@@ -1,1637 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n- * agreements. See the NOTICE file distributed with this work for additional information regarding\n- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n- * copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package org.apache.geode.redis.internal.executor.string;\n-\n-import static java.lang.Integer.parseInt;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-import static redis.clients.jedis.Protocol.Command.SET;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import org.assertj.core.api.SoftAssertions;\n-import org.junit.After;\n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n-import org.junit.ClassRule;\n-import org.junit.Ignore;\n-import org.junit.Test;\n-import org.junit.experimental.categories.Category;\n-import redis.clients.jedis.BitOP;\n-import redis.clients.jedis.BitPosParams;\n-import redis.clients.jedis.Jedis;\n-import redis.clients.jedis.exceptions.JedisDataException;\n-import redis.clients.jedis.params.SetParams;\n-\n-import org.apache.geode.redis.ConcurrentLoopingThreads;\n-import org.apache.geode.redis.GeodeRedisServerRule;\n-import org.apache.geode.redis.internal.RedisConstants;\n-import org.apache.geode.test.awaitility.GeodeAwaitility;\n-import org.apache.geode.test.junit.categories.RedisTest;\n-\n-@Category({RedisTest.class})\n-public class StringsIntegrationTest {\n-\n-  static Jedis jedis;\n-  static Jedis jedis2;\n-  static Random rand;\n-  private static int ITERATION_COUNT = 4000;\n-\n-  @ClassRule\n-  public static GeodeRedisServerRule server = new GeodeRedisServerRule();\n-\n-  @BeforeClass\n-  public static void setUp() {\n-    rand = new Random();\n-    jedis = new Jedis(\"localhost\", server.getPort(), 10000000);\n-    jedis2 = new Jedis(\"localhost\", server.getPort(), 10000000);\n-  }\n-\n-  @After\n-  public void flushAll() {\n-    jedis.flushAll();\n-  }\n-\n-  @AfterClass\n-  public static void tearDown() {\n-    jedis.close();\n-    jedis2.close();\n-  }\n-\n-  @Test\n-  public void testSET_shouldSetStringValueToKey_givenEmptyKey() {\n-\n-    String key = \"key\";\n-    String value = \"value\";\n-\n-    String result = jedis.get(key);\n-    assertThat(result).isNull();\n-\n-    jedis.set(key, value);\n-    result = jedis.get(key);\n-    assertThat(result).isEqualTo(value);\n-  }\n-\n-  @Test\n-  public void testSET_shouldSetStringValueToKey_givenKeyIsOfDataTypeSet() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    jedis.sadd(key, \"member1\", \"member2\");\n-\n-    jedis.set(key, stringValue);\n-\n-    assertThat(jedis.get(key)).isEqualTo(stringValue);\n-  }\n-\n-  @Test\n-  public void testSET_shouldSetStringValueToKey_givenKeyIsOfDataTypeHash() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    jedis.hset(key, \"field\", \"something else\");\n-\n-    String result = jedis.set(key, stringValue);\n-    assertThat(result).isEqualTo(\"OK\");\n-\n-    assertThat(jedis.get(key)).isEqualTo(stringValue);\n-  }\n-\n-  @Test\n-  public void testSET_withNXAndExArguments() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    SetParams setParams = new SetParams();\n-    setParams.nx();\n-    setParams.ex(20);\n-\n-    jedis.set(key, stringValue, setParams);\n-    assertThat(jedis.ttl(key)).isGreaterThan(15);\n-    assertThat(jedis.get(key)).isEqualTo(stringValue);\n-  }\n-\n-  @Test\n-  public void testSET_withXXAndExArguments() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    jedis.set(key, \"differentValue\");\n-\n-    SetParams setParams = new SetParams();\n-    setParams.xx();\n-    setParams.ex(20);\n-\n-    jedis.set(key, stringValue, setParams);\n-    assertThat(jedis.ttl(key)).isGreaterThan(15);\n-    assertThat(jedis.get(key)).isEqualTo(stringValue);\n-  }\n-\n-  @Test\n-  public void testSET_withNXAndPxArguments() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    SetParams setParams = new SetParams();\n-    setParams.nx();\n-    setParams.px(2000);\n-\n-    jedis.set(key, stringValue, setParams);\n-    assertThat(jedis.pttl(key)).isGreaterThan(1500);\n-    assertThat(jedis.get(key)).isEqualTo(stringValue);\n-  }\n-\n-  @Test\n-  public void testSET_withXXAndPxArguments() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    jedis.set(key, \"differentValue\");\n-\n-    SetParams setParams = new SetParams();\n-    setParams.xx();\n-    setParams.px(2000);\n-\n-    jedis.set(key, stringValue, setParams);\n-    assertThat(jedis.pttl(key)).isGreaterThan(1500);\n-    assertThat(jedis.get(key)).isEqualTo(stringValue);\n-  }\n-\n-  @Test\n-  public void testSET_withNXArgument_shouldReturnNil_ifKeyContainsOtherDataType() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    jedis.sadd(key, \"member1\", \"member2\");\n-    SetParams setParams = new SetParams();\n-    setParams.nx();\n-\n-    String result = jedis.set(key, stringValue, setParams);\n-    assertThat(result).isNull();\n-  }\n-\n-  @Test\n-  public void testSET_shouldSetXX_ifKeyContainsOtherDataType() {\n-    String key = \"key\";\n-    String stringValue = \"value\";\n-\n-    jedis.sadd(key, \"member1\", \"member2\");\n-    SetParams setParams = new SetParams();\n-    setParams.xx();\n-\n-    jedis.set(key, stringValue, setParams);\n-    String result = jedis.get(key);\n-\n-    assertThat(result).isEqualTo(stringValue);\n-  }\n-\n-  @Test\n-  public void setNX_shouldNotConflictWithRegularSet() {\n-    List<String> keys = new ArrayList<>();\n-    List<String> values = new ArrayList<>();\n-    for (int i = 0; i < ITERATION_COUNT; i++) {\n-      keys.add(\"key-\" + i);\n-      values.add(\"value-\" + i);\n-    }\n-\n-    AtomicInteger counter = new AtomicInteger(0);\n-    SetParams setParams = new SetParams();\n-    setParams.nx();\n-\n-    new ConcurrentLoopingThreads(ITERATION_COUNT,\n-        (i) -> {\n-          String ok = jedis.set(keys.get(i), values.get(i));\n-          if (\"OK\".equals(ok)) {\n-            counter.addAndGet(1);\n-          }\n-        },\n-        (i) -> jedis2.set(keys.get(i), values.get(i), setParams))\n-            .run();\n-\n-    assertThat(counter.get()).isEqualTo(ITERATION_COUNT);\n-  }\n-\n-  @Test\n-  public void testSET_withEXArgument_shouldSetExpireTime() {\n-    String key = \"key\";\n-    String value = \"value\";\n-    int secondsUntilExpiration = 20;\n-\n-    SetParams setParams = new SetParams();\n-    setParams.ex(secondsUntilExpiration);\n-\n-    jedis.set(key, value, setParams);\n-\n-    Long result = jedis.ttl(key);\n-\n-    assertThat(result).isGreaterThan(15l);\n-  }\n-\n-  @Test\n-  public void testSET_withNegativeEXTime_shouldReturnError() {\n-    String key = \"key\";\n-    String value = \"value\";\n-    int millisecondsUntilExpiration = -1;\n-\n-    SetParams setParams = new SetParams();\n-    setParams.ex(millisecondsUntilExpiration);\n-\n-    assertThatThrownBy(() -> jedis.set(key, value, setParams))\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(RedisConstants.ERROR_INVALID_EXPIRE_TIME);\n-  }\n-\n-  @Test\n-  public void testSET_withPXArgument_shouldSetExpireTime() {\n-    String key = \"key\";\n-    String value = \"value\";\n-    int millisecondsUntilExpiration = 20000;\n-\n-    SetParams setParams = new SetParams();\n-    setParams.px(millisecondsUntilExpiration);\n-\n-    jedis.set(key, value, setParams);\n-\n-    Long result = jedis.ttl(key);\n-\n-    assertThat(result).isGreaterThan(15l);\n-  }\n-\n-  @Test\n-  public void testSET_withNegativePXTime_shouldReturnError() {\n-    String key = \"key\";\n-    String value = \"value\";\n-    int millisecondsUntilExpiration = -1;\n-\n-    SetParams setParams = new SetParams();\n-    setParams.px(millisecondsUntilExpiration);\n-\n-    assertThatThrownBy(() -> jedis.set(key, value, setParams))\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(RedisConstants.ERROR_INVALID_EXPIRE_TIME);\n-  }\n-\n-  @Test\n-  public void testSET_shouldClearPreviousTTL() {\n-    String key = \"key\";\n-    String value = \"value\";\n-    int secondsUntilExpiration = 20;\n-\n-    SetParams setParams = new SetParams();\n-    setParams.ex(secondsUntilExpiration);\n-\n-    jedis.set(key, value, setParams);\n-\n-    jedis.set(key, \"other value\");\n-\n-    Long result = jedis.ttl(key);\n-\n-    assertThat(result).isEqualTo(-1L);\n-  }\n-\n-  @Test\n-  public void testSET_withXXArgument_shouldClearPreviousTTL() {\n-    String key = \"xx_key\";\n-    String value = \"did exist\";\n-    int secondsUntilExpiration = 20;\n-    SetParams setParamsXX = new SetParams();\n-    setParamsXX.xx();\n-    SetParams setParamsEX = new SetParams();\n-    setParamsEX.ex(secondsUntilExpiration);\n-    String result_EX = jedis.set(key, value, setParamsEX);\n-    assertThat(result_EX).isEqualTo(\"OK\");\n-    assertThat(jedis.ttl(key)).isGreaterThan(15L);\n-\n-    String result_XX = jedis.set(key, value, setParamsXX);\n-\n-    assertThat(result_XX).isEqualTo(\"OK\");\n-    Long result = jedis.ttl(key);\n-    assertThat(result).isEqualTo(-1L);\n-  }\n-\n-  @Test\n-  public void testSET_should_not_clearPreviousTTL_onFailure() {\n-    String key_NX = \"nx_key\";\n-    String value_NX = \"set only if key did not exist\";\n-    int secondsUntilExpiration = 20;\n-\n-    SetParams setParamsEX = new SetParams();\n-    setParamsEX.ex(secondsUntilExpiration);\n-\n-    SetParams setParamsNX = new SetParams();\n-    setParamsNX.nx();\n-\n-    jedis.set(key_NX, value_NX, setParamsEX);\n-    String result_NX = jedis.set(key_NX, value_NX, setParamsNX);\n-    assertThat(result_NX).isNull();\n-\n-    Long result = jedis.ttl(key_NX);\n-    assertThat(result).isGreaterThan(15L);\n-  }\n-\n-  @Test\n-  @Ignore(\"KEEPTTL is part of redis 6\")\n-  public void testSET_with_KEEPTTL_shouldRetainPreviousTTL_OnSuccess() {\n-    String key = \"key\";\n-    String value = \"value\";\n-    int secondsToExpire = 30;\n-\n-    SetParams setParamsEx = new SetParams();\n-    setParamsEx.ex(secondsToExpire);\n-\n-    jedis.set(key, value, setParamsEx);\n-\n-    SetParams setParamsKeepTTL = new SetParams();\n-    // setParamsKeepTTL.keepTtl();\n-    // Jedis Doesn't support KEEPTTL yet.\n-\n-    jedis.set(key, \"newValue\", setParamsKeepTTL);\n-\n-    Long result = jedis.ttl(key);\n-    assertThat(result).isGreaterThan(15L);\n-  }\n-\n-  @Test\n-  public void set_with_KEEPTTL_fails() {\n-    assertThatThrownBy(() -> jedis.sendCommand(SET, \"key\", \"value\", \"KEEPTTL\"))\n-        .hasMessageContaining(\"syntax error\");\n-  }\n-\n-  @Test\n-  public void testSET_withNXArgument_shouldOnlySetKeyIfKeyDoesNotExist() {\n-    String key1 = \"key_1\";\n-    String key2 = \"key_2\";\n-    String value1 = \"value_1\";\n-    String value2 = \"value_2\";\n-\n-    jedis.set(key1, value1);\n-\n-    SetParams setParams = new SetParams();\n-    setParams.nx();\n-\n-    jedis.set(key1, value2, setParams);\n-    String result1 = jedis.get(key1);\n-\n-    assertThat(result1).isEqualTo(value1);\n-\n-    jedis.set(key2, value2, setParams);\n-    String result2 = jedis.get(key2);\n-\n-    assertThat(result2).isEqualTo(value2);\n-  }\n-\n-  @Test\n-  public void testSET_withXXArgument_shouldOnlySetKeyIfKeyExists() {\n-    String key1 = \"key_1\";\n-    String key2 = \"key_2\";\n-    String value1 = \"value_1\";\n-    String value2 = \"value_2\";\n-\n-    jedis.set(key1, value1);\n-\n-    SetParams setParams = new SetParams();\n-    setParams.xx();\n-\n-    jedis.set(key1, value2, setParams);\n-    String result1 = jedis.get(key1);\n-\n-    assertThat(result1).isEqualTo(value2);\n-\n-    jedis.set(key2, value2, setParams);\n-    String result2 = jedis.get(key2);\n-\n-    assertThat(result2).isNull();\n-  }\n-\n-  @Test\n-  public void testSET_XXAndNXArguments_shouldReturnOK_ifSuccessful() {\n-    String key_NX = \"nx_key\";\n-    String key_XX = \"xx_key\";\n-    String value_NX = \"did not exist\";\n-    String value_XX = \"did exist\";\n-\n-    SetParams setParamsXX = new SetParams();\n-    setParamsXX.xx();\n-\n-    SetParams setParamsNX = new SetParams();\n-    setParamsNX.nx();\n-\n-    String result_NX = jedis.set(key_NX, value_NX, setParamsNX);\n-    assertThat(result_NX).isEqualTo(\"OK\");\n-\n-    jedis.set(key_XX, value_XX);\n-    String result_XX = jedis.set(key_NX, value_NX, setParamsXX);\n-    assertThat(result_XX).isEqualTo(\"OK\");\n-  }\n-\n-  @Test\n-  public void testSET_XXAndNXArguments_shouldReturnNull_ifNotSuccessful() {\n-    String key_NX = \"nx_key\";\n-    String key_XX = \"xx_key\";\n-    String value_NX = \"set only if key did not exist\";\n-    String value_XX = \"set only if key did exist\";\n-\n-    SetParams setParamsXX = new SetParams();\n-    setParamsXX.xx();\n-\n-    SetParams setParamsNX = new SetParams();\n-    setParamsNX.nx();\n-\n-    jedis.set(key_NX, value_NX);\n-    String result_NX = jedis.set(key_NX, value_NX, setParamsNX);\n-    assertThat(result_NX).isNull();\n-\n-    String result_XX = jedis.set(key_XX, value_XX, setParamsXX);\n-    assertThat(result_XX).isNull();\n-  }\n-\n-  @Test\n-  public void testGET_shouldReturnValueOfKey_givenValueIsAString() {\n-    String key = \"key\";\n-    String value = \"value\";\n-\n-    String result = jedis.get(key);\n-    assertThat(result).isNull();\n-\n-    jedis.set(key, value);\n-    result = jedis.get(key);\n-    assertThat(result).isEqualTo(value);\n-  }\n-\n-\n-\n-  @Test\n-  public void testSET_withInvalidOptions() {\n-    SoftAssertions soft = new SoftAssertions();\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET))\n-        .as(\"invalid options #1\")\n-        .isInstanceOf(JedisDataException.class);\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET, \"foo\", \"EX\", \"0\"))\n-        .as(\"invalid options #2\")\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(\"syntax error\");\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET, \"foo\", \"bar\", \"EX\", \"a\"))\n-        .as(\"invalid options #3\")\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(\"value is not an integer\");\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET, \"foo\", \"bar\", \"PX\", \"1\", \"EX\", \"0\"))\n-        .as(\"invalid options #4\")\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(\"syntax error\");\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET, \"foo\", \"bar\", \"PX\", \"1\", \"XX\", \"0\"))\n-        .as(\"invalid options #5\")\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(\"syntax error\");\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET, \"foo\", \"bar\", \"PX\", \"XX\", \"0\"))\n-        .as(\"invalid options #6\")\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(\"syntax error\");\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET, \"foo\", \"bar\", \"1\", \"PX\", \"1\"))\n-        .as(\"invalid options #7\")\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(\"syntax error\");\n-\n-    soft.assertThatThrownBy(() -> jedis.sendCommand(SET, \"foo\", \"bar\", \"NX\", \"XX\"))\n-        .as(\"invalid options #8\")\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(\"syntax error\");\n-\n-    soft.assertAll();\n-  }\n-\n-\n-\n-  @Test\n-  public void testGET_shouldReturnNil_givenKeyIsEmpty() {\n-    String key = \"this key does not exist\";\n-\n-    String result = jedis.get(key);\n-    assertThat(result).isNull();\n-  }\n-\n-  @Test\n-  public void testGET_shouldThrowJedisDataExceptionError_givenValueIsNotAString() {\n-    String key = \"key\";\n-    String field = \"field\";\n-    String member = \"member\";\n-\n-    jedis.sadd(key, field, member);\n-\n-    assertThatThrownBy(() -> jedis.get(key))\n-        .hasMessageContaining(\"Operation against a key holding the wrong kind of value\");\n-  }\n-\n-  @Test\n-  public void testAppend_shouldAppendValueWithInputStringAndReturnResultingLength() {\n-    String key = \"key\";\n-    String value = randString();\n-    int originalValueLength = value.length();\n-\n-    boolean result = jedis.exists(key);\n-    assertThat(result).isFalse();\n-\n-    Long output = jedis.append(key, value);\n-    assertThat(output).isEqualTo(originalValueLength);\n-\n-    String randomString = randString();\n-\n-    output = jedis.append(key, randomString);\n-    assertThat(output).isEqualTo(originalValueLength + randomString.length());\n-\n-    String finalValue = jedis.get(key);\n-    assertThat(finalValue).isEqualTo(value.concat(randomString));\n-  }\n-\n-  @Test\n-  public void testAppend_concurrent() {\n-    int listSize = 1000;\n-    String key = \"key\";\n-\n-    List<String> values1 = makeStringList(listSize, \"values1-\");\n-    List<String> values2 = makeStringList(listSize, \"values2-\");\n-\n-    new ConcurrentLoopingThreads(listSize,\n-        (i) -> jedis.append(key, values1.get(i)),\n-        (i) -> jedis2.append(key, values2.get(i))).run();\n-\n-    for (int i = 0; i < listSize; i++) {\n-      assertThat(jedis.get(key)).contains(values1.get(i));\n-      assertThat(jedis.get(key)).contains(values2.get(i));\n-    }\n-  }\n-\n-\n-  @Test\n-  public void testGetRange_whenWholeRangeSpecified_returnsEntireValue() {\n-    String key = \"key\";\n-    String valueWith19Characters = \"abc123babyyouknowme\";\n-\n-    jedis.set(key, valueWith19Characters);\n-\n-    String everything = jedis.getrange(key, 0, -1);\n-    assertThat(everything).isEqualTo(valueWith19Characters);\n-\n-    String alsoEverything = jedis.getrange(key, 0, 18);\n-    assertThat(alsoEverything).isEqualTo(valueWith19Characters);\n-\n-  }\n-\n-  @Test\n-  public void testGetRange_whenMoreThanWholeRangeSpecified_returnsEntireValue() {\n-    String key = \"key\";\n-    String valueWith19Characters = \"abc123babyyouknowme\";\n-\n-    jedis.set(key, valueWith19Characters);\n-\n-    String fromStartToWayPastEnd = jedis.getrange(key, 0, 5000);\n-    assertThat(fromStartToWayPastEnd).isEqualTo(valueWith19Characters);\n-\n-    String wayBeforeStartAndJustToEnd = jedis.getrange(key, -50000, -1);\n-    assertThat(wayBeforeStartAndJustToEnd).isEqualTo(valueWith19Characters);\n-\n-    String wayBeforeStartAndWayAfterEnd = jedis.getrange(key, -50000, 5000);\n-    assertThat(wayBeforeStartAndWayAfterEnd).isEqualTo(valueWith19Characters);\n-  }\n-\n-  @Test\n-  public void testGetRange_whenValidSubrangeSpecified_returnsAppropriateSubstring() {\n-    String key = \"key\";\n-    String valueWith19Characters = \"abc123babyyouknowme\";\n-\n-    jedis.set(key, valueWith19Characters);\n-\n-    String fromStartToBeforeEnd = jedis.getrange(key, 0, 16);\n-    assertThat(fromStartToBeforeEnd).isEqualTo(\"abc123babyyouknow\");\n-\n-    String fromStartByNegativeOffsetToBeforeEnd = jedis.getrange(key, -19, 16);\n-    assertThat(fromStartByNegativeOffsetToBeforeEnd).isEqualTo(\"abc123babyyouknow\");\n-\n-    String fromStartToBeforeEndByNegativeOffset = jedis.getrange(key, 0, -3);\n-    assertThat(fromStartToBeforeEndByNegativeOffset).isEqualTo(\"abc123babyyouknow\");\n-\n-    String fromAfterStartToBeforeEnd = jedis.getrange(key, 2, 16);\n-    assertThat(fromAfterStartToBeforeEnd).isEqualTo(\"c123babyyouknow\");\n-\n-    String fromAfterStartByNegativeOffsetToBeforeEndByNegativeOffset = jedis.getrange(key, -16, -2);\n-    assertThat(fromAfterStartByNegativeOffsetToBeforeEndByNegativeOffset)\n-        .isEqualTo(\"123babyyouknowm\");\n-\n-    String fromAfterStartToEnd = jedis.getrange(key, 2, 18);\n-    assertThat(fromAfterStartToEnd).isEqualTo(\"c123babyyouknowme\");\n-\n-    String fromAfterStartToEndByNegativeOffset = jedis.getrange(key, 2, -1);\n-    assertThat(fromAfterStartToEndByNegativeOffset).isEqualTo(\"c123babyyouknowme\");\n-  }\n-\n-  @Test\n-  public void testGetRange_rangeIsInvalid_returnsEmptyString() {\n-    String key = \"key\";\n-    String valueWith19Characters = \"abc123babyyouknowme\";\n-\n-    jedis.set(key, valueWith19Characters);\n-\n-    String range1 = jedis.getrange(key, -2, -16);\n-    assertThat(range1).isEqualTo(\"\");\n-\n-    String range2 = jedis.getrange(key, 2, 0);\n-    assertThat(range2).isEqualTo(\"\");\n-  }\n-\n-  @Test\n-  public void testGetRange_nonexistentKey_returnsEmptyString() {\n-    String key = \"nonexistent\";\n-\n-    String range = jedis.getrange(key, 0, -1);\n-    assertThat(range).isEqualTo(\"\");\n-  }\n-\n-  @Test\n-  public void testGetRange_rangePastEndOfValue_returnsEmptyString() {\n-    String key = \"key\";\n-    String value = \"value\";\n-\n-    jedis.set(key, value);\n-\n-    String range = jedis.getrange(key, 7, 14);\n-    assertThat(range).isEqualTo(\"\");\n-  }\n-\n-  @Test\n-  public void setRange_replacesStart() {\n-    jedis.set(\"key\", \"0123456789\");\n-    assertThat(jedis.setrange(\"key\", 0, \"abcd\")).isEqualTo(10);\n-    assertThat(jedis.get(\"key\")).isEqualTo(\"abcd456789\");\n-  }\n-\n-  @Test\n-  public void setRange_replacesMiddle() {\n-    jedis.set(\"key\", \"0123456789\");\n-    assertThat(jedis.setrange(\"key\", 3, \"abc\")).isEqualTo(10);\n-    assertThat(jedis.get(\"key\")).isEqualTo(\"012abc6789\");\n-  }\n-\n-  @Test\n-  public void setRange_replacesEnd() {\n-    jedis.set(\"key\", \"0123456789\");\n-    assertThat(jedis.setrange(\"key\", 7, \"abc\")).isEqualTo(10);\n-    assertThat(jedis.get(\"key\")).isEqualTo(\"0123456abc\");\n-  }\n-\n-  @Test\n-  public void setRange_extendsEnd() {\n-    jedis.set(\"key\", \"0123456789\");\n-    assertThat(jedis.setrange(\"key\", 10, \"abc\")).isEqualTo(13);\n-    assertThat(jedis.get(\"key\")).isEqualTo(\"0123456789abc\");\n-  }\n-\n-  @Test\n-  public void setRange_extendsAndPadsWithZero() {\n-    jedis.set(\"key\", \"0123456789\");\n-    assertThat(jedis.setrange(\"key\", 11, \"abc\")).isEqualTo(14);\n-    assertThat((int) (jedis.get(\"key\").charAt(10))).isEqualTo(0);\n-  }\n-\n-  @Test\n-  public void setRange_createsKey() {\n-    assertThat(jedis.setrange(\"key\", 0, \"abcd\")).isEqualTo(4);\n-    assertThat(jedis.get(\"key\")).isEqualTo(\"abcd\");\n-  }\n-\n-  @Test\n-  public void setRange_givenSetFails() {\n-    jedis.sadd(\"key\", \"m1\");\n-    assertThatThrownBy(() -> jedis.setrange(\"key\", 0, \"abc\")).hasMessageContaining(\"WRONGTYPE\");\n-  }\n-\n-  @Test\n-  public void bitcount_givenSetFails() {\n-    jedis.sadd(\"key\", \"m1\");\n-    assertThatThrownBy(() -> jedis.bitcount(\"key\")).hasMessageContaining(\"WRONGTYPE\");\n-  }\n-\n-  @Test\n-  public void bitcount_givenNonExistentKeyReturnsZero() {\n-    assertThat(jedis.bitcount(\"does not exist\")).isEqualTo(0);\n-    assertThat(jedis.exists(\"does not exist\")).isFalse();\n-  }\n-\n-  @Test\n-  public void bitcount_givenEmptyStringReturnsZero() {\n-    jedis.set(\"key\", \"\");\n-    assertThat(jedis.bitcount(\"key\")).isEqualTo(0);\n-  }\n-\n-  @Test\n-  public void bitcount_givenOneBitReturnsOne() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1, 0, 0, 0, 0};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitcount(key)).isEqualTo(1);\n-  }\n-\n-  @Test\n-  public void bitcount_givenTwoBitsReturnsTwo() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1, 0, 0, 0, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitcount(key)).isEqualTo(2);\n-  }\n-\n-  @Test\n-  public void bitcount_givenEmptyRangeReturnsZero() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1, 0, 0, 0, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitcount(key, 1, 3)).isEqualTo(0);\n-  }\n-\n-  @Test\n-  public void bitcount_correctForAllByteValues() {\n-    byte[] key = {1, 2, 3};\n-    byte[] value = {0};\n-    for (int b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n-      value[0] = (byte) b;\n-      jedis.set(key, value);\n-      assertThat(jedis.bitcount(key)).as(\"b=\" + b).isEqualTo(Integer.bitCount(0xFF & b));\n-    }\n-  }\n-\n-  @Test\n-  public void bitpos_givenSetFails() {\n-    jedis.sadd(\"key\", \"m1\");\n-    assertThatThrownBy(() -> jedis.bitpos(\"key\", false)).hasMessageContaining(\"WRONGTYPE\");\n-    assertThatThrownBy(() -> jedis.bitpos(\"key\", true)).hasMessageContaining(\"WRONGTYPE\");\n-  }\n-\n-  @Test\n-  public void bitpos_givenNonExistentKeyReturnsExpectedValue() {\n-    assertThat(jedis.bitpos(\"does not exist\", false)).isEqualTo(0);\n-    assertThat(jedis.bitpos(\"does not exist\", true)).isEqualTo(-1);\n-    assertThat(jedis.bitpos(\"does not exist\", false, new BitPosParams(4, 7))).isEqualTo(0);\n-    assertThat(jedis.bitpos(\"does not exist\", true, new BitPosParams(4, 7))).isEqualTo(-1);\n-    assertThat(jedis.exists(\"does not exist\")).isFalse();\n-  }\n-\n-  @Test\n-  public void bitcount_givenBitInFirstByte() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1, 1, 1, 1, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitpos(key, true)).isEqualTo(7);\n-  }\n-\n-  @Test\n-  public void bitcount_givenOneInSecondByte() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {0, 1, 1, 1, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitpos(key, true)).isEqualTo(7 + 8);\n-  }\n-\n-  @Test\n-  public void bitcountFalse_givenBitInFirstByte() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {-2, 1, 1, 1, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitpos(key, false)).isEqualTo(7);\n-  }\n-\n-  @Test\n-  public void bitcountFalse_givenOneInSecondByte() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {-1, -2, 1, 1, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitpos(key, false)).isEqualTo(7 + 8);\n-  }\n-\n-  @Test\n-  public void bitcountWithStart_givenOneInLastByte() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1, 1, 1, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitpos(key, true, new BitPosParams(-1))).isEqualTo(7 + 3 * 8);\n-  }\n-\n-  @Test\n-  public void bitcountWithStartAndEnd_givenNoBits() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1, 0, 0, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitpos(key, true, new BitPosParams(1, 2))).isEqualTo(-1);\n-  }\n-\n-\n-  @Test\n-  public void getbit_givenSetFails() {\n-    jedis.sadd(\"key\", \"m1\");\n-    assertThatThrownBy(() -> jedis.getbit(\"key\", 1)).hasMessageContaining(\"WRONGTYPE\");\n-  }\n-\n-  @Test\n-  public void getbit_givenNonExistentKeyReturnsFalse() {\n-    assertThat(jedis.getbit(\"does not exist\", 1)).isFalse();\n-    assertThat(jedis.exists(\"does not exist\")).isFalse();\n-  }\n-\n-  @Test\n-  public void getbit_givenNoBitsReturnsFalse() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {0};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.getbit(key, 1)).isFalse();\n-  }\n-\n-  @Test\n-  public void getbit_givenOneBitReturnsTrue() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {0, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.getbit(key, 8 + 7)).isTrue();\n-  }\n-\n-  @Test\n-  public void getbit_pastEndReturnsFalse() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {0, 1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.getbit(key, 8 + 8 + 7)).isFalse();\n-  }\n-\n-  @Test\n-  public void setbit_givenSetFails() {\n-    jedis.sadd(\"key\", \"m1\");\n-    assertThatThrownBy(() -> jedis.setbit(\"key\", 1, true)).hasMessageContaining(\"WRONGTYPE\");\n-  }\n-\n-  @Test\n-  public void setbit_givenNonExistentKeyCreatesString() {\n-    assertThat(jedis.setbit(\"newKey\", 1, true)).isFalse();\n-    assertThat(jedis.exists(\"newKey\")).isTrue();\n-    assertThat(jedis.type(\"newKey\")).isEqualTo(\"string\");\n-    assertThat(jedis.getbit(\"newKey\", 1)).isTrue();\n-  }\n-\n-  @Test\n-  public void setbit_canSetOneBit() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {0};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.setbit(key, 1, true)).isFalse();\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 0x40);\n-  }\n-\n-  @Test\n-  public void setbit_canSetOneBitAlreadySet() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.setbit(key, 7, true)).isTrue();\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 1);\n-  }\n-\n-  @Test\n-  public void setbit_canSetOneBitPastEnd() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {0};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.setbit(key, 1 + 8, true)).isFalse();\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 0);\n-    assertThat(newbytes[1]).isEqualTo((byte) 0x40);\n-  }\n-\n-  @Test\n-  public void bitop_givenSetFails() {\n-    jedis.sadd(\"foo\", \"m1\");\n-    assertThatThrownBy(() -> jedis.bitop(BitOP.AND, \"key\", \"foo\"))\n-        .hasMessageContaining(\"WRONGTYPE\");\n-    assertThatThrownBy(() -> jedis.bitop(BitOP.OR, \"key\", \"foo\")).hasMessageContaining(\"WRONGTYPE\");\n-    assertThatThrownBy(() -> jedis.bitop(BitOP.XOR, \"key\", \"foo\"))\n-        .hasMessageContaining(\"WRONGTYPE\");\n-    assertThatThrownBy(() -> jedis.bitop(BitOP.NOT, \"key\", \"foo\"))\n-        .hasMessageContaining(\"WRONGTYPE\");\n-  }\n-\n-  @Test\n-  public void bitopNOT_givenNothingLeavesKeyUnset() {\n-    assertThat(jedis.bitop(BitOP.NOT, \"key\", \"foo\")).isEqualTo(0);\n-    assertThat(jedis.exists(\"key\")).isFalse();\n-  }\n-\n-  @Test\n-  public void bitopNOT_givenNothingDeletesKey() {\n-    jedis.set(\"key\", \"value\");\n-    assertThat(jedis.bitop(BitOP.NOT, \"key\", \"foo\")).isEqualTo(0);\n-    assertThat(jedis.exists(\"key\")).isFalse();\n-  }\n-\n-  @Test\n-  public void bitopNOT_givenNothingDeletesSet() {\n-    jedis.sadd(\"key\", \"value\");\n-    assertThat(jedis.bitop(BitOP.NOT, \"key\", \"foo\")).isEqualTo(0);\n-    assertThat(jedis.exists(\"key\")).isFalse();\n-  }\n-\n-  @Test\n-  public void bitopNOT_givenEmptyStringDeletesKey() {\n-    jedis.set(\"key\", \"value\");\n-    jedis.set(\"foo\", \"\");\n-    assertThat(jedis.bitop(BitOP.NOT, \"key\", \"foo\")).isEqualTo(0);\n-    assertThat(jedis.exists(\"key\")).isFalse();\n-  }\n-\n-  @Test\n-  public void bitopNOT_givenEmptyStringDeletesSet() {\n-    jedis.sadd(\"key\", \"value\");\n-    jedis.set(\"foo\", \"\");\n-    assertThat(jedis.bitop(BitOP.NOT, \"key\", \"foo\")).isEqualTo(0);\n-    assertThat(jedis.exists(\"key\")).isFalse();\n-  }\n-\n-  @Test\n-  public void bitopNOT_negatesSelf() {\n-    byte[] key = {1, 2, 3};\n-    byte[] bytes = {1};\n-    jedis.set(key, bytes);\n-    assertThat(jedis.bitop(BitOP.NOT, key, key)).isEqualTo(1);\n-    assertThat(jedis.strlen(key)).isEqualTo(1);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 0xFE);\n-  }\n-\n-  @Test\n-  public void bitopNOT_createsNonExistingKey() {\n-    byte[] key = {1};\n-    byte[] other = {2};\n-    byte[] bytes = {1};\n-    jedis.set(other, bytes);\n-    assertThat(jedis.bitop(BitOP.NOT, key, other)).isEqualTo(1);\n-    assertThat(jedis.strlen(key)).isEqualTo(1);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 0xFE);\n-  }\n-\n-  @Test\n-  public void bitopAND_givenSelfAndOther() {\n-    byte[] key = {1};\n-    byte[] other = {2};\n-    byte[] bytes = {1};\n-    byte[] otherBytes = {-1};\n-    jedis.set(key, bytes);\n-    jedis.set(other, otherBytes);\n-    assertThat(jedis.bitop(BitOP.AND, key, key, other)).isEqualTo(1);\n-    assertThat(jedis.strlen(key)).isEqualTo(1);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 1);\n-  }\n-\n-  @Test\n-  public void bitopAND_givenSelfAndLongerOther() {\n-    byte[] key = {1};\n-    byte[] other = {2};\n-    byte[] bytes = {1};\n-    byte[] otherBytes = {-1, 3};\n-    jedis.set(key, bytes);\n-    jedis.set(other, otherBytes);\n-    assertThat(jedis.bitop(BitOP.AND, key, key, other)).isEqualTo(2);\n-    assertThat(jedis.strlen(key)).isEqualTo(2);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 1);\n-    assertThat(newbytes[1]).isEqualTo((byte) 0);\n-  }\n-\n-  @Test\n-  public void bitopOR_givenSelfAndOther() {\n-    byte[] key = {1};\n-    byte[] other = {2};\n-    byte[] bytes = {1};\n-    byte[] otherBytes = {8};\n-    jedis.set(key, bytes);\n-    jedis.set(other, otherBytes);\n-    assertThat(jedis.bitop(BitOP.OR, key, key, other)).isEqualTo(1);\n-    assertThat(jedis.strlen(key)).isEqualTo(1);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 9);\n-  }\n-\n-  @Test\n-  public void bitopOR_givenSelfAndLongerOther() {\n-    byte[] key = {1};\n-    byte[] other = {2};\n-    byte[] bytes = {1};\n-    byte[] otherBytes = {-1, 3};\n-    jedis.set(key, bytes);\n-    jedis.set(other, otherBytes);\n-    assertThat(jedis.bitop(BitOP.OR, key, key, other)).isEqualTo(2);\n-    assertThat(jedis.strlen(key)).isEqualTo(2);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) -1);\n-    assertThat(newbytes[1]).isEqualTo((byte) 3);\n-  }\n-\n-  @Test\n-  public void bitopXOR_givenSelfAndOther() {\n-    byte[] key = {1};\n-    byte[] other = {2};\n-    byte[] bytes = {9};\n-    byte[] otherBytes = {8};\n-    jedis.set(key, bytes);\n-    jedis.set(other, otherBytes);\n-    assertThat(jedis.bitop(BitOP.XOR, key, key, other)).isEqualTo(1);\n-    assertThat(jedis.strlen(key)).isEqualTo(1);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 1);\n-  }\n-\n-  @Test\n-  public void bitopXOR_givenSelfAndLongerOther() {\n-    byte[] key = {1};\n-    byte[] other = {2};\n-    byte[] bytes = {1};\n-    byte[] otherBytes = {-1, 3};\n-    jedis.set(key, bytes);\n-    jedis.set(other, otherBytes);\n-    assertThat(jedis.bitop(BitOP.XOR, key, key, other)).isEqualTo(2);\n-    assertThat(jedis.strlen(key)).isEqualTo(2);\n-    byte[] newbytes = jedis.get(key);\n-    assertThat(newbytes[0]).isEqualTo((byte) 0xFE);\n-    assertThat(newbytes[1]).isEqualTo((byte) 3);\n-  }\n-\n-\n-  @Test\n-  public void testGetSet_updatesKeyWithNewValue_returnsOldValue() {\n-    String key = randString();\n-    String contents = randString();\n-    jedis.set(key, contents);\n-\n-    String newContents = randString();\n-    String oldContents = jedis.getSet(key, newContents);\n-    assertThat(oldContents).isEqualTo(contents);\n-\n-    contents = newContents;\n-    newContents = jedis.get(key);\n-    assertThat(newContents).isEqualTo(contents);\n-  }\n-\n-  @Test\n-  public void testGetSet_setsNonexistentKeyToNewValue_returnsNull() {\n-    String key = randString();\n-    String newContents = randString();\n-\n-    String oldContents = jedis.getSet(key, newContents);\n-    assertThat(oldContents).isNull();\n-\n-    String contents = jedis.get(key);\n-    assertThat(newContents).isEqualTo(contents);\n-  }\n-\n-  @Test\n-  public void testGetSet_shouldWorkWith_INCR_Command() {\n-    String key = \"key\";\n-    Long resultLong;\n-    String resultString;\n-\n-    jedis.set(key, \"0\");\n-\n-    resultLong = jedis.incr(key);\n-    assertThat(resultLong).isEqualTo(1);\n-\n-    resultString = jedis.getSet(key, \"0\");\n-    assertThat(parseInt(resultString)).isEqualTo(1);\n-\n-    resultString = jedis.get(key);\n-    assertThat(parseInt(resultString)).isEqualTo(0);\n-\n-    resultLong = jedis.incr(key);\n-    assertThat(resultLong).isEqualTo(1);\n-  }\n-\n-  @Test\n-  public void testGetSet_whenWrongType_shouldReturnError() {\n-    String key = \"key\";\n-    jedis.hset(key, \"field\", \"some hash value\");\n-\n-    assertThatThrownBy(() -> jedis.getSet(key, \"this value doesn't matter\"))\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(RedisConstants.ERROR_WRONG_TYPE);\n-  }\n-\n-  @Test\n-  public void testGetSet_shouldBeAtomic()\n-      throws ExecutionException, InterruptedException, TimeoutException {\n-    jedis.set(\"contestedKey\", \"0\");\n-    assertThat(jedis.get(\"contestedKey\")).isEqualTo(\"0\");\n-    CountDownLatch latch = new CountDownLatch(1);\n-    ExecutorService pool = Executors.newFixedThreadPool(2);\n-    Callable<Integer> callable1 = () -> doABunchOfIncrs(jedis, latch);\n-    Callable<Integer> callable2 = () -> doABunchOfGetSets(jedis2, latch);\n-    Future<Integer> future1 = pool.submit(callable1);\n-    Future<Integer> future2 = pool.submit(callable2);\n-\n-    latch.countDown();\n-\n-    GeodeAwaitility.await().untilAsserted(() -> assertThat(future2.get()).isEqualTo(future1.get()));\n-    assertThat(future1.get() + future2.get()).isEqualTo(2 * ITERATION_COUNT);\n-  }\n-\n-  private Integer doABunchOfIncrs(Jedis jedis, CountDownLatch latch) throws InterruptedException {\n-    latch.await();\n-    for (int i = 0; i < ITERATION_COUNT; i++) {\n-      jedis.incr(\"contestedKey\");\n-    }\n-    return ITERATION_COUNT;\n-  }\n-\n-  private Integer doABunchOfGetSets(Jedis jedis, CountDownLatch latch) throws InterruptedException {\n-    int sum = 0;\n-    latch.await();\n-\n-    while (sum < ITERATION_COUNT) {\n-      sum += Integer.parseInt(jedis.getSet(\"contestedKey\", \"0\"));\n-    }\n-    return sum;\n-  }\n-\n-  @Test\n-  public void testDel_deletingOneKey_removesKeyAndReturnsOne() {\n-    String key1 = \"firstKey\";\n-    jedis.set(key1, randString());\n-\n-    Long deletedCount = jedis.del(key1);\n-\n-    assertThat(deletedCount).isEqualTo(1L);\n-    assertThat(jedis.get(key1)).isNull();\n-  }\n-\n-  @Test\n-  public void testDel_deletingNonexistentKey_returnsZero() {\n-    assertThat(jedis.del(\"ceci nest pas un clavier\")).isEqualTo(0L);\n-  }\n-\n-  @Test\n-  public void testDel_deletingMultipleKeys_returnsCountOfOnlyDeletedKeys() {\n-    String key1 = \"firstKey\";\n-    String key2 = \"secondKey\";\n-    String key3 = \"thirdKey\";\n-\n-    jedis.set(key1, randString());\n-    jedis.set(key2, randString());\n-\n-    assertThat(jedis.del(key1, key2, key3)).isEqualTo(2L);\n-    assertThat(jedis.get(key1)).isNull();\n-    assertThat(jedis.get(key2)).isNull();\n-  }\n-\n-  @Test\n-  public void testMSetAndMGet_forHappyPath_setsKeysAndReturnsCorrectValues() {\n-    int keyCount = 5;\n-    String[] keyvals = new String[(keyCount * 2)];\n-    String[] keys = new String[keyCount];\n-    String[] vals = new String[keyCount];\n-    for (int i = 0; i < keyCount; i++) {\n-      String key = randString();\n-      String val = randString();\n-      keyvals[2 * i] = key;\n-      keyvals[2 * i + 1] = val;\n-      keys[i] = key;\n-      vals[i] = val;\n-    }\n-\n-    String resultString = jedis.mset(keyvals);\n-    assertThat(resultString).isEqualTo(\"OK\");\n-\n-    List<String> ret = jedis.mget(keys);\n-    Object[] retArray = ret.toArray();\n-\n-    assertThat(Arrays.equals(vals, retArray)).isTrue();\n-  }\n-\n-  @Test\n-  public void testMGet_requestNonexistentKey_respondsWithNil() {\n-    String key1 = \"existingKey\";\n-    String key2 = \"notReallyAKey\";\n-    String value1 = \"theRealValue\";\n-    String[] keys = new String[2];\n-    String[] expectedVals = new String[2];\n-    keys[0] = key1;\n-    keys[1] = key2;\n-    expectedVals[0] = value1;\n-    expectedVals[1] = null;\n-\n-    jedis.set(key1, value1);\n-\n-    List<String> ret = jedis.mget(keys);\n-    Object[] retArray = ret.toArray();\n-\n-    assertThat(Arrays.equals(expectedVals, retArray)).isTrue();\n-  }\n-\n-  @Test\n-  @Ignore(\"GEODE-8192\")\n-  public void testMSet_concurrentInstances_mustBeAtomic()\n-      throws InterruptedException, ExecutionException {\n-    String keyBaseName = \"MSETBASE\";\n-    String val1BaseName = \"FIRSTVALBASE\";\n-    String val2BaseName = \"SECONDVALBASE\";\n-    String[] keysAndVals1 = new String[(ITERATION_COUNT * 2)];\n-    String[] keysAndVals2 = new String[(ITERATION_COUNT * 2)];\n-    String[] keys = new String[ITERATION_COUNT];\n-    String[] vals1 = new String[ITERATION_COUNT];\n-    String[] vals2 = new String[ITERATION_COUNT];\n-    String[] expectedVals;\n-\n-    SetUpArraysForConcurrentMSet(keyBaseName,\n-        val1BaseName, val2BaseName,\n-        keysAndVals1, keysAndVals2,\n-        keys,\n-        vals1, vals2);\n-\n-    RunTwoMSetsInParallelThreadsAndVerifyReturnValue(keysAndVals1, keysAndVals2);\n-\n-    List<String> actualVals = jedis.mget(keys);\n-    expectedVals = DetermineWhichMSetWonTheRace(vals1, vals2, actualVals);\n-\n-    assertThat(actualVals.toArray(new String[] {})).contains(expectedVals);\n-  }\n-\n-  private void SetUpArraysForConcurrentMSet(String keyBaseName, String val1BaseName,\n-      String val2BaseName, String[] keysAndVals1,\n-      String[] keysAndVals2, String[] keys, String[] vals1,\n-      String[] vals2) {\n-    for (int i = 0; i < ITERATION_COUNT; i++) {\n-      String key = keyBaseName + i;\n-      String value1 = val1BaseName + i;\n-      String value2 = val2BaseName + i;\n-      keysAndVals1[2 * i] = key;\n-      keysAndVals1[2 * i + 1] = value1;\n-      keysAndVals2[2 * i] = key;\n-      keysAndVals2[2 * i + 1] = value2;\n-      keys[i] = key;\n-      vals1[i] = value1;\n-      vals2[i] = value2;\n-    }\n-  }\n-\n-  private void RunTwoMSetsInParallelThreadsAndVerifyReturnValue(String[] keysAndVals1,\n-      String[] keysAndVals2)\n-      throws InterruptedException, ExecutionException {\n-    CountDownLatch latch = new CountDownLatch(1);\n-    ExecutorService pool = Executors.newFixedThreadPool(2);\n-    Callable<String> callable1 = () -> jedis.mset(keysAndVals1);\n-    Callable<String> callable2 = () -> jedis2.mset(keysAndVals2);\n-    Future<String> future1 = pool.submit(callable1);\n-    Future<String> future2 = pool.submit(callable2);\n-\n-    latch.countDown();\n-\n-    assertThat(future1.get()).isEqualTo(\"OK\");\n-    assertThat(future2.get()).isEqualTo(\"OK\");\n-  }\n-\n-  private String[] DetermineWhichMSetWonTheRace(String[] vals1, String[] vals2,\n-      List<String> actualVals) {\n-    String[] expectedVals;\n-    if (actualVals.get(0).equals(\"FIRSTVALBASE0\")) {\n-      expectedVals = vals1;\n-    } else {\n-      expectedVals = vals2;\n-    }\n-    return expectedVals;\n-  }\n-\n-  @Test\n-  public void testConcurrentDel_differentClients() {\n-    String keyBaseName = \"DELBASE\";\n-\n-    new ConcurrentLoopingThreads(\n-        ITERATION_COUNT,\n-        (i) -> jedis.set(keyBaseName + i, \"value\" + i))\n-            .run();\n-\n-    AtomicLong deletedCount = new AtomicLong();\n-    new ConcurrentLoopingThreads(ITERATION_COUNT,\n-        (i) -> deletedCount.addAndGet(jedis.del(keyBaseName + i)),\n-        (i) -> deletedCount.addAndGet(jedis2.del(keyBaseName + i)))\n-            .run();\n-\n-\n-    assertThat(deletedCount.get()).isEqualTo(ITERATION_COUNT);\n-\n-    for (int i = 0; i < ITERATION_COUNT; i++) {\n-      assertThat(jedis.get(keyBaseName + i)).isNull();\n-    }\n-\n-  }\n-\n-  @Test\n-  public void testMSetNX() {\n-    Set<String> keysAndVals = new HashSet<String>();\n-    for (int i = 0; i < 2 * 5; i++) {\n-      keysAndVals.add(randString());\n-    }\n-    String[] keysAndValsArray = keysAndVals.toArray(new String[0]);\n-    long response = jedis.msetnx(keysAndValsArray);\n-\n-    assertThat(response).isEqualTo(1);\n-\n-    long response2 = jedis.msetnx(keysAndValsArray[0], randString());\n-\n-    assertThat(response2).isEqualTo(0);\n-    assertThat(keysAndValsArray[1]).isEqualTo(jedis.get(keysAndValsArray[0]));\n-  }\n-\n-  @Test\n-  public void testDecr() {\n-    String oneHundredKey = randString();\n-    String negativeOneHundredKey = randString();\n-    String unsetKey = randString();\n-    final int oneHundredValue = 100;\n-    final int negativeOneHundredValue = -100;\n-    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n-    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n-\n-    jedis.decr(oneHundredKey);\n-    jedis.decr(negativeOneHundredKey);\n-    jedis.decr(unsetKey);\n-\n-    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue - 1));\n-    assertThat(jedis.get(negativeOneHundredKey))\n-        .isEqualTo(Integer.toString(negativeOneHundredValue - 1));\n-    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(-1));\n-  }\n-\n-  @Test\n-  public void testDecr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n-    jedis.set(\"contestedKey\", \"0\");\n-\n-    new ConcurrentLoopingThreads(\n-        ITERATION_COUNT,\n-        (i) -> jedis.decr(\"contestedKey\"),\n-        (i) -> jedis2.decr(\"contestedKey\"))\n-            .run();\n-\n-    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(-2 * ITERATION_COUNT));\n-  }\n-\n-  @Test\n-  public void testIncr() {\n-    String oneHundredKey = randString();\n-    String negativeOneHundredKey = randString();\n-    String unsetKey = randString();\n-    final int oneHundredValue = 100;\n-    final int negativeOneHundredValue = -100;\n-    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n-    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n-\n-    jedis.incr(oneHundredKey);\n-    jedis.incr(negativeOneHundredKey);\n-    jedis.incr(unsetKey);\n-\n-    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue + 1));\n-    assertThat(jedis.get(negativeOneHundredKey))\n-        .isEqualTo(Integer.toString(negativeOneHundredValue + 1));\n-    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(1));\n-  }\n-\n-  @Test\n-  public void testIncr_whenOverflow_shouldReturnError() {\n-    String key = \"key\";\n-    String max64BitIntegerValue = \"9223372036854775807\";\n-    jedis.set(key, max64BitIntegerValue);\n-\n-    try {\n-      jedis.incr(key);\n-    } catch (JedisDataException e) {\n-      assertThat(e.getMessage()).contains(RedisConstants.ERROR_OVERFLOW);\n-    }\n-    assertThat(jedis.get(key)).isEqualTo(max64BitIntegerValue);\n-  }\n-\n-  @Test\n-  public void testIncr_whenWrongType_shouldReturnError() {\n-    String key = \"key\";\n-    String nonIntegerValue = \"I am not a number! I am a free man!\";\n-    assertThat(jedis.set(key, nonIntegerValue)).isEqualTo(\"OK\");\n-\n-    try {\n-      jedis.incr(key);\n-    } catch (JedisDataException e) {\n-      assertThat(e.getMessage()).contains(RedisConstants.ERROR_NOT_INTEGER);\n-    }\n-    assertThat(jedis.get(key)).isEqualTo(nonIntegerValue);\n-  }\n-\n-  @Test\n-  public void testIncr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n-    jedis.set(\"contestedKey\", \"0\");\n-\n-    new ConcurrentLoopingThreads(\n-        ITERATION_COUNT,\n-        (i) -> jedis.incr(\"contestedKey\"),\n-        (i) -> jedis2.incr(\"contestedKey\"))\n-            .run();\n-\n-    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(2 * ITERATION_COUNT));\n-  }\n-\n-  @Test\n-  public void testDecrBy() {\n-    String key1 = randString();\n-    String key2 = randString();\n-    String key3 = randString();\n-    int decr1 = rand.nextInt(100);\n-    int decr2 = rand.nextInt(100);\n-    Long decr3 = Long.MAX_VALUE / 2;\n-    int num1 = 100;\n-    int num2 = -100;\n-    jedis.set(key1, \"\" + num1);\n-    jedis.set(key2, \"\" + num2);\n-    jedis.set(key3, \"\" + Long.MIN_VALUE);\n-\n-    jedis.decrBy(key1, decr1);\n-    jedis.decrBy(key2, decr2);\n-\n-    assertThat(jedis.get(key1)).isEqualTo(\"\" + (num1 - decr1 * 1));\n-    assertThat(jedis.get(key2)).isEqualTo(\"\" + (num2 - decr2 * 1));\n-\n-    Exception ex = null;\n-    try {\n-      jedis.decrBy(key3, decr3);\n-    } catch (Exception e) {\n-      ex = e;\n-    }\n-    assertThat(ex).isNotNull();\n-\n-  }\n-\n-  @Test\n-  public void testSetNX() {\n-    String key1 = randString();\n-    String key2;\n-    do {\n-      key2 = randString();\n-    } while (key2.equals(key1));\n-\n-    long response1 = jedis.setnx(key1, key1);\n-    long response2 = jedis.setnx(key2, key2);\n-    long response3 = jedis.setnx(key1, key2);\n-\n-    assertThat(response1).isEqualTo(1);\n-    assertThat(response2).isEqualTo(1);\n-    assertThat(response3).isEqualTo(0);\n-  }\n-\n-  @Test\n-  public void testIncrBy() {\n-    String key1 = randString();\n-    String key2 = randString();\n-    String key3 = randString();\n-    int incr1 = rand.nextInt(100);\n-    int incr2 = rand.nextInt(100);\n-    Long incr3 = Long.MAX_VALUE / 2;\n-    int num1 = 100;\n-    int num2 = -100;\n-    jedis.set(key1, \"\" + num1);\n-    jedis.set(key2, \"\" + num2);\n-    jedis.set(key3, \"\" + Long.MAX_VALUE);\n-\n-    jedis.incrBy(key1, incr1);\n-    jedis.incrBy(key2, incr2);\n-    assertThat(jedis.get(key1)).isEqualTo(\"\" + (num1 + incr1 * 1));\n-    assertThat(jedis.get(key2)).isEqualTo(\"\" + (num2 + incr2 * 1));\n-\n-    Exception ex = null;\n-    try {\n-      jedis.incrBy(key3, incr3);\n-    } catch (Exception e) {\n-      ex = e;\n-    }\n-    assertThat(ex).isNotNull();\n-  }\n-\n-  @Test\n-  public void testIncrByFloat() {\n-    String key1 = randString();\n-    String key2 = randString();\n-    double incr1 = rand.nextInt(100);\n-    double incr2 = rand.nextInt(100);\n-    double num1 = 100;\n-    double num2 = -100;\n-    jedis.set(key1, \"\" + num1);\n-    jedis.set(key2, \"\" + num2);\n-\n-    jedis.incrByFloat(key1, incr1);\n-    jedis.incrByFloat(key2, incr2);\n-    assertThat(Double.valueOf(jedis.get(key1))).isEqualTo(num1 + incr1);\n-    assertThat(Double.valueOf(jedis.get(key2))).isEqualTo(num2 + incr2);\n-  }\n-\n-  @Test\n-  public void testPAndSetex() {\n-    Random r = new Random();\n-    int setex = r.nextInt(5);\n-    if (setex == 0) {\n-      setex = 1;\n-    }\n-    String key = randString();\n-    jedis.setex(key, setex, randString());\n-    try {\n-      Thread.sleep((setex + 5) * 1000);\n-    } catch (InterruptedException e) {\n-      return;\n-    }\n-    String result = jedis.get(key);\n-    assertThat(result).isNull();\n-\n-    int psetex = r.nextInt(5000);\n-    if (psetex == 0) {\n-      psetex = 1;\n-    }\n-    key = randString();\n-    jedis.psetex(key, psetex, randString());\n-    long start = System.currentTimeMillis();\n-    try {\n-      Thread.sleep(psetex + 5000);\n-    } catch (InterruptedException e) {\n-      return;\n-    }\n-    long stop = System.currentTimeMillis();\n-    result = jedis.get(key);\n-    assertThat(stop - start).isGreaterThanOrEqualTo(psetex);\n-    assertThat(result).isNull();\n-  }\n-\n-  @Test\n-  public void testStrlen_requestNonexistentKey_returnsZero() {\n-    Long result = jedis.strlen(\"Nohbdy\");\n-    assertThat(result).isEqualTo(0);\n-  }\n-\n-  @Test\n-  public void testStrlen_requestKey_returnsLengthOfStringValue() {\n-    String value = \"byGoogle\";\n-\n-    jedis.set(\"golang\", value);\n-\n-    Long result = jedis.strlen(\"golang\");\n-    assertThat(result).isEqualTo(value.length());\n-  }\n-\n-  @Test\n-  public void testStrlen_requestWrongType_shouldReturnError() {\n-    String key = \"hashKey\";\n-    jedis.hset(key, \"field\", \"this value doesn't matter\");\n-\n-    assertThatThrownBy(() -> jedis.strlen(key))\n-        .isInstanceOf(JedisDataException.class)\n-        .hasMessageContaining(RedisConstants.ERROR_WRONG_TYPE);\n-  }\n-\n-  private String randString() {\n-    return Long.toHexString(Double.doubleToLongBits(Math.random()));\n-  }\n-\n-  private List<String> makeStringList(int setSize, String baseString) {\n-    List<String> strings = new ArrayList<>();\n-    for (int i = 0; i < setSize; i++) {\n-      strings.add(baseString + i);\n-    }\n-    return strings;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjg0NA==", "url": "https://github.com/apache/geode/pull/5216#discussion_r445112844", "bodyText": "I'm not sure these tests should be added here. If you added them instead to SetIntegrationTest then I'd feel better because they would also run against native redis.", "author": "dschneider-pivotal", "createdAt": "2020-06-24T19:11:55Z", "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java", "diffHunk": "@@ -213,4 +229,34 @@ public void testSET_XXandNX_inSameCommand_ReturnsError() {\n     assertThat(response.toString()).contains(RedisConstants.ERROR_SYNTAX);\n   }\n \n+  @Test\n+  public void testSET_unknownOption_ReturnsError() {", "originalCommit": "2026a5f7bab748cc1f4daef606276ff2e868f206", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwNDQ3Mw==", "url": "https://github.com/apache/geode/pull/5216#discussion_r445204473", "bodyText": "done.  (1 test deleted instead of  moved as the same basic test already existed in SetIntegrationTest )", "author": "jhutchison", "createdAt": "2020-06-24T22:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwNDY5Ng==", "url": "https://github.com/apache/geode/pull/5216#discussion_r445204696", "bodyText": "done", "author": "jhutchison", "createdAt": "2020-06-24T22:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjg0NA=="}], "type": "inlineReview", "revised_code": {"commit": "6962ca222c835a6d59fafc9d6447c19d35f22fd6", "chunk": "diff --git a/geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java b/geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java\nindex dc91e3f97e..c9fb251710 100644\n--- a/geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java\n+++ b/geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java\n\n@@ -229,34 +229,5 @@ public class StringSetExecutorJUnitTest {\n     assertThat(response.toString()).contains(RedisConstants.ERROR_SYNTAX);\n   }\n \n-  @Test\n-  public void testSET_unknownOption_ReturnsError() {\n-    List<byte[]> commandArgumentWithUnknownParameter = Arrays.asList(\n-        \"SET\".getBytes(),\n-        \"key\".getBytes(),\n-        \"value\".getBytes(),\n-        \"blah\".getBytes());\n-\n-    Command command = new Command(commandArgumentWithUnknownParameter);\n-    RedisResponse response = executor.executeCommand(command, context);\n-\n-    assertThat(response.toString())\n-        .contains(RedisConstants.ERROR_SYNTAX);\n-  }\n-\n-  @Test\n-  public void testSET_numberInUnexpectedPosition_ReturnsError() {\n-    List<byte[]> commandArgumentWithUnknownParameter = Arrays.asList(\n-        \"SET\".getBytes(),\n-        \"key\".getBytes(),\n-        \"value\".getBytes(),\n-        \"30\".getBytes());\n-\n-    Command command = new Command(commandArgumentWithUnknownParameter);\n-    RedisResponse response = executor.executeCommand(command, context);\n-\n-    assertThat(response.toString())\n-        .contains(RedisConstants.ERROR_SYNTAX);\n-  }\n \n }\n"}}, {"oid": "6962ca222c835a6d59fafc9d6447c19d35f22fd6", "url": "https://github.com/apache/geode/commit/6962ca222c835a6d59fafc9d6447c19d35f22fd6", "message": "tests moved to strings/setintegrationTest", "committedDate": "2020-06-24T22:21:12Z", "type": "forcePushed"}, {"oid": "f8913ed3e490b59eea20be630539fae9335800e8", "url": "https://github.com/apache/geode/commit/f8913ed3e490b59eea20be630539fae9335800e8", "message": "refactor SetExecutor", "committedDate": "2020-06-25T18:23:52Z", "type": "commit"}, {"oid": "5914019b99d1a9239d8ffa9d13bcb38f69506b59", "url": "https://github.com/apache/geode/commit/5914019b99d1a9239d8ffa9d13bcb38f69506b59", "message": "add additional changes in setExecutor suggested in review", "committedDate": "2020-06-25T18:23:52Z", "type": "commit"}, {"oid": "5521fe07c537e6f8db39022e32938018a9a3ef53", "url": "https://github.com/apache/geode/commit/5521fe07c537e6f8db39022e32938018a9a3ef53", "message": "correct merge error", "committedDate": "2020-06-25T18:23:52Z", "type": "commit"}, {"oid": "49e7f7a9de0faab173d2dff96c35e5572be5ff8a", "url": "https://github.com/apache/geode/commit/49e7f7a9de0faab173d2dff96c35e5572be5ff8a", "message": "resolve merge conflict", "committedDate": "2020-06-25T18:23:52Z", "type": "commit"}, {"oid": "68475af8cc1bf259f66eba377606edbd361ae494", "url": "https://github.com/apache/geode/commit/68475af8cc1bf259f66eba377606edbd361ae494", "message": "add requested test; change code to make test pass", "committedDate": "2020-06-25T18:23:52Z", "type": "commit"}, {"oid": "67830fe248f71923cdfab7c91f6a730ced1e71cc", "url": "https://github.com/apache/geode/commit/67830fe248f71923cdfab7c91f6a730ced1e71cc", "message": "tests moved to strings/setintegrationTest", "committedDate": "2020-06-25T18:23:52Z", "type": "commit"}, {"oid": "d00b08c438a3480e477a09a48774d3a918ad6456", "url": "https://github.com/apache/geode/commit/d00b08c438a3480e477a09a48774d3a918ad6456", "message": "retrigger ci after unrelated flaky test failure", "committedDate": "2020-06-25T18:24:36Z", "type": "commit"}, {"oid": "d00b08c438a3480e477a09a48774d3a918ad6456", "url": "https://github.com/apache/geode/commit/d00b08c438a3480e477a09a48774d3a918ad6456", "message": "retrigger ci after unrelated flaky test failure", "committedDate": "2020-06-25T18:24:36Z", "type": "forcePushed"}]}