{"pr_number": 2709, "pr_title": "HBASE-25307 ThreadLocal pooling leads to NullPointerException (#2685)", "pr_createdAt": "2020-11-25T16:11:47Z", "pr_url": "https://github.com/apache/hbase/pull/2709", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTYwNg==", "url": "https://github.com/apache/hbase/pull/2709#discussion_r530585606", "bodyText": "one important property of the Reusable pool is that things came out of the pool while being used, which essentially ensured a given resource was only ever in use by a single thread at a time (presuming whatever checked the resource out did not make it visible to multiple threads). So under contention we'd have a number of copies of the resource on par with the number of accessors (similar to the ThreadLocal pool) but when the contention passed we wouldn't keep them around.\nI'm trying to see if we made use of this property or not.", "author": "busbey", "createdAt": "2020-11-25T18:58:49Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -270,58 +195,16 @@ public static PoolType fuzzyMatch(String name) {\n \n   protected Pool<V> createPool() {\n     switch (poolType) {\n-    case Reusable:\n-      return new ReusablePool<>(poolMaxSize);\n-    case RoundRobin:\n-      return new RoundRobinPool<>(poolMaxSize);\n-    case ThreadLocal:\n-      return new ThreadLocalPool<>();\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * The <code>ReusablePool</code> represents a {@link PoolMap.Pool} that builds\n-   * on the {@link java.util.LinkedList} class. It essentially allows resources to be\n-   * checked out, at which point it is removed from this pool. When the resource\n-   * is no longer required, it should be returned to the pool in order to be\n-   * reused.\n-   *\n-   * <p>\n-   * If {@link #maxSize} is set to {@link Integer#MAX_VALUE}, then the size of\n-   * the pool is unbounded. Otherwise, it caps the number of consumers that can\n-   * check out a resource from this pool to the (non-zero positive) value\n-   * specified in {@link #maxSize}.\n-   * </p>\n-   *\n-   * @param <R>\n-   *          the type of the resource\n-   */\n-  @SuppressWarnings(\"serial\")\n-  public static class ReusablePool<R> extends ConcurrentLinkedQueue<R> implements Pool<R> {\n-    private int maxSize;\n-\n-    public ReusablePool(int maxSize) {\n-      this.maxSize = maxSize;\n-\n-    }\n-\n-    @Override\n-    public R get() {\n-      return poll();\n-    }\n-\n-    @Override\n-    public R put(R resource) {\n-      if (super.size() < maxSize) {\n-        add(resource);\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Collection<R> values() {\n-      return this;\n+      case Reusable:\n+        /* Reusable pool is the same as a 1 element round robin pool. It returns the same element\n+         * until it is removed. */\n+        return new RoundRobinPool<>(1);", "originalCommit": "508efac6bc4e22c227d15c14a4729cdb465d9d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NDg1OQ==", "url": "https://github.com/apache/hbase/pull/2709#discussion_r530594859", "bodyText": "I'm looking at AbstractRpcClient before this patch and I'm having some trouble connecting the dots on how ReusablePool would behave. it seems fundamentally broken. Let me go look at when this got removed from the master branch.", "author": "busbey", "createdAt": "2020-11-25T19:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwODQwNQ==", "url": "https://github.com/apache/hbase/pull/2709#discussion_r530608405", "bodyText": "I did some digging and I don't think replacing Reusable with RoundRobinPool(1) will get us equivalent behavior. But I also don't think it matters. AFAICT we have had no way to configure a pool to use the Resuable type for branch-2-ish releases since HBase 2.0.0 thanks to HBASE-13201 removing the use that was present in the hbase-thrift module.\nSo I think you should backport HBASE-24827 and then HBASE-24872 to all active branches-2. After that it should be easier to backport the changes here without having to worry about this stuff because the ReusablePool will be gone.", "author": "busbey", "createdAt": "2020-11-25T19:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "6c06f11f6d6b8173b7ba6030473710903d61347a", "chunk": "diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java\nindex ccfd01da56..057cb7e375 100644\n--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java\n+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java\n\n@@ -195,16 +172,12 @@ public class PoolMap<K, V> {\n \n   protected Pool<V> createPool() {\n     switch (poolType) {\n-      case Reusable:\n-        /* Reusable pool is the same as a 1 element round robin pool. It returns the same element\n-         * until it is removed. */\n-        return new RoundRobinPool<>(1);\n-      case RoundRobin:\n-        return new RoundRobinPool<>(poolMaxSize);\n-      case ThreadLocal:\n-        return new ThreadLocalPool<>();\n-      default:\n-        return new RoundRobinPool<>(poolMaxSize);\n+    case RoundRobin:\n+      return new RoundRobinPool<>(poolMaxSize);\n+    case ThreadLocal:\n+      return new ThreadLocalPool<>();\n+    default:\n+      return new RoundRobinPool<>(poolMaxSize);\n     }\n   }\n \n"}}, {"oid": "6c06f11f6d6b8173b7ba6030473710903d61347a", "url": "https://github.com/apache/hbase/commit/6c06f11f6d6b8173b7ba6030473710903d61347a", "message": "HBASE-25307 ThreadLocal pooling leads to NullPointerException (#2685)\n\n* PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\n* PoolMap does not implement Map interface anymore, so ensuring\nthread-safety has become easier. Put method is replaced with getOrCreate().\n* ThreadLocalPool doesn't use ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections().\n\nSigned-off-by: Sean Busbey <busbey@apache.org>\nSigned-off-by: Wellington Chevreuil <wellington.chevreuil@gmail.com>", "committedDate": "2020-11-26T12:06:45Z", "type": "commit"}, {"oid": "6c06f11f6d6b8173b7ba6030473710903d61347a", "url": "https://github.com/apache/hbase/commit/6c06f11f6d6b8173b7ba6030473710903d61347a", "message": "HBASE-25307 ThreadLocal pooling leads to NullPointerException (#2685)\n\n* PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\n* PoolMap does not implement Map interface anymore, so ensuring\nthread-safety has become easier. Put method is replaced with getOrCreate().\n* ThreadLocalPool doesn't use ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections().\n\nSigned-off-by: Sean Busbey <busbey@apache.org>\nSigned-off-by: Wellington Chevreuil <wellington.chevreuil@gmail.com>", "committedDate": "2020-11-26T12:06:45Z", "type": "forcePushed"}]}