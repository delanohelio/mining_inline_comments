{"pr_number": 2021, "pr_title": "HBASE-24665 MultiWAL : Avoid rolling of ALL WALs when one of the WAL needs a roll", "pr_createdAt": "2020-07-06T03:50:32Z", "pr_url": "https://github.com/apache/hbase/pull/2021", "timeline": [{"oid": "d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "url": "https://github.com/apache/hbase/commit/d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "message": "HBASE-24665 all wal of RegionGroupingProvider together roll", "committedDate": "2020-07-06T03:47:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4NjQ0OQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r451686449", "bodyText": "The actual fix is this alone right?", "author": "anoopsjohn", "createdAt": "2020-07-08T16:48:58Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -178,14 +177,17 @@ public void run() {\n         for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n           .hasNext();) {\n           Entry<WAL, Boolean> entry = iter.next();\n+          if (!periodic && !entry.getValue()) {", "originalCommit": "d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 56d6f8534f..409808b36b 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -173,16 +170,16 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n-          if (!periodic && !entry.getValue()) {\n+        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n+          RollController controller = entry.getValue();\n+          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {\n             continue;\n           }\n           WAL wal = entry.getKey();\n           // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          entry.setValue(Boolean.FALSE);\n+          controller.finishRoll();\n           Map<byte[], List<byte[]>> regionsToFlush = null;\n           try {\n             // Force the roll if the logroll.period is elapsed or if a roll was requested.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4ODEyMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r451688123", "bodyText": "Not on this patch directly.\nWe have the periodic WAL roll.. Every WAL should get rolled as per this period.  When one WAL gets rolled, we will change the lastRollTime and so it can happen that some WALs will ever get rolled!\nThis issue will be visible now as we will selectively roll WAL files after this patch.  Actually we need to track the lastRollTime per WAL instance.", "author": "anoopsjohn", "createdAt": "2020-07-08T16:51:34Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,10 +148,9 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n+      boolean periodic = (now - this.lastRollTime) > this.rollPeriod;", "originalCommit": "d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY1ODQzMg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r452658432", "bodyText": "It's like this, I ignored it. Thanks for reminding", "author": "WenFeiYi", "createdAt": "2020-07-10T07:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4ODEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 56d6f8534f..409808b36b 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -150,13 +148,12 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n     while (running) {\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      boolean periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n+      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n         // Time for periodic roll, fall through\n         LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n       } else {\n         synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(Boolean::booleanValue)) {\n+          if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isRequestRoll)) {\n             // WAL roll requested, fall through\n             LOG.debug(\"WAL roll requested\");\n           } else {\n"}}, {"oid": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "url": "https://github.com/apache/hbase/commit/07afe84ba265901552e2938bdc27a1ba5af8fcff", "message": "fix period roll", "committedDate": "2020-07-10T11:01:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE5MDk2OQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453190969", "bodyText": "isRollRequested() can be the better name?", "author": "anoopsjohn", "createdAt": "2020-07-11T12:36:02Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +248,35 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    boolean isRequestRoll;\n+    long lastRollTime;\n+\n+    RollController() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    void finishRoll() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public boolean isRequestRoll() {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -254,29 +250,36 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n    * can avoid all wal roll together. see HBASE-24665 for detail\n    */\n   protected class RollController {\n-    boolean isRequestRoll;\n-    long lastRollTime;\n+    private final WAL wal;\n+    private boolean isRequestRoll;\n+    private long lastRollTime;\n \n-    RollController() {\n+    RollController(WAL wal) {\n+      this.wal = wal;\n       this.isRequestRoll = false;\n       this.lastRollTime = System.currentTimeMillis();\n     }\n \n-    void requestRoll() {\n+    public synchronized void requestRoll() {\n       this.isRequestRoll = true;\n     }\n \n-    void finishRoll() {\n+    public synchronized Map<byte[], List<byte[]>> rollWal(long lastRollTime) throws IOException {\n       this.isRequestRoll = false;\n-      this.lastRollTime = System.currentTimeMillis();\n+      this.lastRollTime = lastRollTime;\n+      return wal.rollWriter(true);\n     }\n \n-    public boolean isRequestRoll() {\n+    public boolean isRollRequested() {\n       return isRequestRoll;\n     }\n \n-    boolean isPeriodRoll(long now) {\n+    public boolean needsPeriodicRoll(long now) {\n       return (now - lastRollTime) > rollPeriod;\n     }\n+\n+    public boolean needsRoll(long now) {\n+      return isRequestRoll || needsPeriodicRoll(now);\n+    }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE5MTIxNw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453191217", "bodyText": "This is exposed for test cases only.  This is a private class.. So its ok to change the return type.  The new RollController gives clear idea whether a wal instance needs roll because of periodic roll or being explicitly asked for. So that is better.\nA return type of Map<WAL, RollController>\nAny way then we dont need synchronized block.  Else, if we have to do as what is being done below in patch, we would need synchronized block", "author": "anoopsjohn", "createdAt": "2020-07-11T12:39:59Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/LogRoller.java", "diffHunk": "@@ -66,6 +67,10 @@ protected void scheduleFlush(String encodedRegionName, List<byte[]> families) {\n \n   @VisibleForTesting\n   Map<WAL, Boolean> getWalNeedsRoll() {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/LogRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/LogRoller.java\nindex e12fd9f935..cbab595517 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/LogRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/LogRoller.java\n\n@@ -66,11 +65,7 @@ public class LogRoller extends AbstractWALRoller<RegionServerServices> {\n   }\n \n   @VisibleForTesting\n-  Map<WAL, Boolean> getWalNeedsRoll() {\n-    Map<WAL, Boolean> walNeedsRoll = new HashMap<>();\n-    for (Map.Entry<WAL, RollController> entry : this.walNeedsRoll.entrySet()) {\n-      walNeedsRoll.put(entry.getKey(), entry.getValue().isRequestRoll());\n-    }\n-    return walNeedsRoll;\n+  Map<WAL, RollController> getWalNeedsRoll() {\n+    return this.wals;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIwNzMwNQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453207305", "bodyText": "We add all WAL instances into this once it is created. We can just call it wals?", "author": "anoopsjohn", "createdAt": "2020-07-11T15:47:01Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,14 +57,13 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> walNeedsRoll = new ConcurrentHashMap<>();", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -57,7 +57,7 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, RollController> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> wals = new ConcurrentHashMap<>();\n   protected final T abortable;\n   // Period to roll log.\n   private final long rollPeriod;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIwNzgyOA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453207828", "bodyText": "A better name ?  needsPeriodicRoll ?", "author": "anoopsjohn", "createdAt": "2020-07-11T15:53:50Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +248,35 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    boolean isRequestRoll;\n+    long lastRollTime;\n+\n+    RollController() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    void finishRoll() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public boolean isRequestRoll() {\n+      return isRequestRoll;\n+    }\n+\n+    boolean isPeriodRoll(long now) {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -254,29 +250,36 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n    * can avoid all wal roll together. see HBASE-24665 for detail\n    */\n   protected class RollController {\n-    boolean isRequestRoll;\n-    long lastRollTime;\n+    private final WAL wal;\n+    private boolean isRequestRoll;\n+    private long lastRollTime;\n \n-    RollController() {\n+    RollController(WAL wal) {\n+      this.wal = wal;\n       this.isRequestRoll = false;\n       this.lastRollTime = System.currentTimeMillis();\n     }\n \n-    void requestRoll() {\n+    public synchronized void requestRoll() {\n       this.isRequestRoll = true;\n     }\n \n-    void finishRoll() {\n+    public synchronized Map<byte[], List<byte[]>> rollWal(long lastRollTime) throws IOException {\n       this.isRequestRoll = false;\n-      this.lastRollTime = System.currentTimeMillis();\n+      this.lastRollTime = lastRollTime;\n+      return wal.rollWriter(true);\n     }\n \n-    public boolean isRequestRoll() {\n+    public boolean isRollRequested() {\n       return isRequestRoll;\n     }\n \n-    boolean isPeriodRoll(long now) {\n+    public boolean needsPeriodicRoll(long now) {\n       return (now - lastRollTime) > rollPeriod;\n     }\n+\n+    public boolean needsRoll(long now) {\n+      return isRequestRoll || needsPeriodicRoll(now);\n+    }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMjEzNA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453212134", "bodyText": "This name is bit confusing. This is not called once roll is finished. We can just call this resetStatus()? Give proper comment that this resets rollReq status as well as lastRollTime. We can pass the ts as param 'lastRollTime' so that this is clear.", "author": "anoopsjohn", "createdAt": "2020-07-11T16:41:33Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +248,35 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    boolean isRequestRoll;\n+    long lastRollTime;\n+\n+    RollController() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    void finishRoll() {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -254,29 +250,36 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n    * can avoid all wal roll together. see HBASE-24665 for detail\n    */\n   protected class RollController {\n-    boolean isRequestRoll;\n-    long lastRollTime;\n+    private final WAL wal;\n+    private boolean isRequestRoll;\n+    private long lastRollTime;\n \n-    RollController() {\n+    RollController(WAL wal) {\n+      this.wal = wal;\n       this.isRequestRoll = false;\n       this.lastRollTime = System.currentTimeMillis();\n     }\n \n-    void requestRoll() {\n+    public synchronized void requestRoll() {\n       this.isRequestRoll = true;\n     }\n \n-    void finishRoll() {\n+    public synchronized Map<byte[], List<byte[]>> rollWal(long lastRollTime) throws IOException {\n       this.isRequestRoll = false;\n-      this.lastRollTime = System.currentTimeMillis();\n+      this.lastRollTime = lastRollTime;\n+      return wal.rollWriter(true);\n     }\n \n-    public boolean isRequestRoll() {\n+    public boolean isRollRequested() {\n       return isRequestRoll;\n     }\n \n-    boolean isPeriodRoll(long now) {\n+    public boolean needsPeriodicRoll(long now) {\n       return (now - lastRollTime) > rollPeriod;\n     }\n+\n+    public boolean needsRoll(long now) {\n+      return isRequestRoll || needsPeriodicRoll(now);\n+    }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMjU2Mw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453212563", "bodyText": "We can have a single method in RollController which says this WAL needs roll?     RollController#needsRoll().", "author": "anoopsjohn", "createdAt": "2020-07-11T16:46:16Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -174,18 +170,21 @@ public void run() {\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n+          RollController controller = entry.getValue();\n+          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -148,43 +148,39 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n     while (running) {\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isRequestRoll)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n              iter.hasNext();) {\n           Entry<WAL, RollController> entry = iter.next();\n+          WAL wal = entry.getKey();\n           RollController controller = entry.getValue();\n-          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {\n+          if (controller.isRollRequested()) {\n+            // WAL roll requested, fall through\n+            LOG.debug(\"WAL {} roll requested\", wal);\n+          } else if (controller.needsPeriodicRoll(now)){\n+            // Time for periodic roll, fall through\n+            LOG.debug(\"WAL {} roll period {} ms elapsed\", wal, this.rollPeriod);\n+          } else {\n             continue;\n           }\n-          WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          controller.finishRoll();\n           Map<byte[], List<byte[]>> regionsToFlush = null;\n           try {\n             // Force the roll if the logroll.period is elapsed or if a roll was requested.\n             // The returned value is an collection of actual region and family names.\n-            regionsToFlush = wal.rollWriter(true);\n+            regionsToFlush = controller.rollWal(now);\n           } catch (WALClosedException e) {\n             LOG.warn(\"WAL has been closed. Skipping rolling of writer and just remove it\", e);\n             iter.remove();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzQ4OQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453213489", "bodyText": "This log is not much value added now as we dont say for which log(s) need this periodic roll.  We can clearly say WAL roll period {} elapsed for one of the WAL.\nBelow we can make sure we log which wal(s) are getting rolled for what purpose", "author": "anoopsjohn", "createdAt": "2020-07-11T16:56:18Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,16 +146,14 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n+      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n         // Time for periodic roll, fall through\n         LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -148,43 +148,39 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n     while (running) {\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isRequestRoll)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n              iter.hasNext();) {\n           Entry<WAL, RollController> entry = iter.next();\n+          WAL wal = entry.getKey();\n           RollController controller = entry.getValue();\n-          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {\n+          if (controller.isRollRequested()) {\n+            // WAL roll requested, fall through\n+            LOG.debug(\"WAL {} roll requested\", wal);\n+          } else if (controller.needsPeriodicRoll(now)){\n+            // Time for periodic roll, fall through\n+            LOG.debug(\"WAL {} roll period {} ms elapsed\", wal, this.rollPeriod);\n+          } else {\n             continue;\n           }\n-          WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          controller.finishRoll();\n           Map<byte[], List<byte[]>> regionsToFlush = null;\n           try {\n             // Force the roll if the logroll.period is elapsed or if a roll was requested.\n             // The returned value is an collection of actual region and family names.\n-            regionsToFlush = wal.rollWriter(true);\n+            regionsToFlush = controller.rollWal(now);\n           } catch (WALClosedException e) {\n             LOG.warn(\"WAL has been closed. Skipping rolling of writer and just remove it\", e);\n             iter.remove();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzUwMg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453213502", "bodyText": "Same as above comment", "author": "anoopsjohn", "createdAt": "2020-07-11T16:56:30Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,16 +146,14 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n+      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n         // Time for periodic roll, fall through\n         LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n       } else {\n         synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(Boolean::booleanValue)) {\n+          if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isRequestRoll)) {\n             // WAL roll requested, fall through\n             LOG.debug(\"WAL roll requested\");", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -148,43 +148,39 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n     while (running) {\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isRequestRoll)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n              iter.hasNext();) {\n           Entry<WAL, RollController> entry = iter.next();\n+          WAL wal = entry.getKey();\n           RollController controller = entry.getValue();\n-          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {\n+          if (controller.isRollRequested()) {\n+            // WAL roll requested, fall through\n+            LOG.debug(\"WAL {} roll requested\", wal);\n+          } else if (controller.needsPeriodicRoll(now)){\n+            // Time for periodic roll, fall through\n+            LOG.debug(\"WAL {} roll period {} ms elapsed\", wal, this.rollPeriod);\n+          } else {\n             continue;\n           }\n-          WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          controller.finishRoll();\n           Map<byte[], List<byte[]>> regionsToFlush = null;\n           try {\n             // Force the roll if the logroll.period is elapsed or if a roll was requested.\n             // The returned value is an collection of actual region and family names.\n-            regionsToFlush = wal.rollWriter(true);\n+            regionsToFlush = controller.rollWal(now);\n           } catch (WALClosedException e) {\n             LOG.warn(\"WAL has been closed. Skipping rolling of writer and just remove it\", e);\n             iter.remove();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzY5Nw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453213697", "bodyText": "Ideally we need this call also within a synchronized block. This is an existing issue.", "author": "anoopsjohn", "createdAt": "2020-07-11T16:59:01Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -174,18 +170,21 @@ public void run() {\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n+          RollController controller = entry.getValue();\n+          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {\n+            continue;\n+          }\n           WAL wal = entry.getKey();\n           // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          walNeedsRoll.put(wal, Boolean.FALSE);\n+          controller.finishRoll();", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0OTYzMQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453449631", "bodyText": "Thank you very much for your tips", "author": "WenFeiYi", "createdAt": "2020-07-13T05:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 409808b36b..2d387be990 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -148,43 +148,39 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n     while (running) {\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isRequestRoll)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n              iter.hasNext();) {\n           Entry<WAL, RollController> entry = iter.next();\n+          WAL wal = entry.getKey();\n           RollController controller = entry.getValue();\n-          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {\n+          if (controller.isRollRequested()) {\n+            // WAL roll requested, fall through\n+            LOG.debug(\"WAL {} roll requested\", wal);\n+          } else if (controller.needsPeriodicRoll(now)){\n+            // Time for periodic roll, fall through\n+            LOG.debug(\"WAL {} roll period {} ms elapsed\", wal, this.rollPeriod);\n+          } else {\n             continue;\n           }\n-          WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          controller.finishRoll();\n           Map<byte[], List<byte[]>> regionsToFlush = null;\n           try {\n             // Force the roll if the logroll.period is elapsed or if a roll was requested.\n             // The returned value is an collection of actual region and family names.\n-            regionsToFlush = wal.rollWriter(true);\n+            regionsToFlush = controller.rollWal(now);\n           } catch (WALClosedException e) {\n             LOG.warn(\"WAL has been closed. Skipping rolling of writer and just remove it\", e);\n             iter.remove();\n"}}, {"oid": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "url": "https://github.com/apache/hbase/commit/8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "message": "fix", "committedDate": "2020-07-13T05:54:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NjEzMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453456133", "bodyText": "This is overall coming good now.  Much more clean than what we had before. Thanks\nOne issue here though.  We have rollWal() and requestRoll() under same lock now.. That is not good. The requestRoll should not wait for ongoing roll to be finished. The request call is in hot path.", "author": "anoopsjohn", "createdAt": "2020-07-13T06:18:51Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +244,42 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    private final WAL wal;\n+    private boolean isRequestRoll;\n+    private long lastRollTime;\n+\n+    RollController(WAL wal) {\n+      this.wal = wal;\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public synchronized void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    public synchronized Map<byte[], List<byte[]>> rollWal(long lastRollTime) throws IOException {", "originalCommit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15cdba79082d52995c1ad69703007207dbffca41", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 2d387be990..31dc123962 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -251,35 +254,38 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n    */\n   protected class RollController {\n     private final WAL wal;\n-    private boolean isRequestRoll;\n+    // avoid missing roll request before we return from rollWriter\n+    private final AtomicInteger rollRequestCounter;\n     private long lastRollTime;\n \n     RollController(WAL wal) {\n       this.wal = wal;\n-      this.isRequestRoll = false;\n+      this.rollRequestCounter = new AtomicInteger(0);\n       this.lastRollTime = System.currentTimeMillis();\n     }\n \n-    public synchronized void requestRoll() {\n-      this.isRequestRoll = true;\n+    public void requestRoll() {\n+      this.rollRequestCounter.incrementAndGet();\n     }\n \n-    public synchronized Map<byte[], List<byte[]>> rollWal(long lastRollTime) throws IOException {\n-      this.isRequestRoll = false;\n-      this.lastRollTime = lastRollTime;\n+    public Map<byte[], List<byte[]>> rollWal(long now, boolean isRequestRoll) throws IOException {\n+      if (isRequestRoll) {\n+        this.rollRequestCounter.decrementAndGet();\n+      }\n+      this.lastRollTime = now;\n       return wal.rollWriter(true);\n     }\n \n     public boolean isRollRequested() {\n-      return isRequestRoll;\n+      return rollRequestCounter.get() > 0;\n     }\n \n     public boolean needsPeriodicRoll(long now) {\n-      return (now - lastRollTime) > rollPeriod;\n+      return (now - this.lastRollTime) > rollPeriod;\n     }\n \n     public boolean needsRoll(long now) {\n-      return isRequestRoll || needsPeriodicRoll(now);\n+      return isRollRequested() || needsPeriodicRoll(now);\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1Njc3MA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453456770", "bodyText": "Previously, when we are going for a roll because of periodic roll, then also we used to keep the value in Map as TRUE right?  Means here we checked that also.  Because of any reason, the WAL is marked for roll, dont do this check.  So here that is missing now.", "author": "anoopsjohn", "createdAt": "2020-07-13T06:20:44Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -115,9 +113,9 @@ protected AbstractWALRoller(String name, Configuration conf, T abortable) {\n    */\n   private void checkLowReplication(long now) {\n     try {\n-      for (Entry<WAL, Boolean> entry : walNeedsRoll.entrySet()) {\n+      for (Entry<WAL, RollController> entry : wals.entrySet()) {\n         WAL wal = entry.getKey();\n-        boolean needRollAlready = entry.getValue();\n+        boolean needRollAlready = entry.getValue().isRollRequested();", "originalCommit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15cdba79082d52995c1ad69703007207dbffca41", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 2d387be990..31dc123962 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -115,7 +116,7 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n     try {\n       for (Entry<WAL, RollController> entry : wals.entrySet()) {\n         WAL wal = entry.getKey();\n-        boolean needRollAlready = entry.getValue().isRollRequested();\n+        boolean needRollAlready = entry.getValue().needsRoll(now);\n         if (needRollAlready || !(wal instanceof AbstractFSWAL)) {\n           continue;\n         }\n"}}, {"oid": "15cdba79082d52995c1ad69703007207dbffca41", "url": "https://github.com/apache/hbase/commit/15cdba79082d52995c1ad69703007207dbffca41", "message": "fix RollController and TestLogRoller", "committedDate": "2020-07-14T09:02:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTUwNg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r456451506", "bodyText": "Am not sure whether this way of count based thing also correct. Like say 2 times req roll happened before the actual rolling thread picks up this work. Effectively we need to do roll only once right. Even if 2 or more times being asked. But now as per this change it will try do roll again and again.\nSo a boolean based thing is enough\nWhat we can do is make the requestRoll being synchronized and within rollWal have a synchronized block where you can reset it ad then go ahead with actual roll call.\nOr we just need an AtomicBoolean only?", "author": "anoopsjohn", "createdAt": "2020-07-17T13:44:36Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +247,45 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    private final WAL wal;\n+    // avoid missing roll request before we return from rollWriter\n+    private final AtomicInteger rollRequestCounter;\n+    private long lastRollTime;\n+\n+    RollController(WAL wal) {\n+      this.wal = wal;\n+      this.rollRequestCounter = new AtomicInteger(0);\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public void requestRoll() {\n+      this.rollRequestCounter.incrementAndGet();", "originalCommit": "15cdba79082d52995c1ad69703007207dbffca41", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3c1a4807a3f938d009e5b1326f30db271d68f9d8", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 31dc123962..abe7a06dc0 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -254,30 +254,28 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n    */\n   protected class RollController {\n     private final WAL wal;\n-    // avoid missing roll request before we return from rollWriter\n-    private final AtomicInteger rollRequestCounter;\n+    private final AtomicBoolean rollRequest;\n     private long lastRollTime;\n \n     RollController(WAL wal) {\n       this.wal = wal;\n-      this.rollRequestCounter = new AtomicInteger(0);\n+      this.rollRequest = new AtomicBoolean(false);\n       this.lastRollTime = System.currentTimeMillis();\n     }\n \n     public void requestRoll() {\n-      this.rollRequestCounter.incrementAndGet();\n+      this.rollRequest.set(true);\n     }\n \n-    public Map<byte[], List<byte[]>> rollWal(long now, boolean isRequestRoll) throws IOException {\n-      if (isRequestRoll) {\n-        this.rollRequestCounter.decrementAndGet();\n-      }\n+    public Map<byte[], List<byte[]>> rollWal(long now) throws IOException {\n       this.lastRollTime = now;\n-      return wal.rollWriter(true);\n+      Map<byte[], List<byte[]>> regionsToFlush = wal.rollWriter(true);\n+      this.rollRequest.set(false);\n+      return regionsToFlush;\n     }\n \n     public boolean isRollRequested() {\n-      return rollRequestCounter.get() > 0;\n+      return rollRequest.get();\n     }\n \n     public boolean needsPeriodicRoll(long now) {\n"}}, {"oid": "3c1a4807a3f938d009e5b1326f30db271d68f9d8", "url": "https://github.com/apache/hbase/commit/3c1a4807a3f938d009e5b1326f30db271d68f9d8", "message": "fix", "committedDate": "2020-07-20T08:15:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457274033", "bodyText": "Hey this is where we need to reset it even before we do actual roll work.. We were doing that.  We had a comment also.\n// reset the flag in front to avoid missing roll request before we return from rollWriter.", "author": "anoopsjohn", "createdAt": "2020-07-20T10:49:42Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +247,43 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    private final WAL wal;\n+    private final AtomicBoolean rollRequest;\n+    private long lastRollTime;\n+\n+    RollController(WAL wal) {\n+      this.wal = wal;\n+      this.rollRequest = new AtomicBoolean(false);\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public void requestRoll() {\n+      this.rollRequest.set(true);\n+    }\n+\n+    public Map<byte[], List<byte[]>> rollWal(long now) throws IOException {\n+      this.lastRollTime = now;\n+      Map<byte[], List<byte[]>> regionsToFlush = wal.rollWriter(true);\n+      this.rollRequest.set(false);", "originalCommit": "3c1a4807a3f938d009e5b1326f30db271d68f9d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5MTMzMg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457291332", "bodyText": "thank you very much! I also noticed this, but in order to avoid repeated roll, so fix to that. if use boolean, roll at most once, the impact can be ignored. Thanks for review", "author": "WenFeiYi", "createdAt": "2020-07-20T11:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNjQwOA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457306408", "bodyText": "Sorry did not get.  How AtomicBoolean is different compared to boolean wrt repeated roll possibility.  In the past we used to keep the Boolean state in a Map.  Now in this object.", "author": "anoopsjohn", "createdAt": "2020-07-20T11:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1ODU3NA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457858574", "bodyText": "after reset flag, before roll is complete, if have a roll request, that will also cause an extra roll.", "author": "WenFeiYi", "createdAt": "2020-07-21T06:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyMDg4Ng==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457920886", "bodyText": "Yes. That is happening now also.  We intentionally reset the boolean when we start roll itself.\n// reset the flag in front to avoid missing roll request before we return from rollWriter.\nSo there is no change for that right now.", "author": "anoopsjohn", "createdAt": "2020-07-21T08:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2NTU4NA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457965584", "bodyText": "yes, I go it", "author": "WenFeiYi", "createdAt": "2020-07-21T09:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "11e9e134606753f1706c89699a541bbb2a64195d", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex abe7a06dc0..69d5781313 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -269,9 +269,9 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n \n     public Map<byte[], List<byte[]>> rollWal(long now) throws IOException {\n       this.lastRollTime = now;\n-      Map<byte[], List<byte[]>> regionsToFlush = wal.rollWriter(true);\n+      // reset the flag in front to avoid missing roll request before we return from rollWriter.\n       this.rollRequest.set(false);\n-      return regionsToFlush;\n+      return wal.rollWriter(true);\n     }\n \n     public boolean isRollRequested() {\n"}}, {"oid": "11e9e134606753f1706c89699a541bbb2a64195d", "url": "https://github.com/apache/hbase/commit/11e9e134606753f1706c89699a541bbb2a64195d", "message": "fix", "committedDate": "2020-07-20T11:10:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4Mzk0Nw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457983947", "bodyText": "Seems this boolean is not needed now. Can u pls delete", "author": "anoopsjohn", "createdAt": "2020-07-21T10:06:05Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,53 +147,52 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(Boolean::booleanValue)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n           WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          walNeedsRoll.put(wal, Boolean.FALSE);\n-          Map<byte[], List<byte[]>> regionsToFlush = null;\n+          RollController controller = entry.getValue();\n+          boolean isRequestRoll;", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 69d5781313..a5a0ee3a32 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -168,15 +168,12 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n           Entry<WAL, RollController> entry = iter.next();\n           WAL wal = entry.getKey();\n           RollController controller = entry.getValue();\n-          boolean isRequestRoll;\n           if (controller.isRollRequested()) {\n             // WAL roll requested, fall through\n             LOG.debug(\"WAL {} roll requested\", wal);\n-            isRequestRoll = true;\n           } else if (controller.needsPeriodicRoll(now)){\n             // Time for periodic roll, fall through\n             LOG.debug(\"WAL {} roll period {} ms elapsed\", wal, this.rollPeriod);\n-            isRequestRoll = false;\n           } else {\n             continue;\n           }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4ODA1OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457988058", "bodyText": "Checking its usage, I think this API impl is already buggy.   This just checks the status of the boolean. Once we start a roll on a WAL, we reset the boolean (Even before this patch).  So it is not clearly telling anything abt the roll status. This can return true even while an active wal roll is going on.  We can keep it as an another jira and fix (if required).. Just add some TODO comments here.\nWe might need another boolean in Controller which clearly tracks whether we are ongoing a roll. So this really need to check that status as well as a requested roll status.", "author": "anoopsjohn", "createdAt": "2020-07-21T10:13:32Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -232,7 +230,7 @@ private boolean isWaiting() {\n    * @return true if all WAL roll finished\n    */\n   public boolean walRollFinished() {\n-    return walNeedsRoll.values().stream().allMatch(needRoll -> !needRoll) && isWaiting();", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 69d5781313..a5a0ee3a32 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -230,7 +227,9 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n    * @return true if all WAL roll finished\n    */\n   public boolean walRollFinished() {\n-    return wals.values().stream().noneMatch(RollController::isRollRequested) && isWaiting();\n+    // TODO add a status field of roll in RollController\n+    return wals.values().stream().noneMatch(rc -> rc.needsRoll(System.currentTimeMillis()))\n+      && isWaiting();\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4ODg1OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457988858", "bodyText": "Here rather than isRollRequested, we need needsRoll?", "author": "anoopsjohn", "createdAt": "2020-07-21T10:15:00Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -232,7 +230,7 @@ private boolean isWaiting() {\n    * @return true if all WAL roll finished\n    */\n   public boolean walRollFinished() {\n-    return walNeedsRoll.values().stream().allMatch(needRoll -> !needRoll) && isWaiting();\n+    return wals.values().stream().noneMatch(RollController::isRollRequested) && isWaiting();", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\nindex 69d5781313..a5a0ee3a32 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java\n\n@@ -230,7 +227,9 @@ public abstract class AbstractWALRoller<T extends Abortable> extends Thread\n    * @return true if all WAL roll finished\n    */\n   public boolean walRollFinished() {\n-    return wals.values().stream().noneMatch(RollController::isRollRequested) && isWaiting();\n+    // TODO add a status field of roll in RollController\n+    return wals.values().stream().noneMatch(rc -> rc.needsRoll(System.currentTimeMillis()))\n+      && isWaiting();\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MTI1NQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457991255", "bodyText": "We need a 3 sec sleep here? !", "author": "anoopsjohn", "createdAt": "2020-07-21T10:19:18Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java", "diffHunk": "@@ -43,53 +49,104 @@\n   public static final HBaseClassTestRule CLASS_RULE =\n       HBaseClassTestRule.forClass(TestLogRoller.class);\n \n-  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n \n-  private static final int logRollPeriod = 20 * 1000;\n+  private static final int LOG_ROLL_PERIOD = 20 * 1000;\n+  private static final String LOG_DIR = \"WALs\";\n+  private static final String ARCHIVE_DIR = \"archiveWALs\";\n+  private static final String WAL_PREFIX = \"test-log-roller\";\n+  private static Configuration CONF;\n+  private static LogRoller ROLLER;\n+  private static Path ROOT_DIR;\n+  private static FileSystem FS;\n \n   @Before\n   public void setup() throws Exception {\n-    TEST_UTIL.getConfiguration().setInt(\"hbase.regionserver.logroll.period\", logRollPeriod);\n-    TEST_UTIL.startMiniCluster(1);\n-    TableName name = TableName.valueOf(\"Test\");\n-    TEST_UTIL.createTable(name, Bytes.toBytes(\"cf\"));\n-    TEST_UTIL.waitTableAvailable(name);\n+    CONF = TEST_UTIL.getConfiguration();\n+    CONF.setInt(\"hbase.regionserver.logroll.period\", LOG_ROLL_PERIOD);\n+    CONF.setInt(HConstants.THREAD_WAKE_FREQUENCY, 300);\n+    ROOT_DIR = TEST_UTIL.getRandomDir();\n+    FS = FileSystem.get(CONF);\n+    RegionServerServices services = Mockito.mock(RegionServerServices.class);\n+    Mockito.when(services.getConfiguration()).thenReturn(CONF);\n+    ROLLER = new LogRoller(services);\n+    ROLLER.start();\n   }\n \n   @After\n   public void tearDown() throws Exception {\n+    ROLLER.close();\n+    FS.close();\n     TEST_UTIL.shutdownMiniCluster();\n   }\n \n   @Test\n   public void testRemoveClosedWAL() throws Exception {\n-    HRegionServer rs = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0);\n-    Configuration conf = rs.getConfiguration();\n-    LogRoller logRoller = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0).getWalRoller();\n-    int originalSize = logRoller.getWalNeedsRoll().size();\n-    FSHLog wal1 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-        AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal1);\n-    FSHLog wal2 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal2);\n-    FSHLog wal3 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal3);\n-\n-    assertEquals(originalSize + 3, logRoller.getWalNeedsRoll().size());\n-    assertTrue(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal1.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize + 2, logRoller.getWalNeedsRoll().size());\n-    assertFalse(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal2.close();\n-    wal3.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize, logRoller.getWalNeedsRoll().size());\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      ROLLER.addWAL(wal);\n+    }\n+\n+    assertEquals(3, ROLLER.getWalNeedsRoll().size());\n+    Iterator<WAL> it = ROLLER.getWalNeedsRoll().keySet().iterator();\n+    WAL wal = it.next();\n+    assertTrue(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(2, ROLLER.getWalNeedsRoll().size());\n+    assertFalse(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal = it.next();\n+    wal.close();\n+    wal = it.next();\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+  }\n+\n+  /**\n+   * verify that each wal roll separately\n+   */\n+  @Test\n+  public void testRequestRollWithMultiWal() throws Exception {\n+    // add multiple wal\n+    Map<FSHLog, Path> wals = new HashMap<>();\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      wal.init();\n+      wals.put(wal, wal.getCurrentFileName());\n+      ROLLER.addWAL(wal);\n+      Thread.sleep(3000);", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MzQyMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457993423", "bodyText": "We want 3 WALs will different periodic roll time period?  Why we need? If so, can we limit the time to be 1 sec or lesser?", "author": "anoopsjohn", "createdAt": "2020-07-21T10:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MTI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "chunk": "diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java\nindex 1875e9fb88..ed7d5dc9c4 100644\n--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java\n+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java\n\n@@ -122,7 +122,7 @@ public class TestLogRoller {\n       wal.init();\n       wals.put(wal, wal.getCurrentFileName());\n       ROLLER.addWAL(wal);\n-      Thread.sleep(3000);\n+      Thread.sleep(1000);\n     }\n \n     // request roll\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MjE0Ng==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457992146", "bodyText": "Good...", "author": "anoopsjohn", "createdAt": "2020-07-21T10:20:54Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java", "diffHunk": "@@ -43,53 +49,104 @@\n   public static final HBaseClassTestRule CLASS_RULE =\n       HBaseClassTestRule.forClass(TestLogRoller.class);\n \n-  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n \n-  private static final int logRollPeriod = 20 * 1000;\n+  private static final int LOG_ROLL_PERIOD = 20 * 1000;\n+  private static final String LOG_DIR = \"WALs\";\n+  private static final String ARCHIVE_DIR = \"archiveWALs\";\n+  private static final String WAL_PREFIX = \"test-log-roller\";\n+  private static Configuration CONF;\n+  private static LogRoller ROLLER;\n+  private static Path ROOT_DIR;\n+  private static FileSystem FS;\n \n   @Before\n   public void setup() throws Exception {\n-    TEST_UTIL.getConfiguration().setInt(\"hbase.regionserver.logroll.period\", logRollPeriod);\n-    TEST_UTIL.startMiniCluster(1);\n-    TableName name = TableName.valueOf(\"Test\");\n-    TEST_UTIL.createTable(name, Bytes.toBytes(\"cf\"));\n-    TEST_UTIL.waitTableAvailable(name);\n+    CONF = TEST_UTIL.getConfiguration();\n+    CONF.setInt(\"hbase.regionserver.logroll.period\", LOG_ROLL_PERIOD);\n+    CONF.setInt(HConstants.THREAD_WAKE_FREQUENCY, 300);\n+    ROOT_DIR = TEST_UTIL.getRandomDir();\n+    FS = FileSystem.get(CONF);\n+    RegionServerServices services = Mockito.mock(RegionServerServices.class);\n+    Mockito.when(services.getConfiguration()).thenReturn(CONF);\n+    ROLLER = new LogRoller(services);\n+    ROLLER.start();\n   }\n \n   @After\n   public void tearDown() throws Exception {\n+    ROLLER.close();\n+    FS.close();\n     TEST_UTIL.shutdownMiniCluster();\n   }\n \n   @Test\n   public void testRemoveClosedWAL() throws Exception {\n-    HRegionServer rs = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0);\n-    Configuration conf = rs.getConfiguration();\n-    LogRoller logRoller = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0).getWalRoller();\n-    int originalSize = logRoller.getWalNeedsRoll().size();\n-    FSHLog wal1 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-        AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal1);\n-    FSHLog wal2 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal2);\n-    FSHLog wal3 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal3);\n-\n-    assertEquals(originalSize + 3, logRoller.getWalNeedsRoll().size());\n-    assertTrue(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal1.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize + 2, logRoller.getWalNeedsRoll().size());\n-    assertFalse(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal2.close();\n-    wal3.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize, logRoller.getWalNeedsRoll().size());\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      ROLLER.addWAL(wal);\n+    }\n+\n+    assertEquals(3, ROLLER.getWalNeedsRoll().size());\n+    Iterator<WAL> it = ROLLER.getWalNeedsRoll().keySet().iterator();\n+    WAL wal = it.next();\n+    assertTrue(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(2, ROLLER.getWalNeedsRoll().size());\n+    assertFalse(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal = it.next();\n+    wal.close();\n+    wal = it.next();\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+  }\n+\n+  /**\n+   * verify that each wal roll separately\n+   */\n+  @Test\n+  public void testRequestRollWithMultiWal() throws Exception {\n+    // add multiple wal\n+    Map<FSHLog, Path> wals = new HashMap<>();\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      wal.init();\n+      wals.put(wal, wal.getCurrentFileName());\n+      ROLLER.addWAL(wal);\n+      Thread.sleep(3000);\n+    }\n+\n+    // request roll\n+    Iterator<Map.Entry<FSHLog, Path>> it = wals.entrySet().iterator();\n+    Map.Entry<FSHLog, Path> walEntry = it.next();\n+    walEntry.getKey().requestLogRoll();\n+    Thread.sleep(5000);\n+\n+    assertNotEquals(walEntry.getValue(), walEntry.getKey().getCurrentFileName());\n+    walEntry.setValue(walEntry.getKey().getCurrentFileName());\n+    while (it.hasNext()) {\n+      walEntry = it.next();\n+      assertEquals(walEntry.getValue(), walEntry.getKey().getCurrentFileName());", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "chunk": "diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java\nindex 1875e9fb88..ed7d5dc9c4 100644\n--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java\n+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java\n\n@@ -122,7 +122,7 @@ public class TestLogRoller {\n       wal.init();\n       wals.put(wal, wal.getCurrentFileName());\n       ROLLER.addWAL(wal);\n-      Thread.sleep(3000);\n+      Thread.sleep(1000);\n     }\n \n     // request roll\n"}}, {"oid": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "url": "https://github.com/apache/hbase/commit/18bfdf715d063b64b50f3364dee726ffe1d6716a", "message": "fix", "committedDate": "2020-07-21T12:02:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459223780", "bodyText": "walRolls? instead of wals?", "author": "ramkrish86", "createdAt": "2020-07-23T05:37:58Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,31 +58,31 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> wals = new ConcurrentHashMap<>();", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzNTI4NA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459235284", "bodyText": "rollWals? more suitable\uff1f", "author": "WenFeiYi", "createdAt": "2020-07-23T06:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI1NjM5OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459256398", "bodyText": "This will have all wal entries once the wal instance is created.  Not just when it needs a roll. So ya these were wals which needed roll at some point.  So wals name also fine IMO.", "author": "anoopsjohn", "createdAt": "2020-07-23T07:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM3NDgwNw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459374807", "bodyText": "Ok", "author": "ramkrish86", "createdAt": "2020-07-23T11:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNDE4OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459224188", "bodyText": "Is this talking about what this PR is trying to do?", "author": "ramkrish86", "createdAt": "2020-07-23T05:39:51Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,31 +58,31 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> wals = new ConcurrentHashMap<>();\n   protected final T abortable;\n-  private volatile long lastRollTime = System.currentTimeMillis();\n   // Period to roll log.\n   private final long rollPeriod;\n   private final int threadWakeFrequency;\n   // The interval to check low replication on hlog's pipeline\n-  private long checkLowReplicationInterval;\n+  private final long checkLowReplicationInterval;\n \n   private volatile boolean running = true;\n \n   public void addWAL(WAL wal) {\n     // check without lock first\n-    if (walNeedsRoll.containsKey(wal)) {\n+    if (wals.containsKey(wal)) {\n       return;\n     }\n     // this is to avoid race between addWAL and requestRollAll.\n     synchronized (this) {\n-      if (walNeedsRoll.putIfAbsent(wal, Boolean.FALSE) == null) {\n+      if (wals.putIfAbsent(wal, new RollController(wal)) == null) {\n         wal.registerWALActionsListener(new WALActionsListener() {\n           @Override\n           public void logRollRequested(WALActionsListener.RollRequestReason reason) {\n             // TODO logs will contend with each other here, replace with e.g. DelayedQueue", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMzUyOA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459233528", "bodyText": "No, the todo is pre-existing.", "author": "WenFeiYi", "createdAt": "2020-07-23T06:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNDE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzODUzNA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459238534", "bodyText": "@ramkrish86 the purpose of this PR is to make each wal separate roll when using multiwal. thanks review.", "author": "WenFeiYi", "createdAt": "2020-07-23T06:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNDE4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NDU5NQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459384595", "bodyText": "This is they key. We ensure we only roll if one of the condition is met (if either size reach caused a log roll ) or the time elapsed. That is also tracked per wal.", "author": "ramkrish86", "createdAt": "2020-07-23T11:34:28Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,53 +147,49 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(Boolean::booleanValue)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n           WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          walNeedsRoll.put(wal, Boolean.FALSE);\n-          Map<byte[], List<byte[]>> regionsToFlush = null;\n+          RollController controller = entry.getValue();\n+          if (controller.isRollRequested()) {\n+            // WAL roll requested, fall through\n+            LOG.debug(\"WAL {} roll requested\", wal);\n+          } else if (controller.needsPeriodicRoll(now)){\n+            // Time for periodic roll, fall through\n+            LOG.debug(\"WAL {} roll period {} ms elapsed\", wal, this.rollPeriod);\n+          } else {\n+            continue;", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459628419", "bodyText": "We have already done wals.putIfAbsent(wal, new RollController(wal)) above.\nHence, wals.computeIfAbsent() is needed here? Should we not directly get the value with RollController controller = wals.get(wal) and expect non-null object?", "author": "virajjasani", "createdAt": "2020-07-23T17:57:04Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,31 +58,31 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> wals = new ConcurrentHashMap<>();\n   protected final T abortable;\n-  private volatile long lastRollTime = System.currentTimeMillis();\n   // Period to roll log.\n   private final long rollPeriod;\n   private final int threadWakeFrequency;\n   // The interval to check low replication on hlog's pipeline\n-  private long checkLowReplicationInterval;\n+  private final long checkLowReplicationInterval;\n \n   private volatile boolean running = true;\n \n   public void addWAL(WAL wal) {\n     // check without lock first\n-    if (walNeedsRoll.containsKey(wal)) {\n+    if (wals.containsKey(wal)) {\n       return;\n     }\n     // this is to avoid race between addWAL and requestRollAll.\n     synchronized (this) {\n-      if (walNeedsRoll.putIfAbsent(wal, Boolean.FALSE) == null) {\n+      if (wals.putIfAbsent(wal, new RollController(wal)) == null) {\n         wal.registerWALActionsListener(new WALActionsListener() {\n           @Override\n           public void logRollRequested(WALActionsListener.RollRequestReason reason) {\n             // TODO logs will contend with each other here, replace with e.g. DelayedQueue\n             synchronized (AbstractWALRoller.this) {\n-              walNeedsRoll.put(wal, Boolean.TRUE);\n+              RollController controller = wals.computeIfAbsent(wal, rc -> new RollController(wal));", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NzgwOQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459857809", "bodyText": "Good Q.  In fact I also thought when reviewed this.  Ideally speaking we should get the addWAL call 1st which will add the instance to the Map. When we get call here the wal should be in the map already.  But if u see the cur impl, there is no such contract enforcing.  It just add the WAL with True value.  So  believe while making patch, @WenFeiYi  went with similar lines.\nWe can consider this.. Need to see any chance we get a rollReq before adding.. While RS start, we do some rollReq on WALs.. This introduced some bug in the past.   We need to see that closely..   If we can confirm that we can add that contract enforcing and so what u suggested.  I would say add a TODO here and raise another issue. This went through multiple cycles of changes. :-)  U ok Viraj?", "author": "anoopsjohn", "createdAt": "2020-07-24T05:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4MjQ1Ng==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459882456", "bodyText": "yes, this is my idea, if there is a change, the impact will be greater, it will be far away from the purpose of the issue.", "author": "WenFeiYi", "createdAt": "2020-07-24T06:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4NjIzMQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459886231", "bodyText": "Sure, this is critical code anyways, we can live with bit extra atomic calls on Concurrent Map. Sounds good, TODO should make this better :)\nNice work @WenFeiYi .", "author": "virajjasani", "createdAt": "2020-07-24T07:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ=="}], "type": "inlineReview", "revised_code": null}]}