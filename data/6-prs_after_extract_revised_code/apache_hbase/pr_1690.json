{"pr_number": 1690, "pr_title": "HBASE-24327 : Flaky connection in TestMasterShutdown#testMasterShutdo\u2026", "pr_createdAt": "2020-05-11T10:43:35Z", "pr_url": "https://github.com/apache/hbase/pull/1690", "timeline": [{"oid": "04260b5bf95670e9493400214c9b682267df8de2", "url": "https://github.com/apache/hbase/commit/04260b5bf95670e9493400214c9b682267df8de2", "message": "rebase", "committedDate": "2020-05-11T11:28:19Z", "type": "commit"}, {"oid": "04260b5bf95670e9493400214c9b682267df8de2", "url": "https://github.com/apache/hbase/commit/04260b5bf95670e9493400214c9b682267df8de2", "message": "rebase", "committedDate": "2020-05-11T11:28:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI4MjQ3MA==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423282470", "bodyText": "IIUC, the problem here is this (in your original patch). Like we discussed, shutdown() is running into flaky ZK issues because the ZK failure happens in the context of the shutdown() rpc. Even when that happens, the shutdown still goes through (though the RPC fails). So, once you enter that state, the subsequent RPCs won't ever return succeed (because the master is already down), so it will just wait until the waitFor() times out (and the test fails).", "author": "bharathv", "createdAt": "2020-05-11T19:55:37Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -151,19 +156,42 @@ public void testMasterShutdownBeforeStartingAnyRegionServer() throws Exception {\n       hbaseCluster = new LocalHBaseCluster(htu.getConfiguration(), options.getNumMasters(),\n         options.getNumRegionServers(), options.getMasterClass(), options.getRsClass());\n       final MasterThread masterThread = hbaseCluster.getMasters().get(0);\n+\n       masterThread.start();\n-      // Switching to master registry exacerbated a race in the master bootstrap that can result\n-      // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n-      // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n-      // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n-      // is because the connection creation with ZK registry is so slow that by then the server\n-      // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n-      // wait() in the test, waiting for the server manager to become available.\n-      final long timeout = TimeUnit.MINUTES.toMillis(10);\n-      assertNotEquals(\"Timeout waiting for server manager to become available.\",\n-        -1, Waiter.waitFor(htu.getConfiguration(), timeout,\n-          () -> masterThread.getMaster().getServerManager() != null));\n-      htu.getConnection().getAdmin().shutdown();\n+      final CompletableFuture<Void> shutdownFuture = CompletableFuture.runAsync(() -> {\n+        // Switching to master registry exacerbated a race in the master bootstrap that can result\n+        // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n+        // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n+        // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n+        // is because the connection creation with ZK registry is so slow that by then the server\n+        // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n+        // wait() in the test, waiting for the server manager to become available.\n+        final long timeout = TimeUnit.MINUTES.toMillis(10);\n+        assertNotEquals(\"timeout waiting for server manager to become available.\", -1,\n+          htu.waitFor(timeout, () -> masterThread.getMaster().getServerManager() != null));\n+\n+        // Master has come up far enough that we can terminate it without creating a zombie.\n+        final long result = htu.waitFor(timeout, 1000, () -> {\n+          LOG.debug(\"Attempting to establish connection.\");\n+          try (final Connection conn = htu.getConnection()) {\n+            conn.getAdmin().shutdown();\n+            LOG.info(\"Shutdown RPC sent.\");\n+            return true;", "originalCommit": "04260b5bf95670e9493400214c9b682267df8de2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3fb12a674324037180d9736eb5c8e5e7f60ce9", "chunk": "diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\nindex 160daeaee9..b9df58e1d2 100644\n--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n\n@@ -171,24 +168,15 @@ public class TestMasterShutdown {\n           htu.waitFor(timeout, () -> masterThread.getMaster().getServerManager() != null));\n \n         // Master has come up far enough that we can terminate it without creating a zombie.\n-        final long result = htu.waitFor(timeout, 1000, () -> {\n-          LOG.debug(\"Attempting to establish connection.\");\n-          try (final Connection conn = htu.getConnection()) {\n-            conn.getAdmin().shutdown();\n-            LOG.info(\"Shutdown RPC sent.\");\n-            return true;\n-          } catch (IOException|CompletionException e) {\n-            LOG.error(\"Failed to establish connection.\");\n-            if (connectionFailedWithMaster(e)) {\n-              return true;\n-            }\n-          } catch (Throwable e) {\n-            LOG.error(\"Something unexpected happened.\", e);\n-          }\n-          return false;\n-        });\n-        assertNotEquals(\"Failed to issue shutdown RPC after \" + Duration.ofMillis(timeout),\n-          -1, result);\n+        LOG.debug(\"Attempting to establish connection.\");\n+        try (final Connection conn = htu.getConnection()) {\n+          conn.getAdmin().shutdown();\n+          LOG.info(\"Shutdown RPC sent.\");\n+        } catch (IOException | CompletionException e) {\n+          LOG.warn(\"Failed to establish connection.\", e);\n+        } catch (Throwable e) {\n+          LOG.warn(\"Something unexpected happened.\", e);\n+        }\n       });\n \n       shutdownFuture.join();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI4NDk5MA==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423284990", "bodyText": "I think this is a bit hacky, instead, can we just issue one shutdown(), don't worry about the result of it (since we know it is going to succeed even if it runs into ZK issues) and then just join on the master thread? That means the code will look like this..\nmaster.start()\nhtu.waitFor(.... masterThread.getMaster().serverMgr() != null);\nThread.run() {\nconn.getAdmin().shutdown();\n// don't worry about the return value\n}\nmasterThread.join()\nshutdownThread.join()\nThoughts?", "author": "bharathv", "createdAt": "2020-05-11T20:00:32Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -151,19 +156,42 @@ public void testMasterShutdownBeforeStartingAnyRegionServer() throws Exception {\n       hbaseCluster = new LocalHBaseCluster(htu.getConfiguration(), options.getNumMasters(),\n         options.getNumRegionServers(), options.getMasterClass(), options.getRsClass());\n       final MasterThread masterThread = hbaseCluster.getMasters().get(0);\n+\n       masterThread.start();\n-      // Switching to master registry exacerbated a race in the master bootstrap that can result\n-      // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n-      // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n-      // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n-      // is because the connection creation with ZK registry is so slow that by then the server\n-      // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n-      // wait() in the test, waiting for the server manager to become available.\n-      final long timeout = TimeUnit.MINUTES.toMillis(10);\n-      assertNotEquals(\"Timeout waiting for server manager to become available.\",\n-        -1, Waiter.waitFor(htu.getConfiguration(), timeout,\n-          () -> masterThread.getMaster().getServerManager() != null));\n-      htu.getConnection().getAdmin().shutdown();\n+      final CompletableFuture<Void> shutdownFuture = CompletableFuture.runAsync(() -> {\n+        // Switching to master registry exacerbated a race in the master bootstrap that can result\n+        // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n+        // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n+        // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n+        // is because the connection creation with ZK registry is so slow that by then the server\n+        // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n+        // wait() in the test, waiting for the server manager to become available.\n+        final long timeout = TimeUnit.MINUTES.toMillis(10);\n+        assertNotEquals(\"timeout waiting for server manager to become available.\", -1,\n+          htu.waitFor(timeout, () -> masterThread.getMaster().getServerManager() != null));\n+\n+        // Master has come up far enough that we can terminate it without creating a zombie.\n+        final long result = htu.waitFor(timeout, 1000, () -> {\n+          LOG.debug(\"Attempting to establish connection.\");\n+          try (final Connection conn = htu.getConnection()) {\n+            conn.getAdmin().shutdown();\n+            LOG.info(\"Shutdown RPC sent.\");\n+            return true;\n+          } catch (IOException|CompletionException e) {\n+            LOG.error(\"Failed to establish connection.\");\n+            if (connectionFailedWithMaster(e)) {", "originalCommit": "04260b5bf95670e9493400214c9b682267df8de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDE1Nw==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423500157", "bodyText": "This is what I thought of doing first thing, yesterday :)\nThen I felt better to check the exact error message and confirm. Although we are sure at this point about the failure, I don't have any strong opinion against not validating the exact error message. Let's do this as you mentioned.", "author": "virajjasani", "createdAt": "2020-05-12T06:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI4NDk5MA=="}], "type": "inlineReview", "revised_code": {"commit": "3b3fb12a674324037180d9736eb5c8e5e7f60ce9", "chunk": "diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\nindex 160daeaee9..b9df58e1d2 100644\n--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n\n@@ -171,24 +168,15 @@ public class TestMasterShutdown {\n           htu.waitFor(timeout, () -> masterThread.getMaster().getServerManager() != null));\n \n         // Master has come up far enough that we can terminate it without creating a zombie.\n-        final long result = htu.waitFor(timeout, 1000, () -> {\n-          LOG.debug(\"Attempting to establish connection.\");\n-          try (final Connection conn = htu.getConnection()) {\n-            conn.getAdmin().shutdown();\n-            LOG.info(\"Shutdown RPC sent.\");\n-            return true;\n-          } catch (IOException|CompletionException e) {\n-            LOG.error(\"Failed to establish connection.\");\n-            if (connectionFailedWithMaster(e)) {\n-              return true;\n-            }\n-          } catch (Throwable e) {\n-            LOG.error(\"Something unexpected happened.\", e);\n-          }\n-          return false;\n-        });\n-        assertNotEquals(\"Failed to issue shutdown RPC after \" + Duration.ofMillis(timeout),\n-          -1, result);\n+        LOG.debug(\"Attempting to establish connection.\");\n+        try (final Connection conn = htu.getConnection()) {\n+          conn.getAdmin().shutdown();\n+          LOG.info(\"Shutdown RPC sent.\");\n+        } catch (IOException | CompletionException e) {\n+          LOG.warn(\"Failed to establish connection.\", e);\n+        } catch (Throwable e) {\n+          LOG.warn(\"Something unexpected happened.\", e);\n+        }\n       });\n \n       shutdownFuture.join();\n"}}, {"oid": "3b3fb12a674324037180d9736eb5c8e5e7f60ce9", "url": "https://github.com/apache/hbase/commit/3b3fb12a674324037180d9736eb5c8e5e7f60ce9", "message": "review", "committedDate": "2020-05-12T08:01:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTE5Ng==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423899196", "bodyText": "Add a quick comment about our discussion, with a jira reference? (incase someone else has to touch this code again)...", "author": "bharathv", "createdAt": "2020-05-12T17:12:55Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -151,19 +153,33 @@ public void testMasterShutdownBeforeStartingAnyRegionServer() throws Exception {\n       hbaseCluster = new LocalHBaseCluster(htu.getConfiguration(), options.getNumMasters(),\n         options.getNumRegionServers(), options.getMasterClass(), options.getRsClass());\n       final MasterThread masterThread = hbaseCluster.getMasters().get(0);\n+\n       masterThread.start();\n-      // Switching to master registry exacerbated a race in the master bootstrap that can result\n-      // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n-      // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n-      // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n-      // is because the connection creation with ZK registry is so slow that by then the server\n-      // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n-      // wait() in the test, waiting for the server manager to become available.\n-      final long timeout = TimeUnit.MINUTES.toMillis(10);\n-      assertNotEquals(\"Timeout waiting for server manager to become available.\",\n-        -1, Waiter.waitFor(htu.getConfiguration(), timeout,\n-          () -> masterThread.getMaster().getServerManager() != null));\n-      htu.getConnection().getAdmin().shutdown();\n+      final CompletableFuture<Void> shutdownFuture = CompletableFuture.runAsync(() -> {\n+        // Switching to master registry exacerbated a race in the master bootstrap that can result\n+        // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n+        // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n+        // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n+        // is because the connection creation with ZK registry is so slow that by then the server\n+        // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n+        // wait() in the test, waiting for the server manager to become available.\n+        final long timeout = TimeUnit.MINUTES.toMillis(10);\n+        assertNotEquals(\"timeout waiting for server manager to become available.\", -1,\n+          htu.waitFor(timeout, () -> masterThread.getMaster().getServerManager() != null));\n+\n+        // Master has come up far enough that we can terminate it without creating a zombie.\n+        LOG.debug(\"Attempting to establish connection.\");\n+        try (final Connection conn = htu.getConnection()) {\n+          conn.getAdmin().shutdown();", "originalCommit": "3b3fb12a674324037180d9736eb5c8e5e7f60ce9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "83c052241882534ecec30a36134334e919319256", "chunk": "diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\nindex b9df58e1d2..e99e93204d 100644\n--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n\n@@ -169,13 +168,26 @@ public class TestMasterShutdown {\n \n         // Master has come up far enough that we can terminate it without creating a zombie.\n         LOG.debug(\"Attempting to establish connection.\");\n-        try (final Connection conn = htu.getConnection()) {\n-          conn.getAdmin().shutdown();\n+        try {\n+          // HBASE-24327 : (Resolve Flaky connection issues)\n+          // shutdown() RPC can have flaky ZK connection issues.\n+          // e.g\n+          // ERROR [RpcServer.priority.RWQ.Fifo.read.handler=1,queue=1,port=53033]\n+          // master.HMaster(2878): ZooKeeper exception trying to set cluster as down in ZK\n+          // org.apache.zookeeper.KeeperException$SystemErrorException:\n+          // KeeperErrorCode = SystemError\n+          //\n+          // However, even when above flakes happen, shutdown call does get completed even if\n+          // RPC call has failure. Hence, subsequent retries will never succeed as HMaster is\n+          // already shutdown. Hence, it can fail. To resolve it, after making one shutdown()\n+          // call, we are ignoring IOException.\n+          htu.getConnection().getAdmin().shutdown();\n           LOG.info(\"Shutdown RPC sent.\");\n         } catch (IOException | CompletionException e) {\n           LOG.warn(\"Failed to establish connection.\", e);\n         } catch (Throwable e) {\n           LOG.warn(\"Something unexpected happened.\", e);\n+          throw new RuntimeException(e);\n         }\n       });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMDE5NA==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423900194", "bodyText": "htu.getConnection() is managed by the mini cluster, remove it from try-with-resources block? Otherwise we might run into weird issues in teardown..", "author": "bharathv", "createdAt": "2020-05-12T17:14:37Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -151,19 +153,33 @@ public void testMasterShutdownBeforeStartingAnyRegionServer() throws Exception {\n       hbaseCluster = new LocalHBaseCluster(htu.getConfiguration(), options.getNumMasters(),\n         options.getNumRegionServers(), options.getMasterClass(), options.getRsClass());\n       final MasterThread masterThread = hbaseCluster.getMasters().get(0);\n+\n       masterThread.start();\n-      // Switching to master registry exacerbated a race in the master bootstrap that can result\n-      // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n-      // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n-      // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n-      // is because the connection creation with ZK registry is so slow that by then the server\n-      // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n-      // wait() in the test, waiting for the server manager to become available.\n-      final long timeout = TimeUnit.MINUTES.toMillis(10);\n-      assertNotEquals(\"Timeout waiting for server manager to become available.\",\n-        -1, Waiter.waitFor(htu.getConfiguration(), timeout,\n-          () -> masterThread.getMaster().getServerManager() != null));\n-      htu.getConnection().getAdmin().shutdown();\n+      final CompletableFuture<Void> shutdownFuture = CompletableFuture.runAsync(() -> {\n+        // Switching to master registry exacerbated a race in the master bootstrap that can result\n+        // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n+        // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n+        // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n+        // is because the connection creation with ZK registry is so slow that by then the server\n+        // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n+        // wait() in the test, waiting for the server manager to become available.\n+        final long timeout = TimeUnit.MINUTES.toMillis(10);\n+        assertNotEquals(\"timeout waiting for server manager to become available.\", -1,\n+          htu.waitFor(timeout, () -> masterThread.getMaster().getServerManager() != null));\n+\n+        // Master has come up far enough that we can terminate it without creating a zombie.\n+        LOG.debug(\"Attempting to establish connection.\");\n+        try (final Connection conn = htu.getConnection()) {", "originalCommit": "3b3fb12a674324037180d9736eb5c8e5e7f60ce9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkyNjQ5OQ==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423926499", "bodyText": "Yeah, sounds good.", "author": "virajjasani", "createdAt": "2020-05-12T17:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMDE5NA=="}], "type": "inlineReview", "revised_code": {"commit": "83c052241882534ecec30a36134334e919319256", "chunk": "diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\nindex b9df58e1d2..e99e93204d 100644\n--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n\n@@ -169,13 +168,26 @@ public class TestMasterShutdown {\n \n         // Master has come up far enough that we can terminate it without creating a zombie.\n         LOG.debug(\"Attempting to establish connection.\");\n-        try (final Connection conn = htu.getConnection()) {\n-          conn.getAdmin().shutdown();\n+        try {\n+          // HBASE-24327 : (Resolve Flaky connection issues)\n+          // shutdown() RPC can have flaky ZK connection issues.\n+          // e.g\n+          // ERROR [RpcServer.priority.RWQ.Fifo.read.handler=1,queue=1,port=53033]\n+          // master.HMaster(2878): ZooKeeper exception trying to set cluster as down in ZK\n+          // org.apache.zookeeper.KeeperException$SystemErrorException:\n+          // KeeperErrorCode = SystemError\n+          //\n+          // However, even when above flakes happen, shutdown call does get completed even if\n+          // RPC call has failure. Hence, subsequent retries will never succeed as HMaster is\n+          // already shutdown. Hence, it can fail. To resolve it, after making one shutdown()\n+          // call, we are ignoring IOException.\n+          htu.getConnection().getAdmin().shutdown();\n           LOG.info(\"Shutdown RPC sent.\");\n         } catch (IOException | CompletionException e) {\n           LOG.warn(\"Failed to establish connection.\", e);\n         } catch (Throwable e) {\n           LOG.warn(\"Something unexpected happened.\", e);\n+          throw new RuntimeException(e);\n         }\n       });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMDcyMw==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423900723", "bodyText": "nit: remove..", "author": "bharathv", "createdAt": "2020-05-12T17:15:22Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -186,21 +202,12 @@ private static Configuration createMasterShutdownBeforeStartingAnyRegionServerCo\n     conf.setInt(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART, 1);\n     // don't need a long write pipeline for this test.\n     conf.setInt(\"dfs.replication\", 1);\n-    return conf;\n-  }\n-\n-  /**\n-   * Create a new {@link Configuration} based on {@code baseConf} that has ZooKeeper connection\n-   * settings tuned very aggressively. The resulting client is used within a retry loop, so there's\n-   * no value in having the client itself do the retries. We want to iterate on the base\n-   * configuration because we're waiting for the mini-cluster to start and set it's ZK client port.\n-   *\n-   * @return a new, configured {@link Configuration} instance.\n-   */\n-  private static Configuration createResponsiveZkConfig(final Configuration baseConf) {\n-    final Configuration conf = HBaseConfiguration.create(baseConf);\n+    // reduce client retries\n+    conf.setInt(\"hbase.client.retries.number\", 3);\n+    // Recoverable ZK configs are tuned more aggressively\n     conf.setInt(ReadOnlyZKClient.RECOVERY_RETRY, 3);\n     conf.setInt(ReadOnlyZKClient.RECOVERY_RETRY_INTERVAL_MILLIS, 100);\n     return conf;\n   }\n+", "originalCommit": "3b3fb12a674324037180d9736eb5c8e5e7f60ce9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkyNjMwNg==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r423926306", "bodyText": "Sure", "author": "virajjasani", "createdAt": "2020-05-12T17:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMDcyMw=="}], "type": "inlineReview", "revised_code": {"commit": "83c052241882534ecec30a36134334e919319256", "chunk": "diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\nindex b9df58e1d2..e99e93204d 100644\n--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java\n\n@@ -209,5 +221,4 @@ public class TestMasterShutdown {\n     conf.setInt(ReadOnlyZKClient.RECOVERY_RETRY_INTERVAL_MILLIS, 100);\n     return conf;\n   }\n-\n }\n"}}, {"oid": "83c052241882534ecec30a36134334e919319256", "url": "https://github.com/apache/hbase/commit/83c052241882534ecec30a36134334e919319256", "message": "minor changes", "committedDate": "2020-05-12T21:05:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4OTYyNg==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424089626", "bodyText": "nit: what's the purpose of running this in a separate thread?", "author": "ndimiduk", "createdAt": "2020-05-12T23:25:33Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -151,19 +152,46 @@ public void testMasterShutdownBeforeStartingAnyRegionServer() throws Exception {\n       hbaseCluster = new LocalHBaseCluster(htu.getConfiguration(), options.getNumMasters(),\n         options.getNumRegionServers(), options.getMasterClass(), options.getRsClass());\n       final MasterThread masterThread = hbaseCluster.getMasters().get(0);\n+\n       masterThread.start();\n-      // Switching to master registry exacerbated a race in the master bootstrap that can result\n-      // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n-      // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n-      // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n-      // is because the connection creation with ZK registry is so slow that by then the server\n-      // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n-      // wait() in the test, waiting for the server manager to become available.\n-      final long timeout = TimeUnit.MINUTES.toMillis(10);\n-      assertNotEquals(\"Timeout waiting for server manager to become available.\",\n-        -1, Waiter.waitFor(htu.getConfiguration(), timeout,\n-          () -> masterThread.getMaster().getServerManager() != null));\n-      htu.getConnection().getAdmin().shutdown();\n+      final CompletableFuture<Void> shutdownFuture = CompletableFuture.runAsync(() -> {", "originalCommit": "83c052241882534ecec30a36134334e919319256", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyOTE0Mw==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424429143", "bodyText": "Oh yes, now I can make the call synchronous. The decision of making it go in separate thread goes to previous PR where Bharath and I thought of keeping this async until fixing HBASE-24070 : #1684 (comment)", "author": "virajjasani", "createdAt": "2020-05-13T13:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4OTYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc4OTMxOA==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424789318", "bodyText": "Ah, and that one smells a bit like HBASE-23836.", "author": "ndimiduk", "createdAt": "2020-05-13T23:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4OTYyNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MTI4MQ==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424091281", "bodyText": "Your above comment says \"make one shutdown and ignore failures\" but the warning here makes the reader think the shutdown call failed (or, that something failed. the message doesn't say what was attempting to establish a connection, or to what).\nThe IOException is highly generic -- we don't actually know if it was a connection failure, a failure on the server side processing the request, or a failed on the client to interpret the result.", "author": "ndimiduk", "createdAt": "2020-05-12T23:30:44Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -151,19 +152,46 @@ public void testMasterShutdownBeforeStartingAnyRegionServer() throws Exception {\n       hbaseCluster = new LocalHBaseCluster(htu.getConfiguration(), options.getNumMasters(),\n         options.getNumRegionServers(), options.getMasterClass(), options.getRsClass());\n       final MasterThread masterThread = hbaseCluster.getMasters().get(0);\n+\n       masterThread.start();\n-      // Switching to master registry exacerbated a race in the master bootstrap that can result\n-      // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n-      // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n-      // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n-      // is because the connection creation with ZK registry is so slow that by then the server\n-      // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n-      // wait() in the test, waiting for the server manager to become available.\n-      final long timeout = TimeUnit.MINUTES.toMillis(10);\n-      assertNotEquals(\"Timeout waiting for server manager to become available.\",\n-        -1, Waiter.waitFor(htu.getConfiguration(), timeout,\n-          () -> masterThread.getMaster().getServerManager() != null));\n-      htu.getConnection().getAdmin().shutdown();\n+      final CompletableFuture<Void> shutdownFuture = CompletableFuture.runAsync(() -> {\n+        // Switching to master registry exacerbated a race in the master bootstrap that can result\n+        // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n+        // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n+        // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n+        // is because the connection creation with ZK registry is so slow that by then the server\n+        // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n+        // wait() in the test, waiting for the server manager to become available.\n+        final long timeout = TimeUnit.MINUTES.toMillis(10);\n+        assertNotEquals(\"timeout waiting for server manager to become available.\", -1,\n+          htu.waitFor(timeout, () -> masterThread.getMaster().getServerManager() != null));\n+\n+        // Master has come up far enough that we can terminate it without creating a zombie.\n+        LOG.debug(\"Attempting to establish connection.\");\n+        try {\n+          // HBASE-24327 : (Resolve Flaky connection issues)\n+          // shutdown() RPC can have flaky ZK connection issues.\n+          // e.g\n+          // ERROR [RpcServer.priority.RWQ.Fifo.read.handler=1,queue=1,port=53033]\n+          // master.HMaster(2878): ZooKeeper exception trying to set cluster as down in ZK\n+          // org.apache.zookeeper.KeeperException$SystemErrorException:\n+          // KeeperErrorCode = SystemError\n+          //\n+          // However, even when above flakes happen, shutdown call does get completed even if\n+          // RPC call has failure. Hence, subsequent retries will never succeed as HMaster is\n+          // already shutdown. Hence, it can fail. To resolve it, after making one shutdown()\n+          // call, we are ignoring IOException.\n+          htu.getConnection().getAdmin().shutdown();\n+          LOG.info(\"Shutdown RPC sent.\");\n+        } catch (IOException | CompletionException e) {\n+          LOG.warn(\"Failed to establish connection.\", e);", "originalCommit": "83c052241882534ecec30a36134334e919319256", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMTA1NA==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424421054", "bodyText": "@ndimiduk Are you in favor of checking the root cause like the first commit: 04260b5#diff-144b3c3611227c12067b788b985183f9R182  &&  04260b5#diff-144b3c3611227c12067b788b985183f9R207 ?\ncause message Failed contacting masters after 1 attempts with MasterRegistry being wrapped inside RetriesExhaustedException.", "author": "virajjasani", "createdAt": "2020-05-13T13:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTkxNg==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424795916", "bodyText": "Thanks for the links to the previous commits. GH makes it difficult for me to follow previous conversation.\nOkay, so if you move this code out of the CompletableFuture, the CompletionException can just be re-thrown. It indicates a client-side problem, and there's nothing the test should try to recover.\nI would not catch IOException either, just let it bubble up. Instead, I would focus on meaningful subclasses of IOException. RetriesExhaustedException is a good place to work from: you know your client made some effort. There's potentially multiple cause instances under there, so i guess just pick one to work with, probably the last one. If it's a descendent of java.net.SocketException, you know the client couldn't get anywhere -- how should the test behave if the the master is not running?\nAfter that, I'm not really sure what's thrown in what cases. Our API's checked exception definitions aren't strong enough for me know by reading the interfaces. However, pretty much anything else means the client managed to get the RPC over to the server. I think that fact alone is enough to consider this part of the test has succeeded at its goal. Until the myriad other issues in master startup and shutdown are resolved, I think this is the best the client can hope for (for what it's worth, I think this test will continue to be flakey until those master-side problems are solved, and they cannot be resolved perfectly by client-side gymnastics).\nYou've looked at it, and seen the errors and test failures, more recently than I have, so what do you think? What brought you to this ticket in the first place? Are there more specific subclasses of IOException that are thrown, which you can use to reasonably address that specific condition? Paste the stack traces into Jira and the commit message so we can follow your effort.\nAnd thank you for your effort -- test fixing is usually thankless drudgery but it makes all of our lives better :)", "author": "ndimiduk", "createdAt": "2020-05-13T23:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MDIxMg==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424880212", "bodyText": "Thanks @ndimiduk\nLet me put the code reference of the link that I mentioned. This is what I had in my first commit:\n          } catch (IOException|CompletionException e) {\n            LOG.error(\"Failed to establish connection.\");\n            if (connectionFailedWithMaster(e)) {\n              return true;\n            }\n          }\n\n  private boolean connectionFailedWithMaster(Exception e) {\n    if (e instanceof RetriesExhaustedException) {\n      Throwable cause = e.getCause();\n      if (cause instanceof MasterRegistryFetchException) {\n        cause = cause.getCause();\n        if (cause instanceof RetriesExhaustedException) {\n          final String message = cause.getMessage();\n          return message != null && message\n            .startsWith(\"Failed contacting masters after 1 attempts\");\n        }\n      }\n    }\n    return false;\n  }\n\nreturn true in the first code block indicates returning true to waitFor().", "author": "virajjasani", "createdAt": "2020-05-14T05:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzM3Mw==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424883373", "bodyText": "@ndimiduk @bharathv\nI will remove CompletionException from catch list. And what about IOException? Good to follow above code to find out the root cause message and accordingly handle it?\nThis is what I had in my first commit and then Bharath and I came to conclusion that it's bit hacky and why not just handle IOException and not worry about cause. But now that I again think of it, you are right, although there are less chances of having different root cause for IOException but still it's good to be specific, that way not too hacky right?", "author": "virajjasani", "createdAt": "2020-05-14T05:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0ODg2NQ==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r425448865", "bodyText": "I think the MasterRegistryFetchException is only valid if we re-try shutdown() rpcs. First shutdown() throws an IOException (some subclass of it) and shuts down the master, the second (and later) shutdowns can't find a master to issue a shutdown and the stub fails and throws this MasterRegistryFetchException.\nNow that we decided to only do a single shutdown, we should either see the specific exception (derivate of IOException when shutdown failed) or no exception at all (if shutdown is a success, which is 99% of the test runs). I think we are good if we catch and log the first exception (don't remember the exact checked exception type).\nThe reason I suggested to keep the checks simple and catch the exception and log is because, if there was any issue in the RPC, that'd anyway reflect in the failure of shutdown join thread and the test fails and we have the exception logged (we don't need to go fancy on checking exception.getCause() recursively).\nI think what Nick is suggesting is to catch the specific subclass of IOException that is thrown if shutdown() fails.  If we do that, instead of logging the exception and test failing in masterThread.join(), (any other) exception is propagated to the test runner and test fails. Either way the test is fails and we will have the exception, so I'm fine with the approach. @ndimiduk Correct me if I got you wrong..", "author": "bharathv", "createdAt": "2020-05-14T21:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMDEyMg==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r425700122", "bodyText": "Sounds good, but we can't catch the root cause Exception directly, which in our case is ConnectionClosedException. So we catch RetriesExhaustedException first and look for root cause:\n      } catch (RetriesExhaustedException e) {\n        if (e.getCause() instanceof ConnectionClosedException) {\n          LOG.info(\"Connection is Closed, ZK is not reachable.\", e);\n        } else {\n          throw e;\n        }\n      }", "author": "virajjasani", "createdAt": "2020-05-15T10:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MTI4MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjEzOQ==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424092139", "bodyText": "Since I wrote this code, I realized that this assertNotEquals wrapper is not necessary. Down inside the call hierarchy of this method, there's a default setting that has timeout throw an exception. If you provide an ExplainingPredicate with an implementation of String explainFailure() you can control the error message. A little more convenient than the outer assertion.", "author": "ndimiduk", "createdAt": "2020-05-12T23:33:42Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterShutdown.java", "diffHunk": "@@ -151,19 +152,46 @@ public void testMasterShutdownBeforeStartingAnyRegionServer() throws Exception {\n       hbaseCluster = new LocalHBaseCluster(htu.getConfiguration(), options.getNumMasters(),\n         options.getNumRegionServers(), options.getMasterClass(), options.getRsClass());\n       final MasterThread masterThread = hbaseCluster.getMasters().get(0);\n+\n       masterThread.start();\n-      // Switching to master registry exacerbated a race in the master bootstrap that can result\n-      // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n-      // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n-      // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n-      // is because the connection creation with ZK registry is so slow that by then the server\n-      // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n-      // wait() in the test, waiting for the server manager to become available.\n-      final long timeout = TimeUnit.MINUTES.toMillis(10);\n-      assertNotEquals(\"Timeout waiting for server manager to become available.\",\n-        -1, Waiter.waitFor(htu.getConfiguration(), timeout,\n-          () -> masterThread.getMaster().getServerManager() != null));\n-      htu.getConnection().getAdmin().shutdown();\n+      final CompletableFuture<Void> shutdownFuture = CompletableFuture.runAsync(() -> {\n+        // Switching to master registry exacerbated a race in the master bootstrap that can result\n+        // in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because\n+        // the server manager in HMaster is not initialized by the time shutdown() RPC (below) is\n+        // made to the master. The suspected reason as to why it was uncommon before HBASE-18095\n+        // is because the connection creation with ZK registry is so slow that by then the server\n+        // manager is usually init'ed in time for the RPC to be made. For now, adding an explicit\n+        // wait() in the test, waiting for the server manager to become available.\n+        final long timeout = TimeUnit.MINUTES.toMillis(10);\n+        assertNotEquals(\"timeout waiting for server manager to become available.\", -1,", "originalCommit": "83c052241882534ecec30a36134334e919319256", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMzA0Ng==", "url": "https://github.com/apache/hbase/pull/1690#discussion_r424423046", "bodyText": "Sure let me check that. I was also following Assertion errors so far on top of waitFor().", "author": "virajjasani", "createdAt": "2020-05-13T13:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjEzOQ=="}], "type": "inlineReview", "revised_code": null}]}