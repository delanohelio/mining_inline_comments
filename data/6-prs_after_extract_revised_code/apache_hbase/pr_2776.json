{"pr_number": 2776, "pr_title": "HBASE-24850 CellComparator perf improvement", "pr_createdAt": "2020-12-14T10:26:24Z", "pr_url": "https://github.com/apache/hbase/pull/2776", "timeline": [{"oid": "3fb2ecdf1e758630ce384e6bf5fce146918b8ed0", "url": "https://github.com/apache/hbase/commit/3fb2ecdf1e758630ce384e6bf5fce146918b8ed0", "message": "Using ContiguousCellFormat as a marker alone", "committedDate": "2020-12-14T10:22:25Z", "type": "commit"}, {"oid": "649252391be079db15c1fe6ef74cb6f6264444ac", "url": "https://github.com/apache/hbase/commit/649252391be079db15c1fe6ef74cb6f6264444ac", "message": "Commit the new file", "committedDate": "2020-12-14T10:27:24Z", "type": "commit"}, {"oid": "00ed663366321ce65dfb80b5482ecec321a7a62b", "url": "https://github.com/apache/hbase/commit/00ed663366321ce65dfb80b5482ecec321a7a62b", "message": "Fix the comparator logic that was an oversight", "committedDate": "2020-12-14T12:22:06Z", "type": "commit"}, {"oid": "7d73927371ffa8e6bf8dc97550859a7da81e8164", "url": "https://github.com/apache/hbase/commit/7d73927371ffa8e6bf8dc97550859a7da81e8164", "message": "Fix the sequenceId check order", "committedDate": "2020-12-14T17:13:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU5MjI0Ng==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r542592246", "bodyText": "Say a bit more what you mean here... if you make a new patch (nit)", "author": "saintstack", "createdAt": "2020-12-14T18:02:08Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/ContiguousCellFormat.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ *  A marker interface that indicates that the cells follow the KV serialization pattern.", "originalCommit": "7d73927371ffa8e6bf8dc97550859a7da81e8164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ea3a7ba1ef07a7487b7b95e11acdb4ae555ab9f", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/ContiguousCellFormat.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/ContiguousCellFormat.java\ndeleted file mode 100644\nindex f28861eaf0..0000000000\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/ContiguousCellFormat.java\n+++ /dev/null\n\n@@ -1,28 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hadoop.hbase;\n-\n-import org.apache.yetus.audience.InterfaceAudience;\n-\n-/**\n- *  A marker interface that indicates that the cells follow the KV serialization pattern.\n- */\n-@InterfaceAudience.Private\n-public interface ContiguousCellFormat {\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU5NDUwNA==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r542594504", "bodyText": "So, these methods are not part of the Cell Interface. They are package private. The CellComparator is in same package. It makes use of these package private methods. I think that is fine. I don't think we need the marker interface in this case given all current Cell implementations are 'contiguous'? I say this because there are already too many Cell Interfaces. Lets worry about adding a Marker interface later, when we are adding a new Cell type?", "author": "saintstack", "createdAt": "2020-12-14T18:05:22Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java", "diffHunk": "@@ -1396,7 +1403,14 @@ public int getQualifierOffset() {\n    * @return Qualifier offset\n    */\n   private int getQualifierOffset(int foffset) {\n-    return foffset + getFamilyLength(foffset);\n+    return getQualifierOffset(foffset, getFamilyLength());\n+  }\n+\n+  /**\n+   * @return Qualifier offset\n+   */\n+  int getQualifierOffset(int foffset, int flength) {", "originalCommit": "7d73927371ffa8e6bf8dc97550859a7da81e8164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg0NjcwMw==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r544846703", "bodyText": "Done", "author": "ramkrish86", "createdAt": "2020-12-17T06:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU5NDUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NTIzNQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546265235", "bodyText": "Looks good", "author": "saintstack", "createdAt": "2020-12-19T17:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU5NDUwNA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "b881f85dfed4bf6e3ae9957c7aa1018ade4a3d9f", "url": "https://github.com/apache/hbase/commit/b881f85dfed4bf6e3ae9957c7aa1018ade4a3d9f", "message": "Adding few more static methods that helps in scan flow like query\nmatcher where we have more cols", "committedDate": "2020-12-16T07:00:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMjExNw==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r544702117", "bodyText": "Can be abstract this into a separate method, say KVCompare? Per discussion in the jira, this size of this method is too big to be inlined.", "author": "huaxiangsun", "createdAt": "2020-12-16T23:39:43Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -82,6 +86,337 @@ public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n     return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n   }\n \n+  /**\n+   * Compares cells that are of type {@link ContiguousCellFormat}. It is basically to peel off the common\n+   * comparisons that happen and on top of it make the parsing of individual cell items only once.\n+   * @param l the left cell\n+   * @param r the right cell\n+   * @param ignoreSequenceid if to ignore the sequence id\n+   * @return return > 0 if left cell is bigger, < 0 if right is bigger, == 0 if both cells are same\n+   */\n+  public final static int compare(final ContiguousCellFormat l, final ContiguousCellFormat r, boolean ignoreSequenceid) {\n+    int diff = 0;\n+    if (l instanceof KeyValue && r instanceof KeyValue) {", "originalCommit": "3fb2ecdf1e758630ce384e6bf5fce146918b8ed0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ea3a7ba1ef07a7487b7b95e11acdb4ae555ab9f", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex 014f374451..5e396b9f33 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -58,363 +58,365 @@ public class CellComparatorImpl implements CellComparator {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n \n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ContiguousCellFormat && b instanceof ContiguousCellFormat) {\n-      diff = compare((ContiguousCellFormat)a, (ContiguousCellFormat)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareBBKVvsKV((ByteBufferKeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n-      // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-      return ignoreSequenceid ? diff\n-          : Longs.compare(((ExtendedCell) a).getSequenceId(), ((ExtendedCell) b).getSequenceId());\n     } else {\n-      diff = compareRows(a, b);\n+      int leftRowLength = l.getRowLength();\n+      int rightRowLength = l.getRowLength();\n+      diff = compareRows(l, leftRowLength, r, rightRowLength);\n       if (diff != 0) {\n         return diff;\n       }\n \n-      diff = compareWithoutRow(a, b);\n+      diff = compareWithoutRow(l, r);\n       if (diff != 0) {\n         return diff;\n       }\n     }\n-\n     // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-    return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n+    return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n   }\n \n-  /**\n-   * Compares cells that are of type {@link ContiguousCellFormat}. It is basically to peel off the common\n-   * comparisons that happen and on top of it make the parsing of individual cell items only once.\n-   * @param l the left cell\n-   * @param r the right cell\n-   * @param ignoreSequenceid if to ignore the sequence id\n-   * @return return > 0 if left cell is bigger, < 0 if right is bigger, == 0 if both cells are same\n-   */\n-  public final static int compare(final ContiguousCellFormat l, final ContiguousCellFormat r, boolean ignoreSequenceid) {\n-    int diff = 0;\n-    if (l instanceof KeyValue && r instanceof KeyValue) {\n-      KeyValue left = (KeyValue) l;\n-      KeyValue right = (KeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n-        right.getRowArray(), right.getRowOffset(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+  private static int compareBBKV(final ByteBufferKeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      // No need of right row length below here.\n+    // No need of right row length below here.\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n-      diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n-        right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+      leftFamilyLength, right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare qualifiers\n-      diff = Bytes.compareTo(left.getQualifierArray(),\n-        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n-        rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierByteBuffer(),\n+      right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n-    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n-      KeyValue left = (KeyValue) l;\n-      ByteBufferKeyValue right = (ByteBufferKeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n-        right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareBBKVvsKV(final ByteBufferKeyValue left, final KeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowArray(), right.getRowOffset(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n-        right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierArray(),\n-        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierByteBuffer(),\n-        right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+      leftFamilyLength, right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(left.getTimestamp(rightKeyLength), right.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+      rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n-      ByteBufferKeyValue left = (ByteBufferKeyValue) l;\n-      KeyValue right = (KeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n-        leftRowLength, right.getRowArray(), right.getRowOffset(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareKVVsBBKV(final KeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+      right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n-        leftFamilyLength, right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n-        left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n-        rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+      right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierArray(),\n+      left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierByteBuffer(),\n+      right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-    } else {\n-      ByteBufferKeyValue left = (ByteBufferKeyValue) l;\n-      ByteBufferKeyValue right = (ByteBufferKeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n-        leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareKeyValues(final KeyValue left, final KeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+      right.getRowArray(), right.getRowOffset(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n-        leftFamilyLength, right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n-        left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierByteBuffer(),\n-        right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+    diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+      right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = Bytes.compareTo(left.getQualifierArray(),\n+      left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+      rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n     }\n+\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMjIxNw==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r544702217", "bodyText": "Ditto here.", "author": "huaxiangsun", "createdAt": "2020-12-16T23:40:03Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -82,6 +86,337 @@ public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n     return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n   }\n \n+  /**\n+   * Compares cells that are of type {@link ContiguousCellFormat}. It is basically to peel off the common\n+   * comparisons that happen and on top of it make the parsing of individual cell items only once.\n+   * @param l the left cell\n+   * @param r the right cell\n+   * @param ignoreSequenceid if to ignore the sequence id\n+   * @return return > 0 if left cell is bigger, < 0 if right is bigger, == 0 if both cells are same\n+   */\n+  public final static int compare(final ContiguousCellFormat l, final ContiguousCellFormat r, boolean ignoreSequenceid) {\n+    int diff = 0;\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      KeyValue left = (KeyValue) l;\n+      KeyValue right = (KeyValue) r;\n+      // Compare Rows. Cache row length.\n+      int leftRowLength = left.getRowLength();\n+      int rightRowLength = right.getRowLength();\n+      diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+        right.getRowArray(), right.getRowOffset(), rightRowLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+      // long).\n+      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+      // that\n+      // we can't do memcmp w/ special rules like this.\n+      // TODO: Is there a test for this behavior?\n+      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+      int leftKeyLength = left.getKeyLength();\n+      int leftQualifierLength =\n+          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+      // No need of left row length below here.\n+\n+      byte leftType = left.getTypeByte(leftKeyLength);\n+      if (leftFamilyLength + leftQualifierLength == 0\n+          && leftType == KeyValue.Type.Minimum.getCode()) {\n+        // left is \"bigger\", i.e. it appears later in the sorted order\n+        return 1;\n+      }\n+\n+      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+      int rightKeyLength = right.getKeyLength();\n+      int rightQualifierLength =\n+          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+      // No need of right row length below here.\n+\n+      byte rightType = right.getTypeByte(rightKeyLength);\n+      if (rightFamilyLength + rightQualifierLength == 0\n+          && rightType == KeyValue.Type.Minimum.getCode()) {\n+        return -1;\n+      }\n+\n+      // Compare families.\n+      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+      diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+        right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare qualifiers\n+      diff = Bytes.compareTo(left.getQualifierArray(),\n+        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+        rightQualifierLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Timestamps.\n+      // Swap order we pass into compare so we get DESCENDING order.\n+      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare types. Let the delete types sort ahead of puts; i.e. types\n+      // of higher numbers sort before those of lesser numbers. Maximum (255)\n+      // appears ahead of everything, and minimum (0) appears after\n+      // everything.\n+      return (0xff & rightType) - (0xff & leftType);\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      KeyValue left = (KeyValue) l;\n+      ByteBufferKeyValue right = (ByteBufferKeyValue) r;\n+      // Compare Rows. Cache row length.\n+      int leftRowLength = left.getRowLength();\n+      int rightRowLength = right.getRowLength();\n+      diff = ByteBufferUtils.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+        right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+      // long).\n+      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+      // that\n+      // we can't do memcmp w/ special rules like this.\n+      // TODO: Is there a test for this behavior?\n+      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+      int leftKeyLength = left.getKeyLength();\n+      int leftQualifierLength =\n+          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+      // No need of left row length below here.\n+\n+      byte leftType = left.getTypeByte(leftKeyLength);\n+      if (leftFamilyLength + leftQualifierLength == 0\n+          && leftType == KeyValue.Type.Minimum.getCode()) {\n+        // left is \"bigger\", i.e. it appears later in the sorted order\n+        return 1;\n+      }\n+\n+      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+      int rightKeyLength = right.getKeyLength();\n+      int rightQualifierLength =\n+          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+      // No need of right row length below here.\n+\n+      byte rightType = right.getTypeByte(rightKeyLength);\n+      if (rightFamilyLength + rightQualifierLength == 0\n+          && rightType == KeyValue.Type.Minimum.getCode()) {\n+        return -1;\n+      }\n+\n+      // Compare families.\n+      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+      int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+      diff = ByteBufferUtils.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+        right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare qualifiers\n+      diff = ByteBufferUtils.compareTo(left.getQualifierArray(),\n+        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+        right.getQualifierByteBuffer(),\n+        right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Timestamps.\n+      // Swap order we pass into compare so we get DESCENDING order.\n+      diff = Long.compare(left.getTimestamp(rightKeyLength), right.getTimestamp(leftKeyLength));\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare types. Let the delete types sort ahead of puts; i.e. types\n+      // of higher numbers sort before those of lesser numbers. Maximum (255)\n+      // appears ahead of everything, and minimum (0) appears after\n+      // everything.\n+      return (0xff & rightType) - (0xff & leftType);\n+\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      ByteBufferKeyValue left = (ByteBufferKeyValue) l;\n+      KeyValue right = (KeyValue) r;\n+      // Compare Rows. Cache row length.\n+      int leftRowLength = left.getRowLength();\n+      int rightRowLength = right.getRowLength();\n+      diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+        leftRowLength, right.getRowArray(), right.getRowOffset(), rightRowLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+      // long).\n+      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+      // that\n+      // we can't do memcmp w/ special rules like this.\n+      // TODO: Is there a test for this behavior?\n+      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+      int leftKeyLength = left.getKeyLength();\n+      int leftQualifierLength =\n+          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+      // No need of left row length below here.\n+\n+      byte leftType = left.getTypeByte(leftKeyLength);\n+      if (leftFamilyLength + leftQualifierLength == 0\n+          && leftType == KeyValue.Type.Minimum.getCode()) {\n+        // left is \"bigger\", i.e. it appears later in the sorted order\n+        return 1;\n+      }\n+\n+      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+      int rightKeyLength = right.getKeyLength();\n+      int rightQualifierLength =\n+          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+      // No need of right row length below here.\n+\n+      byte rightType = right.getTypeByte(rightKeyLength);\n+      if (rightFamilyLength + rightQualifierLength == 0\n+          && rightType == KeyValue.Type.Minimum.getCode()) {\n+        return -1;\n+      }\n+\n+      // Compare families.\n+      int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+      diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+        leftFamilyLength, right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare qualifiers\n+      diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+        left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+        rightQualifierLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Timestamps.\n+      // Swap order we pass into compare so we get DESCENDING order.\n+      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare types. Let the delete types sort ahead of puts; i.e. types\n+      // of higher numbers sort before those of lesser numbers. Maximum (255)\n+      // appears ahead of everything, and minimum (0) appears after\n+      // everything.\n+      return (0xff & rightType) - (0xff & leftType);\n+\n+    } else {", "originalCommit": "3fb2ecdf1e758630ce384e6bf5fce146918b8ed0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ea3a7ba1ef07a7487b7b95e11acdb4ae555ab9f", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex 014f374451..5e396b9f33 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -58,363 +58,365 @@ public class CellComparatorImpl implements CellComparator {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n \n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ContiguousCellFormat && b instanceof ContiguousCellFormat) {\n-      diff = compare((ContiguousCellFormat)a, (ContiguousCellFormat)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareBBKVvsKV((ByteBufferKeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n-      // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-      return ignoreSequenceid ? diff\n-          : Longs.compare(((ExtendedCell) a).getSequenceId(), ((ExtendedCell) b).getSequenceId());\n     } else {\n-      diff = compareRows(a, b);\n+      int leftRowLength = l.getRowLength();\n+      int rightRowLength = l.getRowLength();\n+      diff = compareRows(l, leftRowLength, r, rightRowLength);\n       if (diff != 0) {\n         return diff;\n       }\n \n-      diff = compareWithoutRow(a, b);\n+      diff = compareWithoutRow(l, r);\n       if (diff != 0) {\n         return diff;\n       }\n     }\n-\n     // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-    return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n+    return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n   }\n \n-  /**\n-   * Compares cells that are of type {@link ContiguousCellFormat}. It is basically to peel off the common\n-   * comparisons that happen and on top of it make the parsing of individual cell items only once.\n-   * @param l the left cell\n-   * @param r the right cell\n-   * @param ignoreSequenceid if to ignore the sequence id\n-   * @return return > 0 if left cell is bigger, < 0 if right is bigger, == 0 if both cells are same\n-   */\n-  public final static int compare(final ContiguousCellFormat l, final ContiguousCellFormat r, boolean ignoreSequenceid) {\n-    int diff = 0;\n-    if (l instanceof KeyValue && r instanceof KeyValue) {\n-      KeyValue left = (KeyValue) l;\n-      KeyValue right = (KeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n-        right.getRowArray(), right.getRowOffset(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+  private static int compareBBKV(final ByteBufferKeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      // No need of right row length below here.\n+    // No need of right row length below here.\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n-      diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n-        right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+      leftFamilyLength, right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare qualifiers\n-      diff = Bytes.compareTo(left.getQualifierArray(),\n-        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n-        rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierByteBuffer(),\n+      right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n-    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n-      KeyValue left = (KeyValue) l;\n-      ByteBufferKeyValue right = (ByteBufferKeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n-        right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareBBKVvsKV(final ByteBufferKeyValue left, final KeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowArray(), right.getRowOffset(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n-        right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierArray(),\n-        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierByteBuffer(),\n-        right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+      leftFamilyLength, right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(left.getTimestamp(rightKeyLength), right.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+      rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n-      ByteBufferKeyValue left = (ByteBufferKeyValue) l;\n-      KeyValue right = (KeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n-        leftRowLength, right.getRowArray(), right.getRowOffset(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareKVVsBBKV(final KeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+      right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n-        leftFamilyLength, right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n-        left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n-        rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+      right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierArray(),\n+      left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierByteBuffer(),\n+      right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-    } else {\n-      ByteBufferKeyValue left = (ByteBufferKeyValue) l;\n-      ByteBufferKeyValue right = (ByteBufferKeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n-        leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareKeyValues(final KeyValue left, final KeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+      right.getRowArray(), right.getRowOffset(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n-        leftFamilyLength, right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n-        left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierByteBuffer(),\n-        right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+    diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+      right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = Bytes.compareTo(left.getQualifierArray(),\n+      left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+      rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n     }\n+\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMzQxNg==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r544703416", "bodyText": "For     } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\nand } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) { cases, essentially, there are same.\nCan we have a method for BBKVCompare() and swap parameters for these two cases?", "author": "huaxiangsun", "createdAt": "2020-12-16T23:43:04Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -82,6 +86,337 @@ public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n     return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n   }\n \n+  /**\n+   * Compares cells that are of type {@link ContiguousCellFormat}. It is basically to peel off the common\n+   * comparisons that happen and on top of it make the parsing of individual cell items only once.\n+   * @param l the left cell\n+   * @param r the right cell\n+   * @param ignoreSequenceid if to ignore the sequence id\n+   * @return return > 0 if left cell is bigger, < 0 if right is bigger, == 0 if both cells are same\n+   */\n+  public final static int compare(final ContiguousCellFormat l, final ContiguousCellFormat r, boolean ignoreSequenceid) {\n+    int diff = 0;\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      KeyValue left = (KeyValue) l;\n+      KeyValue right = (KeyValue) r;\n+      // Compare Rows. Cache row length.\n+      int leftRowLength = left.getRowLength();\n+      int rightRowLength = right.getRowLength();\n+      diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+        right.getRowArray(), right.getRowOffset(), rightRowLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+      // long).\n+      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+      // that\n+      // we can't do memcmp w/ special rules like this.\n+      // TODO: Is there a test for this behavior?\n+      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+      int leftKeyLength = left.getKeyLength();\n+      int leftQualifierLength =\n+          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+      // No need of left row length below here.\n+\n+      byte leftType = left.getTypeByte(leftKeyLength);\n+      if (leftFamilyLength + leftQualifierLength == 0\n+          && leftType == KeyValue.Type.Minimum.getCode()) {\n+        // left is \"bigger\", i.e. it appears later in the sorted order\n+        return 1;\n+      }\n+\n+      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+      int rightKeyLength = right.getKeyLength();\n+      int rightQualifierLength =\n+          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+      // No need of right row length below here.\n+\n+      byte rightType = right.getTypeByte(rightKeyLength);\n+      if (rightFamilyLength + rightQualifierLength == 0\n+          && rightType == KeyValue.Type.Minimum.getCode()) {\n+        return -1;\n+      }\n+\n+      // Compare families.\n+      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+      diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+        right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare qualifiers\n+      diff = Bytes.compareTo(left.getQualifierArray(),\n+        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+        rightQualifierLength);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Timestamps.\n+      // Swap order we pass into compare so we get DESCENDING order.\n+      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+      if (diff != 0) {\n+        return diff;\n+      }\n+\n+      // Compare types. Let the delete types sort ahead of puts; i.e. types\n+      // of higher numbers sort before those of lesser numbers. Maximum (255)\n+      // appears ahead of everything, and minimum (0) appears after\n+      // everything.\n+      return (0xff & rightType) - (0xff & leftType);\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {", "originalCommit": "3fb2ecdf1e758630ce384e6bf5fce146918b8ed0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ea3a7ba1ef07a7487b7b95e11acdb4ae555ab9f", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex 014f374451..5e396b9f33 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -58,363 +58,365 @@ public class CellComparatorImpl implements CellComparator {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n \n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ContiguousCellFormat && b instanceof ContiguousCellFormat) {\n-      diff = compare((ContiguousCellFormat)a, (ContiguousCellFormat)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareBBKVvsKV((ByteBufferKeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n-      // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-      return ignoreSequenceid ? diff\n-          : Longs.compare(((ExtendedCell) a).getSequenceId(), ((ExtendedCell) b).getSequenceId());\n     } else {\n-      diff = compareRows(a, b);\n+      int leftRowLength = l.getRowLength();\n+      int rightRowLength = l.getRowLength();\n+      diff = compareRows(l, leftRowLength, r, rightRowLength);\n       if (diff != 0) {\n         return diff;\n       }\n \n-      diff = compareWithoutRow(a, b);\n+      diff = compareWithoutRow(l, r);\n       if (diff != 0) {\n         return diff;\n       }\n     }\n-\n     // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-    return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n+    return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n   }\n \n-  /**\n-   * Compares cells that are of type {@link ContiguousCellFormat}. It is basically to peel off the common\n-   * comparisons that happen and on top of it make the parsing of individual cell items only once.\n-   * @param l the left cell\n-   * @param r the right cell\n-   * @param ignoreSequenceid if to ignore the sequence id\n-   * @return return > 0 if left cell is bigger, < 0 if right is bigger, == 0 if both cells are same\n-   */\n-  public final static int compare(final ContiguousCellFormat l, final ContiguousCellFormat r, boolean ignoreSequenceid) {\n-    int diff = 0;\n-    if (l instanceof KeyValue && r instanceof KeyValue) {\n-      KeyValue left = (KeyValue) l;\n-      KeyValue right = (KeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n-        right.getRowArray(), right.getRowOffset(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+  private static int compareBBKV(final ByteBufferKeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      // No need of right row length below here.\n+    // No need of right row length below here.\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n-      diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n-        right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+      leftFamilyLength, right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare qualifiers\n-      diff = Bytes.compareTo(left.getQualifierArray(),\n-        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n-        rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierByteBuffer(),\n+      right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n-    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n-      KeyValue left = (KeyValue) l;\n-      ByteBufferKeyValue right = (ByteBufferKeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n-        right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareBBKVvsKV(final ByteBufferKeyValue left, final KeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowArray(), right.getRowOffset(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n-        right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierArray(),\n-        left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierByteBuffer(),\n-        right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+      leftFamilyLength, right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(left.getTimestamp(rightKeyLength), right.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+      rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n-      ByteBufferKeyValue left = (ByteBufferKeyValue) l;\n-      KeyValue right = (KeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n-        leftRowLength, right.getRowArray(), right.getRowOffset(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareKVVsBBKV(final KeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+      right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n-        leftFamilyLength, right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n-        left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n-        rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+      right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierArray(),\n+      left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierByteBuffer(),\n+      right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-    } else {\n-      ByteBufferKeyValue left = (ByteBufferKeyValue) l;\n-      ByteBufferKeyValue right = (ByteBufferKeyValue) r;\n-      // Compare Rows. Cache row length.\n-      int leftRowLength = left.getRowLength();\n-      int rightRowLength = right.getRowLength();\n-      diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n-        leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }\n \n-      // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n-      // order, regardless of the timestamp. This is used for specifying the last key/value in a\n-      // given row, because there is no \"lexicographically last column\" (it would be infinitely\n-      // long).\n-      // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n-      // that\n-      // we can't do memcmp w/ special rules like this.\n-      // TODO: Is there a test for this behavior?\n-      int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n-      int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n-      int leftKeyLength = left.getKeyLength();\n-      int leftQualifierLength =\n-          left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n-\n-      // No need of left row length below here.\n-\n-      byte leftType = left.getTypeByte(leftKeyLength);\n-      if (leftFamilyLength + leftQualifierLength == 0\n-          && leftType == KeyValue.Type.Minimum.getCode()) {\n-        // left is \"bigger\", i.e. it appears later in the sorted order\n-        return 1;\n-      }\n+  private static int compareKeyValues(final KeyValue left, final KeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+      right.getRowArray(), right.getRowOffset(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n-      int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n-      int rightKeyLength = right.getKeyLength();\n-      int rightQualifierLength =\n-          right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n \n-      // No need of right row length below here.\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n \n-      byte rightType = right.getTypeByte(rightKeyLength);\n-      if (rightFamilyLength + rightQualifierLength == 0\n-          && rightType == KeyValue.Type.Minimum.getCode()) {\n-        return -1;\n-      }\n+    // No need of right row length below here.\n \n-      // Compare families.\n-      int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n-      int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n-      diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n-        leftFamilyLength, right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n \n-      // Compare qualifiers\n-      diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n-        left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n-        right.getQualifierByteBuffer(),\n-        right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+    diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+      right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Timestamps.\n-      // Swap order we pass into compare so we get DESCENDING order.\n-      diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n-      if (diff != 0) {\n-        return diff;\n-      }\n+    // Compare qualifiers\n+    diff = Bytes.compareTo(left.getQualifierArray(),\n+      left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+      rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n \n-      // Compare types. Let the delete types sort ahead of puts; i.e. types\n-      // of higher numbers sort before those of lesser numbers. Maximum (255)\n-      // appears ahead of everything, and minimum (0) appears after\n-      // everything.\n-      return (0xff & rightType) - (0xff & leftType);\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n     }\n+\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n   }\n \n   /**\n"}}, {"oid": "9ea3a7ba1ef07a7487b7b95e11acdb4ae555ab9f", "url": "https://github.com/apache/hbase/commit/9ea3a7ba1ef07a7487b7b95e11acdb4ae555ab9f", "message": "Remove ContiguousCellFormat and ensure compare() can be inlined", "committedDate": "2020-12-17T06:34:55Z", "type": "commit"}, {"oid": "b46ce5cf148e4e0b4ddf6dc3fe6849094b61d100", "url": "https://github.com/apache/hbase/commit/b46ce5cf148e4e0b4ddf6dc3fe6849094b61d100", "message": "applying negation as per review comment", "committedDate": "2020-12-17T07:45:14Z", "type": "commit"}, {"oid": "0915e94ec039ac58392976bce0e260b455f9d073", "url": "https://github.com/apache/hbase/commit/0915e94ec039ac58392976bce0e260b455f9d073", "message": "Fix checkstyle comments", "committedDate": "2020-12-17T10:44:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MjYxOQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545552619", "bodyText": "More efficient way is ((lrowlength == rrowlength) && (lfamlength == rfamlength) && (lqlength == rqlength) ?", "author": "anoopsjohn", "createdAt": "2020-12-18T03:37:50Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java", "diffHunk": "@@ -1598,16 +1621,21 @@ public static boolean matchingRows(final Cell left, final Cell right) {\n    * @return True if same row and column.\n    */\n   public static boolean matchingRowColumn(final Cell left, final Cell right) {\n-    if ((left.getRowLength() + left.getFamilyLength()\n-        + left.getQualifierLength()) != (right.getRowLength() + right.getFamilyLength()\n-            + right.getQualifierLength())) {\n+    short lrowlength = left.getRowLength();\n+    short rrowlength = right.getRowLength();\n+    byte lfamlength = left.getFamilyLength();\n+    byte rfamlength = right.getFamilyLength();\n+    int lqlength = left.getQualifierLength();\n+    int rqlength = right.getQualifierLength();\n+    // match length\n+    if ((lrowlength + lfamlength + lqlength) != (rrowlength + rfamlength + rqlength)) {", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1OTIwMg==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546259202", "bodyText": "I like the @anoopsjohn suggestion", "author": "saintstack", "createdAt": "2020-12-19T16:56:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MjYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\nindex 1e706bc8df..b51c564111 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\n\n@@ -1627,8 +1627,9 @@ public final class CellUtil {\n     byte rfamlength = right.getFamilyLength();\n     int lqlength = left.getQualifierLength();\n     int rqlength = right.getQualifierLength();\n+\n     // match length\n-    if ((lrowlength + lfamlength + lqlength) != (rrowlength + rfamlength + rqlength)) {\n+    if ((lrowlength != rrowlength) || (lfamlength != rfamlength) || (lqlength != rqlength)) {\n       return false;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NTYxOQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545555619", "bodyText": "In read path mostly both cells will be either KV or BBKV.  In write path we have BBKV now? I think some patches did that for master branch already. we create the ChunkCell or so. Is that reverted? Pls check.\nSo better to do both KV check and then both BBKV followed by other 2 options?\nTe perf tests u did now was giving all cells are KVs right?  is it possible to test for both cells as BBKV also?  That will be better.  May be a JMH test?\nThe split of private methods came good now.", "author": "anoopsjohn", "createdAt": "2020-12-18T03:48:54Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,287 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NTQ3OQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546265479", "bodyText": "The perf tests were PE @ramkrish86 ? Yeah, we need a JMH test so can do the combinations @anoopsjohn suggests. I can work on that...", "author": "saintstack", "createdAt": "2020-12-19T17:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NTYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex ac8c7e7632..059dd0a6fe 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -76,8 +76,6 @@ public class CellComparatorImpl implements CellComparator {\n         // negate- Findbugs will complain?\n         return -diff;\n       }\n-      // if ignoreSequenceid then the diff will be 0.\n-      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n     } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n       diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NTg3Mw==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545555873", "bodyText": "Is this line needed here? All other branches fall back to the last line in this method.  Any specific reason for doing it here?", "author": "anoopsjohn", "createdAt": "2020-12-18T03:49:52Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,287 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) r, (ByteBufferKeyValue) l);\n+      if (diff != 0) {\n+        // negate- Findbugs will complain?\n+        return -diff;\n+      }\n+      // if ignoreSequenceid then the diff will be 0.\n+      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex ac8c7e7632..059dd0a6fe 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -76,8 +76,6 @@ public class CellComparatorImpl implements CellComparator {\n         // negate- Findbugs will complain?\n         return -diff;\n       }\n-      // if ignoreSequenceid then the diff will be 0.\n-      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n     } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n       diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NjEwOQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545556109", "bodyText": "Can we extract this also to a private method pls?", "author": "anoopsjohn", "createdAt": "2020-12-18T03:50:51Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,287 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) r, (ByteBufferKeyValue) l);\n+      if (diff != 0) {\n+        // negate- Findbugs will complain?\n+        return -diff;\n+      }\n+      // if ignoreSequenceid then the diff will be 0.\n+      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n     } else {\n-      diff = compareRows(a, b);", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex ac8c7e7632..059dd0a6fe 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -76,8 +76,6 @@ public class CellComparatorImpl implements CellComparator {\n         // negate- Findbugs will complain?\n         return -diff;\n       }\n-      // if ignoreSequenceid then the diff will be 0.\n-      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n     } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n       diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1Nzg5MQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545557891", "bodyText": "We can reverse the check. Mostly leftType wont be Minimum type and so we can skip the '+' operator eval.  These were like this before.. But can we focus on these small small optimization also now?  That would be good.", "author": "anoopsjohn", "createdAt": "2020-12-18T03:57:21Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,287 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) r, (ByteBufferKeyValue) l);\n+      if (diff != 0) {\n+        // negate- Findbugs will complain?\n+        return -diff;\n+      }\n+      // if ignoreSequenceid then the diff will be 0.\n+      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n     } else {\n-      diff = compareRows(a, b);\n+      int leftRowLength = l.getRowLength();\n+      int rightRowLength = r.getRowLength();\n+      diff = compareRows(l, leftRowLength, r, rightRowLength);\n       if (diff != 0) {\n         return diff;\n       }\n \n-      diff = compareWithoutRow(a, b);\n+      diff = compareWithoutRow(l, r);\n       if (diff != 0) {\n         return diff;\n       }\n     }\n-\n     // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-    return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n+    return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+  }\n+\n+  private static int compareBBKV(final ByteBufferKeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex ac8c7e7632..059dd0a6fe 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -76,8 +76,6 @@ public class CellComparatorImpl implements CellComparator {\n         // negate- Findbugs will complain?\n         return -diff;\n       }\n-      // if ignoreSequenceid then the diff will be 0.\n-      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n     } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n       diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1Nzk4NA==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545557984", "bodyText": "Same here also", "author": "anoopsjohn", "createdAt": "2020-12-18T03:57:38Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,287 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) r, (ByteBufferKeyValue) l);\n+      if (diff != 0) {\n+        // negate- Findbugs will complain?\n+        return -diff;\n+      }\n+      // if ignoreSequenceid then the diff will be 0.\n+      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n     } else {\n-      diff = compareRows(a, b);\n+      int leftRowLength = l.getRowLength();\n+      int rightRowLength = r.getRowLength();\n+      diff = compareRows(l, leftRowLength, r, rightRowLength);\n       if (diff != 0) {\n         return diff;\n       }\n \n-      diff = compareWithoutRow(a, b);\n+      diff = compareWithoutRow(l, r);\n       if (diff != 0) {\n         return diff;\n       }\n     }\n-\n     // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-    return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n+    return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+  }\n+\n+  private static int compareBBKV(final ByteBufferKeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n+\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+    // No need of right row length below here.\n+\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex ac8c7e7632..059dd0a6fe 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -76,8 +76,6 @@ public class CellComparatorImpl implements CellComparator {\n         // negate- Findbugs will complain?\n         return -diff;\n       }\n-      // if ignoreSequenceid then the diff will be 0.\n-      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n     } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n       diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1OTAzOQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545559039", "bodyText": "Not suggesting for doing in this patch.\nBut may be we can avoid the long decodes and do compare but instead bytes level compare we can do.  We are not interested in the exact diff here anyways. A compare value of 0 or +ve number of -ve number. Add a TODO so that we can come back and do some JMH tests and if that helps, we can incorporate in all places. WDYT?", "author": "anoopsjohn", "createdAt": "2020-12-18T04:01:40Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,287 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) r, (ByteBufferKeyValue) l);\n+      if (diff != 0) {\n+        // negate- Findbugs will complain?\n+        return -diff;\n+      }\n+      // if ignoreSequenceid then the diff will be 0.\n+      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n     } else {\n-      diff = compareRows(a, b);\n+      int leftRowLength = l.getRowLength();\n+      int rightRowLength = r.getRowLength();\n+      diff = compareRows(l, leftRowLength, r, rightRowLength);\n       if (diff != 0) {\n         return diff;\n       }\n \n-      diff = compareWithoutRow(a, b);\n+      diff = compareWithoutRow(l, r);\n       if (diff != 0) {\n         return diff;\n       }\n     }\n-\n     // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-    return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n+    return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+  }\n+\n+  private static int compareBBKV(final ByteBufferKeyValue left, final ByteBufferKeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = ByteBufferUtils.compareTo(left.getRowByteBuffer(), left.getRowPosition(),\n+      leftRowLength, right.getRowByteBuffer(), right.getRowPosition(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftFamilyLength + leftQualifierLength == 0\n+        && leftType == KeyValue.Type.Minimum.getCode()) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n+\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+    // No need of right row length below here.\n+\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightFamilyLength + rightQualifierLength == 0\n+        && rightType == KeyValue.Type.Minimum.getCode()) {\n+      return -1;\n+    }\n+\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+    diff = ByteBufferUtils.compareTo(left.getFamilyByteBuffer(), leftFamilyPosition,\n+      leftFamilyLength, right.getFamilyByteBuffer(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // Compare qualifiers\n+    diff = ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      left.getQualifierPosition(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierByteBuffer(),\n+      right.getQualifierPosition(rightFamilyPosition, rightFamilyLength), rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1OTQ4Mg==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546259482", "bodyText": "Nice idea. Wonder if we can do this elsewhere?", "author": "saintstack", "createdAt": "2020-12-19T16:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1OTAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex ac8c7e7632..059dd0a6fe 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -76,8 +76,6 @@ public class CellComparatorImpl implements CellComparator {\n         // negate- Findbugs will complain?\n         return -diff;\n       }\n-      // if ignoreSequenceid then the diff will be 0.\n-      return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n     } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n       diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0ODY4Nw==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r545748687", "bodyText": "We have ByteBufferKeyValue which extends ByteBufferExtendedCell  and other sub types also.  May be its time to reduce these types. I see we have KeyOnlyByteBufferExtendedCell..  But there is some ways.. Same way will see how we can have the DBE seekers also returning Cells of type KV or BBKV.  So the optimizations will be used in case of scan over DBEed table:cf.   Will do it in a followup issue. I can do that.", "author": "anoopsjohn", "createdAt": "2020-12-18T10:42:37Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -125,38 +442,174 @@ public final int compareFamilies(Cell left, Cell right) {\n         right.getFamilyArray(), right.getFamilyOffset(), right.getFamilyLength());\n   }\n \n+  static int compareQualifiers(KeyValue left, KeyValue right) {\n+    // NOTE: Same method is in CellComparatorImpl, also private, not shared, intentionally. Not\n+    // sharing gets us a few percent more throughput in compares. If changes here or there, make\n+    // sure done in both places.\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    byte leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    byte rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+    // Compare families.\n+    int leftFamilyOffset = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyOffset = right.getFamilyOffset(rightFamilyLengthPosition);\n+\n+    // Compare qualifiers\n+    return Bytes.compareTo(left.getQualifierArray(), leftFamilyOffset + leftFamilyLength,\n+      leftQualifierLength, right.getQualifierArray(), rightFamilyOffset + rightFamilyLength,\n+      rightQualifierLength);\n+  }\n+\n+  static int compareQualifiers(KeyValue left, ByteBufferKeyValue right) {\n+    // NOTE: Same method is in CellComparatorImpl, also private, not shared, intentionally. Not\n+    // sharing gets us a few percent more throughput in compares. If changes here or there, make\n+    // sure done in both places.\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    byte leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    byte rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+    // Compare families.\n+    int leftFamilyOffset = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+\n+    // Compare qualifiers\n+    return ByteBufferUtils.compareTo(left.getQualifierArray(),\n+      leftFamilyOffset + leftFamilyLength, leftQualifierLength, right.getQualifierByteBuffer(),\n+      rightFamilyPosition + rightFamilyLength, rightQualifierLength);\n+  }\n+\n+  static int compareQualifiers(ByteBufferKeyValue left, KeyValue right) {\n+    // NOTE: Same method is in CellComparatorImpl, also private, not shared, intentionally. Not\n+    // sharing gets us a few percent more throughput in compares. If changes here or there, make\n+    // sure done in both places.\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    byte leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    byte rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyOffset = right.getFamilyOffset(rightFamilyLengthPosition);\n+\n+    // Compare qualifiers\n+    return ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      leftFamilyPosition + leftFamilyLength, leftQualifierLength, right.getQualifierArray(),\n+      rightFamilyOffset + rightFamilyLength, rightQualifierLength);\n+  }\n+\n+  static int compareQualifiers(ByteBufferKeyValue left, ByteBufferKeyValue right) {\n+    // NOTE: Same method is in CellComparatorImpl, also private, not shared, intentionally. Not\n+    // sharing gets us a few percent more throughput in compares. If changes here or there, make\n+    // sure done in both places.\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    byte leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    byte rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyPosition(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyPosition(rightFamilyLengthPosition);\n+\n+    // Compare qualifiers\n+    return ByteBufferUtils.compareTo(left.getQualifierByteBuffer(),\n+      leftFamilyPosition + leftFamilyLength, leftQualifierLength, right.getQualifierByteBuffer(),\n+      rightFamilyPosition + rightFamilyLength, rightQualifierLength);\n+  }\n+\n   /**\n    * Compare the qualifiers part of the left and right cells.\n    * @return 0 if both cells are equal, 1 if left cell is bigger than right, -1 otherwise\n    */\n   @Override\n   public final int compareQualifiers(Cell left, Cell right) {\n-    if (left instanceof ByteBufferExtendedCell && right instanceof ByteBufferExtendedCell) {\n-      return ByteBufferUtils\n-          .compareTo(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-              ((ByteBufferExtendedCell) left).getQualifierPosition(),\n-              left.getQualifierLength(), ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-              ((ByteBufferExtendedCell) right).getQualifierPosition(),\n-              right.getQualifierLength());\n-    }\n-    if (left instanceof ByteBufferExtendedCell) {\n-      return ByteBufferUtils.compareTo(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+    if ((left instanceof ByteBufferKeyValue) && (right instanceof ByteBufferKeyValue)) {\n+      return compareQualifiers((ByteBufferKeyValue) left, (ByteBufferKeyValue) right);\n+    } else if ((left instanceof KeyValue) && (right instanceof KeyValue)) {\n+      return compareQualifiers((KeyValue) left, (KeyValue) right);\n+    } else if ((left instanceof KeyValue) && (right instanceof ByteBufferKeyValue)) {\n+      return compareQualifiers((KeyValue) left, (ByteBufferKeyValue) right);\n+    } else if ((left instanceof ByteBufferKeyValue) && (right instanceof KeyValue)) {\n+      return compareQualifiers((ByteBufferKeyValue) left, (KeyValue) right);\n+    } else {\n+      if (left instanceof ByteBufferExtendedCell && right instanceof ByteBufferExtendedCell) {", "originalCommit": "0915e94ec039ac58392976bce0e260b455f9d073", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1OTYwMQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546259601", "bodyText": "+1. Not in this issue but file a follow-on.", "author": "saintstack", "createdAt": "2020-12-19T16:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0ODY4Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "url": "https://github.com/apache/hbase/commit/37579e00a65eb3deede01bdb15d6808b7e7c309e", "message": "fix review comments", "committedDate": "2020-12-18T12:05:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NTAxOQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546265019", "bodyText": "These have to be public? They are in same package as comparator and Cell types.", "author": "saintstack", "createdAt": "2020-12-19T17:55:23Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java", "diffHunk": "@@ -920,6 +930,14 @@ public static boolean matchingColumn(final Cell left, final Cell right) {\n     return matchingQualifier(left, right);\n   }\n \n+  public static boolean matchingColumn(final Cell left, final byte lFamLen, final int lQualLength,", "originalCommit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c833703fa88c046a71f725aa27936d2155bc8b72", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\nindex b51c564111..967482238b 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\n\n@@ -930,7 +930,7 @@ public final class CellUtil {\n     return matchingQualifier(left, right);\n   }\n \n-  public static boolean matchingColumn(final Cell left, final byte lFamLen, final int lQualLength,\n+  private static boolean matchingColumn(final Cell left, final byte lFamLen, final int lQualLength,\n       final Cell right, final byte rFamLen, final int rQualLength) {\n     if (!matchingFamily(left, lFamLen, right, rFamLen)) {\n       return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NTEzMQ==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546265131", "bodyText": "We are decoding ints, bytes and shorts that we might end up not using at all.", "author": "saintstack", "createdAt": "2020-12-19T17:56:14Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java", "diffHunk": "@@ -1598,16 +1621,22 @@ public static boolean matchingRows(final Cell left, final Cell right) {\n    * @return True if same row and column.\n    */\n   public static boolean matchingRowColumn(final Cell left, final Cell right) {\n-    if ((left.getRowLength() + left.getFamilyLength()\n-        + left.getQualifierLength()) != (right.getRowLength() + right.getFamilyLength()\n-            + right.getQualifierLength())) {\n+    short lrowlength = left.getRowLength();\n+    short rrowlength = right.getRowLength();\n+    byte lfamlength = left.getFamilyLength();\n+    byte rfamlength = right.getFamilyLength();\n+    int lqlength = left.getQualifierLength();\n+    int rqlength = right.getQualifierLength();", "originalCommit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c833703fa88c046a71f725aa27936d2155bc8b72", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\nindex b51c564111..967482238b 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java\n\n@@ -1623,13 +1623,20 @@ public final class CellUtil {\n   public static boolean matchingRowColumn(final Cell left, final Cell right) {\n     short lrowlength = left.getRowLength();\n     short rrowlength = right.getRowLength();\n+    // match length\n+    if (lrowlength != rrowlength) {\n+      return false;\n+    }\n+\n     byte lfamlength = left.getFamilyLength();\n     byte rfamlength = right.getFamilyLength();\n+    if (lfamlength != rfamlength) {\n+      return false;\n+    }\n+\n     int lqlength = left.getQualifierLength();\n     int rqlength = right.getQualifierLength();\n-\n-    // match length\n-    if ((lrowlength != rrowlength) || (lfamlength != rfamlength) || (lqlength != rqlength)) {\n+    if (lqlength != rqlength) {\n       return false;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NTU5Mg==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546265592", "bodyText": "This if/else is a lot of code. Would be good to break it out... check for it at top of the compare.... For a follow-on.", "author": "saintstack", "createdAt": "2020-12-19T18:00:41Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,285 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) r, (ByteBufferKeyValue) l);\n+      if (diff != 0) {\n+        // negate- Findbugs will complain?\n+        return -diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {", "originalCommit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c833703fa88c046a71f725aa27936d2155bc8b72", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex 059dd0a6fe..a6be237856 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -166,6 +166,7 @@ public class CellComparatorImpl implements CellComparator {\n \n     // Timestamps.\n     // Swap order we pass into compare so we get DESCENDING order.\n+    // TODO : Ensure we read the bytes and do the compare instead of the value.\n     diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n     if (diff != 0) {\n       return diff;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NjE1Mg==", "url": "https://github.com/apache/hbase/pull/2776#discussion_r546266152", "bodyText": "In follow-on, we should look at produced byte code. Might get ideas on how to make this go faster.", "author": "saintstack", "createdAt": "2020-12-19T18:06:15Z", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java", "diffHunk": "@@ -57,29 +57,285 @@ public final int compare(final Cell a, final Cell b) {\n   }\n \n   @Override\n-  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {\n-\n+  public int compare(final Cell l, final Cell r, boolean ignoreSequenceid) {\n     int diff = 0;\n     // \"Peel off\" the most common path.\n-    if (a instanceof ByteBufferKeyValue && b instanceof ByteBufferKeyValue) {\n-      diff = BBKVComparator.compare((ByteBufferKeyValue)a, (ByteBufferKeyValue)b, ignoreSequenceid);\n+    if (l instanceof KeyValue && r instanceof KeyValue) {\n+      diff = compareKeyValues((KeyValue) l, (KeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof KeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) l, (ByteBufferKeyValue) r);\n+      if (diff != 0) {\n+        return diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof KeyValue) {\n+      diff = compareKVVsBBKV((KeyValue) r, (ByteBufferKeyValue) l);\n+      if (diff != 0) {\n+        // negate- Findbugs will complain?\n+        return -diff;\n+      }\n+    } else if (l instanceof ByteBufferKeyValue && r instanceof ByteBufferKeyValue) {\n+      diff = compareBBKV((ByteBufferKeyValue) l, (ByteBufferKeyValue) r);\n       if (diff != 0) {\n         return diff;\n       }\n     } else {\n-      diff = compareRows(a, b);\n+      int leftRowLength = l.getRowLength();\n+      int rightRowLength = r.getRowLength();\n+      diff = compareRows(l, leftRowLength, r, rightRowLength);\n       if (diff != 0) {\n         return diff;\n       }\n \n-      diff = compareWithoutRow(a, b);\n+      diff = compareWithoutRow(l, r);\n       if (diff != 0) {\n         return diff;\n       }\n     }\n-\n     // Negate following comparisons so later edits show up first mvccVersion: later sorts first\n-    return ignoreSequenceid? diff: Long.compare(b.getSequenceId(), a.getSequenceId());\n+    return ignoreSequenceid ? diff : Long.compare(r.getSequenceId(), l.getSequenceId());\n+  }\n+\n+  private static int compareKeyValues(final KeyValue left, final KeyValue right) {\n+    int diff;\n+    // Compare Rows. Cache row length.\n+    int leftRowLength = left.getRowLength();\n+    int rightRowLength = right.getRowLength();\n+    diff = Bytes.compareTo(left.getRowArray(), left.getRowOffset(), leftRowLength,\n+      right.getRowArray(), right.getRowOffset(), rightRowLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // If the column is not specified, the \"minimum\" key type appears as latest in the sorted\n+    // order, regardless of the timestamp. This is used for specifying the last key/value in a\n+    // given row, because there is no \"lexicographically last column\" (it would be infinitely\n+    // long).\n+    // The \"maximum\" key type does not need this behavior. Copied from KeyValue. This is bad in\n+    // that\n+    // we can't do memcmp w/ special rules like this.\n+    // TODO: Is there a test for this behavior?\n+    int leftFamilyLengthPosition = left.getFamilyLengthPosition(leftRowLength);\n+    int leftFamilyLength = left.getFamilyLength(leftFamilyLengthPosition);\n+    int leftKeyLength = left.getKeyLength();\n+    int leftQualifierLength =\n+        left.getQualifierLength(leftKeyLength, leftRowLength, leftFamilyLength);\n+\n+    // No need of left row length below here.\n+\n+    byte leftType = left.getTypeByte(leftKeyLength);\n+    if (leftType == KeyValue.Type.Minimum.getCode()\n+        && leftFamilyLength + leftQualifierLength == 0) {\n+      // left is \"bigger\", i.e. it appears later in the sorted order\n+      return 1;\n+    }\n+\n+    int rightFamilyLengthPosition = right.getFamilyLengthPosition(rightRowLength);\n+    int rightFamilyLength = right.getFamilyLength(rightFamilyLengthPosition);\n+    int rightKeyLength = right.getKeyLength();\n+    int rightQualifierLength =\n+        right.getQualifierLength(rightKeyLength, rightRowLength, rightFamilyLength);\n+\n+    // No need of right row length below here.\n+\n+    byte rightType = right.getTypeByte(rightKeyLength);\n+    if (rightType == KeyValue.Type.Minimum.getCode()\n+        && rightFamilyLength + rightQualifierLength == 0) {\n+      return -1;\n+    }\n+\n+    // Compare families.\n+    int leftFamilyPosition = left.getFamilyOffset(leftFamilyLengthPosition);\n+    int rightFamilyPosition = right.getFamilyOffset(rightFamilyLengthPosition);\n+    diff = Bytes.compareTo(left.getFamilyArray(), leftFamilyPosition, leftFamilyLength,\n+      right.getFamilyArray(), rightFamilyPosition, rightFamilyLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // Compare qualifiers\n+    diff = Bytes.compareTo(left.getQualifierArray(),\n+      left.getQualifierOffset(leftFamilyPosition, leftFamilyLength), leftQualifierLength,\n+      right.getQualifierArray(), right.getQualifierOffset(rightFamilyPosition, rightFamilyLength),\n+      rightQualifierLength);\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // Timestamps.\n+    // Swap order we pass into compare so we get DESCENDING order.\n+    diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n+    if (diff != 0) {\n+      return diff;\n+    }\n+\n+    // Compare types. Let the delete types sort ahead of puts; i.e. types\n+    // of higher numbers sort before those of lesser numbers. Maximum (255)\n+    // appears ahead of everything, and minimum (0) appears after\n+    // everything.\n+    return (0xff & rightType) - (0xff & leftType);\n+  }", "originalCommit": "37579e00a65eb3deede01bdb15d6808b7e7c309e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c833703fa88c046a71f725aa27936d2155bc8b72", "chunk": "diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\nindex 059dd0a6fe..a6be237856 100644\n--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java\n\n@@ -166,6 +166,7 @@ public class CellComparatorImpl implements CellComparator {\n \n     // Timestamps.\n     // Swap order we pass into compare so we get DESCENDING order.\n+    // TODO : Ensure we read the bytes and do the compare instead of the value.\n     diff = Long.compare(right.getTimestamp(rightKeyLength), left.getTimestamp(leftKeyLength));\n     if (diff != 0) {\n       return diff;\n"}}, {"oid": "c833703fa88c046a71f725aa27936d2155bc8b72", "url": "https://github.com/apache/hbase/commit/c833703fa88c046a71f725aa27936d2155bc8b72", "message": "Address review comments", "committedDate": "2020-12-22T05:48:10Z", "type": "commit"}]}