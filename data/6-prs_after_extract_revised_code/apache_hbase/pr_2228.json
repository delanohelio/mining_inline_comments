{"pr_number": 2228, "pr_title": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "pr_createdAt": "2020-08-10T10:32:18Z", "pr_url": "https://github.com/apache/hbase/pull/2228", "timeline": [{"oid": "5e3fdc9f04d3d2b7bce95f13fb33cd4ceaf5cbda", "url": "https://github.com/apache/hbase/commit/5e3fdc9f04d3d2b7bce95f13fb33cd4ceaf5cbda", "message": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "committedDate": "2020-08-11T01:20:23Z", "type": "forcePushed"}, {"oid": "48b758265387fad28561e3a17353d9387ff5933c", "url": "https://github.com/apache/hbase/commit/48b758265387fad28561e3a17353d9387ff5933c", "message": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "committedDate": "2020-08-11T07:39:34Z", "type": "forcePushed"}, {"oid": "fb1ba98fc05a52018b39babdec945679f358b490", "url": "https://github.com/apache/hbase/commit/fb1ba98fc05a52018b39babdec945679f358b490", "message": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "committedDate": "2020-08-11T20:14:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1MzgxMw==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469353813", "bodyText": "nit: preferred", "author": "joshelser", "createdAt": "2020-08-12T15:40:20Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3805,6 +3838,196 @@ public void prepareMiniBatchOperations(MiniBatchOperationInProgress<Mutation> mi\n       }\n     }\n \n+    /**\n+     * Do coprocessor pre-increment or pre-append call.\n+     * @return Result returned out of the coprocessor, which means bypass all further processing\n+     *   and return the proffered Result instead, or null which means proceed.", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f2f7c967cea3b87c54ce46083869584f5deaa8f", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\nindex 13d88e6aad..456f579f1b 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n\n@@ -3839,11 +3839,11 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi\n     }\n \n     /**\n-     * Do coprocessor pre-increment or pre-append call.\n+     * Do coprocessor pre-increment or pre-append after row lock call.\n      * @return Result returned out of the coprocessor, which means bypass all further processing\n-     *   and return the proffered Result instead, or null which means proceed.\n+     *   and return the preferred Result instead, or null which means proceed.\n      */\n-    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+    private Result doCoprocessorPreCallAfterRowLock(Mutation mutation) throws IOException {\n       assert mutation instanceof Increment || mutation instanceof Append;\n       Result result = null;\n       if (region.coprocessorHost != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1NjA0NQ==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469356045", "bodyText": "Maybe doCoprocessorPreCallAfterRowLock() and indicate that this method is a no-op for Mutations which do not have a pre*AfterRowLock() method in the javadoc?", "author": "joshelser", "createdAt": "2020-08-12T15:42:29Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3805,6 +3838,196 @@ public void prepareMiniBatchOperations(MiniBatchOperationInProgress<Mutation> mi\n       }\n     }\n \n+    /**\n+     * Do coprocessor pre-increment or pre-append call.\n+     * @return Result returned out of the coprocessor, which means bypass all further processing\n+     *   and return the proffered Result instead, or null which means proceed.\n+     */\n+    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzMzYzOA==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r470433638", "bodyText": "Will change the name. This method is only for Increment and Append operations. It's called in the following if statement only:\nhttps://github.com/apache/hbase/pull/2228/files#diff-6205e907851ed4f650499f7111cbd91cR3799", "author": "brfrn169", "createdAt": "2020-08-14T06:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1NjA0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4f2f7c967cea3b87c54ce46083869584f5deaa8f", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\nindex 13d88e6aad..456f579f1b 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n\n@@ -3839,11 +3839,11 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi\n     }\n \n     /**\n-     * Do coprocessor pre-increment or pre-append call.\n+     * Do coprocessor pre-increment or pre-append after row lock call.\n      * @return Result returned out of the coprocessor, which means bypass all further processing\n-     *   and return the proffered Result instead, or null which means proceed.\n+     *   and return the preferred Result instead, or null which means proceed.\n      */\n-    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+    private Result doCoprocessorPreCallAfterRowLock(Mutation mutation) throws IOException {\n       assert mutation instanceof Increment || mutation instanceof Append;\n       Result result = null;\n       if (region.coprocessorHost != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1ODMwMw==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469358303", "bodyText": "What about compute or calculate instead of reckon? I had to go to a dictionary :)", "author": "joshelser", "createdAt": "2020-08-12T15:44:22Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3805,6 +3838,196 @@ public void prepareMiniBatchOperations(MiniBatchOperationInProgress<Mutation> mi\n       }\n     }\n \n+    /**\n+     * Do coprocessor pre-increment or pre-append call.\n+     * @return Result returned out of the coprocessor, which means bypass all further processing\n+     *   and return the proffered Result instead, or null which means proceed.\n+     */\n+    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+      assert mutation instanceof Increment || mutation instanceof Append;\n+      Result result = null;\n+      if (region.coprocessorHost != null) {\n+        if (mutation instanceof Increment) {\n+          result = region.coprocessorHost.preIncrementAfterRowLock((Increment) mutation);\n+        } else {\n+          result = region.coprocessorHost.preAppendAfterRowLock((Append) mutation);\n+        }\n+      }\n+      return result;\n+    }\n+\n+    private Map<byte[], List<Cell>> reckonDeltas(Mutation mutation, List<Cell> results)", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1ODgxNA==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469358814", "bodyText": "Javadoc here would also be great to supplement reckonDeltasByStore's javadoc.", "author": "joshelser", "createdAt": "2020-08-12T15:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1ODMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2NDM4NA==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469364384", "bodyText": "I see now that these were moving existing code. Better to keep the naming.", "author": "joshelser", "createdAt": "2020-08-12T15:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1ODMwMw=="}], "type": "inlineReview", "revised_code": {"commit": "4f2f7c967cea3b87c54ce46083869584f5deaa8f", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\nindex 13d88e6aad..456f579f1b 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n\n@@ -3839,11 +3839,11 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi\n     }\n \n     /**\n-     * Do coprocessor pre-increment or pre-append call.\n+     * Do coprocessor pre-increment or pre-append after row lock call.\n      * @return Result returned out of the coprocessor, which means bypass all further processing\n-     *   and return the proffered Result instead, or null which means proceed.\n+     *   and return the preferred Result instead, or null which means proceed.\n      */\n-    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+    private Result doCoprocessorPreCallAfterRowLock(Mutation mutation) throws IOException {\n       assert mutation instanceof Increment || mutation instanceof Append;\n       Result result = null;\n       if (region.coprocessorHost != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2MDIyMg==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469360222", "bodyText": "Genuine question, will this save us anything? Not sure how the JIT will (or won't) optimize such a thing away. I guess, at a minimum, it would save construction of an Iterator object?", "author": "joshelser", "createdAt": "2020-08-12T15:46:12Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3805,6 +3838,196 @@ public void prepareMiniBatchOperations(MiniBatchOperationInProgress<Mutation> mi\n       }\n     }\n \n+    /**\n+     * Do coprocessor pre-increment or pre-append call.\n+     * @return Result returned out of the coprocessor, which means bypass all further processing\n+     *   and return the proffered Result instead, or null which means proceed.\n+     */\n+    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+      assert mutation instanceof Increment || mutation instanceof Append;\n+      Result result = null;\n+      if (region.coprocessorHost != null) {\n+        if (mutation instanceof Increment) {\n+          result = region.coprocessorHost.preIncrementAfterRowLock((Increment) mutation);\n+        } else {\n+          result = region.coprocessorHost.preAppendAfterRowLock((Append) mutation);\n+        }\n+      }\n+      return result;\n+    }\n+\n+    private Map<byte[], List<Cell>> reckonDeltas(Mutation mutation, List<Cell> results)\n+      throws IOException {\n+      long now = EnvironmentEdgeManager.currentTime();\n+      Map<byte[], List<Cell>> ret = new HashMap<>();\n+      // Process a Store/family at a time.\n+      for (Map.Entry<byte [], List<Cell>> entry: mutation.getFamilyCellMap().entrySet()) {\n+        final byte[] columnFamilyName = entry.getKey();\n+        List<Cell> deltas = entry.getValue();\n+        // Reckon for the Store what to apply to WAL and MemStore.\n+        List<Cell> toApply = reckonDeltasByStore(region.stores.get(columnFamilyName), mutation,\n+          now, deltas, results);\n+        if (!toApply.isEmpty()) {\n+          for (Cell cell : toApply) {", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzNTM2OQ==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r470435369", "bodyText": "These were also moving existing code. Will keep this. Thanks.", "author": "brfrn169", "createdAt": "2020-08-14T06:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2MDIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "4f2f7c967cea3b87c54ce46083869584f5deaa8f", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\nindex 13d88e6aad..456f579f1b 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n\n@@ -3839,11 +3839,11 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi\n     }\n \n     /**\n-     * Do coprocessor pre-increment or pre-append call.\n+     * Do coprocessor pre-increment or pre-append after row lock call.\n      * @return Result returned out of the coprocessor, which means bypass all further processing\n-     *   and return the proffered Result instead, or null which means proceed.\n+     *   and return the preferred Result instead, or null which means proceed.\n      */\n-    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+    private Result doCoprocessorPreCallAfterRowLock(Mutation mutation) throws IOException {\n       assert mutation instanceof Increment || mutation instanceof Append;\n       Result result = null;\n       if (region.coprocessorHost != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2MjQ5Nw==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469362497", "bodyText": "Better to check that it's an Append and throw an exception if it isn't?", "author": "joshelser", "createdAt": "2020-08-12T15:49:22Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3805,6 +3838,196 @@ public void prepareMiniBatchOperations(MiniBatchOperationInProgress<Mutation> mi\n       }\n     }\n \n+    /**\n+     * Do coprocessor pre-increment or pre-append call.\n+     * @return Result returned out of the coprocessor, which means bypass all further processing\n+     *   and return the proffered Result instead, or null which means proceed.\n+     */\n+    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+      assert mutation instanceof Increment || mutation instanceof Append;\n+      Result result = null;\n+      if (region.coprocessorHost != null) {\n+        if (mutation instanceof Increment) {\n+          result = region.coprocessorHost.preIncrementAfterRowLock((Increment) mutation);\n+        } else {\n+          result = region.coprocessorHost.preAppendAfterRowLock((Append) mutation);\n+        }\n+      }\n+      return result;\n+    }\n+\n+    private Map<byte[], List<Cell>> reckonDeltas(Mutation mutation, List<Cell> results)\n+      throws IOException {\n+      long now = EnvironmentEdgeManager.currentTime();\n+      Map<byte[], List<Cell>> ret = new HashMap<>();\n+      // Process a Store/family at a time.\n+      for (Map.Entry<byte [], List<Cell>> entry: mutation.getFamilyCellMap().entrySet()) {\n+        final byte[] columnFamilyName = entry.getKey();\n+        List<Cell> deltas = entry.getValue();\n+        // Reckon for the Store what to apply to WAL and MemStore.\n+        List<Cell> toApply = reckonDeltasByStore(region.stores.get(columnFamilyName), mutation,\n+          now, deltas, results);\n+        if (!toApply.isEmpty()) {\n+          for (Cell cell : toApply) {\n+            HStore store = region.getStore(cell);\n+            if (store == null) {\n+              region.checkFamily(CellUtil.cloneFamily(cell));\n+            } else {\n+              ret.computeIfAbsent(store.getColumnFamilyDescriptor().getName(),\n+                key -> new ArrayList<>()).add(cell);\n+            }\n+          }\n+        }\n+      }\n+      return ret;\n+    }\n+\n+    /**\n+     * Reckon the Cells to apply to WAL, memstore, and to return to the Client in passed\n+     * column family/Store.\n+     *\n+     * Does Get of current value and then adds passed in deltas for this Store returning the\n+     * result.\n+     *\n+     * @param mutation The encompassing Mutation object\n+     * @param deltas Changes to apply to this Store; either increment amount or data to append\n+     * @param results In here we accumulate all the Cells we are to return to the client. If null,\n+     *   client doesn't want results returned.\n+     * @return Resulting Cells after <code>deltas</code> have been applied to current\n+     *   values. Side effect is our filling out of the <code>results</code> List.\n+     */\n+    private List<Cell> reckonDeltasByStore(HStore store, Mutation mutation, long now,\n+      List<Cell> deltas, List<Cell> results) throws IOException {\n+      assert mutation instanceof Increment || mutation instanceof Append;\n+      byte[] columnFamily = store.getColumnFamilyDescriptor().getName();\n+      List<Pair<Cell, Cell>> cellPairs = new ArrayList<>(deltas.size());\n+\n+      // Get previous values for all columns in this family.\n+      TimeRange tr;\n+      if (mutation instanceof Increment) {\n+        tr = ((Increment) mutation).getTimeRange();\n+      } else {\n+        tr = ((Append) mutation).getTimeRange();\n+      }\n+      List<Cell> currentValues = get(mutation, store, deltas, tr);\n+\n+      // Iterate the input columns and update existing values if they were found, otherwise\n+      // add new column initialized to the delta amount\n+      int currentValuesIndex = 0;\n+      for (int i = 0; i < deltas.size(); i++) {\n+        Cell delta = deltas.get(i);\n+        Cell currentValue = null;\n+        if (currentValuesIndex < currentValues.size() &&\n+          CellUtil.matchingQualifier(currentValues.get(currentValuesIndex), delta)) {\n+          currentValue = currentValues.get(currentValuesIndex);\n+          if (i < (deltas.size() - 1) && !CellUtil.matchingQualifier(delta, deltas.get(i + 1))) {\n+            currentValuesIndex++;\n+          }\n+        }\n+        // Switch on whether this an increment or an append building the new Cell to apply.\n+        Cell newCell;\n+        if (mutation instanceof Increment) {\n+          long deltaAmount = getLongValue(delta);\n+          final long newValue = currentValue == null ?\n+            deltaAmount : getLongValue(currentValue) + deltaAmount;\n+          newCell = reckonDelta(delta, currentValue, columnFamily, now, mutation,\n+            (oldCell) -> Bytes.toBytes(newValue));\n+        } else {", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzNTU4NQ==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r470435585", "bodyText": "These were also moving existing code. Will keep this. Thanks.", "author": "brfrn169", "createdAt": "2020-08-14T06:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2MjQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4f2f7c967cea3b87c54ce46083869584f5deaa8f", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\nindex 13d88e6aad..456f579f1b 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java\n\n@@ -3839,11 +3839,11 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi\n     }\n \n     /**\n-     * Do coprocessor pre-increment or pre-append call.\n+     * Do coprocessor pre-increment or pre-append after row lock call.\n      * @return Result returned out of the coprocessor, which means bypass all further processing\n-     *   and return the proffered Result instead, or null which means proceed.\n+     *   and return the preferred Result instead, or null which means proceed.\n      */\n-    private Result doCoprocessorPreCall(Mutation mutation) throws IOException {\n+    private Result doCoprocessorPreCallAfterRowLock(Mutation mutation) throws IOException {\n       assert mutation instanceof Increment || mutation instanceof Append;\n       Result result = null;\n       if (region.coprocessorHost != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2OTU2Mg==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469369562", "bodyText": "You've changed the semantics here. Before, we would call preIncrement and then create a new nonce'd operation. Now, we'll always make a new nonce operation, even if the CP is about to say \"skip this increment\"\nIs that intentional?", "author": "joshelser", "createdAt": "2020-08-12T15:59:33Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java", "diffHunk": "@@ -742,36 +741,35 @@ private Result increment(final HRegion region, final OperationQuota quota,\n     spaceQuota.getPolicyEnforcement(region).check(increment);\n     quota.addMutation(increment);\n     Result r = null;\n-    if (region.getCoprocessorHost() != null) {\n-      r = region.getCoprocessorHost().preIncrement(increment);\n-    }\n-    if (r == null) {\n-      boolean canProceed = startNonceOperation(mutation, nonceGroup);\n-      boolean success = false;\n-      try {\n-        long nonce = mutation.hasNonce() ? mutation.getNonce() : HConstants.NO_NONCE;\n-        if (canProceed) {\n-          r = region.increment(increment, nonceGroup, nonce);\n-        } else {\n+    boolean canProceed = startNonceOperation(mutation, nonceGroup);", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3NDUxNA==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r470374514", "bodyText": "Yes, I changed the semantics. This is because we call preIncrement in region.increment() after this change. I don't think this change breaks anything, but it just changes the order of preIncrement and the nonce operation. What do you think?", "author": "brfrn169", "createdAt": "2020-08-14T02:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2OTU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5ODQ2Mw==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r475098463", "bodyText": "I think this is a behavior change. We need to make it clear and then we could say whether it is OK. In general, call startNonceOperation will store a new entry in ServerNonceManager, and it will effect the later retries.", "author": "Apache9", "createdAt": "2020-08-22T14:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2OTU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIyOTAwOA==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r475229008", "bodyText": "Thank you for taking a look at this! @Apache9\nLet me clarify this.\nThe pseudo codes of before and after the change are as follows:\nThe pseudo code before the change:\nr = preIncrement(increment)\nif (r == null) {\n  canProceed = startNonceOperation()\n\n  if (canProceed) {\n    // Process increment...\n    r = ...\n  } else {\n    // Get the incremented cells...\n    r = ...\n  }\n\n  r = postIncrement(increment, r)\n\n  if (canProceed) {\n    endNonceOperation()\n  }\n}\n\nreturn r;\n\nThe pseudo code after the change:\ncanProceed = startNonceOperation()\n\nif (canProceed) {\n  // The following logic is actually executed in HRegion.batchMutate()\n  r = preIncrement(increment)\n  if (r != null) {\n    // Process increment...\n    r = ...\n\n    r = postIncrement(increment, r)\n  }\n} else {\n  r = preIncrement(increment)\n  if (r != null) {\n    // Get the incremented cells...\n    r = ...\n\n    r = postIncrement(increment, r)\n  }\n}\n\nif (canProceed) {\n  endNonceOperation()\n}\n\nreturn r\n\nI think we can discuss two cases when we don't set any RegionObserver or not.\nThe case when we don't set any RegionObserver (preIncrement() always returns null)\nThe behavior of the code before the change when startNonceOperation() returns true:\n\nr = preIncrement(increment) -> This returns null\ncanProceed = startNonceOperation() -> This returns true\n// Process increment...\nr = postIncrement(increment, r)\nendNonceOperation()\nreturn r\n\nThe behavior of the code before the change when startNonceOperation() returns false:\n\nr = preIncrement(increment) -> This returns null\ncanProceed = startNonceOperation() -> This returns false\n// Get the incremented cells...\nr = postIncrement(increment, r)\nreturn r\n\nThe behavior of the code after the change when startNonceOperation() returns true:\n\ncanProceed = startNonceOperation() -> This returns true\nr = preIncrement(increment) -> This returns null\n// Process increment...\nr = postIncrement(increment, r)\nendNonceOperation()\nreturn r\n\nThe behavior of the code after the change when startNonceOperation() returns false:\n\ncanProceed = startNonceOperation() -> This returns false\nr = preIncrement(increment) -> This returns null\n// Get the incremented cells...\nr = postIncrement(increment, r)\nreturn r\n\nI don't think the behaviors in this case are essentially changed.\nThe case when we set RegionObserver with implementing preIncrement()\nThe behavior of the code before the change:\n\nr = preIncrement(increment) -> This returns a non-null value\nreturn r\n\nThe behavior of the code after the change when startNonceOperation() returns true:\n\ncanProceed = startNonceOperation() -> This returns true\nr = preIncrement(increment) -> This returns a non-null value\nendNonceOperation()\nreturn r\n\nThe behavior of the code after the change when startNonceOperation() returns false:\n\ncanProceed = startNonceOperation() -> This returns false\nr = preIncrement(increment)  -> This returns a non-null value\nreturn r\n\nThe behaviors in this case are a bit changed. After the change, we always call startNonceOperation(). However, I don't think that affects the result itself and when we don't set any RegionObserver, we always call startNonceOperation(), too. So I don't think it's a big problem.\nWhat do you think? Thanks.", "author": "brfrn169", "createdAt": "2020-08-23T14:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2OTU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3MDU1MQ==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r478770551", "bodyText": "Ping @Apache9 and @joshelser. Thanks.", "author": "brfrn169", "createdAt": "2020-08-28T00:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2OTU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTcxNDg5Ng==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r479714896", "bodyText": "I will modify the patch to keep the behavior of the nonce operations. Thanks.", "author": "brfrn169", "createdAt": "2020-08-30T03:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2OTU2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b163b609c73e061eac692a8660bec698e68328b3", "chunk": "diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java\nindex d3b687076a..827ac1b418 100644\n--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java\n+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java\n\n@@ -740,32 +684,8 @@ public class RSRpcServices implements HBaseRPCErrorHandler,\n     checkCellSizeLimit(region, increment);\n     spaceQuota.getPolicyEnforcement(region).check(increment);\n     quota.addMutation(increment);\n-    Result r = null;\n-    boolean canProceed = startNonceOperation(mutation, nonceGroup);\n-    boolean success = false;\n-    try {\n-      long nonce = mutation.hasNonce() ? mutation.getNonce() : HConstants.NO_NONCE;\n-      if (canProceed) {\n-        r = region.increment(increment, nonceGroup, nonce);\n-      } else {\n-        if (region.getCoprocessorHost() != null) {\n-          r = region.getCoprocessorHost().preIncrement(increment);\n-        }\n-        if (r == null) {\n-          // convert duplicate increment to get\n-          List<Cell> results = region.get(toGet(increment), false, nonceGroup, nonce);\n-          r = Result.create(results);\n-        }\n-        if (region.getCoprocessorHost() != null) {\n-          r = region.getCoprocessorHost().postIncrement(increment, r);\n-        }\n-      }\n-      success = true;\n-    } finally {\n-      if (canProceed) {\n-        endNonceOperation(mutation, nonceGroup, success);\n-      }\n-    }\n+    long nonce = mutation.hasNonce() ? mutation.getNonce() : HConstants.NO_NONCE;\n+    Result r = region.increment(increment, nonceGroup, nonce);\n     final MetricsRegionServer metricsRegionServer = regionServer.getMetrics();\n     if (metricsRegionServer != null) {\n       metricsRegionServer.updateIncrement(region.getTableDescriptor().getTableName(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3MTU2NA==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469371564", "bodyText": "Is it more optimal to check for the single action case? What does this get us over the previous method of using the \"collection of Actions\" method even if we only have a single action?", "author": "joshelser", "createdAt": "2020-08-12T16:02:39Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java", "diffHunk": "@@ -2910,23 +2908,35 @@ public MultiResponse multi(final RpcController rpcc, final MultiRequest request)\n           }\n \n           try {\n-            CheckAndMutateResult result = checkAndMutate(region, regionAction.getActionList(),\n-              cellScanner, regionAction.getCondition(), spaceQuotaEnforcement);\n-            regionActionResultBuilder.setProcessed(result.isSuccess());\n             ClientProtos.ResultOrException.Builder resultOrExceptionOrBuilder =\n               ClientProtos.ResultOrException.newBuilder();\n-            for (int i = 0; i < regionAction.getActionCount(); i++) {\n-              if (i == 0 && result.getResult() != null) {\n-                resultOrExceptionOrBuilder.setIndex(i);\n-                regionActionResultBuilder.addResultOrException(resultOrExceptionOrBuilder\n-                  .setResult(ProtobufUtil.toResult(result.getResult())).build());\n-                continue;\n+            if (regionAction.getActionCount() == 1) {\n+              CheckAndMutateResult result = checkAndMutate(region, quota,\n+                regionAction.getAction(0).getMutation(), cellScanner,\n+                regionAction.getCondition(), spaceQuotaEnforcement);\n+              regionActionResultBuilder.setProcessed(result.isSuccess());\n+              resultOrExceptionOrBuilder.setIndex(0);\n+              if (result.getResult() != null) {\n+                resultOrExceptionOrBuilder.setResult(ProtobufUtil.toResult(result.getResult()));", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ1MDY0Mg==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r470450642", "bodyText": "Actually, this change supports a CheckAndMutate operation only with a single Increment/Append. That's why I needed the if statement to check whether a single action or not. BTW, I'm going to handle CheckAndMutate operations with multiple Increments/Appends in HBASE-24210.", "author": "brfrn169", "createdAt": "2020-08-14T07:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3MTU2NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3NTYxMA==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r469375610", "bodyText": "Can I send multiple CheckAndMutate's (each with their own Increment or Append) to the same row in one batch?", "author": "joshelser", "createdAt": "2020-08-12T16:08:58Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncTable.java", "diffHunk": "@@ -1282,6 +1438,80 @@ public void testCheckAndMutateBatchWithFilterAndTimeRange() throws Throwable {\n     assertEquals(\"f\", Bytes.toString(result.getValue(FAMILY, Bytes.toBytes(\"F\"))));\n   }\n \n+  @Test\n+  public void testCheckAndIncrementBatch() throws Throwable {\n+    AsyncTable<?> table = getTable.get();\n+    byte[] row2 = Bytes.toBytes(Bytes.toString(row) + \"2\");\n+\n+    table.putAll(Arrays.asList(\n+      new Put(row).addColumn(FAMILY, Bytes.toBytes(\"A\"), Bytes.toBytes(\"a\"))\n+        .addColumn(FAMILY, Bytes.toBytes(\"B\"), Bytes.toBytes(0L)),\n+      new Put(row2).addColumn(FAMILY, Bytes.toBytes(\"C\"), Bytes.toBytes(\"c\"))\n+        .addColumn(FAMILY, Bytes.toBytes(\"D\"), Bytes.toBytes(0L)))).get();\n+\n+    // CheckAndIncrement with correct value\n+    CheckAndMutate checkAndMutate1 = CheckAndMutate.newBuilder(row)\n+      .ifEquals(FAMILY, Bytes.toBytes(\"A\"), Bytes.toBytes(\"a\"))\n+      .build(new Increment(row).addColumn(FAMILY, Bytes.toBytes(\"B\"), 1));\n+\n+    // CheckAndIncrement with wrong value\n+    CheckAndMutate checkAndMutate2 = CheckAndMutate.newBuilder(row2)\n+      .ifEquals(FAMILY, Bytes.toBytes(\"C\"), Bytes.toBytes(\"d\"))\n+      .build(new Increment(row2).addColumn(FAMILY, Bytes.toBytes(\"D\"), 1));\n+\n+    List<CheckAndMutateResult> results =\n+      table.checkAndMutateAll(Arrays.asList(checkAndMutate1, checkAndMutate2)).get();", "originalCommit": "fb1ba98fc05a52018b39babdec945679f358b490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzNjgxNg==", "url": "https://github.com/apache/hbase/pull/2228#discussion_r470436816", "bodyText": "No for now. I'm going to handle that case in HBASE-24210.", "author": "brfrn169", "createdAt": "2020-08-14T06:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3NTYxMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "4f2f7c967cea3b87c54ce46083869584f5deaa8f", "url": "https://github.com/apache/hbase/commit/4f2f7c967cea3b87c54ce46083869584f5deaa8f", "message": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "committedDate": "2020-08-14T07:20:37Z", "type": "forcePushed"}, {"oid": "b163b609c73e061eac692a8660bec698e68328b3", "url": "https://github.com/apache/hbase/commit/b163b609c73e061eac692a8660bec698e68328b3", "message": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "committedDate": "2020-08-31T02:36:24Z", "type": "forcePushed"}, {"oid": "3558f411d669d5902abfd079b3cf493e2cf7a6ad", "url": "https://github.com/apache/hbase/commit/3558f411d669d5902abfd079b3cf493e2cf7a6ad", "message": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "committedDate": "2020-08-31T04:22:37Z", "type": "commit"}, {"oid": "3558f411d669d5902abfd079b3cf493e2cf7a6ad", "url": "https://github.com/apache/hbase/commit/3558f411d669d5902abfd079b3cf493e2cf7a6ad", "message": "HBASE-24602 Add Increment and Append support to CheckAndMutate", "committedDate": "2020-08-31T04:22:37Z", "type": "forcePushed"}]}