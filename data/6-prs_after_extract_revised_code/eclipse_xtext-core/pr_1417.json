{"pr_number": 1417, "pr_title": "Refactor more xtend to java", "pr_createdAt": "2020-03-06T07:19:56Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1417", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1Mjk1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388752959", "bodyText": "you should remove final from all parameters", "author": "cdietrich", "createdAt": "2020-03-06T07:43:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(final IResourceServiceProvider.Registry resourceServiceProviderRegistry,", "originalCommit": "160bdb1022650cb315717906b182eb5812c4cd12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc5MDY0OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388790648", "bodyText": "I will do.", "author": "ArneDeutsch", "createdAt": "2020-03-06T09:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1Mjk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "67ab803d8b2e316e47273e4b16ff6caa5c471045", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\nindex d632f452e..2dd9c047c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n\n@@ -37,15 +37,15 @@ public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n \n \tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n \n-\tpublic ReferenceAcceptor(final IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n-\t\t\tfinal IAcceptor<IReferenceDescription> delegate) {\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n \t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n \t\tthis.delegate = delegate;\n \t}\n \n \t@Override\n-\tpublic void accept(final EObject source, final URI sourceURI, final EReference eReference, final int index,\n-\t\t\tfinal EObject targetOrProxy, final URI targetURI) {\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n \t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n \t\t\tcomputeExportedObjectsMap(source);\n \t\t\tcurrentResource = source.eResource();\n"}}, {"oid": "67ab803d8b2e316e47273e4b16ff6caa5c471045", "url": "https://github.com/eclipse/xtext-core/commit/67ab803d8b2e316e47273e4b16ff6caa5c471045", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T09:29:21Z", "type": "forcePushed"}, {"oid": "716c6eb69f58840bc816e2731e3690b7de20f841", "url": "https://github.com/eclipse/xtext-core/commit/716c6eb69f58840bc816e2731e3690b7de20f841", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T09:36:02Z", "type": "forcePushed"}, {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "url": "https://github.com/eclipse/xtext-core/commit/c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T09:44:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwNjkwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388806908", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T09:50:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\nindex 2dd9c047c..9978ef6f8 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n\n@@ -8,6 +8,8 @@\n  */\n package org.eclipse.xtext.findReferences;\n \n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.emf.common.util.URI;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwNzM3Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388807377", "bodyText": "I don't really like this new HashMap<>() works as well", "author": "tivervac", "createdAt": "2020-03-06T09:51:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\nindex 2dd9c047c..9978ef6f8 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n\n@@ -8,6 +8,8 @@\n  */\n package org.eclipse.xtext.findReferences;\n \n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.emf.common.util.URI;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODMzOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808338", "bodyText": "Collections.emptyMap()", "author": "tivervac", "createdAt": "2020-03-06T09:52:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\nindex 2dd9c047c..9978ef6f8 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n\n@@ -8,6 +8,8 @@\n  */\n package org.eclipse.xtext.findReferences;\n \n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.emf.common.util.URI;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODU4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808589", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T09:53:21Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();\n+\t\t}\n+\t}\n+\n+\tprotected URI findExportedContainer(EObject obj) {\n+\t\tif (exportedContainersInCurrentResource.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEObject source = obj;\n+\t\tURI result = exportedContainersInCurrentResource.get(source);\n+\t\twhile ((result == null)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\nindex 2dd9c047c..9978ef6f8 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n\n@@ -8,6 +8,8 @@\n  */\n package org.eclipse.xtext.findReferences;\n \n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.emf.common.util.URI;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODY3OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808678", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T09:53:29Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();\n+\t\t}\n+\t}\n+\n+\tprotected URI findExportedContainer(EObject obj) {\n+\t\tif (exportedContainersInCurrentResource.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEObject source = obj;\n+\t\tURI result = exportedContainersInCurrentResource.get(source);\n+\t\twhile ((result == null)) {\n+\t\t\tif (exportedContainersInCurrentResource.containsKey(source)) {\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t\tsource = source.eContainer();\n+\t\t\tif ((source == null)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\nindex 2dd9c047c..9978ef6f8 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java\n\n@@ -8,6 +8,8 @@\n  */\n package org.eclipse.xtext.findReferences;\n \n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.emf.common.util.URI;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTIwMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809203", "bodyText": "@szarnekow We prefer not to have there in the java code right?", "author": "tivervac", "createdAt": "2020-03-06T09:54:29Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof InterruptedException) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyNjUxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388826510", "bodyText": "True. catch(Throwable) is a bad sign in general.", "author": "szarnekow", "createdAt": "2020-03-06T10:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\nindex 0877af1e8..b76bce70f 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n\n@@ -14,7 +14,6 @@ import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.OperationCanceledException;\n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n import org.eclipse.emf.common.util.URI;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n \n import com.google.common.annotations.Beta;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTM1Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809356", "bodyText": "@cdietrich We're 2.21 one now, is this still beta?", "author": "tivervac", "createdAt": "2020-03-06T09:54:49Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof InterruptedException) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @since 2.14\n+\t */\n+\t@Beta", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NjI1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389796259", "bodyText": "I'd like to keep this @Beta - the code tickles me. I've doubts that it is really safe to to do it like this.", "author": "szarnekow", "createdAt": "2020-03-09T16:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTM1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\nindex 0877af1e8..b76bce70f 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n\n@@ -14,7 +14,6 @@ import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.OperationCanceledException;\n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n import org.eclipse.emf.common.util.URI;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n \n import com.google.common.annotations.Beta;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTU2Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809563", "bodyText": "We really don't want these ;)", "author": "tivervac", "createdAt": "2020-03-06T09:55:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+@SuppressWarnings(\"all\")", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\nindex 9e8bc768c..f05c20dd0 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n\n@@ -9,13 +9,11 @@\n package org.eclipse.xtext.generator;\n \n import org.eclipse.emf.common.util.URI;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n /**\n  * @author Anton Kosyakov\n  * @since 2.7\n  */\n-@SuppressWarnings(\"all\")\n public class FileSystemAccessRequest implements Runnable {\n \tprivate final URI uri;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTY3Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809673", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T09:55:26Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+@SuppressWarnings(\"all\")\n+public class FileSystemAccessRequest implements Runnable {\n+\tprivate final URI uri;\n+\n+\tprivate final Runnable runMe;\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic FileSystemAccessRequest(final URI uri, final Runnable runMe) {\n+\t\tthis.uri = uri;\n+\t\tthis.runMe = runMe;\n+\t}\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\nindex 9e8bc768c..f05c20dd0 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n\n@@ -9,13 +9,11 @@\n package org.eclipse.xtext.generator;\n \n import org.eclipse.emf.common.util.URI;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n /**\n  * @author Anton Kosyakov\n  * @since 2.7\n  */\n-@SuppressWarnings(\"all\")\n public class FileSystemAccessRequest implements Runnable {\n \tprivate final URI uri;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTc4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809789", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T09:55:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/GeneratorContext.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class GeneratorContext implements IGeneratorContext {\n+\tprivate CancelIndicator cancelIndicator;\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/GeneratorContext.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/GeneratorContext.java\nindex c81f730b3..9eb0ee4a7 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/GeneratorContext.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/GeneratorContext.java\n\n@@ -9,7 +9,6 @@\n package org.eclipse.xtext.generator;\n \n import org.eclipse.xtext.util.CancelIndicator;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n /**\n  * @since 2.9\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDAwNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388810007", "bodyText": "@cdietrich Is this still beta? It's been so long", "author": "tivervac", "createdAt": "2020-03-06T09:55:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NDMyOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388844328", "bodyText": "Almost all implementations that I saw do need access to the issues. If we want to de-betarize this, we should consider passing the issues directly to this API. The caller would make sure that the issues are only computed once.", "author": "szarnekow", "createdAt": "2020-03-06T11:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java\nindex 0bad6a97a..1c2feb9e5 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java\n\n@@ -59,7 +59,7 @@ public interface IShouldGenerate {\n \t}\n \n \t/**\n-\t * whether code should be generated for this resource.\n+\t * Whether code should be generated for this resource.\n \t */\n \tboolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDI2OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388810268", "bodyText": "s/whether/Whether/", "author": "tivervac", "createdAt": "2020-03-06T09:56:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+@ImplementedBy(IShouldGenerate.OnlyWithoutErrors.class)\n+public interface IShouldGenerate {\n+\t@Beta\n+\t@Singleton\n+\tclass OnlyWithoutErrors implements IShouldGenerate {\n+\t\t@Inject\n+\t\tprivate IResourceValidator resourceValidator;\n+\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tif (!resource.getErrors().isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<Issue> issues = resourceValidator.validate(resource, CheckMode.NORMAL_AND_FAST, cancelIndicator);\n+\t\t\treturn !exists(issues, (Issue issue) -> Objects.equal(issue.getSeverity(), Severity.ERROR));\n+\t\t}\n+\t}\n+\n+\t@Beta\n+\t@Singleton\n+\tclass Always implements IShouldGenerate {\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * whether code should be generated for this resource.", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java\nindex 0bad6a97a..1c2feb9e5 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java\n\n@@ -59,7 +59,7 @@ public interface IShouldGenerate {\n \t}\n \n \t/**\n-\t * whether code should be generated for this resource.\n+\t * Whether code should be generated for this resource.\n \t */\n \tboolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjI4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812289", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:25Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\nindex 0f885150b..c975dd7ef 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n\n@@ -12,7 +12,6 @@ import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n-import org.eclipse.xtext.xbase.lib.Pure;\n import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n \n import com.google.common.base.Objects;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjM4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812389", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:34Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\nindex 0f885150b..c975dd7ef 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n\n@@ -12,7 +12,6 @@ import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n-import org.eclipse.xtext.xbase.lib.Pure;\n import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n \n import com.google.common.base.Objects;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjQ0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812444", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic String toString() {\n+\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\nindex 0f885150b..c975dd7ef 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n\n@@ -12,7 +12,6 @@ import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n-import org.eclipse.xtext.xbase.lib.Pure;\n import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n \n import com.google.common.base.Objects;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjQ3Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812472", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:00:42Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\nindex 0f885150b..c975dd7ef 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n\n@@ -12,7 +12,6 @@ import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n-import org.eclipse.xtext.xbase.lib.Pure;\n import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n \n import com.google.common.base.Objects;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzQ5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813492", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:02:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813692", "bodyText": "API typos make me sad :(", "author": "tivervac", "createdAt": "2020-03-06T10:03:11Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwMDA3NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388900074", "bodyText": "Nothing I can change here, right? It's protected.", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNzU5Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388927596", "bodyText": "Nope, sadly you can't do anything about this", "author": "tivervac", "createdAt": "2020-03-06T14:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzkyNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813926", "bodyText": "Sneaky throw", "author": "tivervac", "createdAt": "2020-03-06T10:03:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzk5Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813996", "bodyText": "Sneaky throw", "author": "tivervac", "createdAt": "2020-03-06T10:03:44Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDExMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814112", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:03:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDE4NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814185", "bodyText": "sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:04:04Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDI2NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814264", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:04:12Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDMwOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814309", "bodyText": "Double try?", "author": "tivervac", "createdAt": "2020-03-06T10:04:18Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDM4Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814382", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:04:26Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDQ0Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814443", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:35Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDQ4NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814484", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:40Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDUxMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814510", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDU0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814544", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDU5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814592", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:04:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDY0MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814641", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:01Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeDelete getBeforeDelete() {\n+\t\treturn beforeDelete;\n+\t}\n+\n+\tpublic void setBeforeDelete(URIBasedFileSystemAccess.BeforeDelete beforeDelete) {\n+\t\tthis.beforeDelete = beforeDelete;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeWrite getBeforeWrite() {\n+\t\treturn beforeWrite;\n+\t}\n+\n+\tpublic void setBeforeWrite(URIBasedFileSystemAccess.BeforeWrite beforeWrite) {\n+\t\tthis.beforeWrite = beforeWrite;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDY3OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814679", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeDelete getBeforeDelete() {\n+\t\treturn beforeDelete;\n+\t}\n+\n+\tpublic void setBeforeDelete(URIBasedFileSystemAccess.BeforeDelete beforeDelete) {\n+\t\tthis.beforeDelete = beforeDelete;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDcxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814718", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:10Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDc1OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814758", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:05:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTEwMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815100", "bodyText": "absoluteURI.toUri()", "author": "tivervac", "createdAt": "2020-03-06T10:05:52Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjIwMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388846203", "bodyText": "you mean toString()?", "author": "szarnekow", "createdAt": "2020-03-06T11:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTEwMA=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\nindex 42ce94c3c..737ec8b4c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n\n@@ -11,7 +11,6 @@ package org.eclipse.xtext.generator.trace;\n import org.eclipse.emf.common.util.URI;\n import org.eclipse.xtext.workspace.IProjectConfig;\n import org.eclipse.xtext.workspace.ISourceFolder;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n \n import com.google.common.base.Objects;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTI0Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815243", "bodyText": "Sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:06:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof IllegalArgumentException) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Base URI was \" + getURI(), t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\nindex 42ce94c3c..737ec8b4c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n\n@@ -11,7 +11,6 @@ package org.eclipse.xtext.generator.trace;\n import org.eclipse.emf.common.util.URI;\n import org.eclipse.xtext.workspace.IProjectConfig;\n import org.eclipse.xtext.workspace.ISourceFolder;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n \n import com.google.common.base.Objects;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTYyMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815621", "bodyText": "obj.toString()", "author": "tivervac", "createdAt": "2020-03-06T10:06:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof IllegalArgumentException) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Base URI was \" + getURI(), t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(ISourceFolder sourceFolder) {\n+\t\treturn deresolve(sourceFolder.getPath());\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(IProjectConfig projectConfig) {\n+\t\tISourceFolder sourceFolder = projectConfig.findSourceFolderContaining(getURI());\n+\t\treturn sourceFolder != null ? deresolve(sourceFolder) : null;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj != null && !Objects.equal(obj.getClass(), AbsoluteURI.class)) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(obj) + \" instanceof \" + obj.getClass().getName());", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\nindex 42ce94c3c..737ec8b4c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n\n@@ -11,7 +11,6 @@ package org.eclipse.xtext.generator.trace;\n import org.eclipse.emf.common.util.URI;\n import org.eclipse.xtext.workspace.IProjectConfig;\n import org.eclipse.xtext.workspace.ISourceFolder;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n \n import com.google.common.base.Objects;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTg1NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815854", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:21Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTg4Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815887", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:25Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTkxNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815915", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTk3Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815976", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjA0Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816047", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjA4MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816081", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:48Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjEyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816127", "bodyText": "Not needed", "author": "tivervac", "createdAt": "2020-03-06T10:07:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjI0Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816246", "bodyText": "new ArrayList<>();", "author": "tivervac", "createdAt": "2020-03-06T10:08:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjM3NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816375", "bodyText": "new ArrayList<>()", "author": "tivervac", "createdAt": "2020-03-06T10:08:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjQ5MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816491", "bodyText": "new ArrayList<>();", "author": "tivervac", "createdAt": "2020-03-06T10:08:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjU1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816555", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:08:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjgyMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816820", "bodyText": "Just remove every @Pure in this file", "author": "tivervac", "createdAt": "2020-03-06T10:09:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzYyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817623", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:10:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDM3OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930378", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzYyMw=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzg1Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817857", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:11:24Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDQzMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930432", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzkxNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817914", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:11:32Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDQ4Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930483", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODEzNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818136", "bodyText": "sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:11:57Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM1Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818357", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:12:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDU0Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930542", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818389", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:12:26Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDUyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930527", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODQ3Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818477", "bodyText": "CollectionLiterals", "author": "tivervac", "createdAt": "2020-03-06T10:12:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODcwNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818705", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-03-06T10:13:01Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODc5NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818795", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:13:12Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODg1NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818854", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:13:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODk2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818962", "bodyText": "CollectionLiterals", "author": "tivervac", "createdAt": "2020-03-06T10:13:31Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTEzMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819130", "bodyText": "same", "author": "tivervac", "createdAt": "2020-03-06T10:13:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTM3Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819377", "bodyText": "Is the Integer.valueOf really needed?", "author": "tivervac", "createdAt": "2020-03-06T10:14:15Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDg5NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930895", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTM3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTUwMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819501", "bodyText": "same, also it_1 is a pretty bad name", "author": "tivervac", "createdAt": "2020-03-06T10:14:33Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDkyOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930929", "bodyText": "@ArneDeutsch Missed this one", "author": "tivervac", "createdAt": "2020-03-06T14:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTUwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTc5OA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819798", "bodyText": "Conversions.unwrapArray this really isnt needed", "author": "tivervac", "createdAt": "2020-03-06T10:15:10Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg5NTkyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388895927", "bodyText": "Fixed, but please have a look if you agree that I got the meaning right.", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTc5OA=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTk2Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819963", "bodyText": "Bad naming", "author": "tivervac", "createdAt": "2020-03-06T10:15:30Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDAzNw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820037", "bodyText": "More sneaky", "author": "tivervac", "createdAt": "2020-03-06T10:15:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;\n+\t\ttry {\n+\t\t\treturn render();\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof Exception) {\n+\t\t\t\t_xtrycatchfinallyexpression = Throwables.getStackTraceAsString(t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg5NjYzMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388896631", "bodyText": "Not sure what to do with this ... any suggestion?", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDAzNw=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDEyNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820125", "bodyText": "more pure", "author": "tivervac", "createdAt": "2020-03-06T10:15:47Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;\n+\t\ttry {\n+\t\t\treturn render();\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof Exception) {\n+\t\t\t\t_xtrycatchfinallyexpression = Throwables.getStackTraceAsString(t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t\treturn _xtrycatchfinallyexpression;\n+\t}\n+\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex fee8796b3..0c15b20a3 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -13,21 +13,20 @@ import static com.google.common.collect.Multimaps.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n import org.eclipse.xtext.util.TextRegion;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n-import org.eclipse.xtext.xbase.lib.Conversions;\n-import org.eclipse.xtext.xbase.lib.Exceptions;\n import org.eclipse.xtext.xbase.lib.Functions.Function1;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDI2Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820266", "bodyText": "More pure", "author": "tivervac", "createdAt": "2020-03-06T10:16:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractURIWrapper.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public abstract class AbstractURIWrapper {\n+\tprivate final URI uri;\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn uri.toString();\n+\t}\n+\n+\tpublic AbstractURIWrapper(URI uri) {\n+\t\tthis.uri = uri;\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractURIWrapper.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractURIWrapper.java\nindex d32dd7818..16229dae1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractURIWrapper.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractURIWrapper.java\n\n@@ -9,7 +9,6 @@\n package org.eclipse.xtext.generator.trace;\n \n import org.eclipse.emf.common.util.URI;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n /**\n  * @author Sebastian Zarnekow - Initial contribution and API\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTQ3OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388845479", "bodyText": "sneaky", "author": "szarnekow", "createdAt": "2020-03-06T11:11:30Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTY4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388845689", "bodyText": "Not sure if out should better be buffered if it isn't already.", "author": "szarnekow", "createdAt": "2020-03-06T11:11:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwMTczNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388901734", "bodyText": "Not sure, too. As this is refactoring only I tend to not change behaviour.", "author": "ArneDeutsch", "createdAt": "2020-03-06T13:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex d2fe0e0ba..37130b4b1 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -11,10 +11,11 @@ package org.eclipse.xtext.generator;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjQ3MA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388846470", "bodyText": "obj.toString", "author": "szarnekow", "createdAt": "2020-03-06T11:13:51Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/SourceRelativeURI.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * A source relative URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class SourceRelativeURI extends AbstractURIWrapper {\n+\tpublic static SourceRelativeURI fromAbsolute(URI uri) {\n+\t\tif (uri.isRelative()) {\n+\t\t\tthrow new IllegalArgumentException(uri.toString());\n+\t\t}\n+\t\treturn new SourceRelativeURI(uri.path().substring(1));\n+\t}\n+\n+\tpublic SourceRelativeURI(URI sourceRelativeURI) {\n+\t\tsuper(sourceRelativeURI);\n+\t\tif (!sourceRelativeURI.isRelative() || sourceRelativeURI.path().startsWith(\"/\")) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(sourceRelativeURI));\n+\t\t}\n+\t}\n+\n+\tpublic SourceRelativeURI(String relativeURI) {\n+\t\tthis(URI.createURI(relativeURI));\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj != null && !Objects.equal(obj.getClass(), SourceRelativeURI.class)) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(obj) + \" instanceof \" + obj.getClass().getName());", "originalCommit": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1822521ec3c6e302f6b864c091a9449b16ead439", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/SourceRelativeURI.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/SourceRelativeURI.java\nindex e46042e4d..af3d9cec5 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/SourceRelativeURI.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/SourceRelativeURI.java\n\n@@ -39,7 +39,7 @@ public class SourceRelativeURI extends AbstractURIWrapper {\n \t@Override\n \tpublic boolean equals(Object obj) {\n \t\tif (obj != null && !Objects.equal(obj.getClass(), SourceRelativeURI.class)) {\n-\t\t\tthrow new IllegalArgumentException(String.valueOf(obj) + \" instanceof \" + obj.getClass().getName());\n+\t\t\tthrow new IllegalArgumentException(obj.toString() + \" instanceof \" + obj.getClass().getName());\n \t\t}\n \t\treturn super.equals(obj);\n \t}\n"}}, {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439", "url": "https://github.com/eclipse/xtext-core/commit/1822521ec3c6e302f6b864c091a9449b16ead439", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-06T13:57:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388924692", "bodyText": "Sure this should be an identity check?", "author": "tivervac", "createdAt": "2020-03-06T14:14:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index, EObject targetOrProxy,\n+\t\t\tURI targetURI) {\n+\t\tif (currentResource == null || source.eResource() != currentResource) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU4NjY3Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389586673", "bodyText": "Old generated code: if (((this.currentResource == null) || (source.eResource() != this.currentResource))) {\nHence: Yes, at least sure semantic has not changed.", "author": "ArneDeutsch", "createdAt": "2020-03-09T10:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4OTA4NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389789085", "bodyText": "\ud83d\udc4d", "author": "szarnekow", "createdAt": "2020-03-09T16:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNTQwNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388925406", "bodyText": "Collections.emptyMap", "author": "tivervac", "createdAt": "2020-03-06T14:15:24Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"A slot with name \\'\" + outputConfiguration + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\nindex 37130b4b1..a31605de9 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java\n\n@@ -16,6 +16,7 @@ import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n import java.io.UnsupportedEncodingException;\n+import java.util.Collections;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.URIConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjIxNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926214", "bodyText": "I'd move this three lines lower", "author": "tivervac", "createdAt": "2020-03-06T14:16:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\nindex b76bce70f..ebeeeda7b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n\n@@ -42,13 +42,12 @@ public class FileSystemAccessQueue extends AdapterImpl {\n \t}\n \n \tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\tif (monitor.isCanceled())\n+\t\t\tthrow new OperationCanceledException();\n \t\ttry {\n-\t\t\tif (monitor.isCanceled()) {\n-\t\t\t\tthrow new OperationCanceledException();\n-\t\t\t}\n \t\t\trequestQueue.put(request);\n \t\t\treturn request;\n-\t\t} catch (Throwable t) {\n+\t\t} catch (InterruptedException t) {\n \t\t\tthrow new OperationCanceledException();\n \t\t}\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjUxNg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926516", "bodyText": "This used to be an InterruptedException", "author": "tivervac", "createdAt": "2020-03-06T14:17:17Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\nindex b76bce70f..ebeeeda7b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java\n\n@@ -42,13 +42,12 @@ public class FileSystemAccessQueue extends AdapterImpl {\n \t}\n \n \tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\tif (monitor.isCanceled())\n+\t\t\tthrow new OperationCanceledException();\n \t\ttry {\n-\t\t\tif (monitor.isCanceled()) {\n-\t\t\t\tthrow new OperationCanceledException();\n-\t\t\t}\n \t\t\trequestQueue.put(request);\n \t\t\treturn request;\n-\t\t} catch (Throwable t) {\n+\t\t} catch (InterruptedException t) {\n \t\t\tthrow new OperationCanceledException();\n \t\t}\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjc2Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926766", "bodyText": "Redundant finals", "author": "tivervac", "createdAt": "2020-03-06T14:17:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessRequest implements Runnable {\n+\tprivate final URI uri;\n+\n+\tprivate final Runnable runMe;\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic FileSystemAccessRequest(final URI uri, final Runnable runMe) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\nindex f05c20dd0..7e42139f7 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n\n@@ -22,7 +22,7 @@ public class FileSystemAccessRequest implements Runnable {\n \t/**\n \t * @since 2.9\n \t */\n-\tpublic FileSystemAccessRequest(final URI uri, final Runnable runMe) {\n+\tpublic FileSystemAccessRequest(URI uri, Runnable runMe) {\n \t\tthis.uri = uri;\n \t\tthis.runMe = runMe;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTE1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388931159", "bodyText": "file_1?", "author": "tivervac", "createdAt": "2020-03-06T14:25:35Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex 0c15b20a3..c44d74d8b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -9,7 +9,9 @@\n package org.eclipse.xtext.generator.trace;\n \n import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Iterables.concat;\n import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.util.Strings.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTUzMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388931532", "bodyText": "Another it_1", "author": "tivervac", "createdAt": "2020-03-06T14:26:10Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU4OTczNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389589734", "bodyText": "Need to differentiate from \"it\" here ...", "author": "ArneDeutsch", "createdAt": "2020-03-09T10:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwMTYyNA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r390301624", "bodyText": "You can just call it \"handle\"", "author": "tivervac", "createdAt": "2020-03-10T13:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTUzMg=="}], "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex 0c15b20a3..c44d74d8b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -9,7 +9,9 @@\n package org.eclipse.xtext.generator.trace;\n \n import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Iterables.concat;\n import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.util.Strings.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjMwMg==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388932302", "bodyText": "No need for Integer.valueOf", "author": "tivervac", "createdAt": "2020-03-06T14:27:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU5MDIyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389590223", "bodyText": "In fact it is needed ... eclipse compiler does not complain, but maven build fails without. Guess there are subtable differences in compiler implementation.", "author": "ArneDeutsch", "createdAt": "2020-03-09T11:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex 0c15b20a3..c44d74d8b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -9,7 +9,9 @@\n package org.eclipse.xtext.generator.trace;\n \n import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Iterables.concat;\n import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.util.Strings.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDE1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388934159", "bodyText": "Static import this if there is no name collision", "author": "tivervac", "createdAt": "2020-03-06T14:30:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex 0c15b20a3..c44d74d8b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -9,7 +9,9 @@\n package org.eclipse.xtext.generator.trace;\n \n import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Iterables.concat;\n import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.util.Strings.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDI0NA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388934244", "bodyText": "Same", "author": "tivervac", "createdAt": "2020-03-06T14:30:53Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU5MTUxOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389591519", "bodyText": "In fact it is needed ... eclipse compiler does not complain, but maven build fails without. Guess there are subtable differences in compiler implementation.", "author": "ArneDeutsch", "createdAt": "2020-03-09T11:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\nindex 0c15b20a3..c44d74d8b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java\n\n@@ -9,7 +9,9 @@\n package org.eclipse.xtext.generator.trace;\n \n import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Iterables.concat;\n import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.util.Strings.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNTU3NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388935575", "bodyText": "This used to be IllegalArgumentException", "author": "tivervac", "createdAt": "2020-03-06T14:33:12Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(absoluteURI.toString());\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {", "originalCommit": "1822521ec3c6e302f6b864c091a9449b16ead439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2e39ad150fae434a096c502225e051ce459a4da", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\nindex 737ec8b4c..7bf2a7169 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java\n\n@@ -34,7 +34,7 @@ public class AbsoluteURI extends AbstractURIWrapper {\n \tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n \t\ttry {\n \t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n-\t\t} catch (Throwable t) {\n+\t\t} catch (IllegalArgumentException t) {\n \t\t\tthrow new IllegalArgumentException(\"Base URI was \" + getURI(), t);\n \t\t}\n \t}\n"}}, {"oid": "d2e39ad150fae434a096c502225e051ce459a4da", "url": "https://github.com/eclipse/xtext-core/commit/d2e39ad150fae434a096c502225e051ce459a4da", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-09T11:05:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NjQ3OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389796479", "bodyText": "A toString would be awesome.", "author": "szarnekow", "createdAt": "2020-03-09T16:12:23Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessRequest implements Runnable {", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\nindex 7e42139f7..0acbfa6c9 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java\n\n@@ -16,7 +16,6 @@ import org.eclipse.emf.common.util.URI;\n  */\n public class FileSystemAccessRequest implements Runnable {\n \tprivate final URI uri;\n-\n \tprivate final Runnable runMe;\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NzA0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389797049", "bodyText": "Cosmetics: Can be simplified to OutputConfigurationAdapter.class.equals(type)", "author": "szarnekow", "createdAt": "2020-03-09T16:13:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\nindex c975dd7ef..7f1f8ae97 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n\n@@ -12,9 +12,8 @@ import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n-import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n \n-import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n \n /**\n  * @noreference\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwMjAwMA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389802000", "bodyText": "Could be come Preconditions.checkNotNull(..) and the subsequent hashCode and equals implementation could be simplified.", "author": "szarnekow", "createdAt": "2020-03-09T16:20:37Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\nindex c975dd7ef..7f1f8ae97 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n\n@@ -12,9 +12,8 @@ import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n-import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n \n-import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n \n /**\n  * @noreference\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389830655", "bodyText": "It would be really useful if these would declare throws IOException", "author": "szarnekow", "createdAt": "2020-03-09T17:05:30Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Collections;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3MTA0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392071049", "bodyText": "Not sure here about API consequences ... and what about BeforeRead and BeforeDelete!?", "author": "ArneDeutsch", "createdAt": "2020-03-13T07:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4MjAxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392082018", "bodyText": "I tried to include beforeRead and beforeDelete in these.\nDeclaring an exception on the signature would be binary compatible, but source incompatible. However, since some the callbacks will be implemented with Xtend, it wouldn't matter (sneakyThrow ...). @cdietrich What's your take?", "author": "szarnekow", "createdAt": "2020-03-13T08:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4MjQ4MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392082481", "bodyText": "is there anybody out there using (calling) this at all?", "author": "cdietrich", "createdAt": "2020-03-13T08:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4Mjk4MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r392082981", "bodyText": "maybe you can have a look at these", "author": "cdietrich", "createdAt": "2020-03-13T08:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTA0Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389831046", "bodyText": "There is only a single field. We could try to avoid the ToStringBuilder", "author": "szarnekow", "createdAt": "2020-03-09T17:06:09Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn new ToStringBuilder(this).addAllFields().toString();", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\nindex c975dd7ef..7f1f8ae97 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java\n\n@@ -12,9 +12,8 @@ import java.util.Map;\n import java.util.Set;\n \n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n-import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n \n-import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n \n /**\n  * @noreference\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTM5Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389831396", "bodyText": "Severity is an enum - identity comparison could be used here.", "author": "szarnekow", "createdAt": "2020-03-09T17:06:42Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+@ImplementedBy(IShouldGenerate.OnlyWithoutErrors.class)\n+public interface IShouldGenerate {\n+\t@Beta\n+\t@Singleton\n+\tclass OnlyWithoutErrors implements IShouldGenerate {\n+\t\t@Inject\n+\t\tprivate IResourceValidator resourceValidator;\n+\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tif (!resource.getErrors().isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<Issue> issues = resourceValidator.validate(resource, CheckMode.NORMAL_AND_FAST, cancelIndicator);\n+\t\t\treturn !exists(issues, (Issue issue) -> Objects.equal(issue.getSeverity(), Severity.ERROR));", "originalCommit": "d2e39ad150fae434a096c502225e051ce459a4da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "url": "https://github.com/eclipse/xtext-core/commit/9f4bf0fb16a8d36a8252a316db7602d7387a2697", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-13T07:46:15Z", "type": "commit"}, {"oid": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "url": "https://github.com/eclipse/xtext-core/commit/9f4bf0fb16a8d36a8252a316db7602d7387a2697", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-03-13T07:46:15Z", "type": "forcePushed"}]}