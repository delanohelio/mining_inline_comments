{"pr_number": 1469, "pr_title": "[#1467] Made lookAhead independent from encountered hidden tokens", "pr_createdAt": "2020-05-03T16:16:56Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1469", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4OTA4Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1469#discussion_r419289082", "bodyText": "what if rootNode is null?", "author": "cdietrich", "createdAt": "2020-05-04T08:42:11Z", "path": "org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/util/ParseHelper.java", "diffHunk": "@@ -40,6 +48,13 @@ public void setFileExtensionProvider(FileExtensionProvider extensionProvider) {\n \tpublic T parse(InputStream in, URI uriToUse, Map<?, ?> options, ResourceSet resourceSet) {\n \t\tresourceHelper.setFileExtension(fileExtension);\n \t\tResource resource = resourceHelper.resource(in, uriToUse, options, resourceSet);\n+\t\tif (resource instanceof XtextResource) {\n+\t\t\tIParseResult parseResult = ((XtextResource) resource).getParseResult();\n+\t\t\tif (parseResult != null) {\n+\t\t\t\tICompositeNode rootNode = parseResult.getRootNode();", "originalCommit": "91d3d14a20244f59d86eb7271b59d286ba68be8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c5c754184de772e735a6a4788e1054ee9e06de59", "chunk": "diff --git a/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/util/ParseHelper.java b/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/util/ParseHelper.java\nindex 11f7902ed..4d42a3fca 100644\n--- a/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/util/ParseHelper.java\n+++ b/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/util/ParseHelper.java\n\n@@ -48,13 +40,6 @@ public class ParseHelper<T extends EObject> {\n \tpublic T parse(InputStream in, URI uriToUse, Map<?, ?> options, ResourceSet resourceSet) {\n \t\tresourceHelper.setFileExtension(fileExtension);\n \t\tResource resource = resourceHelper.resource(in, uriToUse, options, resourceSet);\n-\t\tif (resource instanceof XtextResource) {\n-\t\t\tIParseResult parseResult = ((XtextResource) resource).getParseResult();\n-\t\t\tif (parseResult != null) {\n-\t\t\t\tICompositeNode rootNode = parseResult.getRootNode();\n-\t\t\t\tcheckNodeModel(rootNode);\n-\t\t\t}\n-\t\t}\n \t\tfinal T root = (T) (resource.getContents().isEmpty() ? null : resource.getContents().get(0));\n \t\treturn root;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MTY5MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1469#discussion_r419291691", "bodyText": "@Beta ? @since ?", "author": "cdietrich", "createdAt": "2020-05-04T08:46:57Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/nodemodel/LookAheadInfo.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.nodemodel;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.eclipse.xtext.Action;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Utility to work with the lookAhead information in the node model.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class LookAheadInfo {", "originalCommit": "91d3d14a20244f59d86eb7271b59d286ba68be8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c5c754184de772e735a6a4788e1054ee9e06de59", "chunk": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/nodemodel/LookAheadInfo.java b/org.eclipse.xtext/src/org/eclipse/xtext/nodemodel/LookAheadInfo.java\ndeleted file mode 100644\nindex 8ba2e69f1..000000000\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/nodemodel/LookAheadInfo.java\n+++ /dev/null\n\n@@ -1,96 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 Sebastian Zarnekow and others.\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0.\n- * \n- * SPDX-License-Identifier: EPL-2.0\n- *******************************************************************************/\n-package org.eclipse.xtext.nodemodel;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.eclipse.xtext.Action;\n-\n-import com.google.common.base.Preconditions;\n-\n-/**\n- * Utility to work with the lookAhead information in the node model.\n- * \n- * @author Sebastian Zarnekow - Initial contribution and API\n- */\n-public class LookAheadInfo {\n-\n-\t/* TODO \n-\t * - add getLookAhead(INode node) with support for leaf-nodes\n-\t * - add getLookBeyond(INode node)\n-\t * - getParserInformation(int offset): ParserInformation with ParserInformation( ParserRule, TextRegion, Iterator**) \n-\t *   usable for content assist, e.g. it must support parameterized rule stack recreation\n-\t * - getEntryPoint(int offset, int length, String newText) with support for partial parsing (consider lookBeyond)\n-\t * - Iterator** returns an iterator over nodes from the entry point to the position such that\n-\t *   the parser would reach the position as fast as possible, e.g. an iterator that skips over\n-\t *   regions that are not relevant to the parsers decision\n-\t * - INode.getLookAheadInfo(): LookAheadInfo as default method that uses the resource to obtain an \n-\t *   injectable LookAheadInfo.Factory from allow customization\n-\t */\n-\t\n-\tpublic static class InconsistentLookAheadException extends RuntimeException {\n-\n-\t\tprivate static final long serialVersionUID = 1L;\n-\n-\t\tpublic InconsistentLookAheadException(String message, Throwable cause) {\n-\t\t\tsuper(message, cause);\n-\t\t}\n-\n-\t\tpublic InconsistentLookAheadException(String message) {\n-\t\t\tsuper(message);\n-\t\t}\n-\t\t\n-\t}\n-\n-\tprivate final ICompositeNode rootNode;\n-\n-\tpublic LookAheadInfo(ICompositeNode rootNode) {\n-\t\tPreconditions.checkArgument(rootNode.getRootNode() == rootNode);\n-\t\tthis.rootNode = rootNode;\n-\t}\n-\t\n-\tpublic void checkConsistency() throws InconsistentLookAheadException {\n-\t\tAtomicInteger currentLookAhead = new AtomicInteger();\n-\t\tfor(INode node: rootNode.getAsTreeIterable()) {\n-\t\t\tcheckConsistency(node, currentLookAhead);\n-\t\t}\n-\t}\n-\t\n-\tprotected void checkConsistency(INode node, AtomicInteger currentLookAhead) {\n-\t\tif (node instanceof ICompositeNode) {\n-\t\t\tcheckConsistency((ICompositeNode)node, currentLookAhead);\n-\t\t} else {\n-\t\t\tcheckConsistency((ILeafNode)node, currentLookAhead);\n-\t\t}\n-\t}\n-\t\n-\tprotected void checkConsistency(ICompositeNode node, AtomicInteger currentLookAhead) {\n-\t\tint nodeLookAhead = node.getLookAhead();\n-\t\tif (node.getGrammarElement() instanceof Action) {\n-\t\t\tICompositeNode firstChild = (ICompositeNode) node.getFirstChild();\n-\t\t\tif (firstChild.getLookAhead() != nodeLookAhead) {\n-\t\t\t\tthrow new InconsistentLookAheadException(\n-\t\t\t\t\t\tString.format(\"Action nodes must have the lookahead of their first child. Expected %d but was %d at offset %d (%s)\", nodeLookAhead, firstChild.getLookAhead(), node.getTotalOffset(), node.getText()));\n-\t\t\t}\n-\t\t}\n-\t\tif (nodeLookAhead > currentLookAhead.get()) {\n-\t\t\tcurrentLookAhead.set(nodeLookAhead);\n-\t\t} else if (nodeLookAhead < currentLookAhead.get()) {\n-\t\t\tthrow new InconsistentLookAheadException(\n-\t\t\t\t\tString.format(\"Expected at least %d but found %d at offset %d (%s)\", currentLookAhead.get(), nodeLookAhead, node.getTotalOffset(), node.getText()));\n-\t\t}\n-\t}\n-\t\n-\tprotected void checkConsistency(ILeafNode node, AtomicInteger currentLookAhead) {\n-\t\tif (!node.isHidden()) {\n-\t\t\tcurrentLookAhead.updateAndGet(old->old > 0 ? old - 1 : old);\n-\t\t}\n-\t}\n-\t\n-}\n"}}, {"oid": "c5c754184de772e735a6a4788e1054ee9e06de59", "url": "https://github.com/eclipse/xtext-core/commit/c5c754184de772e735a6a4788e1054ee9e06de59", "message": "[#1467] Added more tests for lookAhead", "committedDate": "2020-05-04T11:52:12Z", "type": "commit"}, {"oid": "7cf5abc79e88340a69918167958f9eaea1b850b2", "url": "https://github.com/eclipse/xtext-core/commit/7cf5abc79e88340a69918167958f9eaea1b850b2", "message": "[#1467] Made lookAhead independent from encountered hidden tokens", "committedDate": "2020-05-04T11:52:13Z", "type": "commit"}, {"oid": "735bed10cabd09deb7fde3a034b0a80a0cf540f8", "url": "https://github.com/eclipse/xtext-core/commit/735bed10cabd09deb7fde3a034b0a80a0cf540f8", "message": "[#1467] Add consistency checks to all parsing routines in tests", "committedDate": "2020-05-04T11:52:13Z", "type": "commit"}, {"oid": "0897f6f9de42cae8615ec770ff365f335b2b3824", "url": "https://github.com/eclipse/xtext-core/commit/0897f6f9de42cae8615ec770ff365f335b2b3824", "message": "Adjust pipelines", "committedDate": "2020-05-04T11:52:13Z", "type": "forcePushed"}, {"oid": "735bed10cabd09deb7fde3a034b0a80a0cf540f8", "url": "https://github.com/eclipse/xtext-core/commit/735bed10cabd09deb7fde3a034b0a80a0cf540f8", "message": "[#1467] Add consistency checks to all parsing routines in tests", "committedDate": "2020-05-04T11:52:13Z", "type": "forcePushed"}, {"oid": "190e326af7a83faa12612b1429940a0d25f5ac67", "url": "https://github.com/eclipse/xtext-core/commit/190e326af7a83faa12612b1429940a0d25f5ac67", "message": "Review feedback", "committedDate": "2020-05-04T13:54:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjI0OA==", "url": "https://github.com/eclipse/xtext-core/pull/1469#discussion_r426446248", "bodyText": "@szarnekow @cdietrich Should the inner class be marked with the @since 2.22 as well, or it is enough if the outer class have the @since 2.22 tag?", "author": "miklossy", "createdAt": "2020-05-18T08:16:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/nodemodel/LookAheadInfo.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.nodemodel;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.eclipse.xtext.Action;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Utility to work with the lookAhead information in the node model.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * \n+ * @since 2.22\n+ */\n+@Beta\n+public class LookAheadInfo {\n+\n+\t/* TODO \n+\t * - add getLookAhead(INode node) with support for leaf-nodes\n+\t * - add getLookBeyond(INode node)\n+\t * - getParserInformation(int offset): ParserInformation with ParserInformation( ParserRule, TextRegion, Iterator**) \n+\t *   usable for content assist, e.g. it must support parameterized rule stack recreation\n+\t * - getEntryPoint(int offset, int length, String newText) with support for partial parsing (consider lookBeyond)\n+\t * - Iterator** returns an iterator over nodes from the entry point to the position such that\n+\t *   the parser would reach the position as fast as possible, e.g. an iterator that skips over\n+\t *   regions that are not relevant to the parsers decision\n+\t * - INode.getLookAheadInfo(): LookAheadInfo as default method that uses the resource to obtain an \n+\t *   injectable LookAheadInfo.Factory from allow customization\n+\t */\n+\t\n+\tpublic static class InconsistentLookAheadException extends RuntimeException {", "originalCommit": "190e326af7a83faa12612b1429940a0d25f5ac67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjgwMA==", "url": "https://github.com/eclipse/xtext-core/pull/1469#discussion_r426446800", "bodyText": "It is enough for the enclosing type.", "author": "szarnekow", "createdAt": "2020-05-18T08:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjI0OA=="}], "type": "inlineReview", "revised_code": null}]}