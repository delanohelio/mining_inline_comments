{"pr_number": 1631, "pr_title": "[#1625] Added a lot of tests and a few fixes to the formatter.", "pr_createdAt": "2020-11-27T14:49:35Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1631", "timeline": [{"oid": "2c2d5b987e68c54143d28abefb0bbeae41448ce7", "url": "https://github.com/eclipse/xtext-core/commit/2c2d5b987e68c54143d28abefb0bbeae41448ce7", "message": "[#1625] Added a lot of tests and a few fixes to the formatter.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-11-27T14:48:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4MzkwNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1631#discussion_r531683905", "bodyText": "wonder if simply using a real tab makes this more readable", "author": "cdietrich", "createdAt": "2020-11-27T16:16:57Z", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/formatting2/internal/JavaFormatterGrammarTest.java", "diffHunk": "@@ -181,7 +181,223 @@ public void conjunctedGuardExpressions() {\n \t\t\t\t);\n \t\t// @formatter:on\n \t}\n-\t\n+\n+\t@Test\n+\tpublic void bug287941TestLanguage() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"WhereEntry returns WhereEntry:\" + NL +\n+\t\t\t\tTAB + \"AndWhereEntry ({OrWhereEntry.entries+=current} \" + NL +\n+\t\t\t\tTAB + TAB + \"(\\\"or\\\" entries+=AndWhereEntry)+)?\" + NL +\n+\t\t\t\t\";\"\n+\t\t\t\t,\n+\t\t\t\t\"WhereEntry returns WhereEntry:\" + NL +\n+\t\t\t\tTAB + \"AndWhereEntry ({OrWhereEntry.entries+=current}\" + NL +\n+\t\t\t\tTAB + \"(\\\"or\\\" entries+=AndWhereEntry)+)?;\"\n+\t\t\t\t);\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void codetemplates() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"Codetemplate:\" + NL +\n+\t\t\t\t\"  name=ValidID '(' id=ID ',' description = STRING ')' 'for' \" + NL +\n+\t\t\t\t\"        (context=[xtext::AbstractRule|ValidID] | keywordContext=STRING) \" + NL +\n+\t\t\t\t\"    body = TemplateBodyWithQuotes\" + NL +\n+\t\t\t\t\"  ; \"\n+\t\t\t\t,\n+\t\t\t\t\"Codetemplate:\" + NL +\n+\t\t\t\tTAB + \"name=ValidID '(' id=ID ',' description=STRING ')' 'for'\" + NL +\n+\t\t\t\tTAB + \"(context=[xtext::AbstractRule|ValidID] | keywordContext=STRING)\" + NL +\n+\t\t\t\tTAB + \"body=TemplateBodyWithQuotes;\"\n+\t\t\t\t);\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void bug297105TestLanguage() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"Real hidden(): INT ? '.' (EXT_INT | INT);\"\n+\t\t\t\t,\n+\t\t\t\t\"Real hidden():\" + NL +\n+\t\t\t\tTAB + \"INT? '.' (EXT_INT | INT);\"\n+\t\t\t\t);\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void xtextGrammarTestLanguage() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"ParserRule :\" + NL +\n+\t\t\t\t\"(\" + NL +\n+\t\t\t\tTAB +   \"  ^fragment?='fragment' RuleNameAndParams (wildcard?='*' | ReturnsClause?) \" + NL +\n+\t\t\t\tTAB + \"| RuleNameAndParams ReturnsClause?\" + NL +\n+\t\t\t\tTAB + \")\" + NL +\n+\t\t\t\tTAB + \"HiddenClause? ':'\" + NL +\n+\t\t\t\t\"   \" + TAB + \"alternatives=Alternatives   \" + NL +\n+\t\t\t\t\"    ';'\" + NL +\n+\t\t\t\t\";\"\n+\t\t\t\t,\n+\t\t\t\t\"ParserRule:\" + NL +\n+\t\t\t\tTAB + \"(^fragment?='fragment' RuleNameAndParams (wildcard?='*' | ReturnsClause?)\" + NL +\n+\t\t\t\tTAB + \"| RuleNameAndParams ReturnsClause?)\" + NL +\n+\t\t\t\tTAB + \"HiddenClause? ':'\" + NL +\n+\t\t\t\tTAB + \"alternatives=Alternatives\" + NL +\n+\t\t\t\tTAB + \"';';\"\n+\t\t\t\t);\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void qualifiedTypes() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"AType returns root::AType:\" + NL +\n+\t\t\t\tTAB + \"'foo' {root::AType};\"\n+\t\t\t\t,\n+\t\t\t\t\"AType returns root::AType:\" + NL +\n+\t\t\t\tTAB + \"'foo' {root::AType};\"\n+\t\t\t\t);\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void qualifiedTypes2() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"AType returns root :: AType :\" + NL +\n+\t\t\t\tTAB + \"'foo' { root :: AType };\"\n+\t\t\t\t,\n+\t\t\t\t\"AType returns root::AType:\" + NL +\n+\t\t\t\tTAB + \"'foo' {root::AType};\"\n+\t\t\t\t);\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void pureXbase() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"@Override \" + NL +\n+\t\t\t\t\"XAssignment returns xbase::XExpression :\" + NL +\n+\t\t\t\t\"\t{xbase::XAssignment} feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign value=XAssignment |\" + NL +\n+\t\t\t\t\"\tXConditionalExpression (\" + NL +\n+\t\t\t\t\"\t\t=>({xbase::XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpMultiAssign]) rightOperand=XAssignment\" + NL +\n+\t\t\t\t\"\t)?;\"\n+\t\t\t\t,\n+\t\t\t\t\"@Override\" + NL +\n+\t\t\t\t\"XAssignment returns xbase::XExpression:\" + NL +\n+\t\t\t\tTAB + \"{xbase::XAssignment} feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign value=XAssignment |\" + NL +\n+\t\t\t\tTAB + \"XConditionalExpression (=>({xbase::XBinaryOperation.leftOperand=current}\" + NL +\n+\t\t\t\tTAB + \"feature=[types::JvmIdentifiableElement|OpMultiAssign]) rightOperand=XAssignment)?;\"\n+\t\t\t\t);\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void pureXbase2() {\n+\t\t// @formatter:off\n+\t\tassertFormattedGrammar(\n+\t\t\t\t\"XClosure returns XExpression:\" + NL +\n+\t\t\t\t\"\t=>({XClosure}\" + NL +\n+\t\t\t\t\"\t'[')\" + NL +\n+\t\t\t\t\"\t\t=>((declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|')?\" + NL +\n+\t\t\t\t\"\t\texpression=XExpressionInClosure\" + NL +\n+\t\t\t\t\"\t']';\"\n+\t\t\t\t,\n+\t\t\t\t\"XClosure returns XExpression:\" + NL +\n+\t\t\t\tTAB + \"=>({XClosure}\" + NL +", "originalCommit": "2c2d5b987e68c54143d28abefb0bbeae41448ce7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}