{"pr_number": 5454, "pr_title": "Lowers log level of RequestRetriesExhaustedException in the gateway", "pr_createdAt": "2020-10-01T15:49:15Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5454", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NzI4MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5454#discussion_r498647281", "bodyText": "Should we set the status then to resource exhausted? As we do with the BrokerResourceExhausted exception?", "author": "Zelldon", "createdAt": "2020-10-02T07:03:49Z", "path": "gateway/src/main/java/io/zeebe/gateway/EndpointManager.java", "diffHunk": "@@ -419,6 +420,12 @@ public static StatusRuntimeException convertThrowable(final Throwable cause) {\n       status = Status.NOT_FOUND.augmentDescription(cause.getMessage());\n       Loggers.GATEWAY_LOGGER.debug(\n           \"Expected to handle gRPC request, but request could not be delivered\", cause);\n+    } else if (cause instanceof RequestRetriesExhaustedException) {\n+      // this error occurs when all partitions have exhausted for requests which have no fixed\n+      // partitions - it will then also occur when back pressure kicks in, leading to a large burst\n+      // of error logs that is, in fact, expected\n+      Loggers.GATEWAY_LOGGER.trace(", "originalCommit": "8c9e43728c95113c51a4a4e687cb488d737c490f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NzU4Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5454#discussion_r498647583", "bodyText": "Previous it was unexpected error occured or what was logged and returned?", "author": "Zelldon", "createdAt": "2020-10-02T07:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NzI4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b7e38d82f292e9f2d7d5a08ee6daf893af1d5b50", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\nindex a54621c6d..ee637d3b0 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n\n@@ -298,181 +276,71 @@ public final class EndpointManager extends GatewayGrpc.GatewayImplBase {\n       final GrpcRequestT grpcRequest,\n       final Function<GrpcRequestT, BrokerRequest<BrokerResponseT>> requestMapper,\n       final BrokerResponseMapper<BrokerResponseT, GrpcResponseT> responseMapper,\n-      final StreamObserver<GrpcResponseT> streamObserver) {\n+      final ServerStreamObserver<GrpcResponseT> streamObserver) {\n+    final BrokerRequest<BrokerResponseT> brokerRequest;\n \n-    final BrokerRequest<BrokerResponseT> brokerRequest =\n-        mapRequest(grpcRequest, requestMapper, streamObserver);\n-    if (brokerRequest == null) {\n+    try {\n+      brokerRequest = requestMapper.apply(grpcRequest);\n+    } catch (final Exception e) {\n+      streamObserver.onError(e);\n       return;\n     }\n \n-    suppressCancelledException(grpcRequest, streamObserver);\n     brokerClient.sendRequestWithRetry(\n         brokerRequest,\n         (key, response) -> consumeResponse(responseMapper, streamObserver, key, response),\n-        error -> streamObserver.onError(convertThrowable(error)));\n+        streamObserver::onError);\n   }\n \n   private <GrpcRequestT, BrokerResponseT, GrpcResponseT> void sendRequestWithRetryPartitions(\n       final GrpcRequestT grpcRequest,\n       final Function<GrpcRequestT, BrokerRequest<BrokerResponseT>> requestMapper,\n       final BrokerResponseMapper<BrokerResponseT, GrpcResponseT> responseMapper,\n-      final StreamObserver<GrpcResponseT> streamObserver) {\n+      final ServerStreamObserver<GrpcResponseT> streamObserver) {\n+    final BrokerRequest<BrokerResponseT> brokerRequest;\n \n-    final BrokerRequest<BrokerResponseT> brokerRequest =\n-        mapRequest(grpcRequest, requestMapper, streamObserver);\n-    if (brokerRequest == null) {\n+    try {\n+      brokerRequest = requestMapper.apply(grpcRequest);\n+    } catch (final Exception e) {\n+      streamObserver.onError(e);\n       return;\n     }\n \n-    suppressCancelledException(grpcRequest, streamObserver);\n     requestRetryHandler.sendRequest(\n         brokerRequest,\n         (key, response) -> consumeResponse(responseMapper, streamObserver, key, response),\n-        error -> streamObserver.onError(convertThrowable(error)));\n+        streamObserver::onError);\n   }\n \n   private <GrpcRequestT, BrokerResponseT, GrpcResponseT> void sendRequestWithRetryPartitions(\n       final GrpcRequestT grpcRequest,\n       final Function<GrpcRequestT, BrokerRequest<BrokerResponseT>> requestMapper,\n       final BrokerResponseMapper<BrokerResponseT, GrpcResponseT> responseMapper,\n-      final StreamObserver<GrpcResponseT> streamObserver,\n+      final ServerStreamObserver<GrpcResponseT> streamObserver,\n       final Duration timeout) {\n+    final BrokerRequest<BrokerResponseT> brokerRequest;\n \n-    final BrokerRequest<BrokerResponseT> brokerRequest =\n-        mapRequest(grpcRequest, requestMapper, streamObserver);\n-    if (brokerRequest == null) {\n+    try {\n+      brokerRequest = requestMapper.apply(grpcRequest);\n+    } catch (final Exception e) {\n+      streamObserver.onError(e);\n       return;\n     }\n \n-    suppressCancelledException(grpcRequest, streamObserver);\n     requestRetryHandler.sendRequest(\n         brokerRequest,\n         (key, response) -> consumeResponse(responseMapper, streamObserver, key, response),\n-        error -> streamObserver.onError(convertThrowable(error)),\n+        streamObserver::onError,\n         timeout);\n   }\n \n-  private <GrpcRequestT, GrpcResponseT> void suppressCancelledException(\n-      final GrpcRequestT grpcRequest, final StreamObserver<GrpcResponseT> streamObserver) {\n-    final ServerCallStreamObserver<GrpcResponseT> serverObserver =\n-        (ServerCallStreamObserver<GrpcResponseT>) streamObserver;\n-    serverObserver.setOnCancelHandler(\n-        () -> Loggers.GATEWAY_LOGGER.trace(\"gRPC {} request cancelled\", grpcRequest.getClass()));\n-  }\n-\n   private <BrokerResponseT, GrpcResponseT> void consumeResponse(\n       final BrokerResponseMapper<BrokerResponseT, GrpcResponseT> responseMapper,\n-      final StreamObserver<GrpcResponseT> streamObserver,\n+      final ServerStreamObserver<GrpcResponseT> streamObserver,\n       final long key,\n       final BrokerResponseT response) {\n     final GrpcResponseT grpcResponse = responseMapper.apply(key, response);\n     streamObserver.onNext(grpcResponse);\n     streamObserver.onCompleted();\n   }\n-\n-  private <GrpcRequestT, BrokerResponseT, GrpcResponseT> BrokerRequest<BrokerResponseT> mapRequest(\n-      final GrpcRequestT grpcRequest,\n-      final Function<GrpcRequestT, BrokerRequest<BrokerResponseT>> requestMapper,\n-      final StreamObserver<GrpcResponseT> streamObserver) {\n-    try {\n-      return requestMapper.apply(grpcRequest);\n-    } catch (final Exception e) {\n-      streamObserver.onError(convertThrowable(e));\n-      return null;\n-    }\n-  }\n-\n-  public static StatusRuntimeException convertThrowable(final Throwable cause) {\n-    Status status = Status.INTERNAL;\n-\n-    if (cause instanceof ExecutionException) {\n-      return convertThrowable(cause.getCause());\n-    } else if (cause instanceof BrokerErrorException) {\n-      status = mapBrokerErrorToStatus(((BrokerErrorException) cause).getError());\n-      // When there is back pressure, there will be a lot of `RESOURCE_EXHAUSTED` errors and the log\n-      // can get flooded. Until we find a way to limit the number of log messages,\n-      // let's do not log them.\n-      if (status.getCode() != Status.RESOURCE_EXHAUSTED.getCode()) {\n-        Loggers.GATEWAY_LOGGER.error(\n-            \"Expected to handle gRPC request, but received error from broker\", cause);\n-      }\n-    } else if (cause instanceof BrokerRejectionException) {\n-      status = mapRejectionToStatus(((BrokerRejectionException) cause).getRejection());\n-      Loggers.GATEWAY_LOGGER.debug(\n-          \"Expected to handle gRPC request, but broker rejected request\", cause);\n-    } else if (cause instanceof TimeoutException) { // can be thrown by transport\n-      status =\n-          Status.DEADLINE_EXCEEDED.augmentDescription(\n-              \"Time out between gateway and broker: \" + cause.getMessage());\n-      Loggers.GATEWAY_LOGGER.debug(\n-          \"Expected to handle gRPC request, but request timed out between gateway and broker\",\n-          cause);\n-    } else if (cause instanceof InvalidBrokerRequestArgumentException) {\n-      status = Status.INVALID_ARGUMENT.augmentDescription(cause.getMessage());\n-      Loggers.GATEWAY_LOGGER.debug(\n-          \"Expected to handle gRPC request, but broker argument was invalid\", cause);\n-    } else if (cause instanceof MsgpackPropertyException) {\n-      status = Status.INVALID_ARGUMENT.augmentDescription(cause.getMessage());\n-      Loggers.GATEWAY_LOGGER.debug(\n-          \"Expected to handle gRPC request, but messagepack property was invalid\", cause);\n-    } else if (cause instanceof PartitionNotFoundException) {\n-      status = Status.NOT_FOUND.augmentDescription(cause.getMessage());\n-      Loggers.GATEWAY_LOGGER.debug(\n-          \"Expected to handle gRPC request, but request could not be delivered\", cause);\n-    } else if (cause instanceof RequestRetriesExhaustedException) {\n-      // this error occurs when all partitions have exhausted for requests which have no fixed\n-      // partitions - it will then also occur when back pressure kicks in, leading to a large burst\n-      // of error logs that is, in fact, expected\n-      Loggers.GATEWAY_LOGGER.trace(\n-          \"Expected to handle gRPC request, but all retries have been exhausted\", cause);\n-    } else {\n-      status = status.augmentDescription(\"Unexpected error occurred during the request processing\");\n-      Loggers.GATEWAY_LOGGER.error(\n-          \"Expected to handle gRPC request, but an unexpected error occurred\", cause);\n-    }\n-\n-    return status.withCause(cause).asRuntimeException();\n-  }\n-\n-  private static Status mapBrokerErrorToStatus(final BrokerError error) {\n-    switch (error.getCode()) {\n-      case WORKFLOW_NOT_FOUND:\n-        return Status.NOT_FOUND.augmentDescription(error.getMessage());\n-      case RESOURCE_EXHAUSTED:\n-        return Status.RESOURCE_EXHAUSTED.augmentDescription(error.getMessage());\n-      default:\n-        return Status.INTERNAL.augmentDescription(\n-            String.format(\n-                \"Unexpected error occurred between gateway and broker (code: %s)\",\n-                error.getCode()));\n-    }\n-  }\n-\n-  private static Status mapRejectionToStatus(final BrokerRejection rejection) {\n-    final String description =\n-        String.format(\n-            \"Command rejected with code '%s': %s\", rejection.getIntent(), rejection.getReason());\n-    final Status status;\n-\n-    switch (rejection.getType()) {\n-      case INVALID_ARGUMENT:\n-        status = Status.INVALID_ARGUMENT;\n-        break;\n-      case NOT_FOUND:\n-        status = Status.NOT_FOUND;\n-        break;\n-      case ALREADY_EXISTS:\n-        status = Status.ALREADY_EXISTS;\n-        break;\n-      case INVALID_STATE:\n-        status = Status.FAILED_PRECONDITION;\n-        break;\n-      default:\n-        status = Status.UNKNOWN;\n-        break;\n-    }\n-\n-    return status.augmentDescription(description);\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NzM4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5454#discussion_r498647387", "bodyText": "Do you think it is necessary?", "author": "Zelldon", "createdAt": "2020-10-02T07:04:09Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetriesExhaustedException.java", "diffHunk": "@@ -9,7 +9,9 @@\n \n import io.zeebe.gateway.cmd.ClientException;\n \n-class RequestRetriesExhaustedException extends ClientException {\n+public class RequestRetriesExhaustedException extends ClientException {\n+\n+  private static final long serialVersionUID = 1493435667474886479L;", "originalCommit": "8c9e43728c95113c51a4a4e687cb488d737c490f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgzMTg3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5454#discussion_r498831875", "bodyText": "No, sorry, my IDE automatically adds it \ud83d\ude48", "author": "npepinpe", "createdAt": "2020-10-02T13:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NzM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b7e38d82f292e9f2d7d5a08ee6daf893af1d5b50", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetriesExhaustedException.java b/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetriesExhaustedException.java\nindex 3d9ee21ce..cb9e5aee3 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetriesExhaustedException.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetriesExhaustedException.java\n\n@@ -9,9 +9,7 @@ package io.zeebe.gateway.impl.broker;\n \n import io.zeebe.gateway.cmd.ClientException;\n \n-public class RequestRetriesExhaustedException extends ClientException {\n-\n-  private static final long serialVersionUID = 1493435667474886479L;\n+public final class RequestRetriesExhaustedException extends ClientException {\n \n   RequestRetriesExhaustedException() {\n     super(\n"}}, {"oid": "b7e38d82f292e9f2d7d5a08ee6daf893af1d5b50", "url": "https://github.com/camunda-cloud/zeebe/commit/b7e38d82f292e9f2d7d5a08ee6daf893af1d5b50", "message": "chore(gateway): log retries exhausted as debug only", "committedDate": "2020-10-14T11:18:52Z", "type": "commit"}, {"oid": "26307e22060c532cca8f4585ab8e839baa1431e5", "url": "https://github.com/camunda-cloud/zeebe/commit/26307e22060c532cca8f4585ab8e839baa1431e5", "message": "chore(gateway): further lower log level", "committedDate": "2020-10-14T11:20:32Z", "type": "commit"}, {"oid": "2665d46bd0770d0ae09aaa36c04ba40b380fd1df", "url": "https://github.com/camunda-cloud/zeebe/commit/2665d46bd0770d0ae09aaa36c04ba40b380fd1df", "message": "chore(gateway): introduce error details", "committedDate": "2020-10-14T12:23:23Z", "type": "forcePushed"}, {"oid": "5e34c52b8943f956f0a1f35b918288e7bd03ae14", "url": "https://github.com/camunda-cloud/zeebe/commit/5e34c52b8943f956f0a1f35b918288e7bd03ae14", "message": "chore(gateway): introduce error details", "committedDate": "2020-10-14T13:35:18Z", "type": "forcePushed"}, {"oid": "40640e19228d0982ed65bdf975d11d2ee16b326a", "url": "https://github.com/camunda-cloud/zeebe/commit/40640e19228d0982ed65bdf975d11d2ee16b326a", "message": "chore(gateway): introduce error details", "committedDate": "2020-10-14T13:42:14Z", "type": "forcePushed"}, {"oid": "a3e7f97a5d5803bc37ac85841854bf4297746681", "url": "https://github.com/camunda-cloud/zeebe/commit/a3e7f97a5d5803bc37ac85841854bf4297746681", "message": "chore(gateway): introduce error details", "committedDate": "2020-10-14T13:56:23Z", "type": "commit"}, {"oid": "a3e7f97a5d5803bc37ac85841854bf4297746681", "url": "https://github.com/camunda-cloud/zeebe/commit/a3e7f97a5d5803bc37ac85841854bf4297746681", "message": "chore(gateway): introduce error details", "committedDate": "2020-10-14T13:56:23Z", "type": "forcePushed"}]}