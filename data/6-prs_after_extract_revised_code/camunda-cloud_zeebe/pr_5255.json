{"pr_number": 5255, "pr_title": "Take snapshots at same index if either exporter or processor position changed", "pr_createdAt": "2020-08-28T09:17:18Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5255", "timeline": [{"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "url": "https://github.com/camunda-cloud/zeebe/commit/5e18ceedb01ec29e99d2ca819e1e17565a891c59", "message": "chore(snapshots): fix for backward compatibility", "committedDate": "2020-08-28T12:01:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1NDUzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479154531", "bodyText": "Should be assertAllNodesHaveSnapshotWithIndex", "author": "Zelldon", "createdAt": "2020-08-28T11:22:47Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -347,7 +343,7 @@ public void shouldReplicateSnapshotToOldLeaderAfterRestart() throws Exception {\n     raftRule.joinCluster(leader);\n \n     // then\n-    assertThat(raftRule.allNodesHaveSnapshotWithIndex(200)).isTrue();\n+    raftRule.assertallNodesHaveSnapshotWithIndex(200);", "originalCommit": "9f7ec170282b71f2528e586a6e32c49476500bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1a6bf99473aad6c331bc94a0735c843b6a711885", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\nindex 62c62ef76f..47c0e1fd56 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\n\n@@ -343,7 +343,7 @@ public class RaftFailOverTest {\n     raftRule.joinCluster(leader);\n \n     // then\n-    raftRule.assertallNodesHaveSnapshotWithIndex(200);\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(200)).isTrue();\n     final var snapshot = raftRule.getSnapshotOnNode(leader);\n \n     assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(200);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1Nzk0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479157947", "bodyText": "I assume this can be removed ? :D", "author": "Zelldon", "createdAt": "2020-08-28T11:25:53Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivedSnapshot;\n+import io.zeebe.snapshots.raft.SnapshotChunk;\n+import io.zeebe.snapshots.raft.SnapshotChunkReader;\n+import io.zeebe.util.StringUtil;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import org.agrona.concurrent.UnsafeBuffer;\n+import org.slf4j.LoggerFactory;\n+\n+public class InMemorySnapshot implements PersistedSnapshot, ReceivedSnapshot {\n+\n+  private final TestSnapshotStore testSnapshotStore;\n+  private final long index;\n+  private final long term;\n+  private final WallClockTimestamp timestamp;\n+  private final String id;\n+  private final NavigableMap<String, String> chunks = new TreeMap<>();\n+  private ByteBuffer nextExpected;\n+\n+  InMemorySnapshot(final TestSnapshotStore testSnapshotStore, final String snapshotId) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    id = snapshotId;\n+    final var parts = snapshotId.split(\"-\");\n+    index = Long.parseLong(parts[0]);\n+    term = Long.parseLong(parts[1]);\n+    timestamp = WallClockTimestamp.from(Long.parseLong(parts[2]));\n+  }\n+\n+  InMemorySnapshot(\n+      final TestSnapshotStore testSnapshotStore,\n+      final long index,\n+      final long term,\n+      final WallClockTimestamp timestamp) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    this.index = index;\n+    this.term = term;\n+    this.timestamp = timestamp;\n+    this.id = String.format(\"%d-%d-%d\", index, term, timestamp.unixTimestamp());\n+  }\n+\n+  public static InMemorySnapshot newPersistedSnapshot(\n+      final long index, final long term, final int size, final TestSnapshotStore snapshotStore) {\n+    final var snapshot = new InMemorySnapshot(snapshotStore, index, term, new WallClockTimestamp());\n+    for (int i = 0; i < size; i++) {\n+      snapshot.writeChunks(\"chunk-\" + i, \"test\".getBytes());\n+    }\n+    snapshot.persist();\n+    return snapshot;\n+  }\n+\n+  void writeChunks(final String id, final byte[] chunk) {\n+    chunks.put(id, StringUtil.fromBytes(chunk));\n+  }\n+\n+  @Override\n+  public WallClockTimestamp getTimestamp() {\n+    return timestamp;\n+  }\n+\n+  @Override\n+  public int version() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public long getIndex() {\n+    return index;\n+  }\n+\n+  @Override\n+  public long getTerm() {\n+    return term;\n+  }\n+\n+  @Override\n+  public SnapshotChunkReader newChunkReader() {\n+    return new SnapshotChunkReader() {\n+      private NavigableMap<String, String> iterator = chunks;\n+\n+      @Override\n+      public void seek(final ByteBuffer id) {\n+        final var chunkId = byteBufferToString(id);\n+        iterator = chunks.tailMap(chunkId, true);\n+      }\n+\n+      @Override\n+      public ByteBuffer nextId() {\n+        if (!hasNext()) {\n+          return null;\n+        }\n+        return ByteBuffer.wrap(iterator.firstEntry().getKey().getBytes());\n+      }\n+\n+      @Override\n+      public void close() {\n+        iterator = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return !iterator.isEmpty();\n+      }\n+\n+      @Override\n+      public SnapshotChunk next() {\n+        final var nextEntry = iterator.firstEntry();\n+        LoggerFactory.getLogger(\"FINDME\").info(\"Returning next chunk Id = {}\", nextEntry.getKey());", "originalCommit": "9f7ec170282b71f2528e586a6e32c49476500bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java\nindex 42a6589c92..7ae889ecaa 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java\n\n@@ -16,10 +16,6 @@\n package io.atomix.raft.snapshot;\n \n import io.atomix.utils.time.WallClockTimestamp;\n-import io.zeebe.snapshots.raft.PersistedSnapshot;\n-import io.zeebe.snapshots.raft.ReceivedSnapshot;\n-import io.zeebe.snapshots.raft.SnapshotChunk;\n-import io.zeebe.snapshots.raft.SnapshotChunkReader;\n import io.zeebe.util.StringUtil;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1ODY1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479158654", "bodyText": "Maybe we have something like that already in io.zeebe.util.BufferUtil", "author": "Zelldon", "createdAt": "2020-08-28T11:26:32Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivedSnapshot;\n+import io.zeebe.snapshots.raft.SnapshotChunk;\n+import io.zeebe.snapshots.raft.SnapshotChunkReader;\n+import io.zeebe.util.StringUtil;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import org.agrona.concurrent.UnsafeBuffer;\n+import org.slf4j.LoggerFactory;\n+\n+public class InMemorySnapshot implements PersistedSnapshot, ReceivedSnapshot {\n+\n+  private final TestSnapshotStore testSnapshotStore;\n+  private final long index;\n+  private final long term;\n+  private final WallClockTimestamp timestamp;\n+  private final String id;\n+  private final NavigableMap<String, String> chunks = new TreeMap<>();\n+  private ByteBuffer nextExpected;\n+\n+  InMemorySnapshot(final TestSnapshotStore testSnapshotStore, final String snapshotId) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    id = snapshotId;\n+    final var parts = snapshotId.split(\"-\");\n+    index = Long.parseLong(parts[0]);\n+    term = Long.parseLong(parts[1]);\n+    timestamp = WallClockTimestamp.from(Long.parseLong(parts[2]));\n+  }\n+\n+  InMemorySnapshot(\n+      final TestSnapshotStore testSnapshotStore,\n+      final long index,\n+      final long term,\n+      final WallClockTimestamp timestamp) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    this.index = index;\n+    this.term = term;\n+    this.timestamp = timestamp;\n+    this.id = String.format(\"%d-%d-%d\", index, term, timestamp.unixTimestamp());\n+  }\n+\n+  public static InMemorySnapshot newPersistedSnapshot(\n+      final long index, final long term, final int size, final TestSnapshotStore snapshotStore) {\n+    final var snapshot = new InMemorySnapshot(snapshotStore, index, term, new WallClockTimestamp());\n+    for (int i = 0; i < size; i++) {\n+      snapshot.writeChunks(\"chunk-\" + i, \"test\".getBytes());\n+    }\n+    snapshot.persist();\n+    return snapshot;\n+  }\n+\n+  void writeChunks(final String id, final byte[] chunk) {\n+    chunks.put(id, StringUtil.fromBytes(chunk));\n+  }\n+\n+  @Override\n+  public WallClockTimestamp getTimestamp() {\n+    return timestamp;\n+  }\n+\n+  @Override\n+  public int version() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public long getIndex() {\n+    return index;\n+  }\n+\n+  @Override\n+  public long getTerm() {\n+    return term;\n+  }\n+\n+  @Override\n+  public SnapshotChunkReader newChunkReader() {\n+    return new SnapshotChunkReader() {\n+      private NavigableMap<String, String> iterator = chunks;\n+\n+      @Override\n+      public void seek(final ByteBuffer id) {\n+        final var chunkId = byteBufferToString(id);\n+        iterator = chunks.tailMap(chunkId, true);\n+      }\n+\n+      @Override\n+      public ByteBuffer nextId() {\n+        if (!hasNext()) {\n+          return null;\n+        }\n+        return ByteBuffer.wrap(iterator.firstEntry().getKey().getBytes());\n+      }\n+\n+      @Override\n+      public void close() {\n+        iterator = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return !iterator.isEmpty();\n+      }\n+\n+      @Override\n+      public SnapshotChunk next() {\n+        final var nextEntry = iterator.firstEntry();\n+        LoggerFactory.getLogger(\"FINDME\").info(\"Returning next chunk Id = {}\", nextEntry.getKey());\n+        iterator = chunks.tailMap(nextEntry.getKey(), false);\n+        return new TestSnapshotChunkImpl(\n+            id, nextEntry.getKey(), StringUtil.getBytes(nextEntry.getValue()), chunks.size());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public void delete() {}\n+\n+  @Override\n+  public Path getPath() {\n+    return null;\n+  }\n+\n+  @Override\n+  public long getCompactionBound() {\n+    return index;\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return id;\n+  }\n+\n+  private String byteBufferToString(final ByteBuffer buf) {\n+    final var view = new UnsafeBuffer(buf);", "originalCommit": "9f7ec170282b71f2528e586a6e32c49476500bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java\nindex 42a6589c92..7ae889ecaa 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java\n\n@@ -16,10 +16,6 @@\n package io.atomix.raft.snapshot;\n \n import io.atomix.utils.time.WallClockTimestamp;\n-import io.zeebe.snapshots.raft.PersistedSnapshot;\n-import io.zeebe.snapshots.raft.ReceivedSnapshot;\n-import io.zeebe.snapshots.raft.SnapshotChunk;\n-import io.zeebe.snapshots.raft.SnapshotChunkReader;\n import io.zeebe.util.StringUtil;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIyNzkwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479227900", "bodyText": "Why is this called active? I assume because you can actively create a snapshot ? :D", "author": "Zelldon", "createdAt": "2020-08-28T12:25:11Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -89,7 +89,7 @@\n   private LogStream logStream;\n   private Role raftRole;\n   private SnapshotReplication stateReplication;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private final ActivePersistedSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk1MDY1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479950653", "bodyText": "We agreed on ConstructableSnapshotStore, if someone has a better name feel free to propose.", "author": "Zelldon", "createdAt": "2020-08-31T07:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIyNzkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java b/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\nindex df3ae19745..a1e8ec0efc 100644\n--- a/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\n+++ b/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\n\n@@ -89,7 +89,7 @@ public final class ZeebePartition extends Actor\n   private LogStream logStream;\n   private Role raftRole;\n   private SnapshotReplication stateReplication;\n-  private final ActivePersistedSnapshotStore persistedSnapshotStore;\n+  private PersistedSnapshotStore persistedSnapshotStore;\n   private StateControllerImpl snapshotController;\n   private ZeebeDb zeebeDb;\n   private final String actorName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMTA1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479231056", "bodyText": "Why we not using the interface?", "author": "Zelldon", "createdAt": "2020-08-28T12:27:48Z", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java", "diffHunk": "@@ -63,13 +63,14 @@\n   private AsyncSnapshotDirector asyncSnapshotDirector;\n   private StreamProcessor mockStreamProcessor;\n   private List<ActorCondition> conditionList;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private FileBasedSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java b/broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java\nindex ad3b27abda..f0e909b761 100644\n--- a/broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java\n+++ b/broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java\n\n@@ -63,14 +63,13 @@ public final class AsyncSnapshotingTest {\n   private AsyncSnapshotDirector asyncSnapshotDirector;\n   private StreamProcessor mockStreamProcessor;\n   private List<ActorCondition> conditionList;\n-  private FileBasedSnapshotStore persistedSnapshotStore;\n+  private PersistedSnapshotStore persistedSnapshotStore;\n \n   @Before\n   public void setup() throws IOException {\n     final var rootDirectory = tempFolderRule.getRoot().toPath();\n     persistedSnapshotStore =\n-        (FileBasedSnapshotStore)\n-            new FileBasedSnapshotStoreFactory().createSnapshotStore(rootDirectory, \"1\");\n+        new FileBasedSnapshotStoreFactory().createSnapshotStore(rootDirectory, \"1\");\n \n     snapshotController =\n         new StateControllerImpl(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMzUyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479233529", "bodyText": "Why we are not using the interface?", "author": "Zelldon", "createdAt": "2020-08-28T12:29:54Z", "path": "logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java", "diffHunk": "@@ -51,13 +51,13 @@\n   private ZeebeIndexAdapter indexMapping;\n   private RaftStorage raftStorage;\n   private RaftLog raftLog;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private NoopSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java b/logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java\nindex 691fd0566a..9c26e565bf 100644\n--- a/logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java\n+++ b/logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java\n\n@@ -51,13 +51,13 @@ public final class AtomixLogStorageRule extends ExternalResource\n   private ZeebeIndexAdapter indexMapping;\n   private RaftStorage raftStorage;\n   private RaftLog raftLog;\n-  private NoopSnapshotStore persistedSnapshotStore;\n+  private PersistedSnapshotStore persistedSnapshotStore;\n   private MetaStore metaStore;\n \n   private AtomixLogStorage storage;\n   private LongConsumer positionListener;\n   private Consumer<Throwable> writeErrorListener;\n-  private final EntryValidator entryValidator;\n+  private EntryValidator entryValidator;\n \n   public AtomixLogStorageRule(final TemporaryFolder temporaryFolder) {\n     this(temporaryFolder, 0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzODY3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479238675", "bodyText": "Active sounds a bit odd to me. Maybe WritableSnapshotStore or PersistableSnapshotStore", "author": "Zelldon", "createdAt": "2020-08-28T12:34:10Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/ActivePersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.snapshots.broker;\n+\n+import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n+import io.zeebe.snapshots.raft.TransientSnapshot;\n+import java.util.Optional;\n+\n+/** A persisted snapshot store than can create a new snapshot and persists it. */\n+public interface ActivePersistedSnapshotStore extends PersistedSnapshotStore {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/ActivePersistedSnapshotStore.java b/snapshot/src/main/java/io/zeebe/snapshots/broker/ActivePersistedSnapshotStore.java\ndeleted file mode 100644\nindex bbf920a54b..0000000000\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/ActivePersistedSnapshotStore.java\n+++ /dev/null\n\n@@ -1,29 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.snapshots.broker;\n-\n-import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n-import io.zeebe.snapshots.raft.TransientSnapshot;\n-import java.util.Optional;\n-\n-/** A persisted snapshot store than can create a new snapshot and persists it. */\n-public interface ActivePersistedSnapshotStore extends PersistedSnapshotStore {\n-\n-  /**\n-   * Starts a new transient snapshot which can be persisted after the snapshot was taken.\n-   *\n-   * @param index the index to which the snapshot corresponds to\n-   * @param term the term to which the snapshots corresponds to\n-   * @param processedPosition the processed position in the snapshot\n-   * @param exportedPosition the exported position in the snapshot\n-   * @return an optional with a transient snapshot if new transient snapshot was taken successfully,\n-   *     otherwise return an empty optional\n-   */\n-  Optional<TransientSnapshot> newTransientSnapshot(\n-      long index, long term, long processedPosition, long exportedPosition);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzOTgyMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479239820", "bodyText": "Maybe we implemented here a fallback to accept also old snapshot id's?", "author": "Zelldon", "createdAt": "2020-08-28T12:35:06Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshot.java", "diffHunk": "@@ -171,8 +163,11 @@ private boolean isTotalCountInvalid(final int currentTotalCount) {\n   }\n \n   private boolean isSnapshotIdInvalid(final String snapshotId) {\n-    final var expectedSnapshotId = metadata.getSnapshotIdAsString();\n-    return !expectedSnapshotId.equals(snapshotId);\n+    final var receivedSnapshotId = FileBasedSnapshotMetadata.ofFileName(snapshotId);", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshot.java b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedReceivedSnapshot.java\nsimilarity index 86%\nrename from snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshot.java\nrename to atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedReceivedSnapshot.java\nindex 459991bc49..f0229dfcb5 100644\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshot.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedReceivedSnapshot.java\n\n@@ -163,11 +171,8 @@ public class FileBasedReceivedSnapshot implements ReceivedSnapshot {\n   }\n \n   private boolean isSnapshotIdInvalid(final String snapshotId) {\n-    final var receivedSnapshotId = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n-    if (receivedSnapshotId.isEmpty()) {\n-      return true;\n-    }\n-    return metadata.compareTo(receivedSnapshotId.get()) != 0;\n+    final var expectedSnapshotId = metadata.getSnapshotIdAsString();\n+    return !expectedSnapshotId.equals(snapshotId);\n   }\n \n   private boolean writeReceivedSnapshotChunk(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0MTQ1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479241452", "bodyText": "Ah cool so we can already receive old snapshots.", "author": "Zelldon", "createdAt": "2020-08-28T12:36:30Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotMetadata.java", "diffHunk": "@@ -42,15 +53,34 @@\n         final var index = Long.parseLong(parts[0]);\n         final var term = Long.parseLong(parts[1]);\n         final var timestamp = Long.parseLong(parts[2]);\n+        final var processedPosition = Long.parseLong(parts[3]);\n+        final var exporterPosition = Long.parseLong(parts[4]);\n \n         metadata =\n             Optional.of(\n-                new FileBasedSnapshotMetadata(index, term, WallClockTimestamp.from(timestamp)));\n+                new FileBasedSnapshotMetadata(\n+                    index,\n+                    term,\n+                    WallClockTimestamp.from(timestamp),\n+                    processedPosition,\n+                    exporterPosition));\n       } catch (final NumberFormatException e) {\n         LOGGER.warn(\"Failed to parse part of snapshot metadata\", e);\n       }\n-    }\n+    } else if (parts.length >= METADATA_PARTS_OLD_VERSION) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotMetadata.java b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotMetadata.java\nsimilarity index 56%\nrename from snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotMetadata.java\nrename to atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotMetadata.java\nindex a0950c1ad1..1924c12436 100644\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotMetadata.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotMetadata.java\n\n@@ -53,34 +42,15 @@ public final class FileBasedSnapshotMetadata implements SnapshotId {\n         final var index = Long.parseLong(parts[0]);\n         final var term = Long.parseLong(parts[1]);\n         final var timestamp = Long.parseLong(parts[2]);\n-        final var processedPosition = Long.parseLong(parts[3]);\n-        final var exporterPosition = Long.parseLong(parts[4]);\n \n         metadata =\n             Optional.of(\n-                new FileBasedSnapshotMetadata(\n-                    index,\n-                    term,\n-                    WallClockTimestamp.from(timestamp),\n-                    processedPosition,\n-                    exporterPosition));\n-      } catch (final NumberFormatException e) {\n-        LOGGER.warn(\"Failed to parse part of snapshot metadata\", e);\n-      }\n-    } else if (parts.length >= METADATA_PARTS_OLD_VERSION) {\n-      try {\n-        final var index = Long.parseLong(parts[0]);\n-        final var term = Long.parseLong(parts[1]);\n-        final var timestamp = Long.parseLong(parts[2]);\n-\n-        metadata =\n-            Optional.of(\n-                new FileBasedSnapshotMetadata(\n-                    index, term, WallClockTimestamp.from(timestamp), 0, 0));\n+                new FileBasedSnapshotMetadata(index, term, WallClockTimestamp.from(timestamp)));\n       } catch (final NumberFormatException e) {\n         LOGGER.warn(\"Failed to parse part of snapshot metadata\", e);\n       }\n     }\n+\n     return metadata;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0Mzg4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479243887", "bodyText": "Is the timestamp also used? Can this ever happen then ? \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-08-28T12:38:30Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -180,6 +164,28 @@ public void delete() {\n     }\n   }\n \n+  @Override\n+  public Optional<TransientSnapshot> newTransientSnapshot(\n+      final long index,\n+      final long term,\n+      final long processedPosition,\n+      final long exportedPosition) {\n+\n+    final WallClockTimestamp timestamp = WallClockTimestamp.from(System.currentTimeMillis());\n+    final var newSnapshotId =\n+        new FileBasedSnapshotMetadata(index, term, timestamp, processedPosition, exportedPosition);\n+    final FileBasedSnapshot currentSnapshot = currentPersistedSnapshotRef.get();\n+    if (currentSnapshot != null && currentSnapshot.getMetadata().compareTo(newSnapshotId) == 0) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStore.java b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java\nsimilarity index 78%\nrename from snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStore.java\nrename to atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java\nindex bb9d7fa3f6..2f2c199529 100644\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStore.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java\n\n@@ -164,28 +180,6 @@ public final class FileBasedSnapshotStore implements ActivePersistedSnapshotStor\n     }\n   }\n \n-  @Override\n-  public Optional<TransientSnapshot> newTransientSnapshot(\n-      final long index,\n-      final long term,\n-      final long processedPosition,\n-      final long exportedPosition) {\n-\n-    final WallClockTimestamp timestamp = WallClockTimestamp.from(System.currentTimeMillis());\n-    final var newSnapshotId =\n-        new FileBasedSnapshotMetadata(index, term, timestamp, processedPosition, exportedPosition);\n-    final FileBasedSnapshot currentSnapshot = currentPersistedSnapshotRef.get();\n-    if (currentSnapshot != null && currentSnapshot.getMetadata().compareTo(newSnapshotId) == 0) {\n-      LOGGER.debug(\n-          \"Previous snapshot was taken for the same processed position {} and exported position {}, will not take snapshot.\",\n-          processedPosition,\n-          exportedPosition);\n-      return Optional.empty();\n-    }\n-    final var directory = buildPendingSnapshotDirectory(newSnapshotId);\n-    return Optional.of(new FileBasedTransientSnapshot(newSnapshotId, directory, this));\n-  }\n-\n   private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n     try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n       var totalSize = 0L;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479247422", "bodyText": "Please always try to return the interfaces", "author": "Zelldon", "createdAt": "2020-08-28T12:41:27Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0ODY5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479248695", "bodyText": "Why was this necessary? To get the same store in the ZeebePartition as in the journal?", "author": "Zelldon", "createdAt": "2020-08-28T12:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0OTUwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479249502", "bodyText": "Is is problematic if we never really recreate the store when we had a leader change?", "author": "Zelldon", "createdAt": "2020-08-28T12:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java\nsimilarity index 53%\nrename from snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java\nrename to atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java\nindex 057764ee68..7720069b7b 100644\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java\n\n@@ -38,14 +43,7 @@ public final class FileBasedSnapshotStoreFactory implements PersistedSnapshotSto\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return partitionSnapshotStores.computeIfAbsent(\n-        partitionName,\n-        p ->\n-            new FileBasedSnapshotStore(\n-                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n-  }\n-\n-  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {\n-    return partitionSnapshotStores.get(partitionName);\n+    return new FileBasedSnapshotStore(\n+        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MjQ5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479252498", "bodyText": "I thought we want to have two factory methods in this factory one to create a store which can receive chunks and one which can be used to take snapshots?", "author": "Zelldon", "createdAt": "2020-08-28T12:47:07Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3MzYxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479973616", "bodyText": "We will create two factory Interfaces  - ConstructableStoreFactory and ReceivableStoreFactory", "author": "deepthidevaki", "createdAt": "2020-08-31T08:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MjQ5OA=="}], "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java\nsimilarity index 53%\nrename from snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java\nrename to atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java\nindex 057764ee68..7720069b7b 100644\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java\n\n@@ -38,14 +43,7 @@ public final class FileBasedSnapshotStoreFactory implements PersistedSnapshotSto\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return partitionSnapshotStores.computeIfAbsent(\n-        partitionName,\n-        p ->\n-            new FileBasedSnapshotStore(\n-                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n-  }\n-\n-  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {\n-    return partitionSnapshotStores.get(partitionName);\n+    return new FileBasedSnapshotStore(\n+        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MzI0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479253245", "bodyText": "We we need to cast this everywhere ?", "author": "Zelldon", "createdAt": "2020-08-28T12:48:00Z", "path": "snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshotTest.java", "diffHunk": "@@ -50,22 +37,26 @@\n public class FileBasedReceivedSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private PersistedSnapshotStore senderSnapshotStore;\n-  private PersistedSnapshotStore receiverSnapshotStore;\n+  private FileBasedSnapshotStore senderSnapshotStore;\n+  private FileBasedSnapshotStore receiverSnapshotStore;\n   private Path receiverSnapshotsDir;\n   private Path receiverPendingSnapshotsDir;\n-  private FileBasedSnapshotStoreFactory factory;\n \n   @Before\n   public void before() throws Exception {\n-    factory = new FileBasedSnapshotStoreFactory();\n     final String partitionName = \"1\";\n     final File senderRoot = temporaryFolder.newFolder(\"sender\");\n \n-    senderSnapshotStore = factory.createSnapshotStore(senderRoot.toPath(), partitionName);\n+    senderSnapshotStore =\n+        (FileBasedSnapshotStore)\n+            new FileBasedSnapshotStoreFactory()\n+                .createSnapshotStore(senderRoot.toPath(), partitionName);\n \n     final var receiverRoot = temporaryFolder.newFolder(\"received\");\n-    receiverSnapshotStore = factory.createSnapshotStore(receiverRoot.toPath(), partitionName);\n+    receiverSnapshotStore =\n+        (FileBasedSnapshotStore)", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshotTest.java b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/impl/FileBasedReceivedSnapshotTest.java\nsimilarity index 71%\nrename from snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshotTest.java\nrename to atomix/cluster/src/test/java/io/atomix/raft/snapshot/impl/FileBasedReceivedSnapshotTest.java\nindex 690c59836e..ad64c5939f 100644\n--- a/snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshotTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/impl/FileBasedReceivedSnapshotTest.java\n\n@@ -37,26 +50,22 @@ import org.junit.rules.TemporaryFolder;\n public class FileBasedReceivedSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private FileBasedSnapshotStore senderSnapshotStore;\n-  private FileBasedSnapshotStore receiverSnapshotStore;\n+  private PersistedSnapshotStore senderSnapshotStore;\n+  private PersistedSnapshotStore receiverSnapshotStore;\n   private Path receiverSnapshotsDir;\n   private Path receiverPendingSnapshotsDir;\n+  private FileBasedSnapshotStoreFactory factory;\n \n   @Before\n   public void before() throws Exception {\n+    factory = new FileBasedSnapshotStoreFactory();\n     final String partitionName = \"1\";\n     final File senderRoot = temporaryFolder.newFolder(\"sender\");\n \n-    senderSnapshotStore =\n-        (FileBasedSnapshotStore)\n-            new FileBasedSnapshotStoreFactory()\n-                .createSnapshotStore(senderRoot.toPath(), partitionName);\n+    senderSnapshotStore = factory.createSnapshotStore(senderRoot.toPath(), partitionName);\n \n     final var receiverRoot = temporaryFolder.newFolder(\"received\");\n-    receiverSnapshotStore =\n-        (FileBasedSnapshotStore)\n-            new FileBasedSnapshotStoreFactory()\n-                .createSnapshotStore(receiverRoot.toPath(), partitionName);\n+    receiverSnapshotStore = factory.createSnapshotStore(receiverRoot.toPath(), partitionName);\n \n     receiverSnapshotsDir =\n         receiverRoot.toPath().resolve(FileBasedSnapshotStoreFactory.SNAPSHOTS_DIRECTORY);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1NDA2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479254064", "bodyText": "i would expect that we still can use the interfaces otherwise we did something wrong in our api", "author": "Zelldon", "createdAt": "2020-08-28T12:49:00Z", "path": "snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedTransientSnapshotTest.java", "diffHunk": "@@ -40,7 +30,7 @@\n public class FileBasedTransientSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private FileBasedSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedTransientSnapshotTest.java b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshotTest.java\nsimilarity index 65%\nrename from snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedTransientSnapshotTest.java\nrename to atomix/cluster/src/test/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshotTest.java\nindex 9091091223..484ebfb5b6 100644\n--- a/snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedTransientSnapshotTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshotTest.java\n\n@@ -30,7 +40,7 @@ import org.junit.rules.TemporaryFolder;\n public class FileBasedTransientSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private FileBasedSnapshotStore persistedSnapshotStore;\n+  private PersistedSnapshotStore persistedSnapshotStore;\n   private Path snapshotsDir;\n   private Path pendingSnapshotsDir;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5NTk3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480095970", "bodyText": "could we rename it to supplier? Or just use the supplier once to get the store?", "author": "Zelldon", "createdAt": "2020-08-31T12:27:36Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -113,13 +113,13 @@ public ZeebePartition(\n       final BrokerCfg brokerCfg,\n       final CommandApiService commandApiService,\n       final ZeebeIndexMapping zeebeIndexMapping,\n-      final ActivePersistedSnapshotStore persistedSnapshotStore,\n+      final SnapshotStoreSupplier snapshotStoreFactory,\n       final TypedRecordProcessorsFactory typedRecordProcessorsFactory) {\n     this.localBroker = localBroker;\n     this.atomixRaftPartition = atomixRaftPartition;\n     this.messagingService = messagingService;\n     this.brokerCfg = brokerCfg;\n-    this.persistedSnapshotStore = persistedSnapshotStore;\n+    this.snapshotStoreFactory = snapshotStoreFactory;", "originalCommit": "cfad20ed0e36d403c5771f3209f1b52ef5e06713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5OTgyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480099828", "bodyText": "Ah this is already outdated nevermind", "author": "Zelldon", "createdAt": "2020-08-31T12:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5NTk3MA=="}], "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java b/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\nindex 56901fb5f3..a1e8ec0efc 100644\n--- a/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\n+++ b/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\n\n@@ -113,19 +113,17 @@ public final class ZeebePartition extends Actor\n       final BrokerCfg brokerCfg,\n       final CommandApiService commandApiService,\n       final ZeebeIndexMapping zeebeIndexMapping,\n-      final SnapshotStoreSupplier snapshotStoreFactory,\n       final TypedRecordProcessorsFactory typedRecordProcessorsFactory) {\n     this.localBroker = localBroker;\n     this.atomixRaftPartition = atomixRaftPartition;\n     this.messagingService = messagingService;\n     this.brokerCfg = brokerCfg;\n-    this.snapshotStoreFactory = snapshotStoreFactory;\n     this.typedRecordProcessorsFactory = typedRecordProcessorsFactory;\n     this.commandApiService = commandApiService;\n     this.partitionListeners = Collections.unmodifiableList(partitionListeners);\n-    this.partitionId = atomixRaftPartition.id().id();\n-    this.scheduler = actorScheduler;\n-    this.maxFragmentSize = (int) brokerCfg.getNetwork().getMaxMessageSizeInBytes();\n+    partitionId = atomixRaftPartition.id().id();\n+    scheduler = actorScheduler;\n+    maxFragmentSize = (int) brokerCfg.getNetwork().getMaxMessageSizeInBytes();\n     this.zeebeIndexMapping = zeebeIndexMapping;\n \n     final var exporterEntries = brokerCfg.getExporters().entrySet();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480098142", "bodyText": "Would be cool if we can adjust the docs then", "author": "Zelldon", "createdAt": "2020-08-31T12:31:45Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/ConstructableSnapshotStore.java", "diffHunk": "@@ -12,7 +12,7 @@\n import java.util.Optional;\n \n /** A persisted snapshot store than can create a new snapshot and persists it. */", "originalCommit": "cfad20ed0e36d403c5771f3209f1b52ef5e06713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExODMzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480118330", "bodyText": "Isn't the doc already up-to-date?", "author": "deepthidevaki", "createdAt": "2020-08-31T13:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTAwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480121002", "bodyText": "Hm ok maybe you're right. I thought maybe using this word 'constructing' in the doc would fit here as well. But feel free to reject this comment", "author": "Zelldon", "createdAt": "2020-08-31T13:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTkzOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480121939", "bodyText": "Ah.. ok. Let me see if I can improve it. Thanks.", "author": "deepthidevaki", "createdAt": "2020-08-31T13:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/ConstructableSnapshotStore.java b/snapshot/src/main/java/io/zeebe/snapshots/broker/ConstructableSnapshotStore.java\ndeleted file mode 100644\nindex fd35941dbb..0000000000\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/ConstructableSnapshotStore.java\n+++ /dev/null\n\n@@ -1,29 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.snapshots.broker;\n-\n-import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n-import io.zeebe.snapshots.raft.TransientSnapshot;\n-import java.util.Optional;\n-\n-/** A persisted snapshot store than can create a new snapshot and persists it. */\n-public interface ConstructableSnapshotStore extends PersistedSnapshotStore {\n-\n-  /**\n-   * Starts a new transient snapshot which can be persisted after the snapshot was taken.\n-   *\n-   * @param index the index to which the snapshot corresponds to\n-   * @param term the term to which the snapshots corresponds to\n-   * @param processedPosition the processed position in the snapshot\n-   * @param exportedPosition the exported position in the snapshot\n-   * @return an optional with a transient snapshot if new transient snapshot was taken successfully,\n-   *     otherwise return an empty optional\n-   */\n-  Optional<TransientSnapshot> newTransientSnapshot(\n-      long index, long term, long processedPosition, long exportedPosition);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480098387", "bodyText": "Do we need that?", "author": "Zelldon", "createdAt": "2020-08-31T12:32:13Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/SnapshotStoreSupplier.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.snapshots.broker;\n+\n+import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n+import io.zeebe.snapshots.raft.ReceivableSnapshotStore;\n+\n+public interface SnapshotStoreSupplier {\n+\n+  /**\n+   * Returns a partition's {@link ConstructableSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ConstructableSnapshotStore\n+   */\n+  ConstructableSnapshotStore getConstructableSnapshotStore(String partitionName);\n+\n+  /**\n+   * Returns a partition's {@link ReceivableSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ReceivableSnapshotStore\n+   */\n+  ReceivableSnapshotStore getReceivableSnapshotStore(final String partitionName);\n+\n+  /**\n+   * Returns a partition's {@link PersistedSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ConstructableSnapshotStore\n+   */\n+  PersistedSnapshotStore getPersistedSnapshotStore(String partitionName);", "originalCommit": "cfad20ed0e36d403c5771f3209f1b52ef5e06713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExNzQ2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480117468", "bodyText": "LogDeletionService expects only PersistedSnapshotStore. It doesn't care if it is Receivable or Constructable.", "author": "deepthidevaki", "createdAt": "2020-08-31T13:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExODIwNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480118206", "bodyText": "But the other interfaces extend this one right? So you can just give one of them? Not sure whether it makes sense to have this getter", "author": "Zelldon", "createdAt": "2020-08-31T13:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMDkwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480120902", "bodyText": "Then the question is which one to use. Both would pass the compiler. But conceptually, on the leader it does not make sense  to use RecievableStore and on the follower to use ConstructableStore.", "author": "deepthidevaki", "createdAt": "2020-08-31T13:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNjg3Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480136872", "bodyText": "sounds not ideal but ok should be fine for now", "author": "Zelldon", "createdAt": "2020-08-31T13:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE2NTkxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480165912", "bodyText": "Thanks. I don't like it either. But could not find a better way. :)  Any other comments?", "author": "deepthidevaki", "createdAt": "2020-08-31T14:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "218e93b1d671776c2143a8fc2a37b499017e2b12", "chunk": "diff --git a/snapshot/src/main/java/io/zeebe/snapshots/broker/SnapshotStoreSupplier.java b/snapshot/src/main/java/io/zeebe/snapshots/broker/SnapshotStoreSupplier.java\ndeleted file mode 100644\nindex 68ce790ce8..0000000000\n--- a/snapshot/src/main/java/io/zeebe/snapshots/broker/SnapshotStoreSupplier.java\n+++ /dev/null\n\n@@ -1,38 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.snapshots.broker;\n-\n-import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n-import io.zeebe.snapshots.raft.ReceivableSnapshotStore;\n-\n-public interface SnapshotStoreSupplier {\n-\n-  /**\n-   * Returns a partition's {@link ConstructableSnapshotStore}\n-   *\n-   * @param partitionName\n-   * @return a ConstructableSnapshotStore\n-   */\n-  ConstructableSnapshotStore getConstructableSnapshotStore(String partitionName);\n-\n-  /**\n-   * Returns a partition's {@link ReceivableSnapshotStore}\n-   *\n-   * @param partitionName\n-   * @return a ReceivableSnapshotStore\n-   */\n-  ReceivableSnapshotStore getReceivableSnapshotStore(final String partitionName);\n-\n-  /**\n-   * Returns a partition's {@link PersistedSnapshotStore}\n-   *\n-   * @param partitionName\n-   * @return a ConstructableSnapshotStore\n-   */\n-  PersistedSnapshotStore getPersistedSnapshotStore(String partitionName);\n-}\n"}}, {"oid": "218e93b1d671776c2143a8fc2a37b499017e2b12", "url": "https://github.com/camunda-cloud/zeebe/commit/218e93b1d671776c2143a8fc2a37b499017e2b12", "message": "chore(atomix): use mock implementation of snapshot store in tests\nThis is in preparation for refactoring snapshot implementations and moving the concrete implementation out of atomix.", "committedDate": "2020-09-01T08:20:51Z", "type": "commit"}, {"oid": "8609cfca1a9e15d87704684f5f7444f41497a84f", "url": "https://github.com/camunda-cloud/zeebe/commit/8609cfca1a9e15d87704684f5f7444f41497a84f", "message": "chore(atomix): remove snapshot listener when closing a role", "committedDate": "2020-09-01T08:20:52Z", "type": "commit"}, {"oid": "1a6bf99473aad6c331bc94a0735c843b6a711885", "url": "https://github.com/camunda-cloud/zeebe/commit/1a6bf99473aad6c331bc94a0735c843b6a711885", "message": "chore(broker): use exporter and processor positions in snapshot id\n* move snapshot interfaces and clases to new module\n* take snapshot at same index if either exporter or processor position is changed\n* snapshot is uniquely identified by index,term,processedposition,exporterposition", "committedDate": "2020-09-01T08:20:52Z", "type": "commit"}, {"oid": "1a6bf99473aad6c331bc94a0735c843b6a711885", "url": "https://github.com/camunda-cloud/zeebe/commit/1a6bf99473aad6c331bc94a0735c843b6a711885", "message": "chore(broker): use exporter and processor positions in snapshot id\n* move snapshot interfaces and clases to new module\n* take snapshot at same index if either exporter or processor position is changed\n* snapshot is uniquely identified by index,term,processedposition,exporterposition", "committedDate": "2020-09-01T08:20:52Z", "type": "forcePushed"}]}