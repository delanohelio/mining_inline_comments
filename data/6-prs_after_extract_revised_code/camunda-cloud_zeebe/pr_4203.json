{"pr_number": 4203, "pr_title": "chore(engine): fix flaky StreamProcessorTest snapshot tests", "pr_createdAt": "2020-04-01T09:40:25Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4203", "timeline": [{"oid": "7175ff9237e7c61a6d7a2d7601cb7da4b19b395a", "url": "https://github.com/camunda-cloud/zeebe/commit/7175ff9237e7c61a6d7a2d7601cb7da4b19b395a", "message": "chore(engine): fix flaky tests\n\n- replaces checking the event count on the stream with actually awaiting\n  that we have processed this event; there was a race condition where\n  the event count might be incremented before the processor had\n  processed, resulting in non-deterministic tests", "committedDate": "2020-04-01T09:41:57Z", "type": "forcePushed"}, {"oid": "b5bebfd3293c3559a1715b8f217b3ce8595a27e7", "url": "https://github.com/camunda-cloud/zeebe/commit/b5bebfd3293c3559a1715b8f217b3ce8595a27e7", "message": "chore(engine): fix flaky tests\n\n- replaces checking the event count on the stream with actually awaiting\n  that we have processed this event; there was a race condition where\n  the event count might be incremented before the processor had\n  processed, resulting in non-deterministic tests", "committedDate": "2020-04-01T09:42:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402105754", "bodyText": "I did not understand the intention of this test. The name says no processor process event, but there is a processor processing the event. \ud83e\udd14", "author": "deepthidevaki", "createdAt": "2020-04-02T07:29:31Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -578,16 +587,25 @@ public void onRecovered(final ReadonlyProcessingContext context) {\n   }\n \n   @Test\n-  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() {\n+  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() throws InterruptedException {", "originalCommit": "b5bebfd3293c3559a1715b8f217b3ce8595a27e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTg4Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402111882", "bodyText": "The name is misleading, true; what it means is that between an open/close of the processor, even if we didn't process an event, on close we still snapshot.\nYou can see we process the event then close, then re-open the processor. This is because we don't take snapshots if we have never processed anything (i.e. if the last processed position is -1) - to support \"empty\" snapshots (e.g. index -1), we'd need to refactor Atomix more, so skipping at -1 seemed simpler. We can challenge that.\nIn the mean time, we can find a better name, any ideas?", "author": "npepinpe", "createdAt": "2020-04-02T07:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExNDQ3MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402114471", "bodyText": "It sounds like shouldNotCreateSnapshotIfNoProcessorProcessEvent().", "author": "deepthidevaki", "createdAt": "2020-04-02T07:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExNTEyMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402115120", "bodyText": "But we want to test that it does create one \ud83d\ude05 Let's just quickly clear it up on Zoom\nI think I wasn't clear on my explanation \ud83d\ude05", "author": "npepinpe", "createdAt": "2020-04-02T07:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "0047fd6cffc1d3a9158b8697c7c7710d9df06a3d", "chunk": "diff --git a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java\nindex 6a97cb5b65..a2923501ff 100755\n--- a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java\n+++ b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java\n\n@@ -473,151 +472,102 @@ public final class StreamProcessorTest {\n   @Test\n   public void shouldCreateSnapshot() throws Exception {\n     // given\n-    final CountDownLatch processingLatch = new CountDownLatch(1);\n-    final StreamProcessor streamProcessor =\n-        streamProcessorRule.startTypedStreamProcessor(\n-            (processors, context) ->\n-                processors.onEvent(\n-                    ValueType.WORKFLOW_INSTANCE,\n-                    WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n-                    new TypedRecordProcessor<UnifiedRecordValue>() {\n-                      @Override\n-                      public void processRecord(\n-                          final TypedRecord<UnifiedRecordValue> record,\n-                          final TypedResponseWriter responseWriter,\n-                          final TypedStreamWriter streamWriter,\n-                          final Consumer<SideEffectProducer> sideEffect) {\n-                        processingLatch.countDown();\n-                      }\n-                    }));\n+    final var listener = new AwaitableProcessedListener();\n+    streamProcessorRule.startTypedStreamProcessor(\n+        (processors, context) ->\n+            processors.onEvent(\n+                ValueType.WORKFLOW_INSTANCE,\n+                WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n+                mock(TypedRecordProcessor.class)),\n+        listener.expect(1));\n \n     // when\n-    final long position =\n-        streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    processingLatch.await();\n-    TestUtil.waitUntil(() -> streamProcessor.getLastProcessedPositionAsync().join() > -1);\n+    streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n+    listener.await();\n     streamProcessorRule.getClock().addTime(SNAPSHOT_INTERVAL);\n \n     // then\n     final StateSnapshotController stateSnapshotController =\n         streamProcessorRule.getStateSnapshotController();\n-    final InOrder inOrder = Mockito.inOrder(stateSnapshotController);\n-\n-    inOrder.verify(stateSnapshotController, TIMEOUT.times(1)).openDb();\n-    inOrder.verify(stateSnapshotController, TIMEOUT.times(1)).takeTempSnapshot(anyLong());\n-    inOrder.verify(stateSnapshotController, TIMEOUT.times(1)).commitSnapshot(any(Snapshot.class));\n+    waitUntil(() -> stateSnapshotController.getValidSnapshotsCount() == 1);\n+    assertThat(stateSnapshotController.getValidSnapshotsCount()).isEqualTo(1);\n   }\n \n   @Test\n   public void shouldCreateSnapshotOnClose() throws Exception {\n     // given\n-    final CountDownLatch processingLatch = new CountDownLatch(2);\n+    final var listener = new AwaitableProcessedListener();\n     streamProcessorRule.startTypedStreamProcessor(\n         (processors, context) ->\n             processors.onEvent(\n                 ValueType.WORKFLOW_INSTANCE,\n                 WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n-                new TypedRecordProcessor<UnifiedRecordValue>() {\n-                  @Override\n-                  public void processRecord(\n-                      final TypedRecord<UnifiedRecordValue> record,\n-                      final TypedResponseWriter responseWriter,\n-                      final TypedStreamWriter streamWriter,\n-                      final Consumer<SideEffectProducer> sideEffect) {\n-                    processingLatch.countDown();\n-                  }\n-                }));\n+                mock(TypedRecordProcessor.class)),\n+        listener.expect(1));\n \n     // when\n     streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    processingLatch.await();\n+    listener.await();\n     final StateSnapshotController stateSnapshotController =\n         streamProcessorRule.getStateSnapshotController();\n     streamProcessorRule.closeStreamProcessor();\n \n     // then\n-    final InOrder inOrder = Mockito.inOrder(stateSnapshotController);\n-\n-    inOrder.verify(stateSnapshotController, TIMEOUT.times(1)).openDb();\n-\n-    inOrder.verify(stateSnapshotController, TIMEOUT.times(1)).takeSnapshot(anyLong());\n+    waitUntil(() -> stateSnapshotController.getValidSnapshotsCount() == 1);\n+    assertThat(stateSnapshotController.getValidSnapshotsCount()).isEqualTo(1);\n   }\n \n   @Test\n   public void shouldCreateSnapshotOnCloseEvenIfNothingProcessedSinceLastSnapshot()\n       throws Exception {\n     // given\n-    final var recoveredLatch = new CountDownLatch(1);\n-    final var processedLatch = new CountDownLatch(1);\n+    final var processedListener = new AwaitableProcessedListener();\n     final var streamProcessor =\n         streamProcessorRule.startTypedStreamProcessor(\n             (processors, context) ->\n                 processors.onEvent(\n                     ValueType.WORKFLOW_INSTANCE,\n                     WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n-                    new TypedRecordProcessor<UnifiedRecordValue>() {\n-                      @Override\n-                      public void onRecovered(final ReadonlyProcessingContext context) {\n-                        recoveredLatch.countDown();\n-                      }\n-\n-                      @Override\n-                      public void processRecord(\n-                          final TypedRecord<UnifiedRecordValue> record,\n-                          final TypedResponseWriter responseWriter,\n-                          final TypedStreamWriter streamWriter) {\n-                        processedLatch.countDown();\n-                      }\n-                    }));\n+                    mock(TypedRecordProcessor.class)),\n+            processedListener.expect(1));\n     final var stateSnapshotController = streamProcessorRule.getStateSnapshotController();\n-    recoveredLatch.await(5, TimeUnit.SECONDS);\n-    final var position =\n-        streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    processedLatch.await(5, TimeUnit.SECONDS);\n+    streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n+    processedListener.await();\n     streamProcessorRule.getClock().addTime(SNAPSHOT_INTERVAL);\n-    TestUtil.waitUntil(() -> stateSnapshotController.getValidSnapshotsCount() == 1);\n+    waitUntil(() -> stateSnapshotController.getValidSnapshotsCount() == 1);\n \n     // when\n     streamProcessorRule.closeStreamProcessor();\n \n     // then\n     assertThat(streamProcessor.isClosed()).isTrue();\n-    TestUtil.waitUntil(() -> stateSnapshotController.getValidSnapshotsCount() == 2);\n+    waitUntil(() -> stateSnapshotController.getValidSnapshotsCount() == 2);\n   }\n \n   @Test\n-  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() throws InterruptedException {\n+  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent()\n+      throws InterruptedException, TimeoutException {\n     // given\n-    final var processingLatch = new CountDownLatch(1);\n+    final var listener = new AwaitableProcessedListener();\n     streamProcessorRule.startTypedStreamProcessor(\n         (processors, context) ->\n             processors.onEvent(\n                 ValueType.WORKFLOW_INSTANCE,\n                 WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n-                new TypedRecordProcessor<UnifiedRecordValue>() {\n-                  @Override\n-                  public void processRecord(\n-                      final TypedRecord<UnifiedRecordValue> record,\n-                      final TypedResponseWriter responseWriter,\n-                      final TypedStreamWriter streamWriter) {\n-                    processingLatch.countDown();\n-                  }\n-                }));\n+                mock(TypedRecordProcessor.class)),\n+        listener.expect(1));\n     streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    processingLatch.await(5, TimeUnit.SECONDS);\n+    listener.await();\n+    streamProcessorRule.getClock().addTime(SNAPSHOT_INTERVAL);\n \n     // when\n-    streamProcessorRule.closeStreamProcessor();\n-    streamProcessorRule.startTypedStreamProcessor((processors, context) -> processors);\n+    final var snapshotController = streamProcessorRule.getStateSnapshotController();\n+    waitUntil(() -> snapshotController.getValidSnapshotsCount() == 1);\n     streamProcessorRule.getClock().addTime(SNAPSHOT_INTERVAL);\n+    waitUntil(() -> snapshotController.getValidSnapshotsCount() == 2);\n \n     // then\n-    final StateSnapshotController stateSnapshotController =\n-        streamProcessorRule.getStateSnapshotController();\n-\n-    waitUntil(() -> stateSnapshotController.getValidSnapshotsCount() == 1);\n-    assertThat(stateSnapshotController.getValidSnapshotsCount()).isEqualTo(1);\n+    assertThat(snapshotController.getValidSnapshotsCount()).isEqualTo(2);\n   }\n \n   @Test\n"}}, {"oid": "0047fd6cffc1d3a9158b8697c7c7710d9df06a3d", "url": "https://github.com/camunda-cloud/zeebe/commit/0047fd6cffc1d3a9158b8697c7c7710d9df06a3d", "message": "chore(engine): use onProcessedListener to wait for processing", "committedDate": "2020-04-03T12:37:43Z", "type": "forcePushed"}, {"oid": "41c584c3be8a2a675f08d6dfc2201a199704e741", "url": "https://github.com/camunda-cloud/zeebe/commit/41c584c3be8a2a675f08d6dfc2201a199704e741", "message": "chore(engine): use onProcessedListener to wait for processing", "committedDate": "2020-04-03T12:40:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA5OTcyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r403099729", "bodyText": "This log statement can be removed.", "author": "deepthidevaki", "createdAt": "2020-04-03T15:48:17Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -731,31 +693,56 @@ public void processRecord(\n   }\n \n   @Test\n-  public void shouldInvokeOnProcessedListener() throws InterruptedException {\n+  public void shouldInvokeOnProcessedListener() throws InterruptedException, TimeoutException {\n     // given\n-    final CountDownLatch processLatch = new CountDownLatch(1);\n+    final var onProcessedListener = new AwaitableProcessedListener();\n     streamProcessorRule.startTypedStreamProcessor(\n         (processors, context) ->\n             processors.onEvent(\n                 ValueType.WORKFLOW_INSTANCE,\n                 WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n-                new TypedRecordProcessor<UnifiedRecordValue>() {\n-                  @Override\n-                  public void processRecord(\n-                      final long position,\n-                      final TypedRecord<UnifiedRecordValue> record,\n-                      final TypedResponseWriter responseWriter,\n-                      final TypedStreamWriter streamWriter,\n-                      final Consumer<SideEffectProducer> sideEffect) {\n-                    processLatch.countDown();\n-                  }\n-                }));\n+                mock(TypedRecordProcessor.class)),\n+        onProcessedListener.expect(1));\n \n     // when\n-    streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    processLatch.await();\n+    final var position =\n+        streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n \n     // then\n-    verify(streamProcessorRule.getProcessedListener(), timeout(1000).times(1)).accept(any());\n+    onProcessedListener.await();\n+    assertThat(onProcessedListener.lastProcessedRecord.getPosition()).isEqualTo(position);\n+  }\n+\n+  /**\n+   * A simple listener which allows you to wait for specific amount of records to be processed.\n+   *\n+   * <p>As it uses a phaser internally, you must always call {@link #expect(int)} before {@link\n+   * #accept(TypedRecord)}}!\n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  private static final class AwaitableProcessedListener implements Consumer<TypedRecord> {\n+    private static final Duration TIMEOUT = Duration.ofSeconds(5);\n+    private final Phaser phaser = new Phaser();\n+\n+    private int expectedPhase = -1;\n+    private TypedRecord lastProcessedRecord;\n+\n+    private AwaitableProcessedListener() {}\n+\n+    @Override\n+    public void accept(final TypedRecord typedRecord) {\n+      phaser.arrive();\n+      lastProcessedRecord = typedRecord;\n+    }\n+\n+    private AwaitableProcessedListener expect(final int expectedCount) {\n+      expectedPhase = phaser.bulkRegister(expectedCount);\n+      return this;\n+    }\n+\n+    private void await() throws TimeoutException, InterruptedException {\n+      Loggers.LOGSTREAMS_LOGGER.info(\"Expected phase: {}\", expectedPhase);", "originalCommit": "41c584c3be8a2a675f08d6dfc2201a199704e741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE1ODA2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r403158066", "bodyText": "Oops, yes \ud83d\ude48", "author": "npepinpe", "createdAt": "2020-04-03T17:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA5OTcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2cf059ff91e8b3713920da294b54c57b0d99be65", "chunk": "diff --git a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java\nindex e36e048381..6d5ad8c261 100755\n--- a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java\n+++ b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java\n\n@@ -709,40 +708,44 @@ public final class StreamProcessorTest {\n         streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n \n     // then\n-    onProcessedListener.await();\n+    assertThat(onProcessedListener.await()).isTrue();\n     assertThat(onProcessedListener.lastProcessedRecord.getPosition()).isEqualTo(position);\n   }\n \n   /**\n    * A simple listener which allows you to wait for specific amount of records to be processed.\n    *\n-   * <p>As it uses a phaser internally, you must always call {@link #expect(int)} before {@link\n-   * #accept(TypedRecord)}}!\n+   * <p>It is necessary to always call {@link #expect(int)} before {@link #accept(TypedRecord)}}\n    */\n   @SuppressWarnings(\"rawtypes\")\n   private static final class AwaitableProcessedListener implements Consumer<TypedRecord> {\n     private static final Duration TIMEOUT = Duration.ofSeconds(5);\n-    private final Phaser phaser = new Phaser();\n \n-    private int expectedPhase = -1;\n+    private CountDownLatch latch;\n     private TypedRecord lastProcessedRecord;\n \n-    private AwaitableProcessedListener() {}\n-\n     @Override\n     public void accept(final TypedRecord typedRecord) {\n-      phaser.arrive();\n+      getLatch().countDown();\n       lastProcessedRecord = typedRecord;\n     }\n \n     private AwaitableProcessedListener expect(final int expectedCount) {\n-      expectedPhase = phaser.bulkRegister(expectedCount);\n+      latch = new CountDownLatch(expectedCount);\n       return this;\n     }\n \n-    private void await() throws TimeoutException, InterruptedException {\n-      Loggers.LOGSTREAMS_LOGGER.info(\"Expected phase: {}\", expectedPhase);\n-      phaser.awaitAdvanceInterruptibly(expectedPhase, TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+    private boolean await() throws InterruptedException {\n+      return getLatch().await(TIMEOUT.toMillis(), TimeUnit.SECONDS);\n+    }\n+\n+    private CountDownLatch getLatch() {\n+      if (latch == null) {\n+        throw new IllegalStateException(\n+            \"Expected #expect to have been called prior to this method, but it was not\");\n+      }\n+\n+      return latch;\n     }\n   }\n }\n"}}, {"oid": "2cf059ff91e8b3713920da294b54c57b0d99be65", "url": "https://github.com/camunda-cloud/zeebe/commit/2cf059ff91e8b3713920da294b54c57b0d99be65", "message": "chore(engine): fix flaky tests\n\n- replaces checking the event count on the stream with actually awaiting\n  that we have processed this event; there was a race condition where\n  the event count might be incremented before the processor had\n  processed, resulting in non-deterministic tests", "committedDate": "2020-04-06T09:10:04Z", "type": "commit"}, {"oid": "2cf059ff91e8b3713920da294b54c57b0d99be65", "url": "https://github.com/camunda-cloud/zeebe/commit/2cf059ff91e8b3713920da294b54c57b0d99be65", "message": "chore(engine): fix flaky tests\n\n- replaces checking the event count on the stream with actually awaiting\n  that we have processed this event; there was a race condition where\n  the event count might be incremented before the processor had\n  processed, resulting in non-deterministic tests", "committedDate": "2020-04-06T09:10:04Z", "type": "forcePushed"}]}