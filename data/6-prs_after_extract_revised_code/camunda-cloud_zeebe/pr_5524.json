{"pr_number": 5524, "pr_title": "Centralize gRPC error mapping", "pr_createdAt": "2020-10-07T11:40:09Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5524", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3OTExNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502279114", "bodyText": "what ? \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-10-09T08:43:38Z", "path": "gateway/src/main/java/io/zeebe/gateway/EndpointManager.java", "diffHunk": "@@ -55,15 +49,13 @@\n import io.zeebe.gateway.protocol.GatewayOuterClass.TopologyResponse;\n import io.zeebe.gateway.protocol.GatewayOuterClass.UpdateJobRetriesRequest;\n import io.zeebe.gateway.protocol.GatewayOuterClass.UpdateJobRetriesResponse;\n-import io.zeebe.msgpack.MsgpackPropertyException;\n import io.zeebe.util.VersionUtil;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n import java.util.function.Function;\n \n+@SuppressWarnings(\"java:S119\")", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\nindex 06e996639..ee637d3b0 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n\n@@ -55,8 +53,7 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.function.Function;\n \n-@SuppressWarnings(\"java:S119\")\n-public final class EndpointManager extends GatewayGrpc.GatewayImplBase {\n+public final class EndpointManager {\n \n   private final BrokerClient brokerClient;\n   private final BrokerTopologyManager topologyManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4NTAxMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502285013", "bodyText": "Have you checked my previous Branch ? I created an EndpointWrapper 9610fed#diff-1f21f97736eb9eec235496e4a782ba7d\nThis makes it possible not change the code it self and also to drop it easily later again.", "author": "Zelldon", "createdAt": "2020-10-09T08:53:47Z", "path": "gateway/src/main/java/io/zeebe/gateway/EndpointManager.java", "diffHunk": "@@ -119,7 +111,8 @@ private void addPartitionInfoToBrokerInfo(\n   public void activateJobs(\n       final ActivateJobsRequest request,\n       final StreamObserver<ActivateJobsResponse> responseObserver) {\n-    activateJobsHandler.activateJobs(request, responseObserver);\n+    activateJobsHandler.activateJobs(", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxNTc2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502315769", "bodyText": "Wasn't aware of it, but its a good idea", "author": "npepinpe", "createdAt": "2020-10-09T09:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4NTAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\nindex 06e996639..ee637d3b0 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n\n@@ -107,145 +104,132 @@ public final class EndpointManager extends GatewayGrpc.GatewayImplBase {\n             });\n   }\n \n-  @Override\n   public void activateJobs(\n       final ActivateJobsRequest request,\n-      final StreamObserver<ActivateJobsResponse> responseObserver) {\n-    activateJobsHandler.activateJobs(\n-        request, ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+      final ServerStreamObserver<ActivateJobsResponse> responseObserver) {\n+    activateJobsHandler.activateJobs(request, responseObserver);\n   }\n \n-  @Override\n   public void cancelWorkflowInstance(\n       final CancelWorkflowInstanceRequest request,\n-      final StreamObserver<CancelWorkflowInstanceResponse> responseObserver) {\n+      final ServerStreamObserver<CancelWorkflowInstanceResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toCancelWorkflowInstanceRequest,\n         ResponseMapper::toCancelWorkflowInstanceResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void completeJob(\n       final CompleteJobRequest request,\n-      final StreamObserver<CompleteJobResponse> responseObserver) {\n+      final ServerStreamObserver<CompleteJobResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toCompleteJobRequest,\n         ResponseMapper::toCompleteJobResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void createWorkflowInstance(\n       final CreateWorkflowInstanceRequest request,\n-      final StreamObserver<CreateWorkflowInstanceResponse> responseObserver) {\n+      final ServerStreamObserver<CreateWorkflowInstanceResponse> responseObserver) {\n     sendRequestWithRetryPartitions(\n         request,\n         RequestMapper::toCreateWorkflowInstanceRequest,\n         ResponseMapper::toCreateWorkflowInstanceResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void createWorkflowInstanceWithResult(\n       final CreateWorkflowInstanceWithResultRequest request,\n-      final StreamObserver<CreateWorkflowInstanceWithResultResponse> responseObserver) {\n+      final ServerStreamObserver<CreateWorkflowInstanceWithResultResponse> responseObserver) {\n     if (request.getRequestTimeout() > 0) {\n       sendRequestWithRetryPartitions(\n           request,\n           RequestMapper::toCreateWorkflowInstanceWithResultRequest,\n           ResponseMapper::toCreateWorkflowInstanceWithResultResponse,\n-          ErrorMappingStreamObserver.ofStreamObserver(responseObserver),\n+          responseObserver,\n           Duration.ofMillis(request.getRequestTimeout()));\n     } else {\n       sendRequestWithRetryPartitions(\n           request,\n           RequestMapper::toCreateWorkflowInstanceWithResultRequest,\n           ResponseMapper::toCreateWorkflowInstanceWithResultResponse,\n-          ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+          responseObserver);\n     }\n   }\n \n-  @Override\n   public void deployWorkflow(\n       final DeployWorkflowRequest request,\n-      final StreamObserver<DeployWorkflowResponse> responseObserver) {\n+      final ServerStreamObserver<DeployWorkflowResponse> responseObserver) {\n \n     sendRequest(\n         request,\n         RequestMapper::toDeployWorkflowRequest,\n         ResponseMapper::toDeployWorkflowResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void failJob(\n-      final FailJobRequest request, final StreamObserver<FailJobResponse> responseObserver) {\n+      final FailJobRequest request, final ServerStreamObserver<FailJobResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toFailJobRequest,\n         ResponseMapper::toFailJobResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void throwError(\n-      final ThrowErrorRequest request, final StreamObserver<ThrowErrorResponse> responseObserver) {\n+      final ThrowErrorRequest request,\n+      final ServerStreamObserver<ThrowErrorResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toThrowErrorRequest,\n         ResponseMapper::toThrowErrorResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void publishMessage(\n       final PublishMessageRequest request,\n-      final StreamObserver<PublishMessageResponse> responseObserver) {\n+      final ServerStreamObserver<PublishMessageResponse> responseObserver) {\n \n     sendRequest(\n         request,\n         RequestMapper::toPublishMessageRequest,\n         ResponseMapper::toPublishMessageResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void resolveIncident(\n       final ResolveIncidentRequest request,\n-      final StreamObserver<ResolveIncidentResponse> responseObserver) {\n+      final ServerStreamObserver<ResolveIncidentResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toResolveIncidentRequest,\n         ResponseMapper::toResolveIncidentResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void setVariables(\n       final SetVariablesRequest request,\n-      final StreamObserver<SetVariablesResponse> responseObserver) {\n+      final ServerStreamObserver<SetVariablesResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toSetVariablesRequest,\n         ResponseMapper::toSetVariablesResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void topology(\n-      final TopologyRequest request, final StreamObserver<TopologyResponse> responseObserver) {\n-    final ErrorMappingStreamObserver<TopologyResponse> wrappedObserver =\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver);\n+      final TopologyRequest request,\n+      final ServerStreamObserver<TopologyResponse> responseObserver) {\n     final TopologyResponse.Builder topologyResponseBuilder = TopologyResponse.newBuilder();\n     final BrokerClusterState topology = topologyManager.getTopology();\n \n     if (topology == null) {\n       final StatusRuntimeException error =\n           Status.UNAVAILABLE.augmentDescription(\"No brokers available\").asRuntimeException();\n-      wrappedObserver.onError(error);\n+      responseObserver.onError(error);\n       return;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4NTM2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502285362", "bodyText": "\ud83d\udc4d", "author": "Zelldon", "createdAt": "2020-10-09T08:54:20Z", "path": "gateway/src/main/java/io/zeebe/gateway/EndpointManager.java", "diffHunk": "@@ -238,48 +231,51 @@ public void setVariables(\n         request,\n         RequestMapper::toSetVariablesRequest,\n         ResponseMapper::toSetVariablesResponse,\n-        responseObserver);\n+        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n   }\n \n   @Override\n   public void topology(\n       final TopologyRequest request, final StreamObserver<TopologyResponse> responseObserver) {\n+    final ErrorMappingStreamObserver<TopologyResponse> wrappedObserver =\n+        ErrorMappingStreamObserver.ofStreamObserver(responseObserver);\n     final TopologyResponse.Builder topologyResponseBuilder = TopologyResponse.newBuilder();\n     final BrokerClusterState topology = topologyManager.getTopology();\n \n-    if (topology != null) {\n-      topologyResponseBuilder\n-          .setClusterSize(topology.getClusterSize())\n-          .setPartitionsCount(topology.getPartitionsCount())\n-          .setReplicationFactor(topology.getReplicationFactor());\n-\n-      final String gatewayVersion = VersionUtil.getVersion();\n-      if (gatewayVersion != null && !gatewayVersion.isBlank()) {\n-        topologyResponseBuilder.setGatewayVersion(gatewayVersion);\n-      }\n-\n-      final ArrayList<BrokerInfo> brokers = new ArrayList<>();\n-\n-      topology\n-          .getBrokers()\n-          .forEach(\n-              brokerId -> {\n-                final Builder brokerInfo = BrokerInfo.newBuilder();\n-                addBrokerInfo(brokerInfo, brokerId, topology);\n-                addPartitionInfoToBrokerInfo(brokerInfo, brokerId, topology);\n-\n-                brokers.add(brokerInfo.build());\n-              });\n-\n-      topologyResponseBuilder.addAllBrokers(brokers);\n-      final TopologyResponse response = topologyResponseBuilder.build();\n-      responseObserver.onNext(response);\n-      responseObserver.onCompleted();\n-    } else {\n+    if (topology == null) {", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\nindex 06e996639..ee637d3b0 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n\n@@ -107,145 +104,132 @@ public final class EndpointManager extends GatewayGrpc.GatewayImplBase {\n             });\n   }\n \n-  @Override\n   public void activateJobs(\n       final ActivateJobsRequest request,\n-      final StreamObserver<ActivateJobsResponse> responseObserver) {\n-    activateJobsHandler.activateJobs(\n-        request, ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+      final ServerStreamObserver<ActivateJobsResponse> responseObserver) {\n+    activateJobsHandler.activateJobs(request, responseObserver);\n   }\n \n-  @Override\n   public void cancelWorkflowInstance(\n       final CancelWorkflowInstanceRequest request,\n-      final StreamObserver<CancelWorkflowInstanceResponse> responseObserver) {\n+      final ServerStreamObserver<CancelWorkflowInstanceResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toCancelWorkflowInstanceRequest,\n         ResponseMapper::toCancelWorkflowInstanceResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void completeJob(\n       final CompleteJobRequest request,\n-      final StreamObserver<CompleteJobResponse> responseObserver) {\n+      final ServerStreamObserver<CompleteJobResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toCompleteJobRequest,\n         ResponseMapper::toCompleteJobResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void createWorkflowInstance(\n       final CreateWorkflowInstanceRequest request,\n-      final StreamObserver<CreateWorkflowInstanceResponse> responseObserver) {\n+      final ServerStreamObserver<CreateWorkflowInstanceResponse> responseObserver) {\n     sendRequestWithRetryPartitions(\n         request,\n         RequestMapper::toCreateWorkflowInstanceRequest,\n         ResponseMapper::toCreateWorkflowInstanceResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void createWorkflowInstanceWithResult(\n       final CreateWorkflowInstanceWithResultRequest request,\n-      final StreamObserver<CreateWorkflowInstanceWithResultResponse> responseObserver) {\n+      final ServerStreamObserver<CreateWorkflowInstanceWithResultResponse> responseObserver) {\n     if (request.getRequestTimeout() > 0) {\n       sendRequestWithRetryPartitions(\n           request,\n           RequestMapper::toCreateWorkflowInstanceWithResultRequest,\n           ResponseMapper::toCreateWorkflowInstanceWithResultResponse,\n-          ErrorMappingStreamObserver.ofStreamObserver(responseObserver),\n+          responseObserver,\n           Duration.ofMillis(request.getRequestTimeout()));\n     } else {\n       sendRequestWithRetryPartitions(\n           request,\n           RequestMapper::toCreateWorkflowInstanceWithResultRequest,\n           ResponseMapper::toCreateWorkflowInstanceWithResultResponse,\n-          ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+          responseObserver);\n     }\n   }\n \n-  @Override\n   public void deployWorkflow(\n       final DeployWorkflowRequest request,\n-      final StreamObserver<DeployWorkflowResponse> responseObserver) {\n+      final ServerStreamObserver<DeployWorkflowResponse> responseObserver) {\n \n     sendRequest(\n         request,\n         RequestMapper::toDeployWorkflowRequest,\n         ResponseMapper::toDeployWorkflowResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void failJob(\n-      final FailJobRequest request, final StreamObserver<FailJobResponse> responseObserver) {\n+      final FailJobRequest request, final ServerStreamObserver<FailJobResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toFailJobRequest,\n         ResponseMapper::toFailJobResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void throwError(\n-      final ThrowErrorRequest request, final StreamObserver<ThrowErrorResponse> responseObserver) {\n+      final ThrowErrorRequest request,\n+      final ServerStreamObserver<ThrowErrorResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toThrowErrorRequest,\n         ResponseMapper::toThrowErrorResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void publishMessage(\n       final PublishMessageRequest request,\n-      final StreamObserver<PublishMessageResponse> responseObserver) {\n+      final ServerStreamObserver<PublishMessageResponse> responseObserver) {\n \n     sendRequest(\n         request,\n         RequestMapper::toPublishMessageRequest,\n         ResponseMapper::toPublishMessageResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void resolveIncident(\n       final ResolveIncidentRequest request,\n-      final StreamObserver<ResolveIncidentResponse> responseObserver) {\n+      final ServerStreamObserver<ResolveIncidentResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toResolveIncidentRequest,\n         ResponseMapper::toResolveIncidentResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void setVariables(\n       final SetVariablesRequest request,\n-      final StreamObserver<SetVariablesResponse> responseObserver) {\n+      final ServerStreamObserver<SetVariablesResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toSetVariablesRequest,\n         ResponseMapper::toSetVariablesResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void topology(\n-      final TopologyRequest request, final StreamObserver<TopologyResponse> responseObserver) {\n-    final ErrorMappingStreamObserver<TopologyResponse> wrappedObserver =\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver);\n+      final TopologyRequest request,\n+      final ServerStreamObserver<TopologyResponse> responseObserver) {\n     final TopologyResponse.Builder topologyResponseBuilder = TopologyResponse.newBuilder();\n     final BrokerClusterState topology = topologyManager.getTopology();\n \n     if (topology == null) {\n       final StatusRuntimeException error =\n           Status.UNAVAILABLE.augmentDescription(\"No brokers available\").asRuntimeException();\n-      wrappedObserver.onError(error);\n+      responseObserver.onError(error);\n       return;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4Nzc1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502287751", "bodyText": "For what is this ?", "author": "Zelldon", "createdAt": "2020-10-09T08:58:19Z", "path": "gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.grpc;\n+\n+import io.grpc.StatusException;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.ServerCallStreamObserver;\n+import io.grpc.stub.StreamObserver;\n+import io.zeebe.gateway.Loggers;\n+\n+/**\n+ * A {@link StreamObserver} decorator which will map errors to {@link StatusException} before\n+ * passing them on to the {@code delegate}.\n+ *\n+ * <p>Additionally, if the decorated {@link StreamObserver} is a {@link ServerCallStreamObserver},\n+ * it will install a cancellation handler to effectively suppress the {@code delegate} from throwing\n+ * an exception if the call was already cancelled.\n+ *\n+ * @param <GrpcResponseT>\n+ */\n+@SuppressWarnings(\"java:S119\")", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java b/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java\nindex b989c6f72..45048e56b 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java\n\n@@ -14,18 +14,15 @@ import io.grpc.stub.StreamObserver;\n import io.zeebe.gateway.Loggers;\n \n /**\n- * A {@link StreamObserver} decorator which will map errors to {@link StatusException} before\n- * passing them on to the {@code delegate}.\n+ * A {@link ServerCallStreamObserver} decorator which will map errors to {@link StatusException}\n+ * before passing them on to the {@code delegate}. It will additionally suppress cancel exceptions;\n+ * by default, the gRPC library will throw an exception if one tries to complete a call which was\n+ * already cancelled. As we don't handle this (yet), simply log the instance.\n  *\n- * <p>Additionally, if the decorated {@link StreamObserver} is a {@link ServerCallStreamObserver},\n- * it will install a cancellation handler to effectively suppress the {@code delegate} from throwing\n- * an exception if the call was already cancelled.\n- *\n- * @param <GrpcResponseT>\n+ * @param <GrpcResponseT> the expected type of the response\n  */\n-@SuppressWarnings(\"java:S119\")\n public final class ErrorMappingStreamObserver<GrpcResponseT>\n-    extends ServerCallStreamObserver<GrpcResponseT> {\n+    extends ServerCallStreamObserver<GrpcResponseT> implements ServerStreamObserver<GrpcResponseT> {\n   private static final GrpcErrorMapper DEFAULT_ERROR_MAPPER = new GrpcErrorMapper();\n \n   private final ServerCallStreamObserver<GrpcResponseT> delegate;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI5OTE3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502299179", "bodyText": "Actually you only accept ServerCallStreamObserver", "author": "Zelldon", "createdAt": "2020-10-09T09:18:38Z", "path": "gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.grpc;\n+\n+import io.grpc.StatusException;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.ServerCallStreamObserver;\n+import io.grpc.stub.StreamObserver;\n+import io.zeebe.gateway.Loggers;\n+\n+/**\n+ * A {@link StreamObserver} decorator which will map errors to {@link StatusException} before\n+ * passing them on to the {@code delegate}.\n+ *\n+ * <p>Additionally, if the decorated {@link StreamObserver} is a {@link ServerCallStreamObserver},", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxNjc5MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502316790", "bodyText": "True, I wrote this before I changed the interface \ud83d\ude05", "author": "npepinpe", "createdAt": "2020-10-09T09:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI5OTE3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java b/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java\nindex b989c6f72..45048e56b 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/grpc/ErrorMappingStreamObserver.java\n\n@@ -14,18 +14,15 @@ import io.grpc.stub.StreamObserver;\n import io.zeebe.gateway.Loggers;\n \n /**\n- * A {@link StreamObserver} decorator which will map errors to {@link StatusException} before\n- * passing them on to the {@code delegate}.\n+ * A {@link ServerCallStreamObserver} decorator which will map errors to {@link StatusException}\n+ * before passing them on to the {@code delegate}. It will additionally suppress cancel exceptions;\n+ * by default, the gRPC library will throw an exception if one tries to complete a call which was\n+ * already cancelled. As we don't handle this (yet), simply log the instance.\n  *\n- * <p>Additionally, if the decorated {@link StreamObserver} is a {@link ServerCallStreamObserver},\n- * it will install a cancellation handler to effectively suppress the {@code delegate} from throwing\n- * an exception if the call was already cancelled.\n- *\n- * @param <GrpcResponseT>\n+ * @param <GrpcResponseT> the expected type of the response\n  */\n-@SuppressWarnings(\"java:S119\")\n public final class ErrorMappingStreamObserver<GrpcResponseT>\n-    extends ServerCallStreamObserver<GrpcResponseT> {\n+    extends ServerCallStreamObserver<GrpcResponseT> implements ServerStreamObserver<GrpcResponseT> {\n   private static final GrpcErrorMapper DEFAULT_ERROR_MAPPER = new GrpcErrorMapper();\n \n   private final ServerCallStreamObserver<GrpcResponseT> delegate;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMzU1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502303559", "bodyText": "Currently thinking whether it really necessary to error in gateway in general, since they properly logged in the broker already and when the client receives the error", "author": "Zelldon", "createdAt": "2020-10-09T09:26:15Z", "path": "gateway/src/main/java/io/zeebe/gateway/grpc/GrpcErrorMapper.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.grpc;\n+\n+import com.google.rpc.Code;\n+import com.google.rpc.Status;\n+import com.google.rpc.Status.Builder;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.protobuf.StatusProto;\n+import io.zeebe.gateway.Loggers;\n+import io.zeebe.gateway.cmd.BrokerErrorException;\n+import io.zeebe.gateway.cmd.BrokerRejectionException;\n+import io.zeebe.gateway.cmd.InvalidBrokerRequestArgumentException;\n+import io.zeebe.gateway.cmd.PartitionNotFoundException;\n+import io.zeebe.gateway.impl.broker.response.BrokerError;\n+import io.zeebe.gateway.impl.broker.response.BrokerRejection;\n+import io.zeebe.msgpack.MsgpackPropertyException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import org.slf4j.Logger;\n+\n+/** Maps arbitrary {@link Throwable} to {@link StatusRuntimeException} and logs the exception. */\n+public final class GrpcErrorMapper {\n+  private final Logger logger;\n+\n+  public GrpcErrorMapper() {\n+    this(Loggers.GATEWAY_LOGGER);\n+  }\n+\n+  public GrpcErrorMapper(final Logger logger) {\n+    this.logger = logger;\n+  }\n+\n+  public StatusRuntimeException mapError(final Throwable error) {\n+    return StatusProto.toStatusRuntimeException(mapErrorToStatus(error));\n+  }\n+\n+  private Status mapErrorToStatus(final Throwable error) {\n+    final Builder builder = Status.newBuilder();\n+\n+    if (error instanceof ExecutionException) {\n+      return mapErrorToStatus(error.getCause());\n+    } else if (error instanceof BrokerErrorException) {\n+      final Status status = mapBrokerErrorToStatus(((BrokerErrorException) error).getError());\n+      builder.mergeFrom(status);\n+\n+      // When there is back pressure, there will be a lot of `RESOURCE_EXHAUSTED` errors and the log\n+      // can get flooded, so log them at the lowest level possible\n+      if (status.getCode() != Code.RESOURCE_EXHAUSTED.getNumber()) {\n+        logger.error(\"Expected to handle gRPC request, but received error from broker\", error);", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxNzQwNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502317404", "bodyText": "I'm not sure we log all errors in the broker. For example, partition mismatch i think is not logged, maybe others?", "author": "npepinpe", "createdAt": "2020-10-09T09:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMzU1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxNzgwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502317800", "bodyText": "But is this really an error then is the question? It is kind of expected that this can happen - ideally we should just retry that in this case", "author": "Zelldon", "createdAt": "2020-10-09T09:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMzU1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2MjU1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502362559", "bodyText": "My rule of thumb in general is, assuming a client-server setup, if the server returns an error, the client should log it, not the server. However, the server might log error details that are not returned to the client - i.e. sensitive info, information that isn't helpful for the client, etc.\nIn this particular case, we return an INTERNAL error to the client (e.g. 500 - which, by the way, is probably the wrong code to return for PARTITION_LEADER_MISMATCH \ud83d\ude05), with very little information from the client point of view. So we need to log it in the broker/gateway. From the broker point of view though, you're right, this is an expected error - hence why I'd log it on the \"client\" side, i.e. the gateway in this instance. But like I said, bad example, as PARTITION_LEADER_MISMATCH should probably return UNAVAILABLE or something like this, indicating the user can retry the request \ud83d\ude05", "author": "npepinpe", "createdAt": "2020-10-09T11:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMzU1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/grpc/GrpcErrorMapper.java b/gateway/src/main/java/io/zeebe/gateway/grpc/GrpcErrorMapper.java\nindex 8241ae8aa..7294cb117 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/grpc/GrpcErrorMapper.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/grpc/GrpcErrorMapper.java\n\n@@ -99,6 +99,20 @@ public final class GrpcErrorMapper {\n       case RESOURCE_EXHAUSTED:\n         builder.setCode(Code.RESOURCE_EXHAUSTED_VALUE);\n         break;\n+      case PARTITION_LEADER_MISMATCH:\n+        // return UNAVAILABLE to indicate to the user that retrying might solve the issue, as this\n+        // is usually a transient issue\n+        builder.setCode(Code.UNAVAILABLE_VALUE);\n+        break;\n+        // all the following are not errors which retrying (with the same gateway) will solve\n+      case INVALID_MESSAGE_TEMPLATE:\n+      case INVALID_DEPLOYMENT_PARTITION:\n+      case MALFORMED_REQUEST:\n+      case INVALID_CLIENT_VERSION:\n+      case UNSUPPORTED_MESSAGE:\n+      case INTERNAL_ERROR:\n+      case SBE_UNKNOWN:\n+      case NULL_VAL:\n       default:\n         builder.setCode(Code.INTERNAL_VALUE);\n         message =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwNDA1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502304053", "bodyText": "\ud83d\ude05", "author": "Zelldon", "createdAt": "2020-10-09T09:27:10Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetryHandler.java", "diffHunk": "@@ -27,6 +27,7 @@\n  * all partitions are tried. The request is retried only for specific errors such as connection\n  * errors or resource exhausted errors. The request is not retried for time outs.\n  */\n+@SuppressWarnings(\"java:S119\")", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxODI1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502318258", "bodyText": "SonarCloud complains that the type names don't conform to the format. I don't think we ever decided on one, but I suppose we could just change the format on sonarcloud and not have to suppress those warnings", "author": "npepinpe", "createdAt": "2020-10-09T09:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwNDA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNjY4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503716685", "bodyText": "What type names we are talking here? That interface should be an adjective?", "author": "Zelldon", "createdAt": "2020-10-13T07:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwNDA1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetryHandler.java b/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetryHandler.java\nindex 2135c713c..50a38e74f 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetryHandler.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/impl/broker/RequestRetryHandler.java\n\n@@ -27,7 +27,6 @@ import java.util.function.Function;\n  * all partitions are tried. The request is retried only for specific errors such as connection\n  * errors or resource exhausted errors. The request is not retried for time outs.\n  */\n-@SuppressWarnings(\"java:S119\")\n public final class RequestRetryHandler {\n \n   private final BrokerClient brokerClient;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwNzI1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r502307258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void shouldTraceLogResourceExhaustedError() {\n          \n          \n            \n              void shouldLogResourceExhaustedErrorOnTrace() {", "author": "Zelldon", "createdAt": "2020-10-09T09:32:45Z", "path": "gateway/src/test/java/io/zeebe/gateway/grpc/GrpcErrorMapperTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.zeebe.gateway.cmd.BrokerErrorException;\n+import io.zeebe.gateway.impl.broker.response.BrokerError;\n+import io.zeebe.protocol.record.ErrorCode;\n+import io.zeebe.util.logging.RecordingAppender;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.LogEvent;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.slf4j.Log4jLogger;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.parallel.Execution;\n+import org.junit.jupiter.api.parallel.ExecutionMode;\n+\n+@Execution(ExecutionMode.CONCURRENT)\n+final class GrpcErrorMapperTest {\n+  private final RecordingAppender recorder = new RecordingAppender();\n+  private final Logger log = (Logger) LogManager.getLogger(GrpcErrorMapperTest.class);\n+  private final GrpcErrorMapper errorMapper =\n+      new GrpcErrorMapper(new Log4jLogger(log, log.getName()));\n+\n+  @BeforeEach\n+  void setUp() {\n+    recorder.start();\n+    log.addAppender(recorder);\n+  }\n+\n+  @AfterEach\n+  void tearDown() {\n+    recorder.stop();\n+    log.removeAppender(recorder);\n+  }\n+\n+  @Test\n+  void shouldTraceLogResourceExhaustedError() {", "originalCommit": "18945aaca8ee080ad1bc7377bc3368ac27373838", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/test/java/io/zeebe/gateway/grpc/GrpcErrorMapperTest.java b/gateway/src/test/java/io/zeebe/gateway/grpc/GrpcErrorMapperTest.java\nindex c6b7ac20f..09f4b81f1 100644\n--- a/gateway/src/test/java/io/zeebe/gateway/grpc/GrpcErrorMapperTest.java\n+++ b/gateway/src/test/java/io/zeebe/gateway/grpc/GrpcErrorMapperTest.java\n\n@@ -46,7 +46,7 @@ final class GrpcErrorMapperTest {\n   }\n \n   @Test\n-  void shouldTraceLogResourceExhaustedError() {\n+  void shouldLogResourceExhaustedErrorOnTrace() {\n     // given\n     final BrokerError brokerError =\n         new BrokerError(ErrorCode.RESOURCE_EXHAUSTED, \"Resources exhausted\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxMTQ1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503711458", "bodyText": "Why are some methods are changed to use the new interface and some not?", "author": "Zelldon", "createdAt": "2020-10-13T07:02:49Z", "path": "gateway/src/main/java/io/zeebe/gateway/EndpointManager.java", "diffHunk": "@@ -107,48 +106,42 @@ private void addPartitionInfoToBrokerInfo(\n             });\n   }\n \n-  @Override\n   public void activateJobs(\n       final ActivateJobsRequest request,\n-      final StreamObserver<ActivateJobsResponse> responseObserver) {\n-    activateJobsHandler.activateJobs(\n-        request, ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+      final ServerStreamObserver<ActivateJobsResponse> responseObserver) {\n+    activateJobsHandler.activateJobs(request, responseObserver);\n   }\n \n-  @Override\n   public void cancelWorkflowInstance(\n       final CancelWorkflowInstanceRequest request,\n-      final StreamObserver<CancelWorkflowInstanceResponse> responseObserver) {\n+      final ServerStreamObserver<CancelWorkflowInstanceResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toCancelWorkflowInstanceRequest,\n         ResponseMapper::toCancelWorkflowInstanceResponse,\n-        ErrorMappingStreamObserver.ofStreamObserver(responseObserver));\n+        responseObserver);\n   }\n \n-  @Override\n   public void completeJob(\n       final CompleteJobRequest request,\n       final StreamObserver<CompleteJobResponse> responseObserver) {", "originalCommit": "5f2f29d7ed2bec6dfc8f34028d602bc87b542968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDc1Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503980757", "bodyText": "Only the activateJobsHandler really needs the new type actually...but it makes sense to change all methods to accept it.", "author": "npepinpe", "createdAt": "2020-10-13T14:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxMTQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\nindex 0392c03c7..ee637d3b0 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/EndpointManager.java\n\n@@ -124,7 +122,7 @@ public final class EndpointManager {\n \n   public void completeJob(\n       final CompleteJobRequest request,\n-      final StreamObserver<CompleteJobResponse> responseObserver) {\n+      final ServerStreamObserver<CompleteJobResponse> responseObserver) {\n     sendRequest(\n         request,\n         RequestMapper::toCompleteJobRequest,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNTU5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503715593", "bodyText": "Maybe it makes more sense to return the string representation of the error code,  instead of returning the code in the error message? Then it is more clear for the user/client?", "author": "Zelldon", "createdAt": "2020-10-13T07:11:22Z", "path": "gateway/src/main/java/io/zeebe/gateway/grpc/GrpcErrorMapper.java", "diffHunk": "@@ -99,6 +99,20 @@ private Status mapBrokerErrorToStatus(final BrokerError error) {\n       case RESOURCE_EXHAUSTED:\n         builder.setCode(Code.RESOURCE_EXHAUSTED_VALUE);\n         break;\n+      case PARTITION_LEADER_MISMATCH:\n+        // return UNAVAILABLE to indicate to the user that retrying might solve the issue, as this\n+        // is usually a transient issue\n+        builder.setCode(Code.UNAVAILABLE_VALUE);\n+        break;\n+        // all the following are not errors which retrying (with the same gateway) will solve\n+      case INVALID_MESSAGE_TEMPLATE:\n+      case INVALID_DEPLOYMENT_PARTITION:\n+      case MALFORMED_REQUEST:\n+      case INVALID_CLIENT_VERSION:\n+      case UNSUPPORTED_MESSAGE:\n+      case INTERNAL_ERROR:\n+      case SBE_UNKNOWN:\n+      case NULL_VAL:\n       default:\n         builder.setCode(Code.INTERNAL_VALUE);\n         message =", "originalCommit": "5f2f29d7ed2bec6dfc8f34028d602bc87b542968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk3NzU1Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503977557", "bodyText": "Probably, - I can't remember now why we return the code and not the string representation.\nEDIT: actually, this sets the gRPC code, which we have to do regardless. I guess you meant why we write the intent and not the rejection type?", "author": "npepinpe", "createdAt": "2020-10-13T14:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNTU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4NjY2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503986666", "bodyText": "What I meant was this line https://github.com/zeebe-io/zeebe/blob/14eba79cc03e0554be3cee37985c54cf4c52a317/gateway/src/main/java/io/zeebe/gateway/grpc/GrpcErrorMapper.java#L120 where we just set the code instead of the string representation", "author": "Zelldon", "createdAt": "2020-10-13T14:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNTU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4OTc1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503989758", "bodyText": "By string representation, you mean of the code (in this case that's what we do), or you mean the error message? The idea why we don't put the error message is that for these errors, we've logged it on the broker side, and it's probably not very useful for the client (also, it may contain sensitive info for some customers such as file path, system info, etc.)", "author": "npepinpe", "createdAt": "2020-10-13T14:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNTU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQxODMzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r504418333", "bodyText": "Ok my fault sorry. I thought this returns the int representation.", "author": "Zelldon", "createdAt": "2020-10-14T05:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNTU5Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNjg0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503716845", "bodyText": "It is a bit weird with the suppresswarnings to be honest", "author": "Zelldon", "createdAt": "2020-10-13T07:13:50Z", "path": "gateway/src/main/java/io/zeebe/gateway/grpc/ServerStreamObserver.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.grpc;\n+\n+import io.grpc.stub.StreamObserver;\n+\n+/**\n+ * A simple extension of {@link StreamObserver}, meant to be used in conjunction with {@link\n+ * io.grpc.stub.ServerCallStreamObserver}. In order to avoid depending on {@link\n+ * io.grpc.stub.ServerCallStreamObserver}, which is experimental (as of now), we introduce this\n+ * simple interface, and we can easily change the implementation whenever the experimental API is\n+ * changed.\n+ *\n+ * @param <GrpcResponseT> the expected gRPC response type\n+ */\n+@SuppressWarnings(\"java:S119\")", "originalCommit": "5f2f29d7ed2bec6dfc8f34028d602bc87b542968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0NjQyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5524#discussion_r503746428", "bodyText": "Like I said, it's because sonar cloud is set up to warn you if you don't use all caps for your types. We can also change the SonarCloud config instead \ud83d\udc4d", "author": "npepinpe", "createdAt": "2020-10-13T08:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxNjg0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "chunk": "diff --git a/gateway/src/main/java/io/zeebe/gateway/grpc/ServerStreamObserver.java b/gateway/src/main/java/io/zeebe/gateway/grpc/ServerStreamObserver.java\nindex cc798d74c..4f537a982 100644\n--- a/gateway/src/main/java/io/zeebe/gateway/grpc/ServerStreamObserver.java\n+++ b/gateway/src/main/java/io/zeebe/gateway/grpc/ServerStreamObserver.java\n\n@@ -18,7 +18,6 @@ import io.grpc.stub.StreamObserver;\n  *\n  * @param <GrpcResponseT> the expected gRPC response type\n  */\n-@SuppressWarnings(\"java:S119\")\n public interface ServerStreamObserver<GrpcResponseT> extends StreamObserver<GrpcResponseT> {\n   boolean isCancelled();\n }\n"}}, {"oid": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "url": "https://github.com/camunda-cloud/zeebe/commit/0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "message": "chore(gateway): centralize gRPC error mapping\n\n- centralizes gRPC error mapping via ErrorMappingStreamObserver\n- wraps EndpointManager behind a GatewayGrpcService which maps\n  StreamObserver to ServerStreamObserver for the EndpointManager\n- prepares the use of a richer error model described by Google using\n  com.google.rpc.Status", "committedDate": "2020-10-14T08:21:01Z", "type": "commit"}, {"oid": "0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "url": "https://github.com/camunda-cloud/zeebe/commit/0ba0f9b4f36b786a3814f3b4e9356c80dfc2450b", "message": "chore(gateway): centralize gRPC error mapping\n\n- centralizes gRPC error mapping via ErrorMappingStreamObserver\n- wraps EndpointManager behind a GatewayGrpcService which maps\n  StreamObserver to ServerStreamObserver for the EndpointManager\n- prepares the use of a richer error model described by Google using\n  com.google.rpc.Status", "committedDate": "2020-10-14T08:21:01Z", "type": "forcePushed"}]}