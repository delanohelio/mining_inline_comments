{"pr_number": 5189, "pr_title": "Replicate snapshots faster", "pr_createdAt": "2020-08-18T08:49:45Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5189", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1Nzg2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5189#discussion_r472257869", "bodyText": "What happens when we failed to open the reader and return here empty? No install request is send. Is this an issue?", "author": "Zelldon", "createdAt": "2020-08-18T14:51:44Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderAppender.java", "diffHunk": "@@ -363,6 +342,28 @@ public void close() {\n                 new RaftException.ProtocolException(\"Failed to reach consensus\")));\n   }\n \n+  private void tryToReplicateSnapshot(final RaftMemberContext member) {\n+    final var optSnapshot = raft.getPersistedSnapshotStore().getLatestSnapshot();\n+\n+    if (optSnapshot.isPresent()\n+        && member.getSnapshotIndex() < optSnapshot.get().getIndex()\n+        && optSnapshot.get().getIndex() >= member.getLogReader().getCurrentIndex()) {\n+      if (!member.canInstall()) {\n+        return;\n+      }\n+\n+      final var persistedSnapshot = optSnapshot.get();\n+      log.debug(\n+          \"Replicating snapshot {} to {}\",\n+          persistedSnapshot.getIndex(),\n+          member.getMember().memberId());\n+      buildInstallRequest(member, persistedSnapshot)\n+          .ifPresent(installRequest -> sendInstallRequest(member, installRequest));", "originalCommit": "9c93a76953b34a88415eddff53a723fb8ab5e1a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5NzMyNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5189#discussion_r472797327", "bodyText": "Ya. Then no install request is send. But will be retried in the next heartbeat/appendEntry turn. In worst case, it will be retried for ever if there is something seriously wrong with the snapshot. The other option is to throw an exception, but this will cause the leader to fail and go to INACTIVE phase.", "author": "deepthidevaki", "createdAt": "2020-08-19T07:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1Nzg2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1ODU4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5189#discussion_r472258587", "bodyText": "Could be flaky, since ordering is not guaranteed right?", "author": "Zelldon", "createdAt": "2020-08-18T14:52:39Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -170,6 +170,28 @@ public void shouldReplicateSnapshotOnJoin() throws Exception {\n     assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n   }\n \n+  @Test\n+  public void shouldReplicateSnapshotWithManyFilesOnJoin() throws Exception {\n+    // given\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(20);\n+    final long snapshotIndex = 10L;\n+    raftRule.doSnapshot(snapshotIndex, 10);\n+    final var leaderSnapshot = raftRule.getSnapshotFromLeader();\n+\n+    // when\n+    raftRule.joinCluster(follower);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(snapshotIndex)).isTrue();\n+    final var snapshot = raftRule.getSnapshotOnNode(follower);\n+\n+    assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(snapshotIndex);\n+    assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n+    assertThat(snapshot.getPath().toFile().list())", "originalCommit": "9c93a76953b34a88415eddff53a723fb8ab5e1a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI2Mzk2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5189#discussion_r472263964", "bodyText": "First I thought hm this Test should also worked before right? So what is the matter of this test, the I tried it without your fix and it toooook soo long, wow didn't expected that :D\nThanks for fixing that, awesome.", "author": "Zelldon", "createdAt": "2020-08-18T14:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1ODU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5OTcyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5189#discussion_r472799722", "bodyText": "Actually, this test was added to test parallel/pipelined sending of snapshot chunks. But this PR doesnot have it. I didn't notice performance difference \ud83d\ude04 Should I keep/remove this test?", "author": "deepthidevaki", "createdAt": "2020-08-19T07:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1ODU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgwMTMwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5189#discussion_r472801300", "bodyText": "Lets keep it. It fails, because of timeouts, if I we create always the snapshot chunk reader :) I tried that :D", "author": "Zelldon", "createdAt": "2020-08-19T07:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1ODU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6811e1ecdfb0d8c0c0a75738c8a1278a8e9d9dd7", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\nindex 54028db78..977c6aa84 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\n\n@@ -189,7 +189,7 @@ public class RaftFailOverTest {\n     assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(snapshotIndex);\n     assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n     assertThat(snapshot.getPath().toFile().list())\n-        .isEqualTo(leaderSnapshot.getPath().toFile().list());\n+        .containsExactlyInAnyOrder(leaderSnapshot.getPath().toFile().list());\n   }\n \n   @Test\n"}}, {"oid": "6811e1ecdfb0d8c0c0a75738c8a1278a8e9d9dd7", "url": "https://github.com/camunda-cloud/zeebe/commit/6811e1ecdfb0d8c0c0a75738c8a1278a8e9d9dd7", "message": "fix(atomix): donot build snapshot reader for each install request\n\nFileBasedSnapshotChunkReader read all files in constructor to calculate checksum. When we create a new instance of the reader for each install request, it affects the overall snapshot replication duration.", "committedDate": "2020-08-19T13:29:12Z", "type": "commit"}, {"oid": "1b3c0f7608d53d6043b9de5960d11dadff6b8724", "url": "https://github.com/camunda-cloud/zeebe/commit/1b3c0f7608d53d6043b9de5960d11dadff6b8724", "message": "chore(atomix): use request's currentTerm instead of snapshot's term to reset hearbeat", "committedDate": "2020-08-19T13:30:11Z", "type": "commit"}, {"oid": "1b3c0f7608d53d6043b9de5960d11dadff6b8724", "url": "https://github.com/camunda-cloud/zeebe/commit/1b3c0f7608d53d6043b9de5960d11dadff6b8724", "message": "chore(atomix): use request's currentTerm instead of snapshot's term to reset hearbeat", "committedDate": "2020-08-19T13:30:11Z", "type": "forcePushed"}]}