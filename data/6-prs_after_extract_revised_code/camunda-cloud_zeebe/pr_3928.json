{"pr_number": 3928, "pr_title": "Introduce new ZeebeIndex", "pr_createdAt": "2020-02-26T14:35:03Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/3928", "timeline": [{"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "url": "https://github.com/camunda-cloud/zeebe/commit/ffdb780c8c6be420caba4d029001b8d3ea9d5065", "message": "chore(logstreams): introduce new ZeebeIndex\n\n In order to improve seek performance and reduce log deletion time,\n we introducing a new ZeebeIndex. This index wraps the Atomix\n SparseJournalIndex and builds an own map of position to index.\n\n With this index it is easily and in a performant way possible to look\n up an index/address for a given position. This look up is used\n for example on deletion instead of the old seek strategy. This treats\n time against space, which means we need to use more space in memory but\n are fast to find an index/position.\n\n The ZeebeIndex is on startup injected into the RaftPartition such that\n is filled on leader and follower on appending new entries.\n\n The underlying data structure needs to be thread safe, since we access\n it on different threads.", "committedDate": "2020-02-28T06:55:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExMjY1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387112656", "bodyText": "Can use floorEntry()\n   public long lookupPosition(final long position) {\n    final var lowerEntry = positionIndexMapping.floorEntry(position);\n    if (lowerEntry != null) {\n      return lowerEntry.getValue();\n    }\n    return -1;\n  }", "author": "deepthidevaki", "createdAt": "2020-03-03T15:50:22Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.index.JournalIndex;\n+import io.atomix.storage.journal.index.Position;\n+import io.atomix.storage.journal.index.SparseJournalIndex;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n+public final class ZeebeIndexAdapter implements JournalIndex, ZeebeIndexMapping {\n+\n+  private final ConcurrentNavigableMap<Long, Long> positionIndexMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final ConcurrentNavigableMap<Long, Long> indexPositionMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final SparseJournalIndex sparseJournalIndex;\n+  private final int density;\n+\n+  private ZeebeIndexAdapter(int density) {\n+    this.density = density;\n+    sparseJournalIndex = new SparseJournalIndex(density);\n+  }\n+\n+  public static ZeebeIndexAdapter ofDensity(int density) {\n+    return new ZeebeIndexAdapter(density);\n+  }\n+\n+  @Override\n+  public void index(final Indexed indexedEntry, final int position) {\n+    final var index = indexedEntry.index();\n+    if (index % density == 0) {\n+      if (indexedEntry.type() == ZeebeEntry.class) {\n+        final ZeebeEntry zeebeEntry = (ZeebeEntry) indexedEntry.entry();\n+        final var lowestPosition = zeebeEntry.lowestPosition();\n+\n+        positionIndexMapping.put(lowestPosition, index);\n+        indexPositionMapping.put(index, lowestPosition);\n+      }\n+    }\n+\n+    sparseJournalIndex.index(indexedEntry, position);\n+  }\n+\n+  @Override\n+  public long lookupPosition(final long position) {\n+    var index = positionIndexMapping.getOrDefault(position, -1L);", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa169cc18a4dd3f295d681a9f9baa507df61d968", "chunk": "diff --git a/logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java b/logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java\ndeleted file mode 100644\nindex 671eac30f..000000000\n--- a/logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java\n+++ /dev/null\n\n@@ -1,102 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.logstreams.storage.atomix;\n-\n-import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.index.JournalIndex;\n-import io.atomix.storage.journal.index.Position;\n-import io.atomix.storage.journal.index.SparseJournalIndex;\n-import java.util.concurrent.ConcurrentNavigableMap;\n-import java.util.concurrent.ConcurrentSkipListMap;\n-\n-public final class ZeebeIndexAdapter implements JournalIndex, ZeebeIndexMapping {\n-\n-  private final ConcurrentNavigableMap<Long, Long> positionIndexMapping =\n-      new ConcurrentSkipListMap<>();\n-  private final ConcurrentNavigableMap<Long, Long> indexPositionMapping =\n-      new ConcurrentSkipListMap<>();\n-  private final SparseJournalIndex sparseJournalIndex;\n-  private final int density;\n-\n-  private ZeebeIndexAdapter(int density) {\n-    this.density = density;\n-    sparseJournalIndex = new SparseJournalIndex(density);\n-  }\n-\n-  public static ZeebeIndexAdapter ofDensity(int density) {\n-    return new ZeebeIndexAdapter(density);\n-  }\n-\n-  @Override\n-  public void index(final Indexed indexedEntry, final int position) {\n-    final var index = indexedEntry.index();\n-    if (index % density == 0) {\n-      if (indexedEntry.type() == ZeebeEntry.class) {\n-        final ZeebeEntry zeebeEntry = (ZeebeEntry) indexedEntry.entry();\n-        final var lowestPosition = zeebeEntry.lowestPosition();\n-\n-        positionIndexMapping.put(lowestPosition, index);\n-        indexPositionMapping.put(index, lowestPosition);\n-      }\n-    }\n-\n-    sparseJournalIndex.index(indexedEntry, position);\n-  }\n-\n-  @Override\n-  public long lookupPosition(final long position) {\n-    var index = positionIndexMapping.getOrDefault(position, -1L);\n-\n-    if (index == -1) {\n-      final var lowerEntry = positionIndexMapping.lowerEntry(position);\n-      if (lowerEntry != null) {\n-        index = lowerEntry.getValue();\n-      }\n-    }\n-\n-    return index;\n-  }\n-\n-  @Override\n-  public Position lookup(final long index) {\n-    return sparseJournalIndex.lookup(index);\n-  }\n-\n-  @Override\n-  public void truncate(final long index) {\n-    final var higherEntry = indexPositionMapping.higherEntry(index);\n-\n-    if (higherEntry != null) {\n-\n-      final var higherIndex = higherEntry.getKey();\n-      final var higherPosition = higherEntry.getValue();\n-\n-      indexPositionMapping.tailMap(higherIndex).clear();\n-      positionIndexMapping.tailMap(higherPosition).clear();\n-    }\n-\n-    sparseJournalIndex.truncate(index);\n-  }\n-\n-  @Override\n-  public void compact(long index) {\n-    final var lowerEntry = indexPositionMapping.lowerEntry(index);\n-\n-    if (lowerEntry != null) {\n-\n-      final var lowerIndex = lowerEntry.getKey();\n-      final var lowerPosition = lowerEntry.getValue();\n-\n-      indexPositionMapping.headMap(lowerIndex).clear();\n-      positionIndexMapping.headMap(lowerPosition).clear();\n-    }\n-\n-    sparseJournalIndex.compact(index);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExNjY0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387116648", "bodyText": "Just for completeness may be test one at exact position.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n          \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(20)).isEqualTo(5);", "author": "deepthidevaki", "createdAt": "2020-03-03T15:56:02Z", "path": "logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.protocols.raft.storage.log.entry.InitializeEntry;\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import java.nio.ByteBuffer;\n+import org.junit.Test;\n+\n+public class ZeebeIndexTest {\n+\n+  @Test\n+  public void shouldNotFindIndexWhenNotReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    final var index = zeebeIndexAdapter.lookupPosition(1L);\n+\n+    // then\n+    assertThat(index).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void shouldFindIndexWhenReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n+    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n+    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n+    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n+    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n+\n+    // then\n+    assertThat(zeebeIndexAdapter.lookupPosition(1)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(16)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa169cc18a4dd3f295d681a9f9baa507df61d968", "chunk": "diff --git a/logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java b/logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java\ndeleted file mode 100644\nindex 237c56e96..000000000\n--- a/logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.logstreams.storage.atomix;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import io.atomix.protocols.raft.storage.log.entry.InitializeEntry;\n-import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n-import io.atomix.storage.journal.Indexed;\n-import java.nio.ByteBuffer;\n-import org.junit.Test;\n-\n-public class ZeebeIndexTest {\n-\n-  @Test\n-  public void shouldNotFindIndexWhenNotReachedDensity() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-\n-    // when\n-    final var index = zeebeIndexAdapter.lookupPosition(1L);\n-\n-    // then\n-    assertThat(index).isEqualTo(-1);\n-  }\n-\n-  @Test\n-  public void shouldFindIndexWhenReachedDensity() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-\n-    // when\n-    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n-    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n-    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n-    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n-    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(1)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(16)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n-  }\n-\n-  @Test\n-  public void shouldNotAddToIndexWhenNotCorrectType() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-\n-    // when\n-    zeebeIndexAdapter.index(\n-        new Indexed(5, new InitializeEntry(0, System.currentTimeMillis()), 10), 10);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(1)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(16)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(-1);\n-  }\n-\n-  @Test\n-  public void shouldFindLowerIndexWhenNotReachedDensity() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-    // index entries\n-    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n-    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n-    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n-    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n-    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n-\n-    // when\n-    zeebeIndexAdapter.index(asZeebeEntry(6, 25), 12);\n-    zeebeIndexAdapter.index(asZeebeEntry(7, 30), 14);\n-    zeebeIndexAdapter.index(asZeebeEntry(8, 35), 16);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(31)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(35)).isEqualTo(5);\n-  }\n-\n-  @Test\n-  public void shouldFindNextIndexWhenReachedDensity() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-    // index entries\n-    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n-    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n-    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n-    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n-    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n-    zeebeIndexAdapter.index(asZeebeEntry(6, 25), 12);\n-    zeebeIndexAdapter.index(asZeebeEntry(7, 30), 14);\n-    zeebeIndexAdapter.index(asZeebeEntry(8, 35), 16);\n-\n-    // when\n-    zeebeIndexAdapter.index(asZeebeEntry(9, 40), 18);\n-    zeebeIndexAdapter.index(asZeebeEntry(10, 45), 20);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(45)).isEqualTo(10);\n-    assertThat(zeebeIndexAdapter.lookupPosition(46)).isEqualTo(10);\n-  }\n-\n-  @Test\n-  public void shouldTruncateIndex() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-    // index entries\n-    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n-    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n-    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n-    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n-    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n-    zeebeIndexAdapter.index(asZeebeEntry(6, 25), 12);\n-    zeebeIndexAdapter.index(asZeebeEntry(7, 30), 14);\n-    zeebeIndexAdapter.index(asZeebeEntry(8, 35), 16);\n-    zeebeIndexAdapter.index(asZeebeEntry(9, 40), 18);\n-    zeebeIndexAdapter.index(asZeebeEntry(10, 45), 20);\n-\n-    // when\n-    zeebeIndexAdapter.truncate(8);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(31)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(35)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(45)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(46)).isEqualTo(5);\n-  }\n-\n-  @Test\n-  public void shouldTruncateCompleteIndex() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-    // index entries\n-    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n-    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n-    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n-    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n-    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n-    zeebeIndexAdapter.index(asZeebeEntry(6, 25), 12);\n-    zeebeIndexAdapter.index(asZeebeEntry(7, 30), 14);\n-    zeebeIndexAdapter.index(asZeebeEntry(8, 35), 16);\n-    zeebeIndexAdapter.index(asZeebeEntry(9, 40), 18);\n-    zeebeIndexAdapter.index(asZeebeEntry(10, 45), 20);\n-    zeebeIndexAdapter.truncate(8);\n-\n-    // when\n-    zeebeIndexAdapter.truncate(4);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(5)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(20)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(35)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(50)).isEqualTo(-1);\n-  }\n-\n-  @Test\n-  public void shouldNotCompactIndex() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-    // index entries\n-    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n-    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n-    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n-    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n-    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n-    zeebeIndexAdapter.index(asZeebeEntry(6, 25), 12);\n-    zeebeIndexAdapter.index(asZeebeEntry(7, 30), 14);\n-    zeebeIndexAdapter.index(asZeebeEntry(8, 35), 16);\n-    zeebeIndexAdapter.index(asZeebeEntry(9, 40), 18);\n-    zeebeIndexAdapter.index(asZeebeEntry(10, 45), 20);\n-\n-    // when\n-    zeebeIndexAdapter.compact(8);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(31)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(35)).isEqualTo(5);\n-    assertThat(zeebeIndexAdapter.lookupPosition(45)).isEqualTo(10);\n-    assertThat(zeebeIndexAdapter.lookupPosition(46)).isEqualTo(10);\n-  }\n-\n-  @Test\n-  public void shouldCompactIndex() {\n-    // given - every 5 index is added\n-    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n-    // index entries\n-    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n-    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n-    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n-    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n-    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n-    zeebeIndexAdapter.index(asZeebeEntry(6, 25), 12);\n-    zeebeIndexAdapter.index(asZeebeEntry(7, 30), 14);\n-    zeebeIndexAdapter.index(asZeebeEntry(8, 35), 16);\n-    zeebeIndexAdapter.index(asZeebeEntry(9, 40), 18);\n-    zeebeIndexAdapter.index(asZeebeEntry(10, 45), 20);\n-\n-    // when\n-    zeebeIndexAdapter.compact(11);\n-\n-    // then\n-    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(31)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(35)).isEqualTo(-1);\n-    assertThat(zeebeIndexAdapter.lookupPosition(45)).isEqualTo(10);\n-    assertThat(zeebeIndexAdapter.lookupPosition(46)).isEqualTo(10);\n-  }\n-\n-  private static Indexed asZeebeEntry(long index, long lowestPos) {\n-    return new Indexed(\n-        index,\n-        new ZeebeEntry(0, System.currentTimeMillis(), lowestPos, lowestPos, ByteBuffer.allocate(0)),\n-        0);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387138724", "bodyText": "Can we use atomixLogStorage.newReader()?", "author": "deepthidevaki", "createdAt": "2020-03-03T16:26:13Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MTk2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388281964", "bodyText": "Actually here I was not 100% sure, since it used a different index as on newReader. Might that @npepinpe knows.", "author": "Zelldon", "createdAt": "2020-03-05T13:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTI3Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388289273", "bodyText": "Hm, I guess we could use it, don't see any reason why not - the goal is just that it starts at the beginning.", "author": "npepinpe", "createdAt": "2020-03-05T13:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTg0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388289845", "bodyText": "newReader uses index zero or 1 and this one -1 \ud83e\udd37\u200d\u2642\ufe0f", "author": "Zelldon", "createdAt": "2020-03-05T13:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MDI2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388290265", "bodyText": "Yeah, doesn't really matter I think, just that it starts at the beginning, as far as I remember. Just try it and see, should be fine", "author": "npepinpe", "createdAt": "2020-03-05T13:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQxMzUwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388413502", "bodyText": "I have approved the PR. You can change to atomixLogStorage.newReader() if you think it wouldn't break anything.", "author": "deepthidevaki", "createdAt": "2020-03-05T16:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3Njc3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r389476776", "bodyText": "We currently need the implementation class in the AtomixRecordSupplier. I will leave it for now.", "author": "Zelldon", "createdAt": "2020-03-09T06:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "fa169cc18a4dd3f295d681a9f9baa507df61d968", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java b/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\nindex 0e1be40b3..385b4c790 100644\n--- a/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\n+++ b/broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java\n\n@@ -316,10 +314,8 @@ public final class ZeebePartition extends Actor\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n-\n     final var reader =\n-        new AtomixLogStorageReader(\n-            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n     final var runtimeDirectory = atomixRaftPartition.dataDirectory().toPath().resolve(\"runtime\");\n     return new AtomixSnapshotStorage(\n         runtimeDirectory,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387140247", "bodyText": "This returns an address <= the current address, right? It will be better explained in the doc.", "author": "deepthidevaki", "createdAt": "2020-03-03T16:28:14Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "diffHunk": "@@ -64,14 +64,14 @@\n   long getPosition();\n \n   /**\n-   * The last log storage address, from which the last block of events was read.\n-   *\n-   * <p>Useful if you want to found out the related block address, then just seek to a given\n-   * position and call this method.\n+   * Look up the nearest log storage address, where the entry with the given position can be found.\n+   * The implementation do not need to provide the exact log event address, it is more about an\n+   * approximation, which can then be used to find the entry.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @return the last log storage address, from which the last block of events was read.\n+   * @param position the position, for which the look up should made\n+   * @return the approximated address in the log storage\n    */\n-  long lastReadAddress();\n+  long lookupAddress(long position);", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MzUxNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388283514", "bodyText": "What do you mean with the current address? Which current? \ud83d\ude05 It just checks the index.", "author": "Zelldon", "createdAt": "2020-03-05T13:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MDc0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388290746", "bodyText": "Sorry. I mean it returns an index corresponding to a pos <= given position.", "author": "deepthidevaki", "createdAt": "2020-03-05T13:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MTMxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388291316", "bodyText": "Ok I think I get it :D", "author": "Zelldon", "createdAt": "2020-03-05T13:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "fa169cc18a4dd3f295d681a9f9baa507df61d968", "chunk": "diff --git a/logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java b/logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java\nindex e859f3487..f479c5bb7 100644\n--- a/logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java\n+++ b/logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java\n\n@@ -64,14 +64,14 @@ public interface LogStreamReader extends Iterator<LoggedEvent>, CloseableSilentl\n   long getPosition();\n \n   /**\n-   * Look up the nearest log storage address, where the entry with the given position can be found.\n-   * The implementation do not need to provide the exact log event address, it is more about an\n-   * approximation, which can then be used to find the entry.\n+   * The last log storage address, from which the last block of events was read.\n+   *\n+   * <p>Useful if you want to found out the related block address, then just seek to a given\n+   * position and call this method.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @param position the position, for which the look up should made\n-   * @return the approximated address in the log storage\n+   * @return the last log storage address, from which the last block of events was read.\n    */\n-  long lookupAddress(long position);\n+  long lastReadAddress();\n }\n"}}, {"oid": "fa169cc18a4dd3f295d681a9f9baa507df61d968", "url": "https://github.com/camunda-cloud/zeebe/commit/fa169cc18a4dd3f295d681a9f9baa507df61d968", "message": "chore(util): set cause exception", "committedDate": "2020-03-05T13:15:04Z", "type": "commit"}, {"oid": "fb6187c9a99fceba0ea1afd2aba537b19cfea4ae", "url": "https://github.com/camunda-cloud/zeebe/commit/fb6187c9a99fceba0ea1afd2aba537b19cfea4ae", "message": "chore(logstreams): introduce new ZeebeIndex\n\n In order to improve seek performance and reduce log deletion time,\n we introducing a new ZeebeIndex. This index wraps the Atomix\n SparseJournalIndex and builds an own map of position to index.\n\n With this index it is easily and in a performant way possible to look\n up an index/address for a given position. This look up is used\n for example on deletion instead of the old seek strategy. This treats\n time against space, which means we need to use more space in memory but\n are fast to find an index/position.\n\n The ZeebeIndex is on startup injected into the RaftPartition such that\n is filled on leader and follower on appending new entries.\n\n The underlying data structure needs to be thread safe, since we access\n it on different threads.", "committedDate": "2020-03-05T13:16:37Z", "type": "commit"}, {"oid": "564a742c87161fbd8a5491480321edd381ae5d14", "url": "https://github.com/camunda-cloud/zeebe/commit/564a742c87161fbd8a5491480321edd381ae5d14", "message": "chore(logstreams): follow review hints", "committedDate": "2020-03-05T13:16:37Z", "type": "commit"}, {"oid": "564a742c87161fbd8a5491480321edd381ae5d14", "url": "https://github.com/camunda-cloud/zeebe/commit/564a742c87161fbd8a5491480321edd381ae5d14", "message": "chore(logstreams): follow review hints", "committedDate": "2020-03-05T13:16:37Z", "type": "forcePushed"}]}