{"pr_number": 4781, "pr_title": "Multiple Swim improvements", "pr_createdAt": "2020-06-22T05:18:36Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4781", "timeline": [{"oid": "dd9fa1c6c977b8ca29af976a0198a7db7ad9a3c4", "url": "https://github.com/camunda-cloud/zeebe/commit/dd9fa1c6c977b8ca29af976a0198a7db7ad9a3c4", "message": "chore(atomix): do not trigger listeners multiple times\n\n removethe possibility that listerners got MEMBER_REMOVED multiple\n times", "committedDate": "2020-06-22T05:12:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwMDcyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444000728", "bodyText": "Why is comparing with address needed?", "author": "deepthidevaki", "createdAt": "2020-06-23T06:55:02Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java", "diffHunk": "@@ -225,14 +229,15 @@ private void checkMetadata() {\n    */\n   private boolean updateState(final ImmutableMember member) {\n     // If the member matches the local member, ignore the update.\n-    if (member.id().equals(localMember.id())) {\n+    if (member.id().equals(localMember.id()) || member.address().equals(localMember.address())) {", "originalCommit": "d1a34f6e7c961986eecb758a5b1d847f2fe3fc32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgwMzY2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444803668", "bodyText": "Ok I think here it is not necessary It was more necessary for sending the requests", "author": "Zelldon", "createdAt": "2020-06-24T10:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwMDcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NzIzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r446087236", "bodyText": "Ok I have still the feeling we need that.\nWe get from the BootstrapNodeProvider nodes which have as id an uuid, which means the localMember.id will not be equal to the member id. The localMember.id will be 0, 1, 2 etc. When we get an update from other member about that bootstrap node, that it is not reachable for example. We will remove it from our members, which might mean we remove us? Idk how problematic it is.", "author": "Zelldon", "createdAt": "2020-06-26T09:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwMDcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4ODU3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r446088570", "bodyText": "Ok nevermind i think it is fine if we remove the bootstrap local node - since we are anyway in the list as localMember", "author": "Zelldon", "createdAt": "2020-06-26T09:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwMDcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "f98a8a3a44c0a1159227b18a498af3660a754a25", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\nindex 6258d97ae..fe0afc7d2 100644\n--- a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n+++ b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n\n@@ -229,7 +223,7 @@ public class SwimMembershipProtocol\n    */\n   private boolean updateState(final ImmutableMember member) {\n     // If the member matches the local member, ignore the update.\n-    if (member.id().equals(localMember.id()) || member.address().equals(localMember.address())) {\n+    if (member.id().equals(localMember.id())) {\n       return false;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MjA2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444252067", "bodyText": "Should we wait for the response to schedule the next probe? Worst case, if the remote member is dead, we wait probeTimeout + probeInterval  time to send the next probe. This will increase the latency to detect failures of other nodes. Right?", "author": "deepthidevaki", "createdAt": "2020-06-23T14:07:32Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java", "diffHunk": "@@ -523,6 +525,10 @@ private void probe(final ImmutableMember member) {\n                   requestProbes(swimMember.copy());\n                 }\n               }\n+              swimScheduler.schedule(", "originalCommit": "d1a34f6e7c961986eecb758a5b1d847f2fe3fc32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgyODg4Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444828882", "bodyText": "I think we discussed that, that the current impl was not ideal. Actually I would expect that the timeout is much lower. We could also say on timeout we directly trigger the next probe.", "author": "Zelldon", "createdAt": "2020-06-24T11:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MjA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1NDg4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r445354885", "bodyText": "The current impl is not ideal because it is scheduled at fixed rate. Doesn't sending the probe and immediately scheduling the next one already reduce that problem? I don't know clearly what will be the impact of both approaches (Any comments @saig0 ). If we wait for the timeout, I am afraid we increase the failure detection latency. Decreasing the timeout would probably help, but it might unnecessarily detect slow nodes as failed. That said, 2s timeout is too much. This timeout should be based on expected RTT in the network.\nI'm ok with accepting this implementation and revisit this if we find any problem in future.", "author": "deepthidevaki", "createdAt": "2020-06-25T07:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MjA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2NTQ5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r445365496", "bodyText": "Extract from http://www.cs.cornell.edu/info/projects/spinglass/public_pdfs/swim.pdf page 4. So yes it should be smaller then the ping interval.\nExample how it is done on other implementations\n\nHashicorp uses 500 ms timeout https://github.com/hashicorp/memberlist/blob/master/config.go#L288\nscalecube uses 100ms https://github.com/scalecube/scalecube-cluster", "author": "Zelldon", "createdAt": "2020-06-25T07:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MjA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NjQ2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r445456469", "bodyText": "@deepthidevaki Should I create a follow up for the timeout lowering?", "author": "Zelldon", "createdAt": "2020-06-25T10:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MjA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5NDc5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r445994793", "bodyText": "Follow up #4827", "author": "Zelldon", "createdAt": "2020-06-26T06:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MjA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5ODAyNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r445998025", "bodyText": "\ud83d\udc4d", "author": "deepthidevaki", "createdAt": "2020-06-26T06:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MjA2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f98a8a3a44c0a1159227b18a498af3660a754a25", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\nindex 6258d97ae..fe0afc7d2 100644\n--- a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n+++ b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n\n@@ -525,10 +518,8 @@ public class SwimMembershipProtocol\n                   requestProbes(swimMember.copy());\n                 }\n               }\n-              swimScheduler.schedule(\n-                  (Runnable) this::probe,\n-                  config.getProbeInterval().toMillis(),\n-                  TimeUnit.MILLISECONDS);\n+\n+              scheduleProbe();\n             },\n             swimScheduler);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MzI3Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444253272", "bodyText": "These futures should be updated when they are scheduled again.", "author": "deepthidevaki", "createdAt": "2020-06-23T14:09:13Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java", "diffHunk": "@@ -161,22 +161,26 @@ public Member getMember(final MemberId memberId) {\n       this.localProperties.putAll(localMember.properties());\n       discoveryService.addListener(discoveryEventListener);\n \n-      LOGGER.info(\"{} - Member activated: {}\", localMember.id(), localMember);\n+      // we need to add our local node to the member list,\n+      // to share the mapping between node id and address in the cluster\n       localMember.setState(State.ALIVE);\n       members.put(localMember.id(), localMember);\n       post(new GroupMembershipEvent(GroupMembershipEvent.Type.MEMBER_ADDED, localMember));\n \n+      LOGGER.debug(\"Nodes from discovery service {}\", discoveryService.getNodes());\n+\n       registerHandlers();\n       gossipFuture =\n-          swimScheduler.scheduleAtFixedRate(\n-              this::gossip, 0, config.getGossipInterval().toMillis(), TimeUnit.MILLISECONDS);\n+          swimScheduler.schedule(", "originalCommit": "d1a34f6e7c961986eecb758a5b1d847f2fe3fc32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgyODk2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444828966", "bodyText": "true", "author": "Zelldon", "createdAt": "2020-06-24T11:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MzI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f98a8a3a44c0a1159227b18a498af3660a754a25", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\nindex 6258d97ae..fe0afc7d2 100644\n--- a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n+++ b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n\n@@ -170,17 +170,11 @@ public class SwimMembershipProtocol\n       LOGGER.debug(\"Nodes from discovery service {}\", discoveryService.getNodes());\n \n       registerHandlers();\n-      gossipFuture =\n-          swimScheduler.schedule(\n-              (Runnable) this::gossip,\n-              config.getGossipInterval().toMillis(),\n-              TimeUnit.MILLISECONDS);\n-      probeFuture =\n-          swimScheduler.schedule(\n-              (Runnable) this::probe, config.getProbeInterval().toMillis(), TimeUnit.MILLISECONDS);\n-      syncFuture =\n-          swimScheduler.schedule(\n-              (Runnable) this::sync, config.getSyncInterval().toMillis(), TimeUnit.MILLISECONDS);\n+\n+      scheduleGossip();\n+      scheduleProbe();\n+      scheduleSync();\n+\n       LOGGER.info(\"Started\");\n     }\n     return CompletableFuture.completedFuture(null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1MzU1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444253554", "bodyText": "\ud83d\udc4d", "author": "deepthidevaki", "createdAt": "2020-06-23T14:09:35Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java", "diffHunk": "@@ -388,25 +385,20 @@ private void checkFailures() {\n           && System.currentTimeMillis() - member.getUpdated()\n               > config.getFailureTimeout().toMillis()) {\n         member.setState(State.DEAD);\n-        members.remove(member.id());\n-        randomMembers.remove(member);\n-        Collections.shuffle(randomMembers);\n-        LOGGER.debug(\"{} - Member removed {}\", this.localMember.id(), member);\n-        post(new GroupMembershipEvent(GroupMembershipEvent.Type.MEMBER_REMOVED, member.copy()));\n+\n+        tryRemoveMember(member);\n         recordUpdate(member.copy());\n       }\n     }\n   }\n \n-  /** Synchronizes the node state with peers. */\n-  private void syncAll() {\n-    final List<SwimMember> syncMembers =\n-        discoveryService.getNodes().stream()\n-            .map(node -> new SwimMember(MemberId.from(node.id().id()), node.address()))\n-            .filter(member -> !member.id().equals(localMember.id()))\n-            .collect(Collectors.toList());\n-    for (final SwimMember member : syncMembers) {\n-      sync(member.copy());\n+  private void tryRemoveMember(final SwimMember member) {", "originalCommit": "d1a34f6e7c961986eecb758a5b1d847f2fe3fc32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9556935960cf6ea35817a933834f68527376758b", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\nindex 6258d97ae..2da476ea8 100644\n--- a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n+++ b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n\n@@ -402,6 +401,19 @@ public class SwimMembershipProtocol\n     }\n   }\n \n+  /** Synchronizes the node state with peers. */\n+  private void syncAll() {\n+    final List<SwimMember> syncMembers =\n+        discoveryService.getNodes().stream()\n+            .map(node -> new SwimMember(MemberId.from(node.id().id()), node.address()))\n+            .filter(member -> !member.id().equals(localMember.id()))\n+            .filter(member -> !member.address().equals(localMember.address()))\n+            .collect(Collectors.toList());\n+    for (final SwimMember member : syncMembers) {\n+      sync(member.copy());\n+    }\n+  }\n+\n   /**\n    * Synchronizes the node state with the given peer.\n    *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2MzU3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4781#discussion_r444263575", "bodyText": "Similar to sync(),  if probeMembers is empty, you have to schedule probe.", "author": "deepthidevaki", "createdAt": "2020-06-23T14:23:05Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java", "diffHunk": "@@ -475,20 +476,21 @@ private void probe() {\n     // This is necessary to ensure we attempt to probe all nodes that are provided by the discovery\n     // provider.\n     final List<SwimMember> probeMembers =\n-        Lists.newArrayList(\n-            discoveryService.getNodes().stream()\n-                .map(node -> new SwimMember(MemberId.from(node.id().id()), node.address()))\n-                .filter(member -> !members.containsKey(member.id()))\n-                .filter(member -> !member.id().equals(localMember.id()))\n-                .sorted(Comparator.comparing(Member::id))\n-                .collect(Collectors.toList()));\n+        discoveryService.getNodes().stream()\n+            .map(node -> new SwimMember(MemberId.from(node.id().id()), node.address()))\n+            .filter(member -> !members.containsKey(member.id()))\n+            .filter(member -> !member.id().equals(localMember.id()))\n+            .filter(member -> !member.address().equals(localMember.address()))\n+            .sorted(Comparator.comparing(Member::id))\n+            .collect(Collectors.toList());\n \n     // Then add the randomly sorted list of SWIM members.\n     probeMembers.addAll(randomMembers);\n \n     // If there are members to probe, select the next member to probe using a counter for round\n     // robin probes.\n     if (!probeMembers.isEmpty()) {", "originalCommit": "d1a34f6e7c961986eecb758a5b1d847f2fe3fc32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f98a8a3a44c0a1159227b18a498af3660a754a25", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\nindex 6258d97ae..fe0afc7d2 100644\n--- a/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n+++ b/atomix/cluster/src/main/java/io/atomix/cluster/protocol/SwimMembershipProtocol.java\n\n@@ -494,6 +485,8 @@ public class SwimMembershipProtocol\n       final SwimMember probeMember =\n           probeMembers.get(Math.abs(probeCounter.incrementAndGet() % probeMembers.size()));\n       probe(probeMember.copy());\n+    } else {\n+      scheduleProbe();\n     }\n   }\n \n"}}, {"oid": "f98a8a3a44c0a1159227b18a498af3660a754a25", "url": "https://github.com/camunda-cloud/zeebe/commit/f98a8a3a44c0a1159227b18a498af3660a754a25", "message": "chore(atomix): remove address check in updateState", "committedDate": "2020-06-26T10:20:18Z", "type": "forcePushed"}, {"oid": "9556935960cf6ea35817a933834f68527376758b", "url": "https://github.com/camunda-cloud/zeebe/commit/9556935960cf6ea35817a933834f68527376758b", "message": "chore(swim): do not send requests to local node", "committedDate": "2020-06-29T06:48:42Z", "type": "commit"}, {"oid": "eb785bb6bc2097f68a36d33d8444e1d69fc0e5bf", "url": "https://github.com/camunda-cloud/zeebe/commit/eb785bb6bc2097f68a36d33d8444e1d69fc0e5bf", "message": "chore(atomix): trigger swim requests not in a fixed rate\n\n Requests are awaited for reponse or timeout and then next requests are\n scheduled", "committedDate": "2020-06-29T06:49:03Z", "type": "commit"}, {"oid": "eb785bb6bc2097f68a36d33d8444e1d69fc0e5bf", "url": "https://github.com/camunda-cloud/zeebe/commit/eb785bb6bc2097f68a36d33d8444e1d69fc0e5bf", "message": "chore(atomix): trigger swim requests not in a fixed rate\n\n Requests are awaited for reponse or timeout and then next requests are\n scheduled", "committedDate": "2020-06-29T06:49:03Z", "type": "forcePushed"}]}