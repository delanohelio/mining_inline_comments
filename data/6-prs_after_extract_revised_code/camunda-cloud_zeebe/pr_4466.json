{"pr_number": 4466, "pr_title": "Refactor Atomix", "pr_createdAt": "2020-05-06T20:54:28Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4466", "timeline": [{"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "url": "https://github.com/camunda-cloud/zeebe/commit/e920effc9dc7aef5836da9347a22bc7daca5e46f", "message": "chore(atomix): refactor raft tests\n\n Remove all tests which are session related.\n Replace/migrate tests which used sessions/primitives and append\n directly to the log.\n\n Some tests will no longer work if the state machine and snapshot is\n moved into atomix, which means they are removed for now and need to be\n replaced later in a follow up issue.", "committedDate": "2020-05-07T05:54:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MjI4MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422942280", "bodyText": "RaftStateMachineFactory could be simplified to only take one parameter", "author": "pihme", "createdAt": "2020-05-11T10:28:25Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -584,13 +571,11 @@ default boolean isLeader() {\n     protected RaftStorage storage;\n     protected Duration electionTimeout = DEFAULT_ELECTION_TIMEOUT;\n     protected Duration heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n-    protected Duration sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n-    protected PrimitiveTypeRegistry primitiveTypes;\n     protected ThreadModel threadModel = DEFAULT_THREAD_MODEL;\n     protected int threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n     protected ThreadContextFactory threadContextFactory;\n-    protected RaftStateMachineFactory stateMachineFactory = RaftServiceManager::new;\n-    protected LoadMonitorFactory loadMonitorFactory = LoadMonitor::new;\n+    protected RaftStateMachineFactory stateMachineFactory =", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java b/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\nindex bef32e7199..a7d57bc374 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\n\n@@ -571,11 +583,12 @@ public interface RaftServer {\n     protected RaftStorage storage;\n     protected Duration electionTimeout = DEFAULT_ELECTION_TIMEOUT;\n     protected Duration heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n+    protected Duration sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n+    protected PrimitiveTypeRegistry primitiveTypes;\n     protected ThreadModel threadModel = DEFAULT_THREAD_MODEL;\n     protected int threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n     protected ThreadContextFactory threadContextFactory;\n-    protected RaftStateMachineFactory stateMachineFactory =\n-        ((raft, stateContext, factory) -> new ZeebeRaftStateMachine(raft));\n+    protected RaftStateMachineFactory stateMachineFactory = ZeebeRaftStateMachine::new;\n     protected Supplier<JournalIndex> journalIndexFactory;\n \n     protected Builder(final MemberId localMemberId) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1NzczNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422957734", "bodyText": "I think the builder should use the SnapshotStoreFactory of the RaftStorageConfig by default, and not hardcode a snapshot store. This would mean that either the factory of the config need to be passed to the builder on construction.", "author": "pihme", "createdAt": "2020-05-11T10:57:43Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/storage/RaftStorage.java", "diffHunk": "@@ -698,7 +698,8 @@ public Builder withSnapshotStore(final SnapshotStore snapshotStore) {\n     @Override\n     public RaftStorage build() {\n       if (snapshotStore == null) {\n-        snapshotStore = new DefaultSnapshotStore(directory.toPath(), prefix);\n+        snapshotStore =", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyMjkzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424222935", "bodyText": "Thanks for the hint. I will take a look at it when refactoring and merging the snapshot stuff. Probably need to refactor all these cfg and builders, seem like lot of redudancy.", "author": "Zelldon", "createdAt": "2020-05-13T07:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1NzczNA=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/storage/RaftStorage.java b/atomix/cluster/src/main/java/io/atomix/raft/storage/RaftStorage.java\nindex 6ace3a8fa0..14120a6e6c 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/storage/RaftStorage.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/storage/RaftStorage.java\n\n@@ -698,8 +698,7 @@ public final class RaftStorage {\n     @Override\n     public RaftStorage build() {\n       if (snapshotStore == null) {\n-        snapshotStore =\n-            new DbSnapshotStoreFactory().createSnapshotStore(directory.toPath(), prefix);\n+        snapshotStore = new DefaultSnapshotStore(directory.toPath(), prefix);\n       }\n \n       return new RaftStorage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2MTE3Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422961173", "bodyText": "Looks like a verbatim copy of io.zeebe.engine.util.StreamProcessingComposite Maybe it was a rename and the commit was incomplete?", "author": "pihme", "createdAt": "2020-05-11T11:04:13Z", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/StreamProcessingComposite.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyNDExMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424224112", "bodyText": "I plan to remove this stuff from then tests.", "author": "Zelldon", "createdAt": "2020-05-13T07:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2MTE3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/broker/src/test/java/io/zeebe/broker/system/partitions/StreamProcessingComposite.java b/broker/src/test/java/io/zeebe/broker/system/partitions/StreamProcessingComposite.java\ndeleted file mode 100644\nindex 6b9f9861df..0000000000\n--- a/broker/src/test/java/io/zeebe/broker/system/partitions/StreamProcessingComposite.java\n+++ /dev/null\n\n@@ -1,207 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.broker.system.partitions;\n-\n-import static io.zeebe.engine.util.Records.workflowInstance;\n-\n-import io.zeebe.db.ZeebeDbFactory;\n-import io.zeebe.engine.processor.ReadonlyProcessingContext;\n-import io.zeebe.engine.processor.StreamProcessor;\n-import io.zeebe.engine.processor.TypedRecord;\n-import io.zeebe.engine.processor.TypedRecordProcessorFactory;\n-import io.zeebe.engine.processor.TypedRecordProcessors;\n-import io.zeebe.engine.state.ZeebeState;\n-import io.zeebe.engine.util.RecordStream;\n-import io.zeebe.engine.util.RecordToWrite;\n-import io.zeebe.logstreams.log.LogStreamRecordWriter;\n-import io.zeebe.msgpack.UnpackedObject;\n-import io.zeebe.protocol.record.RecordType;\n-import io.zeebe.protocol.record.intent.Intent;\n-import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n-import java.util.function.Consumer;\n-\n-public class StreamProcessingComposite {\n-\n-  private static final String STREAM_NAME = \"stream-\";\n-\n-  private final TestStreams streams;\n-  private final int partitionId;\n-  private final ZeebeDbFactory zeebeDbFactory;\n-  private ZeebeState zeebeState;\n-\n-  public StreamProcessingComposite(\n-      final TestStreams streams, final int partitionId, final ZeebeDbFactory zeebeDbFactory) {\n-    this.streams = streams;\n-    this.partitionId = partitionId;\n-    this.zeebeDbFactory = zeebeDbFactory;\n-  }\n-\n-  public LogStreamRecordWriter getLogStreamRecordWriter(final int partitionId) {\n-    final String logName = getLogName(partitionId);\n-    return streams.getLogStreamRecordWriter(logName);\n-  }\n-\n-  public StreamProcessor startTypedStreamProcessor(final StreamProcessorTestFactory factory) {\n-    return startTypedStreamProcessor(factory, r -> {});\n-  }\n-\n-  public StreamProcessor startTypedStreamProcessor(\n-      final StreamProcessorTestFactory factory, final Consumer<TypedRecord> onProcessedListener) {\n-    return startTypedStreamProcessor(\n-        (processingContext) -> {\n-          zeebeState = processingContext.getZeebeState();\n-          processingContext.onProcessedListener(onProcessedListener);\n-          return factory.build(\n-              TypedRecordProcessors.processors(zeebeState.getKeyGenerator()), processingContext);\n-        });\n-  }\n-\n-  public StreamProcessor startTypedStreamProcessor(final TypedRecordProcessorFactory factory) {\n-    return startTypedStreamProcessor(partitionId, factory);\n-  }\n-\n-  public StreamProcessor startTypedStreamProcessor(\n-      final int partitionId, final TypedRecordProcessorFactory factory) {\n-    return streams.startStreamProcessor(\n-        getLogName(partitionId),\n-        zeebeDbFactory,\n-        (processingContext -> {\n-          zeebeState = processingContext.getZeebeState();\n-          return factory.createProcessors(processingContext);\n-        }));\n-  }\n-\n-  public void closeStreamProcessor(final int partitionId) {\n-    try {\n-      streams.closeProcessor(getLogName(partitionId));\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  public ZeebeState getZeebeState() {\n-    return zeebeState;\n-  }\n-\n-  public RecordStream events() {\n-    return new RecordStream(streams.events(getLogName(partitionId)));\n-  }\n-\n-  public long writeWorkflowInstanceEvent(final WorkflowInstanceIntent intent) {\n-    return writeWorkflowInstanceEvent(intent, 1);\n-  }\n-\n-  public long writeWorkflowInstanceEventWithSource(\n-      final WorkflowInstanceIntent intent, final int instanceKey, final long sourceEventPosition) {\n-    return streams\n-        .newRecord(getLogName(partitionId))\n-        .event(workflowInstance(instanceKey))\n-        .recordType(RecordType.EVENT)\n-        .sourceRecordPosition(sourceEventPosition)\n-        .intent(intent)\n-        .write();\n-  }\n-\n-  public long writeWorkflowInstanceEvent(\n-      final WorkflowInstanceIntent intent, final int instanceKey) {\n-    return streams\n-        .newRecord(getLogName(partitionId))\n-        .event(workflowInstance(instanceKey))\n-        .recordType(RecordType.EVENT)\n-        .intent(intent)\n-        .write();\n-  }\n-\n-  public long writeEvent(final long key, final Intent intent, final UnpackedObject value) {\n-    return streams\n-        .newRecord(getLogName(partitionId))\n-        .recordType(RecordType.EVENT)\n-        .key(key)\n-        .intent(intent)\n-        .event(value)\n-        .write();\n-  }\n-\n-  public long writeEvent(final Intent intent, final UnpackedObject value) {\n-    return streams\n-        .newRecord(getLogName(partitionId))\n-        .recordType(RecordType.EVENT)\n-        .intent(intent)\n-        .event(value)\n-        .write();\n-  }\n-\n-  public long writeBatch(final RecordToWrite... recordToWrites) {\n-    return streams.writeBatch(getLogName(partitionId), recordToWrites);\n-  }\n-\n-  public long writeCommandOnPartition(\n-      final int partition, final Intent intent, final UnpackedObject value) {\n-    return streams\n-        .newRecord(getLogName(partition))\n-        .recordType(RecordType.COMMAND)\n-        .intent(intent)\n-        .event(value)\n-        .write();\n-  }\n-\n-  public long writeCommandOnPartition(\n-      final int partition, final long key, final Intent intent, final UnpackedObject value) {\n-    return streams\n-        .newRecord(getLogName(partition))\n-        .key(key)\n-        .recordType(RecordType.COMMAND)\n-        .intent(intent)\n-        .event(value)\n-        .write();\n-  }\n-\n-  public long writeCommand(final long key, final Intent intent, final UnpackedObject value) {\n-    return streams\n-        .newRecord(getLogName(partitionId))\n-        .recordType(RecordType.COMMAND)\n-        .key(key)\n-        .intent(intent)\n-        .event(value)\n-        .write();\n-  }\n-\n-  public long writeCommand(final Intent intent, final UnpackedObject value) {\n-    return streams\n-        .newRecord(getLogName(partitionId))\n-        .recordType(RecordType.COMMAND)\n-        .intent(intent)\n-        .event(value)\n-        .write();\n-  }\n-\n-  public long writeCommand(\n-      final int requestStreamId,\n-      final long requestId,\n-      final Intent intent,\n-      final UnpackedObject value) {\n-    return streams\n-        .newRecord(getLogName(partitionId))\n-        .recordType(RecordType.COMMAND)\n-        .requestId(requestId)\n-        .requestStreamId(requestStreamId)\n-        .intent(intent)\n-        .event(value)\n-        .write();\n-  }\n-\n-  public static String getLogName(final int partitionId) {\n-    return STREAM_NAME + partitionId;\n-  }\n-\n-  @FunctionalInterface\n-  public interface StreamProcessorTestFactory {\n-    TypedRecordProcessors build(\n-        TypedRecordProcessors builder, ReadonlyProcessingContext processingContext);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NTcwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422965701", "bodyText": "Maybe unit tests here?\n\nsame file should always get the same checksum\ntwo different files get different checksums\nsame files in same order get same checksum\nsame files, but different order gets different checksums", "author": "pihme", "createdAt": "2020-05-11T11:13:22Z", "path": "util/src/main/java/io/zeebe/util/ChecksumUtil.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.zip.CRC32;\n+\n+public final class ChecksumUtil {\n+\n+  private ChecksumUtil() {}\n+\n+  /** computes a checksum for the files, in the order they're presented */\n+  public static long createCombinedChecksum(final List<Path> paths) throws IOException {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/util/src/main/java/io/zeebe/util/ChecksumUtil.java b/util/src/main/java/io/zeebe/util/ChecksumUtil.java\ndeleted file mode 100644\nindex 4f539c4e1a..0000000000\n--- a/util/src/main/java/io/zeebe/util/ChecksumUtil.java\n+++ /dev/null\n\n@@ -1,37 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.util;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.zip.CRC32;\n-\n-public final class ChecksumUtil {\n-\n-  private ChecksumUtil() {}\n-\n-  /** computes a checksum for the files, in the order they're presented */\n-  public static long createCombinedChecksum(final List<Path> paths) throws IOException {\n-    final CRC32 checksumGenerator = new CRC32();\n-    final List<Long> chunkChecksum = new ArrayList<>();\n-\n-    for (final var path : paths) {\n-      checksumGenerator.update(Files.readAllBytes(path));\n-      chunkChecksum.add(checksumGenerator.getValue());\n-      checksumGenerator.reset();\n-    }\n-\n-    chunkChecksum.forEach(\n-        c -> checksumGenerator.update(ByteBuffer.allocate(Long.BYTES).putLong(0, c)));\n-    return checksumGenerator.getValue();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3NzczOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422977738", "bodyText": "CLOSED_SESSION is never used and can probably be removed.", "author": "pihme", "createdAt": "2020-05-11T11:37:27Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftError.java", "diffHunk": "@@ -188,7 +188,7 @@ PrimitiveException createException() {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        return message != null ? new PrimitiveException.ClosedSession(message) : createException();\n+        throw new UnsupportedOperationException(\"Sessions are no longer supported.\");", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI4OTE4OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424289189", "bodyText": "Removing these enums might break backwards compatibility. I have to investigate that separately.", "author": "Zelldon", "createdAt": "2020-05-13T09:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3NzczOA=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java b/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java\nindex 99fa55d2b6..da6c895875 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java\n\n@@ -188,7 +188,7 @@ public class RaftError {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        throw new UnsupportedOperationException(\"Sessions are no longer supported.\");\n+        return message != null ? new PrimitiveException.ClosedSession(message) : createException();\n       }\n     },\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MTE4OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422981188", "bodyText": "UNKNOWN_SESSIONis still being used in LeaderRole\nI think it is worth investigating, how the removal of sessions impacts the implementation of LeaderRole. Ideally, LeaderRole wouldn't need this enum value anymore, so that it can be removed", "author": "pihme", "createdAt": "2020-05-11T11:44:30Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftError.java", "diffHunk": "@@ -162,7 +162,7 @@ PrimitiveException createException() {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        return message != null ? new PrimitiveException.UnknownSession(message) : createException();\n+        throw new UnsupportedOperationException(\"Sessions are no longer supported\");", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java b/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java\nindex 99fa55d2b6..da6c895875 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/RaftError.java\n\n@@ -162,7 +162,7 @@ public class RaftError {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        throw new UnsupportedOperationException(\"Sessions are no longer supported\");\n+        return message != null ? new PrimitiveException.UnknownSession(message) : createException();\n       }\n     },\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NTYzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422985636", "bodyText": "??? What does this even mean?", "author": "pihme", "createdAt": "2020-05-11T11:53:52Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -60,10 +54,8 @@\n  *\n  * <h2>State machines</h2>\n  *\n- * Underlying each server is a {@link PrimitiveService}. The state machine is responsible for\n- * maintaining the state with relation to {@link OperationType#COMMAND}s and {@link\n- * OperationType#QUERY}s submitted to the server by a client. State machines are provided in a\n- * factory to allow servers to transition between stateful and stateless states.\n+ * State machines are provided in a factory to allow servers to transition between stateful and", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2MzA3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423463076", "bodyText": "Idk. Just removed the related comment which references session. You should be aware that all of these comments and most of the atomix code is not initially written by us.", "author": "Zelldon", "createdAt": "2020-05-12T05:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NTYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java b/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\nindex bef32e7199..a7d57bc374 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\n\n@@ -54,8 +59,10 @@ import java.util.function.Supplier;\n  *\n  * <h2>State machines</h2>\n  *\n- * State machines are provided in a factory to allow servers to transition between stateful and\n- * stateless states.\n+ * Underlying each server is a {@link PrimitiveService}. The state machine is responsible for\n+ * maintaining the state with relation to {@link OperationType#COMMAND}s and {@link\n+ * OperationType#QUERY}s submitted to the server by a client. State machines are provided in a\n+ * factory to allow servers to transition between stateful and stateless states.\n  *\n  * <pre>{@code\n  * Address address = new Address(\"123.456.789.0\", 5000);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NzgwNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422987805", "bodyText": "Maybe at least log the exception?", "author": "pihme", "createdAt": "2020-05-11T11:58:19Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -185,37 +165,9 @@ public String name() {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n-  /** Updates the partition with the given metadata. */\n-  CompletableFuture<Void> update(\n-      final PartitionMetadata metadata, final PartitionManagementService managementService) {\n-    if (server == null\n-        && metadata\n-            .members()\n-            .contains(managementService.getMembershipService().getLocalMember().id())) {\n-      initServer(managementService);\n-      return server.join(metadata.members());\n-    } else if (server != null\n-        && !metadata\n-            .members()\n-            .contains(managementService.getMembershipService().getLocalMember().id())) {\n-      return server.leave().thenRun(() -> server = null);\n-    }\n-    return CompletableFuture.completedFuture(null);\n-  }\n-\n   /** Closes the partition. */\n   CompletableFuture<Void> close() {\n-    return closeClient()\n-        .exceptionally(v -> null)\n-        .thenCompose(v -> closeServer())\n-        .exceptionally(v -> null);\n-  }\n-\n-  private CompletableFuture<Void> closeClient() {\n-    if (client != null) {\n-      return client.stop();\n-    }\n-    return CompletableFuture.completedFuture(null);\n+    return closeServer().exceptionally(v -> null);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java b/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\nindex 535482c64c..5de300362f 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\n\n@@ -165,9 +185,37 @@ public class RaftPartition implements Partition {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n+  /** Updates the partition with the given metadata. */\n+  CompletableFuture<Void> update(\n+      final PartitionMetadata metadata, final PartitionManagementService managementService) {\n+    if (server == null\n+        && metadata\n+            .members()\n+            .contains(managementService.getMembershipService().getLocalMember().id())) {\n+      initServer(managementService);\n+      return server.join(metadata.members());\n+    } else if (server != null\n+        && !metadata\n+            .members()\n+            .contains(managementService.getMembershipService().getLocalMember().id())) {\n+      return server.leave().thenRun(() -> server = null);\n+    }\n+    return CompletableFuture.completedFuture(null);\n+  }\n+\n   /** Closes the partition. */\n   CompletableFuture<Void> close() {\n-    return closeServer().exceptionally(v -> null);\n+    return closeClient()\n+        .exceptionally(v -> null)\n+        .thenCompose(v -> closeServer())\n+        .exceptionally(v -> null);\n+  }\n+\n+  private CompletableFuture<Void> closeClient() {\n+    if (client != null) {\n+      return client.stop();\n+    }\n+    return CompletableFuture.completedFuture(null);\n   }\n \n   private CompletableFuture<Void> closeServer() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5MTIwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422991209", "bodyText": "could perhaps lead to NPE in ZeebePartition#onRoleChange Not sure whether the lifecycle guarantees that a server is set when onRoleChange() is called", "author": "pihme", "createdAt": "2020-05-11T12:05:03Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -262,25 +213,6 @@ public long term() {\n     return partitionMetadata != null ? partitionMetadata.members() : Collections.emptyList();\n   }\n \n-  @Override\n-  public MemberId primary() {\n-    return client != null ? client.leader() : null;\n-  }\n-\n-  @Override\n-  public Collection<MemberId> backups() {\n-    final MemberId leader = primary();\n-    if (leader == null) {\n-      return members();\n-    }\n-    return members().stream().filter(m -> !m.equals(leader)).collect(Collectors.toSet());\n-  }\n-\n-  @Override\n-  public RaftPartitionClient getClient() {\n-    return client;\n-  }\n-\n   public Role getRole() {\n     return server != null ? server.getRole() : null;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java b/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\nindex 535482c64c..5de300362f 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\n\n@@ -213,6 +262,25 @@ public class RaftPartition implements Partition {\n     return partitionMetadata != null ? partitionMetadata.members() : Collections.emptyList();\n   }\n \n+  @Override\n+  public MemberId primary() {\n+    return client != null ? client.leader() : null;\n+  }\n+\n+  @Override\n+  public Collection<MemberId> backups() {\n+    final MemberId leader = primary();\n+    if (leader == null) {\n+      return members();\n+    }\n+    return members().stream().filter(m -> !m.equals(leader)).collect(Collectors.toSet());\n+  }\n+\n+  @Override\n+  public RaftPartitionClient getClient() {\n+    return client;\n+  }\n+\n   public Role getRole() {\n     return server != null ? server.getRole() : null;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5MzAxMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422993011", "bodyText": "Please add the old types as line comments for the new void lines. Otherwise, this is just way too confusing.", "author": "pihme", "createdAt": "2020-05-11T12:08:51Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/impl/RaftNamespaces.java", "diffHunk": "@@ -117,57 +73,45 @@\n           .register(VoteResponse.class)\n           .register(AppendRequest.class)\n           .register(AppendResponse.class)\n-          .register(PublishRequest.class)\n-          .register(ResetRequest.class)\n           .register(RaftResponse.Status.class)\n           .register(RaftError.class)\n           .register(RaftError.Type.class)\n-          .register(ReadConsistency.class)\n-          .register(SessionMetadata.class)\n-          .register(CloseSessionEntry.class)\n-          .register(CommandEntry.class)\n           .register(ConfigurationEntry.class)\n           .register(InitializeEntry.class)\n-          .register(KeepAliveEntry.class)\n-          .register(MetadataEntry.class)\n-          .register(OpenSessionEntry.class)\n-          .register(QueryEntry.class)\n-          .register(PrimitiveOperation.class)\n-          .register(PrimitiveEvent.class)\n-          .register(DefaultEventType.class)\n-          .register(DefaultOperationId.class)\n-          .register(OperationType.class)\n-          .register(ReadConsistency.class)\n           .register(ArrayList.class)\n           .register(LinkedList.class)\n           .register(Collections.emptyList().getClass())\n           .register(HashSet.class)\n           .register(DefaultRaftMember.class)\n           .register(MemberId.class)\n-          .register(SessionId.class)\n           .register(RaftMember.Type.class)\n           .register(Instant.class)\n           .register(Configuration.class)\n           .register(ZeebeEntry.class)\n           .build(\"RaftProtocol\");\n \n-  /** Raft storage namespace. */\n+  /**\n+   * Raft storage namespace.\n+   *\n+   * <p>*Be aware* we use the Void type for replaced/removed types to keep the id's of used types,\n+   * otherwise we break compatibility.\n+   */\n   public static final Namespace RAFT_STORAGE =\n       Namespace.builder()\n           .register(Namespaces.BASIC)\n           .nextId(Namespaces.BEGIN_USER_CUSTOM_ID + 100)\n-          .register(CloseSessionEntry.class)", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/partition/impl/RaftNamespaces.java b/atomix/cluster/src/main/java/io/atomix/raft/partition/impl/RaftNamespaces.java\nindex 75cf4a94fd..a81027e0dd 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/partition/impl/RaftNamespaces.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/partition/impl/RaftNamespaces.java\n\n@@ -73,45 +117,57 @@ public final class RaftNamespaces {\n           .register(VoteResponse.class)\n           .register(AppendRequest.class)\n           .register(AppendResponse.class)\n+          .register(PublishRequest.class)\n+          .register(ResetRequest.class)\n           .register(RaftResponse.Status.class)\n           .register(RaftError.class)\n           .register(RaftError.Type.class)\n+          .register(ReadConsistency.class)\n+          .register(SessionMetadata.class)\n+          .register(CloseSessionEntry.class)\n+          .register(CommandEntry.class)\n           .register(ConfigurationEntry.class)\n           .register(InitializeEntry.class)\n+          .register(KeepAliveEntry.class)\n+          .register(MetadataEntry.class)\n+          .register(OpenSessionEntry.class)\n+          .register(QueryEntry.class)\n+          .register(PrimitiveOperation.class)\n+          .register(PrimitiveEvent.class)\n+          .register(DefaultEventType.class)\n+          .register(DefaultOperationId.class)\n+          .register(OperationType.class)\n+          .register(ReadConsistency.class)\n           .register(ArrayList.class)\n           .register(LinkedList.class)\n           .register(Collections.emptyList().getClass())\n           .register(HashSet.class)\n           .register(DefaultRaftMember.class)\n           .register(MemberId.class)\n+          .register(SessionId.class)\n           .register(RaftMember.Type.class)\n           .register(Instant.class)\n           .register(Configuration.class)\n           .register(ZeebeEntry.class)\n           .build(\"RaftProtocol\");\n \n-  /**\n-   * Raft storage namespace.\n-   *\n-   * <p>*Be aware* we use the Void type for replaced/removed types to keep the id's of used types,\n-   * otherwise we break compatibility.\n-   */\n+  /** Raft storage namespace. */\n   public static final Namespace RAFT_STORAGE =\n       Namespace.builder()\n           .register(Namespaces.BASIC)\n           .nextId(Namespaces.BEGIN_USER_CUSTOM_ID + 100)\n-          .register(Void.class)\n-          .register(Void.class)\n+          .register(CloseSessionEntry.class)\n+          .register(CommandEntry.class)\n           .register(ConfigurationEntry.class)\n           .register(InitializeEntry.class)\n-          .register(Void.class)\n-          .register(Void.class)\n-          .register(Void.class)\n-          .register(Void.class)\n-          .register(Void.class)\n-          .register(Void.class)\n-          .register(Void.class)\n-          .register(Void.class)\n+          .register(KeepAliveEntry.class)\n+          .register(MetadataEntry.class)\n+          .register(OpenSessionEntry.class)\n+          .register(QueryEntry.class)\n+          .register(PrimitiveOperation.class)\n+          .register(DefaultOperationId.class)\n+          .register(OperationType.class)\n+          .register(ReadConsistency.class)\n           .register(ArrayList.class)\n           .register(HashSet.class)\n           .register(DefaultRaftMember.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDczMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423010733", "bodyText": "Optional: personally I would expect these lines as part of the when section:\nWhen I append an entry and wait for the commit and log, then ..", "author": "pihme", "createdAt": "2020-05-11T12:42:15Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftAppendTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(2)},\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldAppendEntryOnAllNodes() throws Throwable {\n+    // given\n+\n+    // when\n+    raftRule.appendEntry();\n+\n+    // then\n+    raftRule.awaitCommit(2);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java\ndeleted file mode 100644\nindex 123bdb9fc0..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java\n+++ /dev/null\n\n@@ -1,92 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import io.atomix.storage.journal.Indexed;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-@RunWith(Parameterized.class)\n-public class RaftAppendTest {\n-\n-  @Rule @Parameter public RaftRule raftRule;\n-\n-  @Parameters(name = \"{index}: {0}\")\n-  public static Object[][] reprocessingTriggers() {\n-    return new Object[][] {\n-      new Object[] {RaftRule.withBootstrappedNodes(2)},\n-      new Object[] {RaftRule.withBootstrappedNodes(3)},\n-      new Object[] {RaftRule.withBootstrappedNodes(4)},\n-      new Object[] {RaftRule.withBootstrappedNodes(5)}\n-    };\n-  }\n-\n-  @Test\n-  public void shouldAppendEntryOnAllNodes() throws Throwable {\n-    // given\n-\n-    // when\n-    raftRule.appendEntry();\n-\n-    // then\n-    raftRule.awaitCommit(2);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).withFailMessage(memberLog.toString()).isEqualTo(2);\n-\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldAppendEntriesOnAllNodes() throws Throwable {\n-    // given\n-    final var entryCount = 128;\n-\n-    // when\n-    raftRule.awaitAppendEntries(entryCount);\n-\n-    // then\n-    raftRule.awaitCommit(entryCount + 1);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(entryCount + 1);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n-    final var firstMemberEntries = memberLog.get(\"1\");\n-    final var members = memberLog.keySet();\n-    for (final var member : members) {\n-      if (!member.equals(\"1\")) {\n-        final var otherEntries = memberLog.get(member);\n-\n-        assertThat(firstMemberEntries).containsExactly(otherEntries.toArray(new Indexed[0]));\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzk2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423013968", "bodyText": "you could use assertThat(firstMemberEntries).describedAs(\"Enty comparison 1 v \" + member.getId() to give the error message more context", "author": "pihme", "createdAt": "2020-05-11T12:47:55Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftAppendTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(2)},\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldAppendEntryOnAllNodes() throws Throwable {\n+    // given\n+\n+    // when\n+    raftRule.appendEntry();\n+\n+    // then\n+    raftRule.awaitCommit(2);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).withFailMessage(memberLog.toString()).isEqualTo(2);\n+\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  @Test\n+  public void shouldAppendEntriesOnAllNodes() throws Throwable {\n+    // given\n+    final var entryCount = 128;\n+\n+    // when\n+    raftRule.awaitAppendEntries(entryCount);\n+\n+    // then\n+    raftRule.awaitCommit(entryCount + 1);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).isEqualTo(entryCount + 1);\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n+    final var firstMemberEntries = memberLog.get(\"1\");\n+    final var members = memberLog.keySet();\n+    for (final var member : members) {\n+      if (!member.equals(\"1\")) {\n+        final var otherEntries = memberLog.get(member);\n+\n+        assertThat(firstMemberEntries).containsExactly(otherEntries.toArray(new Indexed[0]));", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java\ndeleted file mode 100644\nindex 123bdb9fc0..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java\n+++ /dev/null\n\n@@ -1,92 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import io.atomix.storage.journal.Indexed;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-@RunWith(Parameterized.class)\n-public class RaftAppendTest {\n-\n-  @Rule @Parameter public RaftRule raftRule;\n-\n-  @Parameters(name = \"{index}: {0}\")\n-  public static Object[][] reprocessingTriggers() {\n-    return new Object[][] {\n-      new Object[] {RaftRule.withBootstrappedNodes(2)},\n-      new Object[] {RaftRule.withBootstrappedNodes(3)},\n-      new Object[] {RaftRule.withBootstrappedNodes(4)},\n-      new Object[] {RaftRule.withBootstrappedNodes(5)}\n-    };\n-  }\n-\n-  @Test\n-  public void shouldAppendEntryOnAllNodes() throws Throwable {\n-    // given\n-\n-    // when\n-    raftRule.appendEntry();\n-\n-    // then\n-    raftRule.awaitCommit(2);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).withFailMessage(memberLog.toString()).isEqualTo(2);\n-\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldAppendEntriesOnAllNodes() throws Throwable {\n-    // given\n-    final var entryCount = 128;\n-\n-    // when\n-    raftRule.awaitAppendEntries(entryCount);\n-\n-    // then\n-    raftRule.awaitCommit(entryCount + 1);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(entryCount + 1);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n-    final var firstMemberEntries = memberLog.get(\"1\");\n-    final var members = memberLog.keySet();\n-    for (final var member : members) {\n-      if (!member.equals(\"1\")) {\n-        final var otherEntries = memberLog.get(member);\n-\n-        assertThat(firstMemberEntries).containsExactly(otherEntries.toArray(new Indexed[0]));\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyNTgwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423025809", "bodyText": "Will throw IAE as per line 83. Not sure what this method is for", "author": "pihme", "createdAt": "2020-05-11T13:08:31Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyODM0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423028347", "bodyText": "Not sure why there is a timeout. The exception will be ignored anyway. And if this runs sequentially, then each server could take up to 30 seconds. Maybe better collect the futures and wait for all of them. Or just call shutdown without waiting", "author": "pihme", "createdAt": "2020-05-11T13:12:40Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMDQyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423030421", "bodyText": "directory is not reset", "author": "pihme", "createdAt": "2020-05-11T13:15:52Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjAzOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423032039", "bodyText": "When can this happen? Lines 166 look they always create active members", "author": "pihme", "createdAt": "2020-05-11T13:18:30Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MjMxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424392315", "bodyText": "this was copied from the previous RaftTests. It is needed when we test with passive nodes. But we can also remove it for now", "author": "Zelldon", "createdAt": "2020-05-13T12:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjQ3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423032470", "bodyText": "Why wait longer for more nodes?", "author": "pihme", "createdAt": "2020-05-11T13:19:06Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MjcwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424392707", "bodyText": "\ud83e\udd37 this was the way it was used before", "author": "Zelldon", "createdAt": "2020-05-13T12:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMzg2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423033866", "bodyText": "This method behaves strange, if members already has entries. Then new members would be added at the end, but the first entries would be used to create the servers.", "author": "pihme", "createdAt": "2020-05-11T13:21:17Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNjMxOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423036318", "bodyText": "Maybe call next method to avoid code dpulication", "author": "pihme", "createdAt": "2020-05-11T13:24:59Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNzU2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423037566", "bodyText": "getMemberLog->getMemberLogs()", "author": "pihme", "createdAt": "2020-05-11T13:26:47Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzOTQwMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423039403", "bodyText": "Function<Builder, Builder> -> UnaryOperator<Builder>", "author": "pihme", "createdAt": "2020-05-11T13:29:33Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0NjAzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423046034", "bodyText": "Don't understand this class at all. Has nothing to do with commits. It's just an index comparator. Might make more sense if this class were a RaftCommitListener itself\nEven then the implementation won't work, if the index I am waiting for has already bean reached when the class is constructed, and there are no more commits which trigger the commit listener, and the reachedCommit()method.", "author": "pihme", "createdAt": "2020-05-11T13:39:09Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {\n+    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n+    final RaftServer.Builder defaults =\n+        RaftServer.builder(memberId)\n+            .withMembershipService(mock(ClusterMembershipService.class))\n+            .withProtocol(protocol);\n+    final RaftServer server = configurator.apply(defaults).build();\n+\n+    servers.add(server);\n+    return server;\n+  }\n+\n+  private RaftStorage createStorage(final MemberId memberId) {\n+    return createStorage(memberId, Function.identity());\n+  }\n+\n+  private RaftStorage createStorage(\n+      final MemberId memberId,\n+      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n+    final RaftStorage.Builder defaults =\n+        RaftStorage.builder()\n+            .withStorageLevel(StorageLevel.DISK)\n+            .withDirectory(new File(directory.toFile(), memberId.toString()))\n+            .withMaxEntriesPerSegment(10)\n+            .withMaxSegmentSize(1024 * 10)\n+            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n+    return configurator.apply(defaults).build();\n+  }\n+\n+  private Optional<RaftServer> getLeader() {\n+    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n+  }\n+\n+  private Optional<RaftServer> getFollower() {\n+    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n+  }\n+\n+  public void appendEntries(final int count) {\n+    final var leader = getLeader().orElseThrow();\n+\n+    for (int i = 0; i < count; i++) {\n+      appendEntryAsync(leader, 1024);\n+    }\n+  }\n+\n+  public long appendEntry() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+\n+    return appendEntry(leader, 1024);\n+  }\n+\n+  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n+    final var raftRole = leader.getContext().getRaftRole();\n+    if (raftRole instanceof LeaderRole) {\n+      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n+      return testAppendListener.awaitCommit();\n+    }\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n+    final var raftRole = leader.getContext().getRaftRole();\n+\n+    if (raftRole instanceof LeaderRole) {\n+      appendEntry(entrySize, (LeaderRole) raftRole);\n+      return;\n+    }\n+\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n+    final var appendListener = new TestAppendListener();\n+    position += 1;\n+    leaderRole.appendEntry(\n+        position,\n+        position + 10,\n+        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n+        appendListener);\n+    position += 10;\n+    return appendListener;\n+  }\n+\n+  public void awaitAppendEntries(final int i) throws Exception {\n+    // this call is async\n+    appendEntries(i - 1);\n+\n+    // this awaits the last append\n+    appendEntry();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RaftRule with \" + nodeCount + \" nodes.\";\n+  }\n+\n+  private static final class CommitAwaiter {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0Njk3Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423046977", "bodyText": "rename to reachedCommit(final long currentIndex) The way it is now it is confusing", "author": "pihme", "createdAt": "2020-05-11T13:40:35Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {\n+    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n+    final RaftServer.Builder defaults =\n+        RaftServer.builder(memberId)\n+            .withMembershipService(mock(ClusterMembershipService.class))\n+            .withProtocol(protocol);\n+    final RaftServer server = configurator.apply(defaults).build();\n+\n+    servers.add(server);\n+    return server;\n+  }\n+\n+  private RaftStorage createStorage(final MemberId memberId) {\n+    return createStorage(memberId, Function.identity());\n+  }\n+\n+  private RaftStorage createStorage(\n+      final MemberId memberId,\n+      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n+    final RaftStorage.Builder defaults =\n+        RaftStorage.builder()\n+            .withStorageLevel(StorageLevel.DISK)\n+            .withDirectory(new File(directory.toFile(), memberId.toString()))\n+            .withMaxEntriesPerSegment(10)\n+            .withMaxSegmentSize(1024 * 10)\n+            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n+    return configurator.apply(defaults).build();\n+  }\n+\n+  private Optional<RaftServer> getLeader() {\n+    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n+  }\n+\n+  private Optional<RaftServer> getFollower() {\n+    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n+  }\n+\n+  public void appendEntries(final int count) {\n+    final var leader = getLeader().orElseThrow();\n+\n+    for (int i = 0; i < count; i++) {\n+      appendEntryAsync(leader, 1024);\n+    }\n+  }\n+\n+  public long appendEntry() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+\n+    return appendEntry(leader, 1024);\n+  }\n+\n+  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n+    final var raftRole = leader.getContext().getRaftRole();\n+    if (raftRole instanceof LeaderRole) {\n+      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n+      return testAppendListener.awaitCommit();\n+    }\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n+    final var raftRole = leader.getContext().getRaftRole();\n+\n+    if (raftRole instanceof LeaderRole) {\n+      appendEntry(entrySize, (LeaderRole) raftRole);\n+      return;\n+    }\n+\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n+    final var appendListener = new TestAppendListener();\n+    position += 1;\n+    leaderRole.appendEntry(\n+        position,\n+        position + 10,\n+        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n+        appendListener);\n+    position += 10;\n+    return appendListener;\n+  }\n+\n+  public void awaitAppendEntries(final int i) throws Exception {\n+    // this call is async\n+    appendEntries(i - 1);\n+\n+    // this awaits the last append\n+    appendEntry();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RaftRule with \" + nodeCount + \" nodes.\";\n+  }\n+\n+  private static final class CommitAwaiter {\n+\n+    private final long awaitedIndex;\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    public CommitAwaiter(final long index) {\n+      this.awaitedIndex = index;\n+    }\n+\n+    public boolean reachedCommit(final long index) {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgxODE3OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422818178", "bodyText": "We probably don't need this anymore. It was used by the clients, right?", "author": "deepthidevaki", "createdAt": "2020-05-11T06:49:56Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/MultiRaftProtocol.java", "diffHunk": "@@ -18,19 +18,8 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n-import io.atomix.primitive.PrimitiveType;\n-import io.atomix.primitive.partition.PartitionGroup;\n-import io.atomix.primitive.partition.PartitionService;\n import io.atomix.primitive.protocol.PrimitiveProtocol;\n import io.atomix.primitive.protocol.ProxyProtocol;\n-import io.atomix.primitive.proxy.ProxyClient;\n-import io.atomix.primitive.proxy.impl.DefaultProxyClient;\n-import io.atomix.primitive.service.ServiceConfig;\n-import io.atomix.primitive.session.SessionClient;\n-import io.atomix.raft.partition.RaftPartition;\n-import io.atomix.utils.config.ConfigurationException;\n-import java.util.Collection;\n-import java.util.stream.Collectors;\n \n /** Multi-Raft protocol. */\n public class MultiRaftProtocol implements ProxyProtocol {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/MultiRaftProtocol.java b/atomix/cluster/src/main/java/io/atomix/raft/MultiRaftProtocol.java\nindex d5417942bb..7d1d62d897 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/MultiRaftProtocol.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/MultiRaftProtocol.java\n\n@@ -18,8 +18,19 @@ package io.atomix.raft;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import io.atomix.primitive.PrimitiveType;\n+import io.atomix.primitive.partition.PartitionGroup;\n+import io.atomix.primitive.partition.PartitionService;\n import io.atomix.primitive.protocol.PrimitiveProtocol;\n import io.atomix.primitive.protocol.ProxyProtocol;\n+import io.atomix.primitive.proxy.ProxyClient;\n+import io.atomix.primitive.proxy.impl.DefaultProxyClient;\n+import io.atomix.primitive.service.ServiceConfig;\n+import io.atomix.primitive.session.SessionClient;\n+import io.atomix.raft.partition.RaftPartition;\n+import io.atomix.utils.config.ConfigurationException;\n+import java.util.Collection;\n+import java.util.stream.Collectors;\n \n /** Multi-Raft protocol. */\n public class MultiRaftProtocol implements ProxyProtocol {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NjkzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423496936", "bodyText": "Can be removed.", "author": "deepthidevaki", "createdAt": "2020-05-12T06:43:57Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -94,20 +83,16 @@\n   private static final int HIGH_LOAD_THRESHOLD = 500;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java b/atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java\nindex cf087bacc3..1ab54658bc 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java\n\n@@ -83,16 +94,20 @@ public class RaftContext implements AutoCloseable {\n   private static final int HIGH_LOAD_THRESHOLD = 500;\n   protected final String name;\n   protected final ThreadContext threadContext;\n+  protected final PrimitiveTypeRegistry primitiveTypes;\n   protected final ClusterMembershipService membershipService;\n   protected final RaftClusterContext cluster;\n   protected final RaftServerProtocol protocol;\n   protected final RaftStorage storage;\n+  protected final RaftServiceRegistry services = new RaftServiceRegistry();\n+  protected final RaftSessionRegistry sessions = new RaftSessionRegistry();\n   private final Logger log;\n   private final Set<RaftRoleChangeListener> roleChangeListeners = new CopyOnWriteArraySet<>();\n   private final Set<Consumer<State>> stateChangeListeners = new CopyOnWriteArraySet<>();\n   private final Set<Consumer<RaftMember>> electionListeners = new CopyOnWriteArraySet<>();\n   private final Set<RaftCommitListener> commitListeners = new CopyOnWriteArraySet<>();\n   private final Set<Runnable> failureListeners = new CopyOnWriteArraySet<>();\n+  private final LoadMonitor loadMonitor;\n   private final RaftRoleMetrics raftRoleMetrics;\n   private final MetaStore meta;\n   private final RaftLog raftLog;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDE1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423500156", "bodyText": "This is required if we want dynamic reconfiguration \ud83d\ude00", "author": "deepthidevaki", "createdAt": "2020-05-12T06:51:02Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -185,37 +165,9 @@ public String name() {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n-  /** Updates the partition with the given metadata. */\n-  CompletableFuture<Void> update(", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwNzMxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424407316", "bodyText": "Which we can re-add if we really need it", "author": "Zelldon", "createdAt": "2020-05-13T12:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDE1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java b/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\nindex 535482c64c..5de300362f 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java\n\n@@ -165,9 +185,37 @@ public class RaftPartition implements Partition {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n+  /** Updates the partition with the given metadata. */\n+  CompletableFuture<Void> update(\n+      final PartitionMetadata metadata, final PartitionManagementService managementService) {\n+    if (server == null\n+        && metadata\n+            .members()\n+            .contains(managementService.getMembershipService().getLocalMember().id())) {\n+      initServer(managementService);\n+      return server.join(metadata.members());\n+    } else if (server != null\n+        && !metadata\n+            .members()\n+            .contains(managementService.getMembershipService().getLocalMember().id())) {\n+      return server.leave().thenRun(() -> server = null);\n+    }\n+    return CompletableFuture.completedFuture(null);\n+  }\n+\n   /** Closes the partition. */\n   CompletableFuture<Void> close() {\n-    return closeServer().exceptionally(v -> null);\n+    return closeClient()\n+        .exceptionally(v -> null)\n+        .thenCompose(v -> closeServer())\n+        .exceptionally(v -> null);\n+  }\n+\n+  private CompletableFuture<Void> closeClient() {\n+    if (client != null) {\n+      return client.stop();\n+    }\n+    return CompletableFuture.completedFuture(null);\n   }\n \n   private CompletableFuture<Void> closeServer() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNTIwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423515200", "bodyText": "Is it safe to compact without a snapshot? Depending on what we want to test, this might not work.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:21:09Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxODkwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424418901", "bodyText": "I think you're right. I have a follow up issue to investigate this.", "author": "Zelldon", "createdAt": "2020-05-13T13:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNTIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\ndeleted file mode 100644\nindex 82df5a3046..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.mock;\n-\n-import io.atomix.cluster.ClusterMembershipService;\n-import io.atomix.cluster.MemberId;\n-import io.atomix.raft.RaftServer.Builder;\n-import io.atomix.raft.RaftServer.Role;\n-import io.atomix.raft.cluster.RaftMember;\n-import io.atomix.raft.partition.impl.RaftNamespaces;\n-import io.atomix.raft.primitive.TestMember;\n-import io.atomix.raft.protocol.TestRaftProtocolFactory;\n-import io.atomix.raft.protocol.TestRaftServerProtocol;\n-import io.atomix.raft.roles.LeaderRole;\n-import io.atomix.raft.storage.RaftStorage;\n-import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.zeebe.ZeebeEntry;\n-import io.atomix.raft.zeebe.ZeebeLogAppender;\n-import io.atomix.storage.StorageLevel;\n-import io.atomix.storage.journal.Indexed;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.atomix.utils.concurrent.SingleThreadContext;\n-import io.atomix.utils.concurrent.ThreadContext;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BooleanSupplier;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import org.apache.commons.lang3.RandomStringUtils;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class RaftRule extends ExternalResource {\n-\n-  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-  private volatile int nextId;\n-  private volatile List<RaftMember> members;\n-  private Map<String, Long> memberLog;\n-  private final List<RaftServer> servers = new ArrayList<>();\n-  private volatile TestRaftProtocolFactory protocolFactory;\n-  private volatile ThreadContext context;\n-  private Path directory;\n-  private final int nodeCount;\n-  private volatile long highestCommit;\n-  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n-  private long position;\n-\n-  private RaftRule(final int nodeCount) {\n-    this.nodeCount = nodeCount;\n-  }\n-\n-  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n-    if (nodeCount < 1) {\n-      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n-    }\n-    return new RaftRule(nodeCount);\n-  }\n-\n-  public static RaftRule withoutNodes() {\n-    return new RaftRule(-1);\n-  }\n-\n-  @Override\n-  public Statement apply(final Statement base, final Description description) {\n-    final var statement = super.apply(base, description);\n-    return temporaryFolder.apply(statement, description);\n-  }\n-\n-  @Override\n-  protected void before() throws Throwable {\n-    directory = temporaryFolder.newFolder().toPath();\n-\n-    position = 0;\n-    members = new ArrayList<>();\n-    memberLog = new ConcurrentHashMap<>();\n-    nextId = 0;\n-    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n-    protocolFactory = new TestRaftProtocolFactory(context);\n-\n-    if (nodeCount > 0) {\n-      createServers(nodeCount);\n-    }\n-  }\n-\n-  @Override\n-  protected void after() {\n-    servers.forEach(\n-        s -> {\n-          try {\n-            if (s.isRunning()) {\n-              s.shutdown().get(30, TimeUnit.SECONDS);\n-            }\n-          } catch (final Exception e) {\n-            // its fine..\n-          }\n-        });\n-    servers.clear();\n-    context.close();\n-    context = null;\n-    members.clear();\n-    nextId = 0;\n-    protocolFactory = null;\n-    highestCommit = 0;\n-    commitAwaiterRef.set(null);\n-    memberLog.clear();\n-    memberLog = null;\n-    position = 0;\n-  }\n-\n-  /**\n-   * Returns the next server address.\n-   *\n-   * @param type The startup member type.\n-   * @return The next server address.\n-   */\n-  private RaftMember nextMember(final RaftMember.Type type) {\n-    return new TestMember(nextNodeId(), type);\n-  }\n-\n-  /**\n-   * Returns the next unique member identifier.\n-   *\n-   * @return The next unique member identifier.\n-   */\n-  private MemberId nextNodeId() {\n-    return MemberId.from(String.valueOf(++nextId));\n-  }\n-\n-  /** Creates a set of Raft servers. */\n-  private List<RaftServer> createServers(final int nodes) throws Exception {\n-    final List<RaftServer> servers = new ArrayList<>();\n-\n-    for (int i = 0; i < nodes; i++) {\n-      members.add(nextMember(RaftMember.Type.ACTIVE));\n-    }\n-\n-    final CountDownLatch latch = new CountDownLatch(nodes);\n-\n-    for (int i = 0; i < nodes; i++) {\n-      final RaftServer server = createServer(members.get(i).memberId());\n-      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n-        server\n-            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      } else {\n-        server\n-            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n-            .thenAccept(this::addCommitListener)\n-            .thenRun(latch::countDown);\n-      }\n-      servers.add(server);\n-    }\n-\n-    latch.await(30 * nodes, TimeUnit.SECONDS);\n-\n-    return servers;\n-  }\n-\n-  public void shutdownFollower() throws Exception {\n-    final var follower = getFollower().orElseThrow();\n-    shutdownServer(follower);\n-  }\n-\n-  public RaftServer shutdownLeader() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-    shutdownServer(leader);\n-    return leader;\n-  }\n-\n-  public void restartLeader() throws Exception {\n-    awaitNewLeader();\n-    final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n-  }\n-\n-  private List<MemberId> getMemberIds() {\n-    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n-  }\n-\n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public void shutdownServer(final RaftServer raftServer) throws Exception {\n-    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n-    memberLog.remove(raftServer.name());\n-  }\n-\n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n-  private RaftMember getRaftMember(final String memberId) {\n-    return members.stream()\n-        .filter(member -> member.memberId().id().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n-\n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n-\n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n-    }\n-\n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n-  }\n-\n-  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n-    final var raftServer = getRaftServer(memberId);\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n-  }\n-\n-  public void awaitNewLeader() {\n-    waitUntil(() -> getLeader().isPresent(), 100);\n-  }\n-\n-  private void addCommitListener(final RaftServer raftServer) {\n-    raftServer\n-        .getContext()\n-        .addCommitListener(\n-            new RaftCommitListener() {\n-              @Override\n-              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n-                final var index = entry.index();\n-\n-                memberLog.put(raftServer.name(), index);\n-                if (highestCommit < index) {\n-                  highestCommit = index;\n-                }\n-\n-                final var commitAwaiter = commitAwaiterRef.get();\n-                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n-                  commitAwaiterRef.set(null);\n-                }\n-              }\n-            });\n-  }\n-\n-  public Map<String, List<Indexed<?>>> getMemberLog() {\n-\n-    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n-\n-    for (final var server : servers) {\n-      if (server.isRunning()) {\n-\n-        final var log = server.getContext().getLog();\n-        final List<Indexed<?>> entryList = new ArrayList<>();\n-        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n-\n-          while (raftLogReader.hasNext()) {\n-            final var indexedEntry = raftLogReader.next();\n-            entryList.add(indexedEntry);\n-          }\n-        }\n-\n-        memberLogs.put(server.name(), entryList);\n-      }\n-    }\n-\n-    return memberLogs;\n-  }\n-\n-  public void awaitSameLogSizeOnAllNodes() {\n-    waitUntil(\n-        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n-    waitUntil(condition, 100, errorMessage);\n-  }\n-\n-  private void waitUntil(final BooleanSupplier condition, final int retries) {\n-    waitUntil(condition, retries, () -> null);\n-  }\n-\n-  private void waitUntil(\n-      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n-    try {\n-      while (!condition.getAsBoolean() && retries > 0) {\n-        Thread.sleep(100);\n-        retries--;\n-      }\n-    } catch (final Exception e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    assertTrue(errorMessage.get(), condition.getAsBoolean());\n-  }\n-\n-  public void awaitCommit(final long commitIndex) throws Exception {\n-    if (highestCommit >= commitIndex) {\n-      return;\n-    }\n-\n-    final var commitAwaiter = new CommitAwaiter(commitIndex);\n-    commitAwaiterRef.set(commitAwaiter);\n-\n-    commitAwaiter.awaitCommit();\n-  }\n-\n-  /** Creates a Raft server. */\n-  private RaftServer createServer(final MemberId memberId) {\n-    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n-  }\n-\n-  private RaftServer createServer(\n-      final MemberId memberId, final Function<Builder, Builder> configurator) {\n-    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n-    final RaftServer.Builder defaults =\n-        RaftServer.builder(memberId)\n-            .withMembershipService(mock(ClusterMembershipService.class))\n-            .withProtocol(protocol);\n-    final RaftServer server = configurator.apply(defaults).build();\n-\n-    servers.add(server);\n-    return server;\n-  }\n-\n-  private RaftStorage createStorage(final MemberId memberId) {\n-    return createStorage(memberId, Function.identity());\n-  }\n-\n-  private RaftStorage createStorage(\n-      final MemberId memberId,\n-      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n-    final RaftStorage.Builder defaults =\n-        RaftStorage.builder()\n-            .withStorageLevel(StorageLevel.DISK)\n-            .withDirectory(new File(directory.toFile(), memberId.toString()))\n-            .withMaxEntriesPerSegment(10)\n-            .withMaxSegmentSize(1024 * 10)\n-            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n-    return configurator.apply(defaults).build();\n-  }\n-\n-  private Optional<RaftServer> getLeader() {\n-    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n-  }\n-\n-  private Optional<RaftServer> getFollower() {\n-    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n-  }\n-\n-  public void appendEntries(final int count) {\n-    final var leader = getLeader().orElseThrow();\n-\n-    for (int i = 0; i < count; i++) {\n-      appendEntryAsync(leader, 1024);\n-    }\n-  }\n-\n-  public long appendEntry() throws Exception {\n-    final var leader = getLeader().orElseThrow();\n-\n-    return appendEntry(leader, 1024);\n-  }\n-\n-  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n-    final var raftRole = leader.getContext().getRaftRole();\n-    if (raftRole instanceof LeaderRole) {\n-      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n-      return testAppendListener.awaitCommit();\n-    }\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n-    final var raftRole = leader.getContext().getRaftRole();\n-\n-    if (raftRole instanceof LeaderRole) {\n-      appendEntry(entrySize, (LeaderRole) raftRole);\n-      return;\n-    }\n-\n-    throw new IllegalArgumentException(\n-        \"Expected to append entry on leader, \"\n-            + leader.getContext().getName()\n-            + \" was not the leader!\");\n-  }\n-\n-  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n-    final var appendListener = new TestAppendListener();\n-    position += 1;\n-    leaderRole.appendEntry(\n-        position,\n-        position + 10,\n-        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n-        appendListener);\n-    position += 10;\n-    return appendListener;\n-  }\n-\n-  public void awaitAppendEntries(final int i) throws Exception {\n-    // this call is async\n-    appendEntries(i - 1);\n-\n-    // this awaits the last append\n-    appendEntry();\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"RaftRule with \" + nodeCount + \" nodes.\";\n-  }\n-\n-  private static final class CommitAwaiter {\n-\n-    private final long awaitedIndex;\n-    private final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public CommitAwaiter(final long index) {\n-      this.awaitedIndex = index;\n-    }\n-\n-    public boolean reachedCommit(final long index) {\n-      if (this.awaitedIndex <= index) {\n-        latch.countDown();\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    public void awaitCommit() throws Exception {\n-      latch.await(30, TimeUnit.SECONDS);\n-    }\n-  }\n-\n-  private static final class TestAppendListener implements ZeebeLogAppender.AppendListener {\n-\n-    private final CompletableFuture<Long> commitFuture = new CompletableFuture<>();\n-\n-    @Override\n-    public void onWrite(final Indexed<ZeebeEntry> indexed) {}\n-\n-    @Override\n-    public void onWriteError(final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    @Override\n-    public void onCommit(final Indexed<ZeebeEntry> indexed) {\n-      commitFuture.complete(indexed.index());\n-    }\n-\n-    @Override\n-    public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n-      fail(\"Unexpected write error: \" + error.getMessage());\n-    }\n-\n-    public long awaitCommit() throws Exception {\n-      return commitFuture.get(30, TimeUnit.SECONDS);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjAxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423516012", "bodyText": "Name doesn't match \ud83d\ude42", "author": "deepthidevaki", "createdAt": "2020-05-12T07:22:38Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwODY2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424408665", "bodyText": "great catch \ud83d\udc4d", "author": "Zelldon", "createdAt": "2020-05-13T12:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjAxMg=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\ndeleted file mode 100644\nindex b51cca1d8e..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\n+++ /dev/null\n\n@@ -1,148 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import io.atomix.storage.journal.Indexed;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.Ignore;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-@RunWith(Parameterized.class)\n-public class RaftFailOverTest {\n-\n-  @Rule @Parameter public RaftRule raftRule;\n-\n-  @Parameters(name = \"{index}: {0}\")\n-  public static Object[][] reprocessingTriggers() {\n-    return new Object[][] {\n-      new Object[] {RaftRule.withBootstrappedNodes(3)},\n-      new Object[] {RaftRule.withBootstrappedNodes(4)},\n-      new Object[] {RaftRule.withBootstrappedNodes(5)}\n-    };\n-  }\n-\n-  @Test\n-  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.shutdownFollower();\n-\n-    // when\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 1 initial entry\n-    final var expectedEntryCount = entryCount * 2 + 1;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldCommitEntriesAfterLeaderShutdown() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.shutdownLeader();\n-\n-    // when\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 2 initial entries\n-    final var expectedEntryCount = entryCount * 2 + 2;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldRecoverLeaderRestart() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.restartLeader();\n-\n-    // when\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 2 initial entries\n-    final var expectedEntryCount = entryCount * 2 + 2;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n-    // given\n-    raftRule.shutdownServer(\"1\");\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(100);\n-    raftRule.tryToCompactLogsOnServersExcept(\"1\", 100).join();\n-\n-    // when\n-    final var future = raftRule.startServer(\"1\");\n-\n-    // then\n-    future.join();\n-  }\n-\n-  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n-    final var members = memberLog.keySet();\n-    final var iterator = members.iterator();\n-\n-    if (iterator.hasNext()) {\n-      final var first = iterator.next();\n-      final var firstMemberEntries = memberLog.get(first);\n-\n-      while (iterator.hasNext()) {\n-        final var otherEntries = memberLog.get(iterator.next());\n-        assertThat(firstMemberEntries)\n-            .withFailMessage(memberLog.toString())\n-            .containsExactly(otherEntries.toArray(new Indexed[0]));\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNzA2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423517066", "bodyText": "We can get the index from appendEntry and use that to await commit, instead of estimating the commit index.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:24:45Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownFollower();\n+\n+    // when\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 1 initial entry", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\ndeleted file mode 100644\nindex b51cca1d8e..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\n+++ /dev/null\n\n@@ -1,148 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import io.atomix.storage.journal.Indexed;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.Ignore;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-@RunWith(Parameterized.class)\n-public class RaftFailOverTest {\n-\n-  @Rule @Parameter public RaftRule raftRule;\n-\n-  @Parameters(name = \"{index}: {0}\")\n-  public static Object[][] reprocessingTriggers() {\n-    return new Object[][] {\n-      new Object[] {RaftRule.withBootstrappedNodes(3)},\n-      new Object[] {RaftRule.withBootstrappedNodes(4)},\n-      new Object[] {RaftRule.withBootstrappedNodes(5)}\n-    };\n-  }\n-\n-  @Test\n-  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.shutdownFollower();\n-\n-    // when\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 1 initial entry\n-    final var expectedEntryCount = entryCount * 2 + 1;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldCommitEntriesAfterLeaderShutdown() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.shutdownLeader();\n-\n-    // when\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 2 initial entries\n-    final var expectedEntryCount = entryCount * 2 + 2;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldRecoverLeaderRestart() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.restartLeader();\n-\n-    // when\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 2 initial entries\n-    final var expectedEntryCount = entryCount * 2 + 2;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n-    // given\n-    raftRule.shutdownServer(\"1\");\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(100);\n-    raftRule.tryToCompactLogsOnServersExcept(\"1\", 100).join();\n-\n-    // when\n-    final var future = raftRule.startServer(\"1\");\n-\n-    // then\n-    future.join();\n-  }\n-\n-  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n-    final var members = memberLog.keySet();\n-    final var iterator = members.iterator();\n-\n-    if (iterator.hasNext()) {\n-      final var first = iterator.next();\n-      final var firstMemberEntries = memberLog.get(first);\n-\n-      while (iterator.hasNext()) {\n-        final var otherEntries = memberLog.get(iterator.next());\n-        assertThat(firstMemberEntries)\n-            .withFailMessage(memberLog.toString())\n-            .containsExactly(otherEntries.toArray(new Indexed[0]));\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNzc1NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423517755", "bodyText": "Same as above. We cannot guarantee there are only 2 initial entries.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:25:57Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownFollower();\n+\n+    // when\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 1 initial entry\n+    final var expectedEntryCount = entryCount * 2 + 1;\n+    raftRule.awaitCommit(expectedEntryCount);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).isEqualTo(expectedEntryCount);\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterLeaderShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownLeader();\n+\n+    // when\n+    raftRule.awaitNewLeader();\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 2 initial entries\n+    final var expectedEntryCount = entryCount * 2 + 2;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\ndeleted file mode 100644\nindex b51cca1d8e..0000000000\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java\n+++ /dev/null\n\n@@ -1,148 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.atomix.raft;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import io.atomix.storage.journal.Indexed;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.Ignore;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-@RunWith(Parameterized.class)\n-public class RaftFailOverTest {\n-\n-  @Rule @Parameter public RaftRule raftRule;\n-\n-  @Parameters(name = \"{index}: {0}\")\n-  public static Object[][] reprocessingTriggers() {\n-    return new Object[][] {\n-      new Object[] {RaftRule.withBootstrappedNodes(3)},\n-      new Object[] {RaftRule.withBootstrappedNodes(4)},\n-      new Object[] {RaftRule.withBootstrappedNodes(5)}\n-    };\n-  }\n-\n-  @Test\n-  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.shutdownFollower();\n-\n-    // when\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 1 initial entry\n-    final var expectedEntryCount = entryCount * 2 + 1;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldCommitEntriesAfterLeaderShutdown() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.shutdownLeader();\n-\n-    // when\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 2 initial entries\n-    final var expectedEntryCount = entryCount * 2 + 2;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  public void shouldRecoverLeaderRestart() throws Throwable {\n-    // given\n-    final var entryCount = 20;\n-    raftRule.appendEntries(entryCount);\n-    raftRule.awaitCommit(entryCount);\n-    raftRule.restartLeader();\n-\n-    // when\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(entryCount);\n-\n-    // then\n-    // 40 zeebe entries and 2 initial entries\n-    final var expectedEntryCount = entryCount * 2 + 2;\n-    raftRule.awaitCommit(expectedEntryCount);\n-    raftRule.awaitSameLogSizeOnAllNodes();\n-    final var memberLog = raftRule.getMemberLog();\n-\n-    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n-    assertThat(logLength).isEqualTo(expectedEntryCount);\n-    assertMemberLogs(memberLog);\n-  }\n-\n-  @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n-    // given\n-    raftRule.shutdownServer(\"1\");\n-    raftRule.awaitNewLeader();\n-    raftRule.appendEntries(100);\n-    raftRule.tryToCompactLogsOnServersExcept(\"1\", 100).join();\n-\n-    // when\n-    final var future = raftRule.startServer(\"1\");\n-\n-    // then\n-    future.join();\n-  }\n-\n-  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n-    final var members = memberLog.keySet();\n-    final var iterator = members.iterator();\n-\n-    if (iterator.hasNext()) {\n-      final var first = iterator.next();\n-      final var firstMemberEntries = memberLog.get(first);\n-\n-      while (iterator.hasNext()) {\n-        final var otherEntries = memberLog.get(iterator.next());\n-        assertThat(firstMemberEntries)\n-            .withFailMessage(memberLog.toString())\n-            .containsExactly(otherEntries.toArray(new Indexed[0]));\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDMyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423524328", "bodyText": "Is it difficult to use RaftRule for this also?", "author": "deepthidevaki", "createdAt": "2020-05-12T07:37:53Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java", "diffHunk": "@@ -108,21 +75,18 @@\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n import org.mockito.Mockito;\n-import org.slf4j.LoggerFactory;\n \n /** Raft test. */\n public class RaftTest extends ConcurrentTestCase {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0ODAxMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423648010", "bodyText": "Probably not. I used most of the setup code from there, but I wanted to minimize the changes \ud83d\ude05 But yes I can migrated them as well. I had hoped that we can replace most of them step by step.", "author": "Zelldon", "createdAt": "2020-05-12T11:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNDc2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424424769", "bodyText": "I put it on my agenda of my next issues where I also work on the tests.", "author": "Zelldon", "createdAt": "2020-05-13T13:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java\nindex 87215c7455..595594f6ad 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java\n\n@@ -75,6 +107,7 @@ import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n import org.mockito.Mockito;\n+import org.slf4j.LoggerFactory;\n \n /** Raft test. */\n public class RaftTest extends ConcurrentTestCase {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTY1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423525659", "bodyText": "Did you move this test to some where else? This is important to test.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:40:19Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java", "diffHunk": "@@ -1178,444 +485,24 @@ public void testThreeNodesSequentiallyStart() throws Throwable {\n     await(2000 * 3, 3);\n   }\n \n-  /** Tests submitting linearizable events. */\n-  @Test\n-  public void testFiveNodesManyEventsAfterLeaderShutdown() throws Throwable {\n-    testManyEventsAfterLeaderShutdown(5);\n-  }\n-\n-  /** Tests submitting sequential events. */\n-  @Test\n-  public void testThreeNodesEventsAfterFollowerKill() throws Throwable {\n-    testEventsAfterFollowerKill(3);\n-  }\n-\n-  /** Tests submitting a sequential event that publishes to all sessions. */\n-  private void testEventsAfterFollowerKill(final int nodes) throws Throwable {\n-    final List<RaftServer> servers = createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-\n-    primitive.sendEvent(true).thenRun(this::resume);\n-\n-    final RaftServer follower =\n-        servers.stream().filter(s -> s.getRole() == RaftServer.Role.FOLLOWER).findFirst().get();\n-    follower.shutdown().get(10, TimeUnit.SECONDS);\n-\n-    await(30000, 2);\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-  }\n-\n-  /** Tests submitting sequential events. */\n-  @Test\n-  public void testFiveNodesEventsAfterFollowerKill() throws Throwable {\n-    testEventsAfterFollowerKill(5);\n-  }\n-\n-  /** Tests submitting events. */\n-  @Test\n-  public void testFiveNodesEventsAfterLeaderKill() throws Throwable {\n-    testEventsAfterLeaderKill(5);\n-  }\n-\n-  /** Tests submitting a linearizable event that publishes to all sessions. */\n-  private void testEventsAfterLeaderKill(final int nodes) throws Throwable {\n-    final List<RaftServer> servers = createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-\n-    primitive.sendEvent(true).thenRun(this::resume);\n-\n-    final RaftServer leader = getLeader(servers).get();\n-    leader.shutdown().get(10, TimeUnit.SECONDS);\n-\n-    await(30000);\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-  }\n-\n-  /** Tests submitting linearizable events. */\n-  @Test\n-  public void testFiveNodeManySessionsManyEvents() throws Throwable {\n-    testManySessionsManyEvents(5);\n-  }\n-\n-  /** Tests submitting a linearizable event that publishes to all sessions. */\n-  private void testManySessionsManyEvents(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    createPrimitive(createClient())\n-        .onEvent(\n-            event -> {\n-              threadAssertNotNull(event);\n-              resume();\n-            });\n-\n-    createPrimitive(createClient())\n-        .onEvent(\n-            event -> {\n-              threadAssertNotNull(event);\n-              resume();\n-            });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(false).thenRun(this::resume);\n-      await(10000, 4);\n-    }\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testOneNodeExpireEvent() throws Throwable {\n-    testSessionExpire(1);\n-  }\n-\n-  /** Tests a session expiring. */\n-  private void testSessionExpire(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client1 = createClient();\n-    final TestPrimitive primitive1 = createPrimitive(client1);\n-    final RaftClient client2 = createClient();\n-    createSession(client2);\n-    primitive1.onExpire(event -> resume()).thenRun(this::resume);\n-    client2.close().thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 3);\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testThreeNodeExpireEvent() throws Throwable {\n-    testSessionExpire(3);\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testFiveNodeExpireEvent() throws Throwable {\n-    testSessionExpire(5);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testOneNodeCloseEvent() throws Throwable {\n-    testSessionClose(1);\n-  }\n-\n-  /** Tests a session closing. */\n-  private void testSessionClose(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client1 = createClient();\n-    final TestPrimitive primitive1 = createPrimitive(client1);\n-    final RaftClient client2 = createClient();\n-    primitive1.onClose(event -> resume()).thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 1);\n-    createSession(client2).close().thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 2);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testThreeNodeCloseEvent() throws Throwable {\n-    testSessionClose(3);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testFiveNodeCloseEvent() throws Throwable {\n-    testSessionClose(5);\n-  }\n-\n   @Test\n   public void testThreeNodeManyEventsDoNotMissHeartbeats() throws Throwable {\n     // given\n     createServers(3);\n+    final var leader = getLeader(servers).orElseThrow();\n \n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        message -> {\n-          threadAssertNotNull(message);\n-          resume();\n-        });\n+    appendEntry(leader);\n \n     final double startMissedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n \n     // when\n-    for (int i = 0; i < 1_000; i++) {\n-      primitive.sendEvent(true);\n-    }\n-    await(10000, 1_000);\n+    appendEntries(leader, 1000);\n \n     // then\n     final double missedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n     assertThat(0.0, is(missedHeartBeats - startMissedHeartBeats));\n   }\n \n-  @Test\n-  public void testSnapshotSentOnDataLoss() throws Throwable {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0NzY0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423647648", "bodyText": "As I explained, this tests doesn't make sense with the ZeebeRaftStateMachine. This test can't be done in the Raft module, since we are not able to create normal snapshot here. I created a follow up issue #4468 to investigate them. Maybe it is possible to create fake snapshots otherwise we have to test it elsewhere. Furthermore I thought that we have such a test already in QA.", "author": "Zelldon", "createdAt": "2020-05-12T11:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTY1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java b/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java\nindex 87215c7455..595594f6ad 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java\n\n@@ -485,24 +1177,399 @@ public class RaftTest extends ConcurrentTestCase {\n     await(2000 * 3, 3);\n   }\n \n+  /** Tests submitting linearizable events. */\n+  @Test\n+  public void testFiveNodesManyEventsAfterLeaderShutdown() throws Throwable {\n+    testManyEventsAfterLeaderShutdown(5);\n+  }\n+\n+  /** Tests submitting sequential events. */\n+  @Test\n+  public void testThreeNodesEventsAfterFollowerKill() throws Throwable {\n+    testEventsAfterFollowerKill(3);\n+  }\n+\n+  /** Tests submitting a sequential event that publishes to all sessions. */\n+  private void testEventsAfterFollowerKill(final int nodes) throws Throwable {\n+    final List<RaftServer> servers = createServers(nodes);\n+\n+    final RaftClient client = createClient();\n+    final TestPrimitive primitive = createPrimitive(client);\n+    primitive.onEvent(\n+        event -> {\n+          threadAssertNotNull(event);\n+          resume();\n+        });\n+\n+    for (int i = 0; i < 10; i++) {\n+      primitive.sendEvent(true).thenRun(this::resume);\n+      await(30000, 2);\n+    }\n+\n+    primitive.sendEvent(true).thenRun(this::resume);\n+\n+    final RaftServer follower =\n+        servers.stream().filter(s -> s.getRole() == RaftServer.Role.FOLLOWER).findFirst().get();\n+    follower.shutdown().get(10, TimeUnit.SECONDS);\n+\n+    await(30000, 2);\n+\n+    for (int i = 0; i < 10; i++) {\n+      primitive.sendEvent(true).thenRun(this::resume);\n+      await(30000, 2);\n+    }\n+  }\n+\n+  /** Tests submitting sequential events. */\n+  @Test\n+  public void testFiveNodesEventsAfterFollowerKill() throws Throwable {\n+    testEventsAfterFollowerKill(5);\n+  }\n+\n+  /** Tests submitting events. */\n+  @Test\n+  public void testFiveNodesEventsAfterLeaderKill() throws Throwable {\n+    testEventsAfterLeaderKill(5);\n+  }\n+\n+  /** Tests submitting a linearizable event that publishes to all sessions. */\n+  private void testEventsAfterLeaderKill(final int nodes) throws Throwable {\n+    final List<RaftServer> servers = createServers(nodes);\n+\n+    final RaftClient client = createClient();\n+    final TestPrimitive primitive = createPrimitive(client);\n+    primitive.onEvent(\n+        event -> {\n+          threadAssertNotNull(event);\n+          resume();\n+        });\n+\n+    for (int i = 0; i < 10; i++) {\n+      primitive.sendEvent(true).thenRun(this::resume);\n+      await(30000, 2);\n+    }\n+\n+    primitive.sendEvent(true).thenRun(this::resume);\n+\n+    final RaftServer leader = getLeader(servers).get();\n+    leader.shutdown().get(10, TimeUnit.SECONDS);\n+\n+    await(30000);\n+\n+    for (int i = 0; i < 10; i++) {\n+      primitive.sendEvent(true).thenRun(this::resume);\n+      await(30000, 2);\n+    }\n+  }\n+\n+  /** Tests submitting linearizable events. */\n+  @Test\n+  public void testFiveNodeManySessionsManyEvents() throws Throwable {\n+    testManySessionsManyEvents(5);\n+  }\n+\n+  /** Tests submitting a linearizable event that publishes to all sessions. */\n+  private void testManySessionsManyEvents(final int nodes) throws Throwable {\n+    createServers(nodes);\n+\n+    final RaftClient client = createClient();\n+    final TestPrimitive primitive = createPrimitive(client);\n+    primitive.onEvent(\n+        event -> {\n+          threadAssertNotNull(event);\n+          resume();\n+        });\n+\n+    createPrimitive(createClient())\n+        .onEvent(\n+            event -> {\n+              threadAssertNotNull(event);\n+              resume();\n+            });\n+\n+    createPrimitive(createClient())\n+        .onEvent(\n+            event -> {\n+              threadAssertNotNull(event);\n+              resume();\n+            });\n+\n+    for (int i = 0; i < 10; i++) {\n+      primitive.sendEvent(false).thenRun(this::resume);\n+      await(10000, 4);\n+    }\n+  }\n+\n+  /** Tests session expiring events. */\n+  @Test\n+  public void testOneNodeExpireEvent() throws Throwable {\n+    testSessionExpire(1);\n+  }\n+\n+  /** Tests a session expiring. */\n+  private void testSessionExpire(final int nodes) throws Throwable {\n+    createServers(nodes);\n+\n+    final RaftClient client1 = createClient();\n+    final TestPrimitive primitive1 = createPrimitive(client1);\n+    final RaftClient client2 = createClient();\n+    createSession(client2);\n+    primitive1.onExpire(event -> resume()).thenRun(this::resume);\n+    client2.close().thenRun(this::resume);\n+    await(Duration.ofSeconds(10).toMillis(), 3);\n+  }\n+\n+  /** Tests session expiring events. */\n+  @Test\n+  public void testThreeNodeExpireEvent() throws Throwable {\n+    testSessionExpire(3);\n+  }\n+\n+  /** Tests session expiring events. */\n+  @Test\n+  public void testFiveNodeExpireEvent() throws Throwable {\n+    testSessionExpire(5);\n+  }\n+\n+  /** Tests session close events. */\n+  @Test\n+  public void testOneNodeCloseEvent() throws Throwable {\n+    testSessionClose(1);\n+  }\n+\n+  /** Tests a session closing. */\n+  private void testSessionClose(final int nodes) throws Throwable {\n+    createServers(nodes);\n+\n+    final RaftClient client1 = createClient();\n+    final TestPrimitive primitive1 = createPrimitive(client1);\n+    final RaftClient client2 = createClient();\n+    primitive1.onClose(event -> resume()).thenRun(this::resume);\n+    await(Duration.ofSeconds(10).toMillis(), 1);\n+    createSession(client2).close().thenRun(this::resume);\n+    await(Duration.ofSeconds(10).toMillis(), 2);\n+  }\n+\n+  /** Tests session close events. */\n+  @Test\n+  public void testThreeNodeCloseEvent() throws Throwable {\n+    testSessionClose(3);\n+  }\n+\n+  /** Tests session close events. */\n+  @Test\n+  public void testFiveNodeCloseEvent() throws Throwable {\n+    testSessionClose(5);\n+  }\n+\n   @Test\n   public void testThreeNodeManyEventsDoNotMissHeartbeats() throws Throwable {\n     // given\n     createServers(3);\n-    final var leader = getLeader(servers).orElseThrow();\n \n-    appendEntry(leader);\n+    final RaftClient client = createClient();\n+    final TestPrimitive primitive = createPrimitive(client);\n+    primitive.onEvent(\n+        message -> {\n+          threadAssertNotNull(message);\n+          resume();\n+        });\n \n     final double startMissedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n \n     // when\n-    appendEntries(leader, 1000);\n+    for (int i = 0; i < 1_000; i++) {\n+      primitive.sendEvent(true);\n+    }\n+    await(10000, 1_000);\n \n     // then\n     final double missedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n     assertThat(0.0, is(missedHeartBeats - startMissedHeartBeats));\n   }\n \n+  @Test\n+  public void testSnapshotSentOnDataLoss() throws Throwable {\n+    final List<RaftMember> members =\n+        Lists.newArrayList(createMember(), createMember(), createMember());\n+    final Map<MemberId, RaftStorage> storages =\n+        members.stream()\n+            .map(RaftMember::memberId)\n+            .collect(Collectors.toMap(Function.identity(), this::createStorage));\n+    final Map<MemberId, RaftServer> servers =\n+        storages.entrySet().stream()\n+            .collect(Collectors.toMap(Map.Entry::getKey, this::createServer));\n+\n+    // wait for cluster to start\n+    startCluster(servers);\n+\n+    // fill two segments then compact so we have at least one snapshot\n+    final RaftClient client = createClient(members);\n+    final TestPrimitive primitive = createPrimitive(client);\n+    fillSegment(primitive);\n+    fillSegment(primitive);\n+    Futures.allOf(servers.values().stream().map(RaftServer::compact)).thenRun(this::resume);\n+    await(30000);\n+\n+    // partition into leader/followers\n+    final Map<Boolean, List<RaftMember>> collect =\n+        members.stream()\n+            .collect(Collectors.partitioningBy(m -> servers.get(m.memberId()).isLeader()));\n+    final RaftMember leader = collect.get(true).get(0);\n+    final RaftStorage leaderStorage = storages.get(leader.memberId());\n+    final RaftMember slave = collect.get(false).get(0);\n+\n+    // shutdown client + primitive\n+    primitive.close().thenCompose(nothing -> client.close()).thenRun(this::resume);\n+    await(30000);\n+\n+    // shutdown other node\n+    final RaftMember other = collect.get(false).get(1);\n+    servers.get(other.memberId()).shutdown().thenRun(this::resume);\n+    await(30000);\n+\n+    // shutdown slave and recreate from scratch\n+    RaftServer slaveServer =\n+        recreateServerWithDataLoss(\n+            Arrays.asList(leader.memberId(), other.memberId()),\n+            slave,\n+            servers.get(slave.memberId()));\n+    assertEquals(\n+        leaderStorage.getSnapshotStore().getCurrentSnapshotIndex(),\n+        slaveServer.getContext().getStorage().getSnapshotStore().getCurrentSnapshotIndex());\n+\n+    // and again a second time to ensure the snapshot index of the member is reset\n+    slaveServer =\n+        recreateServerWithDataLoss(\n+            Arrays.asList(leader.memberId(), other.memberId()), slave, slaveServer);\n+\n+    // ensure the snapshots are the same\n+    final Snapshot leaderSnapshot = leaderStorage.getSnapshotStore().getCurrentSnapshot();\n+    final Snapshot slaveSnapshot =\n+        slaveServer.getContext().getStorage().getSnapshotStore().getCurrentSnapshot();\n+\n+    assertEquals(leaderSnapshot.index(), slaveSnapshot.index());\n+    assertEquals(leaderSnapshot.term(), slaveSnapshot.term());\n+    assertEquals(leaderSnapshot.timestamp(), slaveSnapshot.timestamp());\n+    assertEquals(leaderSnapshot.version(), slaveSnapshot.version());\n+\n+    final ByteBuffer leaderSnapshotData = readSnapshot(leaderSnapshot);\n+    final ByteBuffer slaveSnapshotData = readSnapshot(slaveSnapshot);\n+    assertEquals(leaderSnapshotData, slaveSnapshotData);\n+  }\n+\n+  @Test\n+  public void testCorrectTermInSnapshot() throws Throwable {\n+    final List<RaftMember> members =\n+        Lists.newArrayList(createMember(), createMember(), createMember());\n+    final List<MemberId> memberIds =\n+        members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+    final Map<MemberId, RaftServer> servers =\n+        memberIds.stream().collect(Collectors.toMap(Function.identity(), this::createServer));\n+\n+    // wait for cluster to start\n+    startCluster(servers);\n+    servers.get(members.get(0).memberId()).shutdown().join();\n+\n+    // fill two segments then compact so we have at least one snapshot\n+    final RaftClient client = createClient(members);\n+    final TestPrimitive primitive = createPrimitive(client);\n+    fillSegment(primitive);\n+    fillSegment(primitive);\n+    final MemberId leaderId =\n+        members.stream()\n+            .filter(m -> servers.get(m.memberId()).isLeader())\n+            .findFirst()\n+            .get()\n+            .memberId();\n+    servers.get(leaderId).compact().get(15_000, TimeUnit.MILLISECONDS);\n+\n+    final Snapshot currentSnapshot =\n+        servers.get(leaderId).getContext().getStorage().getSnapshotStore().getCurrentSnapshot();\n+    final long leaderTerm = servers.get(leaderId).getTerm();\n+\n+    assertEquals(currentSnapshot.term(), leaderTerm);\n+\n+    final RaftServer server = createServer(members.get(0).memberId());\n+    server.join(memberIds).get(15_000, TimeUnit.MILLISECONDS);\n+\n+    final SnapshotStore snapshotStore = server.getContext().getStorage().getSnapshotStore();\n+\n+    waitUntil(() -> snapshotStore.getCurrentSnapshot() != null, 100);\n+\n+    final Snapshot receivedSnapshot = snapshotStore.getCurrentSnapshot();\n+\n+    assertEquals(receivedSnapshot.index(), currentSnapshot.index());\n+    assertEquals(receivedSnapshot.term(), leaderTerm);\n+  }\n+\n+  private ByteBuffer readSnapshot(final Snapshot snapshot) {\n+    ByteBuffer buffer = ByteBuffer.allocate(2048);\n+    try (final SnapshotChunkReader reader = snapshot.newChunkReader()) {\n+      while (reader.hasNext()) {\n+        final SnapshotChunk chunk = reader.next();\n+        // resize buffer\n+        if (buffer.remaining() < chunk.data().remaining()) {\n+          final ByteBuffer buf = ByteBuffer.allocate(buffer.capacity() * 2);\n+          buffer.flip();\n+          buf.put(buffer);\n+          buffer = buf;\n+        }\n+\n+        buffer.put(chunk.data());\n+      }\n+    }\n+\n+    return buffer;\n+  }\n+\n+  private RaftServer recreateServerWithDataLoss(\n+      final List<MemberId> others, final RaftMember member, final RaftServer server)\n+      throws TimeoutException, InterruptedException {\n+    server.shutdown().thenRun(this::resume);\n+    await(30000);\n+    deleteStorage(server.getContext().getStorage());\n+\n+    final RaftServer newServer = createServer(member.memberId());\n+    newServer.bootstrap(others).thenRun(this::resume);\n+    await(30000);\n+    return newServer;\n+  }\n+\n+  private void deleteStorage(final RaftStorage storage) {\n+    storage.deleteSnapshotStore();\n+    storage.deleteLog();\n+    storage.deleteMetaStore();\n+  }\n+\n+  private void fillSegment(final TestPrimitive primitive)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    final String entry = RandomStringUtils.randomAscii(1024);\n+    IntStream.range(0, 10).forEach(i -> primitive.write(entry).whenComplete((v, t) -> resume()));\n+    await(10_000, 10);\n+  }\n+\n+  private RaftMember createMember() {\n+    final RaftMember member = nextMember(RaftMember.Type.ACTIVE);\n+    members.add(member);\n+\n+    return member;\n+  }\n+\n+  private void startCluster(final Map<MemberId, RaftServer> servers)\n+      throws TimeoutException, InterruptedException {\n+    final List<MemberId> members = new ArrayList<>(servers.keySet());\n+    for (final RaftServer s : servers.values()) {\n+      s.bootstrap(members).thenRun(this::resume);\n+    }\n+\n+    await(30000 * servers.size(), servers.size());\n+  }\n+\n+  private RaftServer createServer(final Map.Entry<MemberId, RaftStorage> entry) {\n+    return createServer(entry.getKey(), b -> b.withStorage(entry.getValue()));\n+  }\n+\n   private void waitUntil(final BooleanSupplier condition, int retries) {\n     try {\n       while (!condition.getAsBoolean() && retries > 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDY3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424954676", "bodyText": "Nit: I'd be fine collapsing this and the interface type, or at least renaming to something more descriptive than Zeebe \ud83d\ude05", "author": "npepinpe", "createdAt": "2020-05-14T08:20:32Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -22,20 +22,14 @@\n \n import io.atomix.cluster.ClusterMembershipService;\n import io.atomix.cluster.MemberId;\n-import io.atomix.primitive.PrimitiveTypeRegistry;\n-import io.atomix.primitive.operation.OperationType;\n-import io.atomix.primitive.service.PrimitiveService;\n import io.atomix.raft.cluster.RaftCluster;\n import io.atomix.raft.cluster.RaftMember;\n import io.atomix.raft.impl.DefaultRaftServer;\n import io.atomix.raft.impl.RaftContext;\n-import io.atomix.raft.impl.RaftServiceManager;\n+import io.atomix.raft.impl.zeebe.ZeebeRaftStateMachine;", "originalCommit": "e58ce0574d49cd8b689c47a15d019b6c434cc037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java b/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\nindex d23b4ad571..a7d57bc374 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java\n\n@@ -22,6 +22,9 @@ import static io.atomix.raft.RaftException.ConfigurationException;\n \n import io.atomix.cluster.ClusterMembershipService;\n import io.atomix.cluster.MemberId;\n+import io.atomix.primitive.PrimitiveTypeRegistry;\n+import io.atomix.primitive.operation.OperationType;\n+import io.atomix.primitive.service.PrimitiveService;\n import io.atomix.raft.cluster.RaftCluster;\n import io.atomix.raft.cluster.RaftMember;\n import io.atomix.raft.impl.DefaultRaftServer;\n"}}, {"oid": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "url": "https://github.com/camunda-cloud/zeebe/commit/26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "message": "chore(atomix): migrate zeebe state machine to atomix", "committedDate": "2020-05-14T12:25:15Z", "type": "commit"}, {"oid": "3d1d9dbbdc85fcc4ae0bc4384abfd02af3f04b9c", "url": "https://github.com/camunda-cloud/zeebe/commit/3d1d9dbbdc85fcc4ae0bc4384abfd02af3f04b9c", "message": "chore(atomix): move snapshotting and statemachine to atomix\n\n We add some implementations which are only used in atomix and for there tests, but have been replaced on broker side.\n This means we haven't tested our code completely with the other tests and had duplicate logic. We still have for replicate\n but this migration makes it now easier to move and merge the related classes.\n\n The engine doesn't know anymore about snapshoting, since it doesnt need to.", "committedDate": "2020-05-14T12:26:09Z", "type": "commit"}, {"oid": "d34a70ac0ead5ff927ea939d695576da626412a0", "url": "https://github.com/camunda-cloud/zeebe/commit/d34a70ac0ead5ff927ea939d695576da626412a0", "message": "chore(atomix): remove sessions and primitives\n\nWe no longer need everything session related nor primitives.", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "eeb0980056cf4880562d356b0f637edf5c32d895", "url": "https://github.com/camunda-cloud/zeebe/commit/eeb0980056cf4880562d356b0f637edf5c32d895", "message": "chore(atomix): refactor raft tests\n\n Remove all tests which are session related.\n Replace/migrate tests which used sessions/primitives and append\n directly to the log.\n\n Some tests will no longer work if the state machine and snapshot is\n moved into atomix, which means they are removed for now and need to be\n replaced later in a follow up issue.", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "f425fa37685cc34221c6a265f9c23341ad16afac", "url": "https://github.com/camunda-cloud/zeebe/commit/f425fa37685cc34221c6a265f9c23341ad16afac", "message": "chore(atomix): rename annotated parameters method", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "bdd49e38a8e5d02b94a959367e920b735bf52ebd", "url": "https://github.com/camunda-cloud/zeebe/commit/bdd49e38a8e5d02b94a959367e920b735bf52ebd", "message": "chore(atomix): log errors on closing server", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "bdd49e38a8e5d02b94a959367e920b735bf52ebd", "url": "https://github.com/camunda-cloud/zeebe/commit/bdd49e38a8e5d02b94a959367e920b735bf52ebd", "message": "chore(atomix): log errors on closing server", "committedDate": "2020-05-14T12:26:48Z", "type": "forcePushed"}]}