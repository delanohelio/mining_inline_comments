{"pr_number": 4834, "pr_title": "chore(atomix): add missing test for multiple data loss", "pr_createdAt": "2020-06-26T13:19:38Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4834", "timeline": [{"oid": "198faaacf04d2009c084b55428a19f519af0bb03", "url": "https://github.com/camunda-cloud/zeebe/commit/198faaacf04d2009c084b55428a19f519af0bb03", "message": "chore(atomix): add missing test for multiple data loss", "committedDate": "2020-06-26T13:16:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2ODU5Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4834#discussion_r447068597", "bodyText": "Is it guaranteed that the snapshot is available immediately after the bootstrap? Or should it wait until the snapshot is replicated?", "author": "deepthidevaki", "createdAt": "2020-06-29T15:42:08Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -228,7 +228,37 @@ public void shouldReplicateSnapshotAfterDataLoss() throws Exception {\n     final var snapshot = raftRule.getSnapshotOnNode(follower);\n \n     assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(100);\n-    assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n+    assertThat(snapshot.getTerm()).isEqualTo(leaderSnapshot.getTerm());\n+    assertThat(snapshot.getId()).isEqualTo(leaderSnapshot.getId());\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotMultipleTimesAfterMultipleDataLoss() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    final var leaderSnapshot = raftRule.getSnapshotFromLeader();\n+    raftRule.triggerDataLossOnNode(follower);\n+    raftRule.bootstrapNode(follower);\n+\n+    final var firstSnapshot = raftRule.getSnapshotOnNode(follower);", "originalCommit": "198faaacf04d2009c084b55428a19f519af0bb03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MTQyNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4834#discussion_r448861424", "bodyText": "The test runs without problems so I thought yes. I checked the code again and indeed the follower needs to apply the first entries to become ready.\nOn bootstrap:\n    if (openFutureRef.compareAndSet(null, new AtomixFuture<>())) {\n      joiner\n          .get()\n          .whenComplete(\n              (result, error) -> {\n                if (error == null) {\n                  context.awaitState(\n                      RaftContext.State.READY,\n                      state -> {\n                        started = true;\n                        openFutureRef.get().complete(this);\n                      });\n                } else {\n                  openFutureRef.get().completeExceptionally(error);\n                }\n              });\n    }\n\nState ready is only set on applying entries https://github.com/zeebe-io/zeebe/blob/develop/atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java#L371-L383", "author": "Zelldon", "createdAt": "2020-07-02T09:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2ODU5Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2ODk2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4834#discussion_r447068960", "bodyText": "Same as above.", "author": "deepthidevaki", "createdAt": "2020-06-29T15:42:39Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -228,7 +228,37 @@ public void shouldReplicateSnapshotAfterDataLoss() throws Exception {\n     final var snapshot = raftRule.getSnapshotOnNode(follower);\n \n     assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(100);\n-    assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n+    assertThat(snapshot.getTerm()).isEqualTo(leaderSnapshot.getTerm());\n+    assertThat(snapshot.getId()).isEqualTo(leaderSnapshot.getId());\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotMultipleTimesAfterMultipleDataLoss() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    final var leaderSnapshot = raftRule.getSnapshotFromLeader();\n+    raftRule.triggerDataLossOnNode(follower);\n+    raftRule.bootstrapNode(follower);\n+\n+    final var firstSnapshot = raftRule.getSnapshotOnNode(follower);\n+\n+    // when another data loss happens\n+    raftRule.shutdownServer(follower);\n+    raftRule.triggerDataLossOnNode(follower);\n+    assertThat(firstSnapshot.getPath()).doesNotExist();\n+    raftRule.bootstrapNode(follower);\n+\n+    // then snapshot is replicated again\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();", "originalCommit": "198faaacf04d2009c084b55428a19f519af0bb03", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}