{"pr_number": 4093, "pr_title": "chore(engine): add inconsistency check", "pr_createdAt": "2020-03-20T13:05:34Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4093", "timeline": [{"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "url": "https://github.com/camunda-cloud/zeebe/commit/43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "message": "test(engine): add inconsistency log test\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode.", "committedDate": "2020-03-23T08:51:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMTU2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396331561", "bodyText": "Nit: can we keep the same wording as we usually do for error messages?", "author": "npepinpe", "createdAt": "2020-03-23T09:58:58Z", "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "diffHunk": "@@ -79,6 +79,10 @@\n       \"Processor finished reprocessing at event position {}\";\n   private static final String LOG_STMT_FAILED_ON_PROCESSING =\n       \"Event {} failed on processing last time, will call #onError to update workflow instance blacklist.\";\n+\n+  private static final String ERROR_INCONSISTENT_LOG =\n+      \"Inconsistent log detected! Last position was '%d' and current position is '%d'.\";", "originalCommit": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "64edf6f041bf18c878be8be4ba24013776bba72b", "chunk": "diff --git a/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java b/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java\nindex b26af7e59c..d60fb39d0b 100644\n--- a/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java\n+++ b/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java\n\n@@ -81,7 +81,7 @@ public final class ReProcessingStateMachine {\n       \"Event {} failed on processing last time, will call #onError to update workflow instance blacklist.\";\n \n   private static final String ERROR_INCONSISTENT_LOG =\n-      \"Inconsistent log detected! Last position was '%d' and current position is '%d'.\";\n+      \"Expected that position '%d' of current event is higher then position '%d' of last event, but was not. Inconsistent log detected!\";\n \n   private static final Consumer<Long> NOOP_LONG_CONSUMER = (instanceKey) -> {};\n   protected final RecordMetadata metadata = new RecordMetadata();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMTg4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396331885", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // ERROR", "author": "npepinpe", "createdAt": "2020-03-23T09:59:28Z", "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "diffHunk": "@@ -146,9 +150,19 @@ private long scanLog(final long snapshotPosition) {\n \n     if (logStreamReader.hasNext()) {\n       lastSourceEventPosition = snapshotPosition;\n+\n+      long lastPosition = snapshotPosition;\n       while (logStreamReader.hasNext()) {\n         final LoggedEvent newEvent = logStreamReader.next();\n \n+        final var currentPosition = newEvent.getPosition();\n+        if (lastPosition >= currentPosition) {\n+          // ERROR", "originalCommit": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "64edf6f041bf18c878be8be4ba24013776bba72b", "chunk": "diff --git a/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java b/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java\nindex b26af7e59c..d60fb39d0b 100644\n--- a/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java\n+++ b/engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java\n\n@@ -157,9 +157,8 @@ public final class ReProcessingStateMachine {\n \n         final var currentPosition = newEvent.getPosition();\n         if (lastPosition >= currentPosition) {\n-          // ERROR\n           throw new IllegalStateException(\n-              String.format(ERROR_INCONSISTENT_LOG, lastPosition, currentPosition));\n+              String.format(ERROR_INCONSISTENT_LOG, currentPosition, lastPosition));\n         }\n         lastPosition = currentPosition;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0MzMzMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396343332", "bodyText": "Since on recovery we switch the processor phase to Phase.PROCESSING, would comparing phases only not be enough? What additional guarantees does the latch provide?", "author": "npepinpe", "createdAt": "2020-03-23T10:19:24Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);", "originalCommit": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1MzY3OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396353678", "bodyText": "It is more a remaining because I checked before whether I call this method. I kept that to verify that after we failed we haven't called it, but probably not necessary.", "author": "Zelldon", "createdAt": "2020-03-23T10:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0MzMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "64edf6f041bf18c878be8be4ba24013776bba72b", "chunk": "diff --git a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\nindex ed485913c5..8ae4a11dee 100644\n--- a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\n+++ b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\n\n@@ -25,7 +25,6 @@ import io.zeebe.protocol.record.ValueType;\n import io.zeebe.test.util.AutoCloseableRule;\n import io.zeebe.util.sched.clock.ControlledActorClock;\n import io.zeebe.util.sched.testing.ActorSchedulerRule;\n-import java.util.concurrent.CountDownLatch;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NDI4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396344287", "bodyText": "Shouldn't it be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        new RecordStream(testStreams.events(getLogName(2)))\n          \n          \n            \n                        new RecordStream(testStreams.events(getLogName(1)))", "author": "npepinpe", "createdAt": "2020-03-23T10:21:06Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))", "originalCommit": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1Mzc5Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396353792", "bodyText": "copy paste error", "author": "Zelldon", "createdAt": "2020-03-23T10:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NDI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "64edf6f041bf18c878be8be4ba24013776bba72b", "chunk": "diff --git a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\nindex ed485913c5..8ae4a11dee 100644\n--- a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\n+++ b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\n\n@@ -25,7 +25,6 @@ import io.zeebe.protocol.record.ValueType;\n import io.zeebe.test.util.AutoCloseableRule;\n import io.zeebe.util.sched.clock.ControlledActorClock;\n import io.zeebe.util.sched.testing.ActorSchedulerRule;\n-import java.util.concurrent.CountDownLatch;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NTM2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396345369", "bodyText": "Is it enough to only test the first processor composite?", "author": "npepinpe", "createdAt": "2020-03-23T10:22:59Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final TypedRecordProcessor typedRecordProcessor = mock(TypedRecordProcessor.class);\n+    final var streamProcessor =", "originalCommit": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1Mzg5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396353896", "bodyText": "yes why not?", "author": "Zelldon", "createdAt": "2020-03-23T10:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NTM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1NjE1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396356154", "bodyText": "Don't we want to ensure that inconsistencies would be detected in both? I guess they're both too close to detect different cases that this test would fail. It's probably fine as is \ud83d\udc4d", "author": "npepinpe", "createdAt": "2020-03-23T10:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NTM2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "64edf6f041bf18c878be8be4ba24013776bba72b", "chunk": "diff --git a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\nindex ed485913c5..8ae4a11dee 100644\n--- a/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\n+++ b/engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java\n\n@@ -25,7 +25,6 @@ import io.zeebe.protocol.record.ValueType;\n import io.zeebe.test.util.AutoCloseableRule;\n import io.zeebe.util.sched.clock.ControlledActorClock;\n import io.zeebe.util.sched.testing.ActorSchedulerRule;\n-import java.util.concurrent.CountDownLatch;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NjYwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396346609", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // things provisioned by this rule", "author": "npepinpe", "createdAt": "2020-03-23T10:25:06Z", "path": "engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.util;\n+\n+import static io.zeebe.engine.util.Records.workflowInstance;\n+\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.engine.processor.ReadonlyProcessingContext;\n+import io.zeebe.engine.processor.StreamProcessor;\n+import io.zeebe.engine.processor.TypedRecordProcessorFactory;\n+import io.zeebe.engine.processor.TypedRecordProcessors;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.logstreams.log.LogStreamRecordWriter;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+\n+public class StreamProcessingComposite {\n+\n+  // things provisioned by this rule", "originalCommit": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "64edf6f041bf18c878be8be4ba24013776bba72b", "chunk": "diff --git a/engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java b/engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java\nindex 7e42296b82..d2a14de583 100644\n--- a/engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java\n+++ b/engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java\n\n@@ -23,7 +23,6 @@ import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n \n public class StreamProcessingComposite {\n \n-  // things provisioned by this rule\n   private static final String STREAM_NAME = \"stream-\";\n \n   private final TestStreams streams;\n"}}, {"oid": "64edf6f041bf18c878be8be4ba24013776bba72b", "url": "https://github.com/camunda-cloud/zeebe/commit/64edf6f041bf18c878be8be4ba24013776bba72b", "message": "chore(engine): add inconsistence check\n\n On reprocessing we verify that the positions are increasing, if not we\n fail the stream processor.\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode.", "committedDate": "2020-03-23T11:20:45Z", "type": "forcePushed"}, {"oid": "8bb0ea0683a03e23dbef01ef4f8221e7835552ab", "url": "https://github.com/camunda-cloud/zeebe/commit/8bb0ea0683a03e23dbef01ef4f8221e7835552ab", "message": "chore(engine): add inconsistence check\n\n On reprocessing we verify that the positions are increasing, if not we\n fail the stream processor.\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode.", "committedDate": "2020-03-23T12:02:32Z", "type": "commit"}, {"oid": "352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "url": "https://github.com/camunda-cloud/zeebe/commit/352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "message": "chore(engine): fix tear down in test", "committedDate": "2020-03-23T12:26:31Z", "type": "commit"}, {"oid": "352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "url": "https://github.com/camunda-cloud/zeebe/commit/352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "message": "chore(engine): fix tear down in test", "committedDate": "2020-03-23T12:26:31Z", "type": "forcePushed"}, {"oid": "20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "url": "https://github.com/camunda-cloud/zeebe/commit/20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "message": "chore(engine): fix AsyncDirector closing", "committedDate": "2020-03-23T17:12:29Z", "type": "commit"}, {"oid": "20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "url": "https://github.com/camunda-cloud/zeebe/commit/20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "message": "chore(engine): fix AsyncDirector closing", "committedDate": "2020-03-23T17:12:29Z", "type": "forcePushed"}]}