{"pr_number": 3660, "pr_title": "Fix inconsistent position creation", "pr_createdAt": "2020-01-15T07:47:17Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/3660", "timeline": [{"oid": "c7fac7c6e1d5fa7769a7502d2ebb34f0af880323", "url": "https://github.com/camunda-cloud/zeebe/commit/c7fac7c6e1d5fa7769a7502d2ebb34f0af880323", "message": "chore(qa): add failing test case", "committedDate": "2020-01-14T18:36:27Z", "type": "commit"}, {"oid": "b12949797f96304325f123805460780e0155bde3", "url": "https://github.com/camunda-cloud/zeebe/commit/b12949797f96304325f123805460780e0155bde3", "message": "fix(logstreams): introduce reference counting for log stream writers\n\n * on first writer creation the log appender and write buffer is created and the initial position is determined\n * on last writer closing the appender and write buffer is closed again", "committedDate": "2020-01-15T07:43:07Z", "type": "commit"}, {"oid": "a417a8fee9c93856420ed59ab10f2517a925a081", "url": "https://github.com/camunda-cloud/zeebe/commit/a417a8fee9c93856420ed59ab10f2517a925a081", "message": "chore(broker): close all used writers", "committedDate": "2020-01-15T07:43:10Z", "type": "commit"}, {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba", "url": "https://github.com/camunda-cloud/zeebe/commit/3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba", "message": "chore(engine): close all writers after usage", "committedDate": "2020-01-15T07:43:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366742047", "bodyText": "Out of curiosity, why call and not run if we don't return anything? Doesn't it just wrap the runnable in a Callable<Void>?\nEDIT: ah, I just saw this isn't really new code, just moved. I'm still wondering why we used call there anyway \ud83e\udd14", "author": "npepinpe", "createdAt": "2020-01-15T08:20:29Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -144,6 +149,38 @@ private void internalSetCommitPosition(final long commitPosition) {\n     onCommitPositionUpdatedConditions.signalConsumers();\n   }\n \n+  @Override\n+  public void delete(final long position) {\n+    actor.call(", "originalCommit": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NTczNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366765735", "bodyText": "I moved the method yes. In the past we had the pattern if there comes an request from outside we use call for the context switch. The run method was later improve to handle this as well.", "author": "Zelldon", "createdAt": "2020-01-15T09:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA0Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDEyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366744129", "bodyText": "If using call, couldn't createWriter not just return the LogStreamWriter? Then you don't need to create an extra future. Or just switch to run; these call calls (\ud83d\ude05) are strange to me when they return nothing.", "author": "npepinpe", "createdAt": "2020-01-15T08:26:15Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));", "originalCommit": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NTIyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366765222", "bodyText": "I need to handle this future in the createWriter method. I can change this to #run yes.", "author": "Zelldon", "createdAt": "2020-01-15T09:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDEyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "181e87bddd7166ac46157aa060d73ea9cc9e1711", "chunk": "diff --git a/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java b/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java\nindex 382db0336a..dc02883f27 100644\n--- a/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java\n+++ b/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java\n\n@@ -194,14 +194,14 @@ public final class LogStreamImpl extends Actor implements LogStream, AutoCloseab\n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n     final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n-    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n+    actor.run(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n     return writerFuture;\n   }\n \n   @Override\n   public ActorFuture<LogStreamBatchWriter> newLogStreamBatchWriter() {\n     final var writerFuture = new CompletableActorFuture<LogStreamBatchWriter>();\n-    actor.call(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n+    actor.run(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n     return writerFuture;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDM5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366744395", "bodyText": "We're in an actor context, no? Why do we need an atomic integer?", "author": "npepinpe", "createdAt": "2020-01-15T08:26:55Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n+    return writerFuture;\n   }\n \n   @Override\n   public ActorFuture<LogStreamBatchWriter> newLogStreamBatchWriter() {\n-    return actor.call(() -> new LogStreamBatchWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamBatchWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n+    return writerFuture;\n+  }\n+\n+  private <T extends LogStreamWriter> void createWriter(\n+      final CompletableActorFuture<T> writerFuture, final WriterCreator<T> creator) {\n+    final var alreadyOpenWriters = openWriterCount.getAndIncrement();", "originalCommit": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NDY1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366764652", "bodyText": "Yes. At the beginning I was not 100% sure how I want to solve it. Either access the count directly, but I decided to sync with the actor. I can replace the count if you want.", "author": "Zelldon", "createdAt": "2020-01-15T09:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "181e87bddd7166ac46157aa060d73ea9cc9e1711", "chunk": "diff --git a/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java b/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java\nindex 382db0336a..dc02883f27 100644\n--- a/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java\n+++ b/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java\n\n@@ -194,14 +194,14 @@ public final class LogStreamImpl extends Actor implements LogStream, AutoCloseab\n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n     final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n-    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n+    actor.run(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n     return writerFuture;\n   }\n \n   @Override\n   public ActorFuture<LogStreamBatchWriter> newLogStreamBatchWriter() {\n     final var writerFuture = new CompletableActorFuture<LogStreamBatchWriter>();\n-    actor.call(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n+    actor.run(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n     return writerFuture;\n   }\n \n"}}, {"oid": "181e87bddd7166ac46157aa060d73ea9cc9e1711", "url": "https://github.com/camunda-cloud/zeebe/commit/181e87bddd7166ac46157aa060d73ea9cc9e1711", "message": "chore(logstreams): replace Actor#call with #run", "committedDate": "2020-01-15T09:29:52Z", "type": "commit"}, {"oid": "6aa68ac059d2baed401bacbc3d4b90bfdf378239", "url": "https://github.com/camunda-cloud/zeebe/commit/6aa68ac059d2baed401bacbc3d4b90bfdf378239", "message": "chore(logstreams): fix deadlock\n\n * after log was closed new writer futures where never completed", "committedDate": "2020-01-15T11:40:02Z", "type": "commit"}, {"oid": "6aa68ac059d2baed401bacbc3d4b90bfdf378239", "url": "https://github.com/camunda-cloud/zeebe/commit/6aa68ac059d2baed401bacbc3d4b90bfdf378239", "message": "chore(logstreams): fix deadlock\n\n * after log was closed new writer futures where never completed", "committedDate": "2020-01-15T11:40:02Z", "type": "forcePushed"}]}