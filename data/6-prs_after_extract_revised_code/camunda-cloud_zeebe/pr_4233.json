{"pr_number": 4233, "pr_title": "Process execution metrics", "pr_createdAt": "2020-04-06T06:37:50Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4233", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4ODg0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r404088847", "bodyText": "Nipick: Can we pass the elapsed time directly so we don't use ActorClock directly here? Just seems strange to couple this to the ActorClock here\nEDIT: same below I guess", "author": "npepinpe", "createdAt": "2020-04-06T13:27:02Z", "path": "engine/src/main/java/io/zeebe/engine/metrics/ExecutionMetrics.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.metrics;\n+\n+import io.prometheus.client.Histogram;\n+import io.zeebe.util.sched.clock.ActorClock;\n+\n+public class ExecutionMetrics {\n+\n+  private static final Histogram WORKFLOW_INSTANCE_EXECUTION =\n+      Histogram.build()\n+          .namespace(\"zeebe\")\n+          .name(\"workflow_instance_execution_time\")\n+          .help(\"The execution time of processing a complete workflow instance\")\n+          .labelNames(\"partition\")\n+          .register();\n+\n+  private final String partitionIdLabel;\n+\n+  public ExecutionMetrics(final int partitionId) {\n+    this.partitionIdLabel = String.valueOf(partitionId);\n+  }\n+\n+  public void observeWorkflowInstanceExecutionTime(final long created) {\n+    WORKFLOW_INSTANCE_EXECUTION\n+        .labels(partitionIdLabel)\n+        .observe((ActorClock.currentTimeMillis() - created) / 1000f);", "originalCommit": "b41991df06e7991e64b2d6f797c9a602fc5b9c3d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "084092f49f231b9d0fdbe99634319ff664e8e23e", "chunk": "diff --git a/engine/src/main/java/io/zeebe/engine/metrics/ExecutionMetrics.java b/engine/src/main/java/io/zeebe/engine/metrics/ExecutionMetrics.java\ndeleted file mode 100644\nindex 4411664456..0000000000\n--- a/engine/src/main/java/io/zeebe/engine/metrics/ExecutionMetrics.java\n+++ /dev/null\n\n@@ -1,34 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.0. You may not use this file\n- * except in compliance with the Zeebe Community License 1.0.\n- */\n-package io.zeebe.engine.metrics;\n-\n-import io.prometheus.client.Histogram;\n-import io.zeebe.util.sched.clock.ActorClock;\n-\n-public class ExecutionMetrics {\n-\n-  private static final Histogram WORKFLOW_INSTANCE_EXECUTION =\n-      Histogram.build()\n-          .namespace(\"zeebe\")\n-          .name(\"workflow_instance_execution_time\")\n-          .help(\"The execution time of processing a complete workflow instance\")\n-          .labelNames(\"partition\")\n-          .register();\n-\n-  private final String partitionIdLabel;\n-\n-  public ExecutionMetrics(final int partitionId) {\n-    this.partitionIdLabel = String.valueOf(partitionId);\n-  }\n-\n-  public void observeWorkflowInstanceExecutionTime(final long created) {\n-    WORKFLOW_INSTANCE_EXECUTION\n-        .labels(partitionIdLabel)\n-        .observe((ActorClock.currentTimeMillis() - created) / 1000f);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4OTY1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r404089658", "bodyText": "Weren't you the one who asked not to create new column families? \ud83d\ude1c", "author": "npepinpe", "createdAt": "2020-04-06T13:28:10Z", "path": "engine/src/main/java/io/zeebe/engine/state/ZbColumnFamilies.java", "diffHunk": "@@ -42,6 +42,7 @@\n \n   // jobs\n   JOBS,\n+  JOBS_CREATION,", "originalCommit": "b41991df06e7991e64b2d6f797c9a602fc5b9c3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExNTQxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r404115412", "bodyText": "Jep but we didn't decided against it so \ud83e\udd37\u200d\u2642\ufe0f", "author": "Zelldon", "createdAt": "2020-04-06T14:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4OTY1OA=="}], "type": "inlineReview", "revised_code": {"commit": "084092f49f231b9d0fdbe99634319ff664e8e23e", "chunk": "diff --git a/engine/src/main/java/io/zeebe/engine/state/ZbColumnFamilies.java b/engine/src/main/java/io/zeebe/engine/state/ZbColumnFamilies.java\nindex 9fea24d89b..1e635a763b 100644\n--- a/engine/src/main/java/io/zeebe/engine/state/ZbColumnFamilies.java\n+++ b/engine/src/main/java/io/zeebe/engine/state/ZbColumnFamilies.java\n\n@@ -42,7 +42,6 @@ public enum ZbColumnFamilies {\n \n   // jobs\n   JOBS,\n-  JOBS_CREATION,\n   JOB_STATES,\n   JOB_DEADLINES,\n   JOB_ACTIVATABLE,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA5MDc5NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r404090794", "bodyText": "Hm, don't know how I feel about using the ActorClock as a default, which has different behaviour based on which thread calls it \ud83d\ude05\nAlso, what about existing instances? Will this metric give me initially incredibly fast jobs since creation time will be instantiated with the current timestamp? \ud83d\ude05", "author": "npepinpe", "createdAt": "2020-04-06T13:29:48Z", "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "diffHunk": "@@ -15,10 +15,13 @@\n import io.zeebe.msgpack.property.ObjectProperty;\n import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.util.sched.clock.ActorClock;\n \n public final class ElementInstance extends UnpackedObject implements DbValue {\n \n   private final LongProperty parentKeyProp = new LongProperty(\"parentKey\", -1L);\n+  private final LongProperty creationTimeProp =\n+      new LongProperty(\"creationTime\", ActorClock.currentTimeMillis());", "originalCommit": "b41991df06e7991e64b2d6f797c9a602fc5b9c3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExNjc4Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r404116782", "bodyText": "Hm, don't know how I feel about using the ActorClock as a default, which has different behaviour based on which thread calls it sweat_smile\n\nWhat is the alternative? You want to use system time? I mean we did in our test but actually the clock was introduced to avoid calling system time to often.\n\nAlso, what about existing instances? Will this metric give me initially incredibly fast jobs since creation time will be instantiated with the current timestamp?\n\ndont get this question to be honest", "author": "Zelldon", "createdAt": "2020-04-06T14:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA5MDc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "084092f49f231b9d0fdbe99634319ff664e8e23e", "chunk": "diff --git a/engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java b/engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java\nindex 2ada151a2a..295598694d 100644\n--- a/engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java\n+++ b/engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java\n\n@@ -15,13 +15,10 @@ import io.zeebe.msgpack.property.LongProperty;\n import io.zeebe.msgpack.property.ObjectProperty;\n import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n-import io.zeebe.util.sched.clock.ActorClock;\n \n public final class ElementInstance extends UnpackedObject implements DbValue {\n \n   private final LongProperty parentKeyProp = new LongProperty(\"parentKey\", -1L);\n-  private final LongProperty creationTimeProp =\n-      new LongProperty(\"creationTime\", ActorClock.currentTimeMillis());\n   private final IntegerProperty childCountProp = new IntegerProperty(\"childCount\", 0);\n   private final LongProperty jobKeyProp = new LongProperty(\"jobKey\", 0L);\n   private final IntegerProperty activeTokensProp = new IntegerProperty(\"activeTokens\", 0);\n"}}, {"oid": "084092f49f231b9d0fdbe99634319ff664e8e23e", "url": "https://github.com/camunda-cloud/zeebe/commit/084092f49f231b9d0fdbe99634319ff664e8e23e", "message": "chore(monitor): add latency metrics to dashboard", "committedDate": "2020-04-08T14:51:07Z", "type": "commit"}, {"oid": "13b2b31f9159d7d834cd2ed758eb9e178046108b", "url": "https://github.com/camunda-cloud/zeebe/commit/13b2b31f9159d7d834cd2ed758eb9e178046108b", "message": "chore(benchmarks): enable metrics exporter", "committedDate": "2020-04-08T14:55:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4NjEzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408186130", "bodyText": "Nitpick: do we need to know from the variable name that it is a tree map? I guess creationTimeToJobKeyNavigableMap doesn't have the same ring ;) I guess I'm just surprised since we don't really want to care about the concrete time except when creating it \ud83e\udd37\u200d\u2642\ufe0f\nJust a nitpick, feel free to ignore", "author": "npepinpe", "createdAt": "2020-04-14T14:35:16Z", "path": "broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.exporter.metrics;\n+\n+import io.zeebe.broker.system.configuration.ExporterCfg;\n+import io.zeebe.exporter.api.Exporter;\n+import io.zeebe.exporter.api.context.Controller;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n+import java.time.Duration;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import org.agrona.collections.Long2LongHashMap;\n+\n+public class MetricsExporter implements Exporter {\n+\n+  public static final Duration TIME_TO_LIVE = Duration.ofSeconds(10);\n+  private final ExecutionLatencyMetrics executionLatencyMetrics;\n+  private final Long2LongHashMap jobKeyToCreationTimeMap;\n+  private final Long2LongHashMap workflowInstanceKeyToCreationTimeMap;\n+\n+  private final NavigableMap<Long, Long> creationTimeToJobKeyTreeMap;", "originalCommit": "13b2b31f9159d7d834cd2ed758eb9e178046108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4OTYxNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408589614", "bodyText": "I added the TreeMap just to know that we can use these subMap stuff, but yes NavigableMap would also be ok.\n\nI guess I'm just surprised since we don't really want to care about the concrete time except when creating it man_shrugging\n\nSorry but I don't get this comment.", "author": "Zelldon", "createdAt": "2020-04-15T05:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4NjEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyODMyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408628329", "bodyText": "Sorry, typo, I meant to write concrete type not concrete time haha, as treeMap the concrete type is part of the name \ud83d\ude05", "author": "npepinpe", "createdAt": "2020-04-15T07:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4NjEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyOTI2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408629263", "bodyText": "Haha that makes much more sense\ud83d\ude00\ud83d\udc4d", "author": "Zelldon", "createdAt": "2020-04-15T07:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4NjEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "54db1cb8727df8ef402849b55591f7557313f0ba", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\nindex ba9173b921..fcbe52234d 100644\n--- a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n+++ b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n\n@@ -15,6 +15,7 @@ import io.zeebe.protocol.record.RecordType;\n import io.zeebe.protocol.record.ValueType;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n import java.time.Duration;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4ODA1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408188058", "bodyText": "Nitpick: any reason to use the concrete type instead of Map<Long, Long>?", "author": "npepinpe", "createdAt": "2020-04-14T14:37:44Z", "path": "broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.exporter.metrics;\n+\n+import io.zeebe.broker.system.configuration.ExporterCfg;\n+import io.zeebe.exporter.api.Exporter;\n+import io.zeebe.exporter.api.context.Controller;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n+import java.time.Duration;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import org.agrona.collections.Long2LongHashMap;\n+\n+public class MetricsExporter implements Exporter {\n+\n+  public static final Duration TIME_TO_LIVE = Duration.ofSeconds(10);\n+  private final ExecutionLatencyMetrics executionLatencyMetrics;\n+  private final Long2LongHashMap jobKeyToCreationTimeMap;", "originalCommit": "13b2b31f9159d7d834cd2ed758eb9e178046108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4ODU1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408588551", "bodyText": "Actually yes because I wanted to avoid the auto boxing.", "author": "Zelldon", "createdAt": "2020-04-15T05:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4ODA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyODY0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408628648", "bodyText": "Ah, right, doing a get(Long) would auto-box, true \ud83d\udc4d Though I wonder if the JIT would optimize if we did final long l = map.get(1) since we always auto-box/auto-unbox \ud83e\udd14", "author": "npepinpe", "createdAt": "2020-04-15T07:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4ODA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDI1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408640250", "bodyText": "I don't think so since you use different method then", "author": "Zelldon", "createdAt": "2020-04-15T07:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4ODA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "54db1cb8727df8ef402849b55591f7557313f0ba", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\nindex ba9173b921..fcbe52234d 100644\n--- a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n+++ b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n\n@@ -15,6 +15,7 @@ import io.zeebe.protocol.record.RecordType;\n import io.zeebe.protocol.record.ValueType;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n import java.time.Duration;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODYxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408358615", "bodyText": "How likely is it to get collision? If we write a batch of follow up events, it's likely they all have the same creation time, no? Especially if we use the ActorClock? Could we end up with \"garbage\" over time? I put it in quotes since technically we should eventually see the completion record for that entity, but still.", "author": "npepinpe", "createdAt": "2020-04-14T18:47:49Z", "path": "broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.exporter.metrics;\n+\n+import io.zeebe.broker.system.configuration.ExporterCfg;\n+import io.zeebe.exporter.api.Exporter;\n+import io.zeebe.exporter.api.context.Controller;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n+import java.time.Duration;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import org.agrona.collections.Long2LongHashMap;\n+\n+public class MetricsExporter implements Exporter {\n+\n+  public static final Duration TIME_TO_LIVE = Duration.ofSeconds(10);\n+  private final ExecutionLatencyMetrics executionLatencyMetrics;\n+  private final Long2LongHashMap jobKeyToCreationTimeMap;\n+  private final Long2LongHashMap workflowInstanceKeyToCreationTimeMap;\n+\n+  private final NavigableMap<Long, Long> creationTimeToJobKeyTreeMap;\n+  private final NavigableMap<Long, Long> creationTimeToWorkflowInstanceKeyTreeMap;\n+\n+  private Controller controller;\n+\n+  public MetricsExporter() {\n+    this.executionLatencyMetrics = new ExecutionLatencyMetrics();\n+    this.jobKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.workflowInstanceKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.creationTimeToJobKeyTreeMap = new TreeMap<>();\n+    this.creationTimeToWorkflowInstanceKeyTreeMap = new TreeMap<>();\n+  }\n+\n+  @Override\n+  public void open(final Controller controller) {\n+    this.controller = controller;\n+\n+    controller.scheduleTask(TIME_TO_LIVE, this::cleanUp);\n+  }\n+\n+  @Override\n+  public void close() {\n+    jobKeyToCreationTimeMap.clear();\n+    workflowInstanceKeyToCreationTimeMap.clear();\n+  }\n+\n+  @Override\n+  public void export(final Record record) {\n+    if (record.getRecordType() != RecordType.EVENT) {\n+      controller.updateLastExportedRecordPosition(record.getPosition());\n+      return;\n+    }\n+\n+    final var partitionId = record.getPartitionId();\n+    final var recordKey = record.getKey();\n+\n+    final var currentValueType = record.getValueType();\n+    if (currentValueType == ValueType.JOB) {\n+      handleJobRecord(record, partitionId, recordKey);\n+    } else if (currentValueType == ValueType.WORKFLOW_INSTANCE) {\n+      handleWorkflowInstanceRecord(record, partitionId, recordKey);\n+    }\n+\n+    controller.updateLastExportedRecordPosition(record.getPosition());\n+  }\n+\n+  private void handleWorkflowInstanceRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == WorkflowInstanceIntent.ELEMENT_ACTIVATING\n+        && isWorkflowInstanceRecord(record)) {\n+      storeWorkflowInstanceCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == WorkflowInstanceIntent.ELEMENT_COMPLETED\n+        && isWorkflowInstanceRecord(record)) {\n+      final var creationTime = workflowInstanceKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeWorkflowInstanceExecutionTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeWorkflowInstanceCreation(final long creationTime, final long recordKey) {\n+    workflowInstanceKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToWorkflowInstanceKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void handleJobRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == JobIntent.CREATED) {\n+      storeJobCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == JobIntent.ACTIVATED) {\n+      final var creationTime = jobKeyToCreationTimeMap.get(recordKey);\n+      executionLatencyMetrics.observeJobActivationTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    } else if (currentIntent == JobIntent.COMPLETED) {\n+      final var creationTime = jobKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeJobLifeTime(partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeJobCreation(final long creationTime, final long recordKey) {\n+    jobKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToJobKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void cleanUp() {\n+    final var currentTimeMillis = System.currentTimeMillis();\n+\n+    final var deadTime = currentTimeMillis - TIME_TO_LIVE.toMillis();\n+    clearMaps(deadTime, creationTimeToJobKeyTreeMap, jobKeyToCreationTimeMap);", "originalCommit": "13b2b31f9159d7d834cd2ed758eb9e178046108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4OTU4Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408589586", "bodyText": "If we write a batch of follow up events, it's likely they all have the same creation time, no?\n\nI think they have the same time on a batch.\n\nCould we end up with \"garbage\" over time? I put it in quotes since technically we should eventually see the completion record for that entity, but still.\n\nCan you elaborate on that?", "author": "Zelldon", "createdAt": "2020-04-15T05:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyOTU2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408629567", "bodyText": "So I add a bunch of keys with the same creation time into the creationTimeToJobKeyTreeMap (or the other one). It's a map, so it only saves the latest value, no? So when I clean up, I actually only clean up that value, not any of the others from the map? Or am I missing something?", "author": "npepinpe", "createdAt": "2020-04-15T07:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzMjI5MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408632291", "bodyText": "Ok got what you mean, but everything which is stored is not created due to batches. So job created for example is not written in a batch and also the workflow instance creation is not.", "author": "Zelldon", "createdAt": "2020-04-15T07:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNTkwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408635907", "bodyText": "Ah true, we only store for processes and jobs, so they are never part of a batch (I think? Can't remember how a multi-instance call activity would look like \ud83d\ude05)", "author": "npepinpe", "createdAt": "2020-04-15T07:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTc2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408639769", "bodyText": "Even if multi instances creates multiple jobs the CREATED will be written again one by one \ud83d\ude42 so should be fine", "author": "Zelldon", "createdAt": "2020-04-15T07:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODYxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "54db1cb8727df8ef402849b55591f7557313f0ba", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\nindex ba9173b921..fcbe52234d 100644\n--- a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n+++ b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n\n@@ -15,6 +15,7 @@ import io.zeebe.protocol.record.RecordType;\n import io.zeebe.protocol.record.ValueType;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n import java.time.Duration;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2MTEzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408361135", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (final Long key : outOfScopeInstances.values()) {\n          \n          \n            \n                  keyToTimestampMap.remove(key);\n          \n          \n            \n                }\n          \n          \n            \n                keyToTimestampMap.keySet().removeAll(outOfScopeInstances.values())\n          \n      \n    \n    \n  \n\nFrom what I understand, changes to keySet() are reflected in the map. From the docs:\n\nThe set is backed by the map, so changes to the map are reflected in the set, and vice-versa\n...\nThe set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.", "author": "npepinpe", "createdAt": "2020-04-14T18:52:10Z", "path": "broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.exporter.metrics;\n+\n+import io.zeebe.broker.system.configuration.ExporterCfg;\n+import io.zeebe.exporter.api.Exporter;\n+import io.zeebe.exporter.api.context.Controller;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n+import java.time.Duration;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import org.agrona.collections.Long2LongHashMap;\n+\n+public class MetricsExporter implements Exporter {\n+\n+  public static final Duration TIME_TO_LIVE = Duration.ofSeconds(10);\n+  private final ExecutionLatencyMetrics executionLatencyMetrics;\n+  private final Long2LongHashMap jobKeyToCreationTimeMap;\n+  private final Long2LongHashMap workflowInstanceKeyToCreationTimeMap;\n+\n+  private final NavigableMap<Long, Long> creationTimeToJobKeyTreeMap;\n+  private final NavigableMap<Long, Long> creationTimeToWorkflowInstanceKeyTreeMap;\n+\n+  private Controller controller;\n+\n+  public MetricsExporter() {\n+    this.executionLatencyMetrics = new ExecutionLatencyMetrics();\n+    this.jobKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.workflowInstanceKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.creationTimeToJobKeyTreeMap = new TreeMap<>();\n+    this.creationTimeToWorkflowInstanceKeyTreeMap = new TreeMap<>();\n+  }\n+\n+  @Override\n+  public void open(final Controller controller) {\n+    this.controller = controller;\n+\n+    controller.scheduleTask(TIME_TO_LIVE, this::cleanUp);\n+  }\n+\n+  @Override\n+  public void close() {\n+    jobKeyToCreationTimeMap.clear();\n+    workflowInstanceKeyToCreationTimeMap.clear();\n+  }\n+\n+  @Override\n+  public void export(final Record record) {\n+    if (record.getRecordType() != RecordType.EVENT) {\n+      controller.updateLastExportedRecordPosition(record.getPosition());\n+      return;\n+    }\n+\n+    final var partitionId = record.getPartitionId();\n+    final var recordKey = record.getKey();\n+\n+    final var currentValueType = record.getValueType();\n+    if (currentValueType == ValueType.JOB) {\n+      handleJobRecord(record, partitionId, recordKey);\n+    } else if (currentValueType == ValueType.WORKFLOW_INSTANCE) {\n+      handleWorkflowInstanceRecord(record, partitionId, recordKey);\n+    }\n+\n+    controller.updateLastExportedRecordPosition(record.getPosition());\n+  }\n+\n+  private void handleWorkflowInstanceRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == WorkflowInstanceIntent.ELEMENT_ACTIVATING\n+        && isWorkflowInstanceRecord(record)) {\n+      storeWorkflowInstanceCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == WorkflowInstanceIntent.ELEMENT_COMPLETED\n+        && isWorkflowInstanceRecord(record)) {\n+      final var creationTime = workflowInstanceKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeWorkflowInstanceExecutionTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeWorkflowInstanceCreation(final long creationTime, final long recordKey) {\n+    workflowInstanceKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToWorkflowInstanceKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void handleJobRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == JobIntent.CREATED) {\n+      storeJobCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == JobIntent.ACTIVATED) {\n+      final var creationTime = jobKeyToCreationTimeMap.get(recordKey);\n+      executionLatencyMetrics.observeJobActivationTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    } else if (currentIntent == JobIntent.COMPLETED) {\n+      final var creationTime = jobKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeJobLifeTime(partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeJobCreation(final long creationTime, final long recordKey) {\n+    jobKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToJobKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void cleanUp() {\n+    final var currentTimeMillis = System.currentTimeMillis();\n+\n+    final var deadTime = currentTimeMillis - TIME_TO_LIVE.toMillis();\n+    clearMaps(deadTime, creationTimeToJobKeyTreeMap, jobKeyToCreationTimeMap);\n+    clearMaps(\n+        deadTime, creationTimeToWorkflowInstanceKeyTreeMap, workflowInstanceKeyToCreationTimeMap);\n+  }\n+\n+  private void clearMaps(\n+      final long deadTime,\n+      final NavigableMap<Long, Long> timeToKeyMap,\n+      final Long2LongHashMap keyToTimestampMap) {\n+    final var outOfScopeInstances = timeToKeyMap.headMap(deadTime);\n+\n+    for (final Long key : outOfScopeInstances.values()) {\n+      keyToTimestampMap.remove(key);\n+    }", "originalCommit": "13b2b31f9159d7d834cd2ed758eb9e178046108b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "54db1cb8727df8ef402849b55591f7557313f0ba", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\nindex ba9173b921..fcbe52234d 100644\n--- a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n+++ b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n\n@@ -15,6 +15,7 @@ import io.zeebe.protocol.record.RecordType;\n import io.zeebe.protocol.record.ValueType;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n import java.time.Duration;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Nzg3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408367876", "bodyText": "Why is it static?", "author": "npepinpe", "createdAt": "2020-04-14T19:03:16Z", "path": "broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.exporter.metrics;\n+\n+import io.zeebe.broker.system.configuration.ExporterCfg;\n+import io.zeebe.exporter.api.Exporter;\n+import io.zeebe.exporter.api.context.Controller;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n+import java.time.Duration;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import org.agrona.collections.Long2LongHashMap;\n+\n+public class MetricsExporter implements Exporter {\n+\n+  public static final Duration TIME_TO_LIVE = Duration.ofSeconds(10);\n+  private final ExecutionLatencyMetrics executionLatencyMetrics;\n+  private final Long2LongHashMap jobKeyToCreationTimeMap;\n+  private final Long2LongHashMap workflowInstanceKeyToCreationTimeMap;\n+\n+  private final NavigableMap<Long, Long> creationTimeToJobKeyTreeMap;\n+  private final NavigableMap<Long, Long> creationTimeToWorkflowInstanceKeyTreeMap;\n+\n+  private Controller controller;\n+\n+  public MetricsExporter() {\n+    this.executionLatencyMetrics = new ExecutionLatencyMetrics();\n+    this.jobKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.workflowInstanceKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.creationTimeToJobKeyTreeMap = new TreeMap<>();\n+    this.creationTimeToWorkflowInstanceKeyTreeMap = new TreeMap<>();\n+  }\n+\n+  @Override\n+  public void open(final Controller controller) {\n+    this.controller = controller;\n+\n+    controller.scheduleTask(TIME_TO_LIVE, this::cleanUp);\n+  }\n+\n+  @Override\n+  public void close() {\n+    jobKeyToCreationTimeMap.clear();\n+    workflowInstanceKeyToCreationTimeMap.clear();\n+  }\n+\n+  @Override\n+  public void export(final Record record) {\n+    if (record.getRecordType() != RecordType.EVENT) {\n+      controller.updateLastExportedRecordPosition(record.getPosition());\n+      return;\n+    }\n+\n+    final var partitionId = record.getPartitionId();\n+    final var recordKey = record.getKey();\n+\n+    final var currentValueType = record.getValueType();\n+    if (currentValueType == ValueType.JOB) {\n+      handleJobRecord(record, partitionId, recordKey);\n+    } else if (currentValueType == ValueType.WORKFLOW_INSTANCE) {\n+      handleWorkflowInstanceRecord(record, partitionId, recordKey);\n+    }\n+\n+    controller.updateLastExportedRecordPosition(record.getPosition());\n+  }\n+\n+  private void handleWorkflowInstanceRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == WorkflowInstanceIntent.ELEMENT_ACTIVATING\n+        && isWorkflowInstanceRecord(record)) {\n+      storeWorkflowInstanceCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == WorkflowInstanceIntent.ELEMENT_COMPLETED\n+        && isWorkflowInstanceRecord(record)) {\n+      final var creationTime = workflowInstanceKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeWorkflowInstanceExecutionTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeWorkflowInstanceCreation(final long creationTime, final long recordKey) {\n+    workflowInstanceKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToWorkflowInstanceKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void handleJobRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == JobIntent.CREATED) {\n+      storeJobCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == JobIntent.ACTIVATED) {\n+      final var creationTime = jobKeyToCreationTimeMap.get(recordKey);\n+      executionLatencyMetrics.observeJobActivationTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    } else if (currentIntent == JobIntent.COMPLETED) {\n+      final var creationTime = jobKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeJobLifeTime(partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeJobCreation(final long creationTime, final long recordKey) {\n+    jobKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToJobKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void cleanUp() {\n+    final var currentTimeMillis = System.currentTimeMillis();\n+\n+    final var deadTime = currentTimeMillis - TIME_TO_LIVE.toMillis();\n+    clearMaps(deadTime, creationTimeToJobKeyTreeMap, jobKeyToCreationTimeMap);\n+    clearMaps(\n+        deadTime, creationTimeToWorkflowInstanceKeyTreeMap, workflowInstanceKeyToCreationTimeMap);\n+  }\n+\n+  private void clearMaps(\n+      final long deadTime,\n+      final NavigableMap<Long, Long> timeToKeyMap,\n+      final Long2LongHashMap keyToTimestampMap) {\n+    final var outOfScopeInstances = timeToKeyMap.headMap(deadTime);\n+\n+    for (final Long key : outOfScopeInstances.values()) {\n+      keyToTimestampMap.remove(key);\n+    }\n+    outOfScopeInstances.clear();\n+  }\n+\n+  public static ExporterCfg defaultConfig() {\n+    final ExporterCfg exporterCfg = new ExporterCfg();\n+    exporterCfg.setClassName(MetricsExporter.class.getName());\n+    return exporterCfg;\n+  }\n+\n+  public static String defaultExporterId() {\n+    return MetricsExporter.class.getSimpleName();\n+  }\n+\n+  private static boolean isWorkflowInstanceRecord(final Record<?> record) {", "originalCommit": "13b2b31f9159d7d834cd2ed758eb9e178046108b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU5Mzk0OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408593949", "bodyText": "Hm not sure anymore I think because it is a helper method and it can also moved elsewhere", "author": "Zelldon", "createdAt": "2020-04-15T05:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Nzg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "54db1cb8727df8ef402849b55591f7557313f0ba", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\nindex ba9173b921..fcbe52234d 100644\n--- a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n+++ b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n\n@@ -15,6 +15,7 @@ import io.zeebe.protocol.record.RecordType;\n import io.zeebe.protocol.record.ValueType;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n import java.time.Duration;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2ODMxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408368312", "bodyText": "Nice catch", "author": "npepinpe", "createdAt": "2020-04-14T19:03:58Z", "path": "broker/src/test/java/io/zeebe/broker/system/configuration/BrokerCfgTest.java", "diffHunk": "@@ -60,8 +61,10 @@\n \n   private static final String ZEEBE_BROKER_NETWORK_HOST = \"zeebe.broker.network.host\";\n   private static final String ZEEBE_BROKER_NETWORK_ADVERTISED_HOST =\n-      \"zeebe.broker.network.advertised-host\";\n+      \"zeebe.broker.network.advertisedHost\";", "originalCommit": "13b2b31f9159d7d834cd2ed758eb9e178046108b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNTE0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408635142", "bodyText": "Nit: Could we also just check if recordValue.getBpmnElementType() == BpmnElementType.PROCESS? I think this is how we do it in WorkflowInstanceMetrics", "author": "npepinpe", "createdAt": "2020-04-15T07:27:51Z", "path": "broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.exporter.metrics;\n+\n+import io.zeebe.broker.system.configuration.ExporterCfg;\n+import io.zeebe.exporter.api.Exporter;\n+import io.zeebe.exporter.api.context.Controller;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n+import java.time.Duration;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import org.agrona.collections.Long2LongHashMap;\n+\n+public class MetricsExporter implements Exporter {\n+\n+  public static final Duration TIME_TO_LIVE = Duration.ofSeconds(10);\n+  private final ExecutionLatencyMetrics executionLatencyMetrics;\n+  private final Long2LongHashMap jobKeyToCreationTimeMap;\n+  private final Long2LongHashMap workflowInstanceKeyToCreationTimeMap;\n+\n+  private final NavigableMap<Long, Long> creationTimeToJobKeyTreeMap;\n+  private final NavigableMap<Long, Long> creationTimeToWorkflowInstanceKeyTreeMap;\n+\n+  private Controller controller;\n+\n+  public MetricsExporter() {\n+    this.executionLatencyMetrics = new ExecutionLatencyMetrics();\n+    this.jobKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.workflowInstanceKeyToCreationTimeMap = new Long2LongHashMap(-1);\n+    this.creationTimeToJobKeyTreeMap = new TreeMap<>();\n+    this.creationTimeToWorkflowInstanceKeyTreeMap = new TreeMap<>();\n+  }\n+\n+  @Override\n+  public void open(final Controller controller) {\n+    this.controller = controller;\n+\n+    controller.scheduleTask(TIME_TO_LIVE, this::cleanUp);\n+  }\n+\n+  @Override\n+  public void close() {\n+    jobKeyToCreationTimeMap.clear();\n+    workflowInstanceKeyToCreationTimeMap.clear();\n+  }\n+\n+  @Override\n+  public void export(final Record record) {\n+    if (record.getRecordType() != RecordType.EVENT) {\n+      controller.updateLastExportedRecordPosition(record.getPosition());\n+      return;\n+    }\n+\n+    final var partitionId = record.getPartitionId();\n+    final var recordKey = record.getKey();\n+\n+    final var currentValueType = record.getValueType();\n+    if (currentValueType == ValueType.JOB) {\n+      handleJobRecord(record, partitionId, recordKey);\n+    } else if (currentValueType == ValueType.WORKFLOW_INSTANCE) {\n+      handleWorkflowInstanceRecord(record, partitionId, recordKey);\n+    }\n+\n+    controller.updateLastExportedRecordPosition(record.getPosition());\n+  }\n+\n+  private void handleWorkflowInstanceRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == WorkflowInstanceIntent.ELEMENT_ACTIVATING\n+        && isWorkflowInstanceRecord(record)) {\n+      storeWorkflowInstanceCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == WorkflowInstanceIntent.ELEMENT_COMPLETED\n+        && isWorkflowInstanceRecord(record)) {\n+      final var creationTime = workflowInstanceKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeWorkflowInstanceExecutionTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeWorkflowInstanceCreation(final long creationTime, final long recordKey) {\n+    workflowInstanceKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToWorkflowInstanceKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void handleJobRecord(\n+      final Record<?> record, final int partitionId, final long recordKey) {\n+    final var currentIntent = record.getIntent();\n+\n+    if (currentIntent == JobIntent.CREATED) {\n+      storeJobCreation(record.getTimestamp(), recordKey);\n+    } else if (currentIntent == JobIntent.ACTIVATED) {\n+      final var creationTime = jobKeyToCreationTimeMap.get(recordKey);\n+      executionLatencyMetrics.observeJobActivationTime(\n+          partitionId, creationTime, record.getTimestamp());\n+    } else if (currentIntent == JobIntent.COMPLETED) {\n+      final var creationTime = jobKeyToCreationTimeMap.remove(recordKey);\n+      executionLatencyMetrics.observeJobLifeTime(partitionId, creationTime, record.getTimestamp());\n+    }\n+  }\n+\n+  private void storeJobCreation(final long creationTime, final long recordKey) {\n+    jobKeyToCreationTimeMap.put(recordKey, creationTime);\n+    creationTimeToJobKeyTreeMap.put(creationTime, recordKey);\n+  }\n+\n+  private void cleanUp() {\n+    final var currentTimeMillis = System.currentTimeMillis();\n+\n+    final var deadTime = currentTimeMillis - TIME_TO_LIVE.toMillis();\n+    clearMaps(deadTime, creationTimeToJobKeyTreeMap, jobKeyToCreationTimeMap);\n+    clearMaps(\n+        deadTime, creationTimeToWorkflowInstanceKeyTreeMap, workflowInstanceKeyToCreationTimeMap);\n+  }\n+\n+  private void clearMaps(\n+      final long deadTime,\n+      final NavigableMap<Long, Long> timeToKeyMap,\n+      final Long2LongHashMap keyToTimestampMap) {\n+    final var outOfScopeInstances = timeToKeyMap.headMap(deadTime);\n+\n+    keyToTimestampMap.keySet().removeAll(outOfScopeInstances.values())\n+    outOfScopeInstances.clear();\n+  }\n+\n+  public static ExporterCfg defaultConfig() {\n+    final ExporterCfg exporterCfg = new ExporterCfg();\n+    exporterCfg.setClassName(MetricsExporter.class.getName());\n+    return exporterCfg;\n+  }\n+\n+  public static String defaultExporterId() {\n+    return MetricsExporter.class.getSimpleName();\n+  }\n+\n+  private static boolean isWorkflowInstanceRecord(final Record<?> record) {\n+    final var recordKey = record.getKey();\n+    final var recordValue = (WorkflowInstanceRecordValue) record.getValue();\n+    return recordKey == recordValue.getWorkflowInstanceKey();", "originalCommit": "c709e0ec7c6a84d404c31c8c37fc8560b5c88be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTEyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4233#discussion_r408639121", "bodyText": "Ah yes thanks always forget this elementType thing \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-04-15T07:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNTE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "54db1cb8727df8ef402849b55591f7557313f0ba", "chunk": "diff --git a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\nindex 6c27e5cca3..fcbe52234d 100644\n--- a/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n+++ b/broker/src/main/java/io/zeebe/broker/exporter/metrics/MetricsExporter.java\n\n@@ -15,6 +15,7 @@ import io.zeebe.protocol.record.RecordType;\n import io.zeebe.protocol.record.ValueType;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n import io.zeebe.protocol.record.value.WorkflowInstanceRecordValue;\n import java.time.Duration;\n import java.util.NavigableMap;\n"}}, {"oid": "54db1cb8727df8ef402849b55591f7557313f0ba", "url": "https://github.com/camunda-cloud/zeebe/commit/54db1cb8727df8ef402849b55591f7557313f0ba", "message": "chore(broker): add metric exporter\n\nThe execution metric exporter will collect informations based on the seen records\nand publish latency metric like:\n\n * process execution time, shows the time between creating and completing/terminating a workflow instance\n * job activation time, shows the time between creating an job and activating it\n * job lifetime, show the time between creating an job and completing it\n\nAs it makes more sense for short running process and not on all use cases it is disabled by default.\nWe can enabled it for example with a env variable, which we will do with\nout benchmark setup. For performance analysis the metrics are quite\ninteresting. We moved these metrics into an exporter, such that we not\nhave this in our current state (db) since it is not always needed and\ncan easily be extended.", "committedDate": "2020-04-15T07:47:45Z", "type": "commit"}, {"oid": "6e4005ddb1238577a8f72f7abeeb8a257bf372f4", "url": "https://github.com/camunda-cloud/zeebe/commit/6e4005ddb1238577a8f72f7abeeb8a257bf372f4", "message": "chore(benchmarks): enable metrics exporter", "committedDate": "2020-04-15T07:47:51Z", "type": "commit"}, {"oid": "6e4005ddb1238577a8f72f7abeeb8a257bf372f4", "url": "https://github.com/camunda-cloud/zeebe/commit/6e4005ddb1238577a8f72f7abeeb8a257bf372f4", "message": "chore(benchmarks): enable metrics exporter", "committedDate": "2020-04-15T07:47:51Z", "type": "forcePushed"}]}