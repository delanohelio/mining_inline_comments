{"pr_number": 5844, "pr_title": "chore(atomix): add checksum to append request", "pr_createdAt": "2020-11-13T15:55:12Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5844", "timeline": [{"oid": "d057358dd33c0b91353fe2a62c2f4700fcf518ec", "url": "https://github.com/camunda-cloud/zeebe/commit/d057358dd33c0b91353fe2a62c2f4700fcf518ec", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-18T17:57:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU0Nzk3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r528547979", "bodyText": "May be refactor the code so that we don't have to read the checksum twice?", "author": "deepthidevaki", "createdAt": "2020-11-23T08:56:21Z", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentReader.java", "diffHunk": "@@ -209,17 +209,21 @@ private void readNext() {\n   }\n \n   private void readNextEntry(final long index, final int length) {\n+    final int checksumPosition = memory.position();\n+\n     if (isChecksumInvalid(length)) {\n       resetReading();\n       return;\n     }\n+    memory.position(checksumPosition);", "originalCommit": "d057358dd33c0b91353fe2a62c2f4700fcf518ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b8ecc988847128a890cf3bf20220c6c8b71bfc71", "chunk": "diff --git a/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentReader.java b/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentReader.java\nindex 7a9a47a2b6..c28a9d9acd 100644\n--- a/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentReader.java\n+++ b/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentReader.java\n\n@@ -209,14 +209,12 @@ class FileChannelJournalSegmentReader<E> implements JournalReader<E> {\n   }\n \n   private void readNextEntry(final long index, final int length) {\n-    final int checksumPosition = memory.position();\n+    final long checksum = memory.getInt() & 0xFFFFFFFFL;\n \n-    if (isChecksumInvalid(length)) {\n+    if (isChecksumInvalid(checksum, length)) {\n       resetReading();\n       return;\n     }\n-    memory.position(checksumPosition);\n-    final long checksum = memory.getInt() & 0xFFFFFFFFL;\n \n     // If the stored checksum equals the computed checksum, set the next entry.\n     final int limit = memory.limit();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU1NDc1Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r528554757", "bodyText": "The assumption is if the checksums is null, it is from an old version. Right?", "author": "deepthidevaki", "createdAt": "2020-11-23T09:09:25Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -618,6 +648,23 @@ protected void appendEntries(\n     succeedAppend(lastLogIndex, future);\n   }\n \n+  private boolean validChecksum(final AppendRequest request, final int index) {\n+    if (request.checksums() == null) {", "originalCommit": "d057358dd33c0b91353fe2a62c2f4700fcf518ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY3MjY2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r528672663", "bodyText": "Yes", "author": "MiguelPires", "createdAt": "2020-11-23T12:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU1NDc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b8ecc988847128a890cf3bf20220c6c8b71bfc71", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\nindex 67cb42ed32..70bf8c618e 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n\n@@ -648,28 +652,12 @@ public class PassiveRole extends InactiveRole {\n     succeedAppend(lastLogIndex, future);\n   }\n \n-  private boolean validChecksum(final AppendRequest request, final int index) {\n-    if (request.checksums() == null) {\n-      return true;\n-    }\n-\n-    final long checksum = request.checksums().get(index);\n-    final RaftLogEntry entry = request.entries().get(index);\n-\n-    buffer.clear();\n-    namespace.serialize(entry, buffer);\n-    buffer.flip();\n-\n-    checksumGenerator.reset();\n-    checksumGenerator.update(buffer);\n-    return checksum == checksumGenerator.getValue();\n-  }\n-\n   private boolean tryToAppend(\n       final CompletableFuture<AppendResponse> future,\n       final RaftLogWriter writer,\n       final RaftLogReader reader,\n       final RaftLogEntry entry,\n+      final Predicate<ByteBuffer> validator,\n       final long index,\n       final Indexed<RaftLogEntry> lastEntry) {\n     boolean failedToAppend = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4Nzg1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r528587859", "bodyText": "We are serializing the entry and calculating the checksums here and again in journal::append. Can we not do that?", "author": "deepthidevaki", "createdAt": "2020-11-23T10:03:54Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -618,6 +648,23 @@ protected void appendEntries(\n     succeedAppend(lastLogIndex, future);\n   }\n \n+  private boolean validChecksum(final AppendRequest request, final int index) {\n+    if (request.checksums() == null) {\n+      return true;\n+    }\n+\n+    final long checksum = request.checksums().get(index);\n+    final RaftLogEntry entry = request.entries().get(index);\n+\n+    buffer.clear();\n+    namespace.serialize(entry, buffer);", "originalCommit": "d057358dd33c0b91353fe2a62c2f4700fcf518ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY3NTkzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r528675933", "bodyText": "I didn't see a way of doing that without refactoring the journal. We'd have to have slightly different journal implementations for the leader and follower (which I think is part of a larger topic we're tackling next quarter)", "author": "MiguelPires", "createdAt": "2020-11-23T12:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4Nzg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczNzg5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r528737896", "bodyText": "Ok. Let's leave it as it is. Can you create a follow up issue for it? Did you run a benchmark with this changes - does having to serialize it twice has any impact on the performance?", "author": "deepthidevaki", "createdAt": "2020-11-23T14:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4Nzg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc5NTgzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r528795834", "bodyText": "Yes, it's in the mp-4736 namespace. It's been running for 10 days without issues. The average for the last 7 days is 142 processes completed per second. I do see the checksum validation in the profiling at ~1% due to the serialization", "author": "MiguelPires", "createdAt": "2020-11-23T15:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4Nzg1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b8ecc988847128a890cf3bf20220c6c8b71bfc71", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\nindex 67cb42ed32..70bf8c618e 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n\n@@ -648,28 +652,12 @@ public class PassiveRole extends InactiveRole {\n     succeedAppend(lastLogIndex, future);\n   }\n \n-  private boolean validChecksum(final AppendRequest request, final int index) {\n-    if (request.checksums() == null) {\n-      return true;\n-    }\n-\n-    final long checksum = request.checksums().get(index);\n-    final RaftLogEntry entry = request.entries().get(index);\n-\n-    buffer.clear();\n-    namespace.serialize(entry, buffer);\n-    buffer.flip();\n-\n-    checksumGenerator.reset();\n-    checksumGenerator.update(buffer);\n-    return checksum == checksumGenerator.getValue();\n-  }\n-\n   private boolean tryToAppend(\n       final CompletableFuture<AppendResponse> future,\n       final RaftLogWriter writer,\n       final RaftLogReader reader,\n       final RaftLogEntry entry,\n+      final Predicate<ByteBuffer> validator,\n       final long index,\n       final Indexed<RaftLogEntry> lastEntry) {\n     boolean failedToAppend = false;\n"}}, {"oid": "b8ecc988847128a890cf3bf20220c6c8b71bfc71", "url": "https://github.com/camunda-cloud/zeebe/commit/b8ecc988847128a890cf3bf20220c6c8b71bfc71", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-26T08:17:26Z", "type": "forcePushed"}, {"oid": "9b52aa1d289b0d94003835417e2f5f86094c8857", "url": "https://github.com/camunda-cloud/zeebe/commit/9b52aa1d289b0d94003835417e2f5f86094c8857", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-26T10:46:08Z", "type": "forcePushed"}, {"oid": "554d5f7289803576bf25cdf7ccb57ad784337463", "url": "https://github.com/camunda-cloud/zeebe/commit/554d5f7289803576bf25cdf7ccb57ad784337463", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-26T12:12:18Z", "type": "forcePushed"}, {"oid": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "url": "https://github.com/camunda-cloud/zeebe/commit/dbe364b9ca898afdff6072c4a55df1f1340a22e5", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-27T08:28:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3MTYzOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531471638", "bodyText": "Must catch StorageException.InvalidChecksum", "author": "deepthidevaki", "createdAt": "2020-11-27T09:13:45Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -706,18 +747,25 @@ private boolean replaceExistingEntry(\n   private boolean appendEntry(\n       final long index,\n       final RaftLogEntry entry,\n+      final AtomicInteger checksum,\n       final RaftLogWriter writer,\n       final CompletableFuture<AppendResponse> future) {\n     try {\n-      final Indexed<RaftLogEntry> indexed = writer.append(entry);\n+      final Indexed<RaftLogEntry> indexed;\n+      if (checksum != null) {\n+        indexed = writer.append(entry, checksum.get());\n+      } else {\n+        indexed = writer.append(entry);\n+      }\n+\n       log.trace(\"Appended {}\", indexed);\n       raft.getReplicationMetrics().setAppendIndex(indexed.index());\n     } catch (final StorageException.TooLarge e) {\n       log.warn(\n           \"Entry size exceeds maximum allowed bytes. Ensure Raft storage configuration is consistent on all nodes!\");\n       return false;\n     } catch (final StorageException.OutOfDiskSpace e) {\n-      log.trace(\"Append failed: {}\", e);\n+      log.trace(\"Append failed: \", e);", "originalCommit": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\nindex f82e58d2af..13d7b3edfb 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n\n@@ -747,13 +730,13 @@ public class PassiveRole extends InactiveRole {\n   private boolean appendEntry(\n       final long index,\n       final RaftLogEntry entry,\n-      final AtomicInteger checksum,\n+      final Long checksum,\n       final RaftLogWriter writer,\n       final CompletableFuture<AppendResponse> future) {\n     try {\n       final Indexed<RaftLogEntry> indexed;\n       if (checksum != null) {\n-        indexed = writer.append(entry, checksum.get());\n+        indexed = writer.append(entry, checksum);\n       } else {\n         indexed = writer.append(entry);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3Mjc2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531472765", "bodyText": "Why is it AtomicInteger? There is no concurrent access to it.", "author": "deepthidevaki", "createdAt": "2020-11-27T09:15:30Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -580,13 +611,20 @@ protected void appendEntries(\n       }\n \n       // Iterate through entries and append them.\n-      for (final RaftLogEntry entry : request.entries()) {\n+      for (int i = 0; i < request.entries().size(); ++i) {\n         final long index = ++lastLogIndex;\n+        final RaftLogEntry entry = request.entries().get(i);\n+\n+        AtomicInteger checksum = null;", "originalCommit": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\nindex f82e58d2af..13d7b3edfb 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n\n@@ -615,9 +598,9 @@ public class PassiveRole extends InactiveRole {\n         final long index = ++lastLogIndex;\n         final RaftLogEntry entry = request.entries().get(i);\n \n-        AtomicInteger checksum = null;\n+        Long checksum = null;\n         if (request.checksums() != null) {\n-          checksum = new AtomicInteger(Math.toIntExact(request.checksums().get(i)));\n+          checksum = request.checksums().get(i);\n         }\n \n         // Get the last entry written to the log by the writer.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NjU3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531476579", "bodyText": "Also add request size and checksum size to the log message.", "author": "deepthidevaki", "createdAt": "2020-11-27T09:22:20Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -437,11 +440,39 @@ private void abortPendingSnapshots() {\n       return future;\n     }\n \n+    if (!checkChecksums(request, future)) {\n+      return future;\n+    }\n+\n     // Append the entries to the log.\n     appendEntries(request, future);\n     return future;\n   }\n \n+  private boolean checkChecksums(\n+      final AppendRequest request, final CompletableFuture<AppendResponse> future) {\n+    if (request.checksums() != null) {\n+      boolean failed = false;\n+      if (request.entries().size() != request.checksums().size()) {\n+        log.debug(\"Rejected {}: expected the same number of checksums as entries\", request);", "originalCommit": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwMjc3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531502774", "bodyText": "That's what the request prints\n@Override\n  public String toString() {\n    return toStringHelper(this)\n        .add(\"term\", term)\n        .add(\"leader\", leader)\n        .add(\"prevLogIndex\", prevLogIndex)\n        .add(\"prevLogTerm\", prevLogTerm)\n        .add(\"entries\", entries.size())\n        .add(\"checksums\", checksums.size())\n        .add(\"commitIndex\", commitIndex)\n        .toString();\n  }", "author": "MiguelPires", "createdAt": "2020-11-27T10:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NjU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "chunk": "diff --git a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\nindex f82e58d2af..13d7b3edfb 100644\n--- a/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n+++ b/atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java\n\n@@ -451,23 +448,9 @@ public class PassiveRole extends InactiveRole {\n \n   private boolean checkChecksums(\n       final AppendRequest request, final CompletableFuture<AppendResponse> future) {\n-    if (request.checksums() != null) {\n-      boolean failed = false;\n-      if (request.entries().size() != request.checksums().size()) {\n-        log.debug(\"Rejected {}: expected the same number of checksums as entries\", request);\n-        failed = true;\n-      }\n-\n-      try {\n-        request.checksums().forEach(Math::toIntExact);\n-      } catch (final ArithmeticException e) {\n-        log.debug(\"Rejected {}: expected checksums to be fit into 4 bytes\", request);\n-        failed = true;\n-      }\n-\n-      if (failed) {\n-        return failAppend(raft.getLogWriter().getLastIndex(), future);\n-      }\n+    if (request.checksums() != null && request.entries().size() != request.checksums().size()) {\n+      log.debug(\"Rejected {}: expected the same number of checksums as entries\", request);\n+      return failAppend(raft.getLogWriter().getLastIndex(), future);\n     }\n \n     return true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3ODAwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531478009", "bodyText": "Please rename this function.", "author": "deepthidevaki", "createdAt": "2020-11-27T09:24:58Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.roles;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.metrics.RaftReplicationMetrics;\n+import io.atomix.raft.protocol.AppendRequest;\n+import io.atomix.raft.protocol.AppendResponse;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.RaftLog;\n+import io.atomix.raft.storage.log.RaftLogWriter;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.utils.serializer.NamespaceImpl;\n+import io.atomix.utils.serializer.NamespaceImpl.Builder;\n+import io.atomix.utils.serializer.Namespaces;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivableSnapshotStore;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.zip.CRC32;\n+import java.util.zip.Checksum;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+public class PassiveRoleTest {\n+\n+  private static final NamespaceImpl NAMESPACE =\n+      new Builder().register(Namespaces.BASIC).register(ZeebeEntry.class).build();\n+  @Rule public Timeout timeout = new Timeout(30, TimeUnit.SECONDS);\n+  private RaftContext ctx;\n+  private final ZeebeEntry entry = new ZeebeEntry(1, 1, 0, 1, ByteBuffer.allocate(0));\n+  private RaftLogWriter writer;\n+\n+  @Before\n+  public void setup() {\n+    final RaftStorage storage = mock(RaftStorage.class);\n+    when(storage.namespace()).thenReturn(NAMESPACE);\n+\n+    writer = mock(RaftLogWriter.class);\n+    when(writer.getLastIndex()).thenReturn(1L);\n+    when(writer.append(any(ZeebeEntry.class))).thenReturn(new Indexed<>(1, entry, 1, 1));\n+    when(writer.append(any(), anyInt())).thenReturn(new Indexed<>(1, entry, 1, 1));\n+\n+    final PersistedSnapshot snapshot = mock(PersistedSnapshot.class);\n+    when(snapshot.getIndex()).thenReturn(1L);\n+    when(snapshot.getTerm()).thenReturn(1L);\n+\n+    final ReceivableSnapshotStore store = mock(ReceivableSnapshotStore.class);\n+    when(store.getLatestSnapshot()).thenReturn(Optional.of(snapshot));\n+\n+    ctx = mock(RaftContext.class);\n+    when(ctx.getStorage()).thenReturn(storage);\n+    when(ctx.getLogWriter()).thenReturn(writer);\n+    when(ctx.getPersistedSnapshotStore()).thenReturn(store);\n+    when(ctx.getTerm()).thenReturn(1L);\n+    when(ctx.getReplicationMetrics()).thenReturn(mock(RaftReplicationMetrics.class));\n+    when(ctx.getLog()).thenReturn(mock(RaftLog.class));\n+  }\n+\n+  @Test\n+  public void shouldRejectRequestIfDifferentNumberEntriesAndChecksums() {\n+    // given\n+    final PassiveRole role = new PassiveRole(ctx);\n+    final List<RaftLogEntry> entries = generateEntries(1);\n+    final AppendRequest request = new AppendRequest(2, \"\", 1, 1, entries, List.of(1L, 2L), 1);\n+\n+    // when\n+    final AppendResponse response = role.handleAppend(request).join();\n+\n+    // then\n+    assertThat(response.succeeded()).isFalse();\n+  }\n+\n+  @Test\n+  public void shouldCreateValidatorForEntry() {", "originalCommit": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java b/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java\nindex 335901f371..b4850e61c1 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java\n\n@@ -17,10 +17,11 @@ package io.atomix.raft.roles;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3ODk1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531478950", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public <T extends E> Indexed<T> append(\n          \n          \n            \n              private <T extends E> Indexed<T> append(", "author": "deepthidevaki", "createdAt": "2020-11-27T09:26:42Z", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java", "diffHunk": "@@ -94,62 +95,85 @@ public long getNextIndex() {\n     }\n   }\n \n+  @Override\n+  public <T extends E> Indexed<T> append(final T entry, final int checksum) {\n+    return append(entry, true, checksum);\n+  }\n+\n   @Override\n   public <T extends E> Indexed<T> append(final T entry) {\n+    return append(entry, false, -1);\n+  }\n+\n+  public <T extends E> Indexed<T> append(", "originalCommit": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "chunk": "diff --git a/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java b/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java\nindex 2a752f1375..baa8a7fa89 100644\n--- a/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java\n+++ b/atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java\n\n@@ -96,82 +96,73 @@ class FileChannelJournalSegmentWriter<E> implements JournalWriter<E> {\n   }\n \n   @Override\n-  public <T extends E> Indexed<T> append(final T entry, final int checksum) {\n-    return append(entry, true, checksum);\n+  public <T extends E> Indexed<T> append(final T entry) {\n+    return append(entry, false, -1);\n   }\n \n   @Override\n-  public <T extends E> Indexed<T> append(final T entry) {\n-    return append(entry, false, -1);\n+  public <T extends E> Indexed<T> append(final T entry, final long checksum) {\n+    return append(entry, true, checksum);\n   }\n \n-  public <T extends E> Indexed<T> append(\n-      final T entry, final boolean validateChecksum, final int expectedChecksum) {\n+  private <T extends E> Indexed<T> append(\n+      final T entry, final boolean validateChecksum, final long expectedChecksum) {\n     // Store the entry index.\n     final long index = getNextIndex();\n \n     try {\n-      final int length = serializeEntry(entry);\n+      // Serialize the entry.\n+      memory.clear();\n+      memory.position(Integer.BYTES + Integer.BYTES);\n+      try {\n+        namespace.serialize(entry, memory);\n+      } catch (final KryoException e) {\n+        throw new StorageException.TooLarge(\n+            \"Entry size exceeds maximum allowed bytes (\" + maxEntrySize + \")\");\n+      }\n+      memory.flip();\n+\n+      final int length = memory.limit() - (Integer.BYTES + Integer.BYTES);\n+\n+      // Ensure there's enough space left in the buffer to store the entry.\n       final long position = channel.position();\n+      if (segment.descriptor().maxSegmentSize() - position\n+          < length + Integer.BYTES + Integer.BYTES) {\n+        throw new BufferOverflowException();\n+      }\n \n-      ensureEnoughSpace(length, position);\n+      // If the entry length exceeds the maximum entry size then throw an exception.\n+      if (length > maxEntrySize) {\n+        throw new StorageException.TooLarge(\n+            \"Entry size \" + length + \" exceeds maximum allowed bytes (\" + maxEntrySize + \")\");\n+      }\n \n-      memory.position(2 * Integer.BYTES);\n-      final int checksum = computeChecksum(memory.slice());\n-      if (validateChecksum && expectedChecksum != checksum) {\n+      final long checksum =\n+          computeChecksum(memory.array(), 2 * Integer.BYTES, memory.limit() - 2 * Integer.BYTES);\n+      if (validateChecksum && checksum != expectedChecksum) {\n         throw new StorageException.InvalidChecksum(\"Entry has an invalid checksum\");\n       }\n \n-      writeEntry(checksum, length);\n-      return (Indexed<T>) createIndexedEntry(entry, checksum, index, length, (int) position);\n+      // Create a single byte[] in memory for the entire entry and write it as a batch to the\n+      // underlying buffer.\n+      memory.putInt(0, length);\n+      memory.putInt(Integer.BYTES, (int) checksum);\n+      channel.write(memory);\n+\n+      // Update the last entry with the correct index/term/length.\n+      final Indexed<E> indexedEntry = new Indexed<>(index, entry, length, checksum);\n+      lastEntry = indexedEntry;\n+      this.index.index(lastEntry, (int) position);\n+      return (Indexed<T>) indexedEntry;\n     } catch (final IOException e) {\n       throw new StorageException(e);\n     }\n   }\n \n-  private <T extends E> Indexed<E> createIndexedEntry(\n-      final T entry, final long checksum, final long index, final int length, final int position) {\n-    final Indexed<E> indexedEntry = new Indexed<>(index, entry, length, checksum);\n-    lastEntry = indexedEntry;\n-    this.index.index(lastEntry, position);\n-    return indexedEntry;\n-  }\n-\n-  private void writeEntry(final int checksum, final int length) throws IOException {\n-    memory.putInt(0, length);\n-    memory.putInt(Integer.BYTES, checksum);\n-    channel.write(memory);\n-  }\n-\n-  private void ensureEnoughSpace(final int length, final long position) {\n-    if (segment.descriptor().maxSegmentSize() - position < length + Integer.BYTES + Integer.BYTES) {\n-      throw new BufferOverflowException();\n-    }\n-\n-    if (length > maxEntrySize) {\n-      throw new StorageException.TooLarge(\n-          \"Entry size \" + length + \" exceeds maximum allowed bytes (\" + maxEntrySize + \")\");\n-    }\n-  }\n-\n-  private int computeChecksum(final ByteBuffer buffer) {\n+  private long computeChecksum(final byte[] array, final int position, final int length) {\n     crc32.reset();\n-    crc32.update(buffer);\n-    return (int) crc32.getValue();\n-  }\n-\n-  private <T extends E> int serializeEntry(final T entry) {\n-    memory.clear();\n-    memory.position(Integer.BYTES + Integer.BYTES);\n-    try {\n-      namespace.serialize(entry, memory);\n-    } catch (final KryoException e) {\n-      throw new StorageException.TooLarge(\n-          \"Entry size exceeds maximum allowed bytes (\" + maxEntrySize + \")\");\n-    }\n-    memory.flip();\n-\n-    return memory.limit() - (Integer.BYTES + Integer.BYTES);\n+    crc32.update(array, position, length);\n+    return crc32.getValue();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MDAwMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531480003", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public <T extends E> Indexed<T> append(\n          \n          \n            \n              private <T extends E> Indexed<T> append(", "author": "deepthidevaki", "createdAt": "2020-11-27T09:28:41Z", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "diffHunk": "@@ -97,56 +98,75 @@ public long getNextIndex() {\n \n   @Override\n   public <T extends E> Indexed<T> append(final T entry) {\n-    // Store the entry index.\n-    final long index = getNextIndex();\n+    return append(entry, false, -1);\n+  }\n+\n+  @Override\n+  public <T extends E> Indexed<T> append(final T entry, final int checksum) {\n+    return append(entry, true, checksum);\n+  }\n \n-    // Serialize the entry.\n+  public <T extends E> Indexed<T> append(", "originalCommit": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "chunk": "diff --git a/atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java b/atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java\nindex 681304dcb0..7636cf89b7 100644\n--- a/atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java\n+++ b/atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java\n\n@@ -102,40 +102,32 @@ class MappedJournalSegmentWriter<E> implements JournalWriter<E> {\n   }\n \n   @Override\n-  public <T extends E> Indexed<T> append(final T entry, final int checksum) {\n+  public <T extends E> Indexed<T> append(final T entry, final long checksum) {\n     return append(entry, true, checksum);\n   }\n \n   public <T extends E> Indexed<T> append(\n-      final T entry, final boolean validateChecksum, final int expectedChecksum) {\n+      final T entry, final boolean validateChecksum, final long expectedChecksum) {\n+    // Store the entry index.\n     final long index = getNextIndex();\n-    final int position = buffer.position();\n-    serializeEntry(entry, position);\n-    final int length = buffer.position() - (position + Integer.BYTES + Integer.BYTES);\n-\n-    ensureEnoughSpace(position, length);\n \n-    buffer.position(position + 2 * Integer.BYTES);\n-    final int checksum = computeChecksum(buffer.slice().limit(length));\n-    if (validateChecksum && expectedChecksum != checksum) {\n-      throw new StorageException.InvalidChecksum(\"Entry has an invalid checksum\");\n+    // Serialize the entry.\n+    final int position = buffer.position();\n+    if (position + Integer.BYTES + Integer.BYTES > buffer.limit()) {\n+      throw new BufferOverflowException();\n     }\n \n-    buffer.position(position);\n-    buffer.putInt(length);\n-    buffer.putInt(checksum);\n-    buffer.position(position + Integer.BYTES + Integer.BYTES + length);\n+    buffer.position(position + Integer.BYTES + Integer.BYTES);\n \n-    return createIndexedEntry(entry, checksum, index, position, length);\n-  }\n+    try {\n+      namespace.serialize(entry, buffer);\n+    } catch (final KryoException e) {\n+      throw new BufferOverflowException();\n+    }\n \n-  private int computeChecksum(final ByteBuffer buffer) {\n-    crc32.reset();\n-    crc32.update(buffer);\n-    return (int) crc32.getValue();\n-  }\n+    final int length = buffer.position() - (position + Integer.BYTES + Integer.BYTES);\n \n-  private void ensureEnoughSpace(final int position, final int length) {\n+    // If the entry length exceeds the maximum entry size then throw an exception.\n     if (length > maxEntrySize) {\n       // Just reset the buffer. There's no need to zero the bytes since we haven't written the\n       // length or checksum.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4Nzk2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5844#discussion_r531487966", "bodyText": "We are missing a test to verify what happens when checksum is invalid.", "author": "deepthidevaki", "createdAt": "2020-11-27T09:43:08Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.roles;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.metrics.RaftReplicationMetrics;\n+import io.atomix.raft.protocol.AppendRequest;\n+import io.atomix.raft.protocol.AppendResponse;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.RaftLog;\n+import io.atomix.raft.storage.log.RaftLogWriter;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.utils.serializer.NamespaceImpl;\n+import io.atomix.utils.serializer.NamespaceImpl.Builder;\n+import io.atomix.utils.serializer.Namespaces;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivableSnapshotStore;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.zip.CRC32;\n+import java.util.zip.Checksum;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+public class PassiveRoleTest {", "originalCommit": "dbe364b9ca898afdff6072c4a55df1f1340a22e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "chunk": "diff --git a/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java b/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java\nindex 335901f371..b4850e61c1 100644\n--- a/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java\n+++ b/atomix/cluster/src/test/java/io/atomix/raft/roles/PassiveRoleTest.java\n\n@@ -17,10 +17,11 @@ package io.atomix.raft.roles;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n"}}, {"oid": "f67f1f2ac92a62132be347f4721052f5f2b785e2", "url": "https://github.com/camunda-cloud/zeebe/commit/f67f1f2ac92a62132be347f4721052f5f2b785e2", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-30T08:09:10Z", "type": "forcePushed"}, {"oid": "6c221e262434757e5167cf83a747c8d3683045a5", "url": "https://github.com/camunda-cloud/zeebe/commit/6c221e262434757e5167cf83a747c8d3683045a5", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-30T08:34:16Z", "type": "commit"}, {"oid": "6c221e262434757e5167cf83a747c8d3683045a5", "url": "https://github.com/camunda-cloud/zeebe/commit/6c221e262434757e5167cf83a747c8d3683045a5", "message": "chore(atomix): add checksum to append request", "committedDate": "2020-11-30T08:34:16Z", "type": "forcePushed"}]}