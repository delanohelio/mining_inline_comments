{"pr_number": 333, "pr_title": "WIP: Add moderation commands", "pr_createdAt": "2020-02-23T09:36:47Z", "pr_url": "https://github.com/PGMDev/PGM/pull/333", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MjIwNg==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383562206", "bodyText": "Do we really need this? Why not just use VERBOSE ?", "author": "Electroid", "createdAt": "2020-02-24T22:51:48Z", "path": "src/main/java/tc/oc/named/NameStyle.java", "diffHunk": "@@ -12,7 +12,8 @@\n   TAB(\n       true, true, true, true, true, false, true,\n       true), // Color, flair, friend status, nick status, death status\n-  VERBOSE(true, true, true, true, true, true, false, true); // Fancy plus nickname\n+  VERBOSE(true, true, true, true, true, true, false, true), // Fancy plus nickname\n+  CONCISE(true, true, true, true, true, true, false, false); // Verbose, but removes teleport", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MTcwNQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383581705", "bodyText": "If you're getting banned or kicked, a \"teleport to this player\" makes no sense", "author": "Pablete1234", "createdAt": "2020-02-24T23:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MjIwNg=="}], "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/named/NameStyle.java b/src/main/java/tc/oc/named/NameStyle.java\ndeleted file mode 100644\nindex 93d2d0a..0000000\n--- a/src/main/java/tc/oc/named/NameStyle.java\n+++ /dev/null\n\n@@ -1,45 +0,0 @@\n-package tc.oc.named;\n-\n-/**\n- * The formatting properties for each different context in which names are displayed. Unlike {@link\n- * NameType}, this varies only by context, and is independent of the viewer.\n- */\n-public enum NameStyle {\n-  PLAIN(false, false, false, false, false, false, false, false), // No formatting\n-  COLOR(true, false, false, false, false, false, false, true), // Color only\n-  FANCY(\n-      true, true, true, true, true, false, false, true), // Color, flair, friend status, nick status\n-  TAB(\n-      true, true, true, true, true, false, true,\n-      true), // Color, flair, friend status, nick status, death status\n-  VERBOSE(true, true, true, true, true, true, false, true), // Fancy plus nickname\n-  CONCISE(true, true, true, true, true, true, false, false); // Verbose, but removes teleport\n-\n-  public final boolean isColor;\n-  public final boolean showPrefix;\n-  public final boolean showSelf; // Bold if self\n-  public final boolean showFriend; // Italic if friend\n-  public final boolean showDisguise; // Strikethrough if disguised\n-  public final boolean showNickname; // Show nickname after real name\n-  public final boolean showDeath; // Grey out name if dead\n-  public final boolean teleport; // Click name to teleport\n-\n-  NameStyle(\n-      boolean isColor,\n-      boolean showPrefix,\n-      boolean showSelf,\n-      boolean showFriend,\n-      boolean showDisguise,\n-      boolean showNickname,\n-      boolean showDeath,\n-      boolean teleport) {\n-    this.isColor = isColor;\n-    this.showPrefix = showPrefix;\n-    this.showSelf = showSelf;\n-    this.showFriend = showFriend;\n-    this.showDisguise = showDisguise;\n-    this.showNickname = showNickname;\n-    this.showDeath = showDeath;\n-    this.teleport = teleport;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mjk3MQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383562971", "bodyText": "No need for a MODERATION, just do String KICK = ROOT + \".kick\";", "author": "Electroid", "createdAt": "2020-02-24T22:53:40Z", "path": "src/main/java/tc/oc/pgm/api/Permissions.java", "diffHunk": "@@ -31,6 +31,13 @@\n   String STAFF = ROOT + \".staff\"; // Considered apart of the staff team\n   String RELOAD = ROOT + \".reload\"; // Reload the PGM configuration\n \n+  // Individual permissions related to moderation\n+  String MODERATION = ROOT + \".moderation\"; // General node for moderation", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Njc5MA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383566790", "bodyText": "Also make sure MOD has these permissions as default.", "author": "Electroid", "createdAt": "2020-02-24T23:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mjk3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/api/Permissions.java b/src/main/java/tc/oc/pgm/api/Permissions.java\ndeleted file mode 100644\nindex 580c954..0000000\n--- a/src/main/java/tc/oc/pgm/api/Permissions.java\n+++ /dev/null\n\n@@ -1,142 +0,0 @@\n-package tc.oc.pgm.api;\n-\n-import com.google.common.collect.ImmutableMap;\n-import java.util.stream.Stream;\n-import org.bukkit.permissions.Permission;\n-import org.bukkit.permissions.PermissionDefault;\n-\n-/** This is a hard-coded list of permissions, that add the basic functionality. */\n-public interface Permissions {\n-\n-  // Root permission node\n-  String ROOT = \"pgm\";\n-\n-  // Root permission node for groups\n-  String GROUP = ROOT + \".group\";\n-\n-  // Individual permission nodes\n-  String START = ROOT + \".start\"; // Start and cycle matches\n-  String STOP = ROOT + \".stop\"; // Stop matches and restart the server\n-  String SETNEXT = ROOT + \".setnext\"; // Change the rotation and maps\n-  String ADMINCHAT = ROOT + \".adminchat\"; // Secret chat with other operators\n-  String GAMEPLAY = ROOT + \".gameplay\"; // Edit gameplay such as time limits, destroyables, modes\n-  String RESIZE = ROOT + \".resize\"; // Resize the number of players per match\n-  String JOIN = ROOT + \".join\"; // Allowed to join a match as a participant\n-  String JOIN_CHOOSE = JOIN + \".choose\"; // Can choose which team to join\n-  String JOIN_FULL = ROOT + \".full\"; // Can join a team or server if it is full\n-  String JOIN_FORCE = JOIN + \".force\"; // Can force other players onto teams\n-  String LEAVE = ROOT + \".leave\"; // Can join observers willingly\n-  String DEFUSE = ROOT + \".defuse\"; // Defuse tnt from observers using shears\n-  String DEBUG = ROOT + \".debug\"; // Errors from map loading and debug commands\n-  String STAFF = ROOT + \".staff\"; // Considered apart of the staff team\n-  String RELOAD = ROOT + \".reload\"; // Reload the PGM configuration\n-\n-  // Individual permissions related to moderation\n-  String MODERATION = ROOT + \".moderation\"; // General node for moderation\n-  String KICK = MODERATION + \".kick\"; // Access to the /kick command\n-  String WARN = MODERATION + \".warn\"; // Access to the /warn command\n-  String MUTE = MODERATION + \".mute\"; // Access to the /mute command\n-  String BAN = MODERATION + \".ban\"; // Access to the /ban command\n-\n-  // Role-specific permission nodes\n-  Permission DEFAULT =\n-      new Permission(\n-          \"pgm.default\",\n-          PermissionDefault.TRUE,\n-          new ImmutableMap.Builder<String, Boolean>().put(JOIN, true).put(LEAVE, true).build());\n-\n-  Permission PREMIUM =\n-      new Permission(\n-          \"pgm.premium\",\n-          PermissionDefault.FALSE,\n-          new ImmutableMap.Builder<String, Boolean>()\n-              .putAll(DEFAULT.getChildren())\n-              .put(JOIN_CHOOSE, true)\n-              .put(JOIN_FULL, true)\n-              .build());\n-\n-  Permission MODERATOR =\n-      new Permission(\n-          \"pgm.mod\",\n-          PermissionDefault.FALSE,\n-          new ImmutableMap.Builder<String, Boolean>()\n-              .putAll(PREMIUM.getChildren())\n-              .put(START, true)\n-              .put(STOP, true)\n-              .put(SETNEXT, true)\n-              .put(ADMINCHAT, true)\n-              .put(RESIZE, true)\n-              .put(JOIN_FORCE, true)\n-              .put(DEFUSE, true)\n-              .put(STAFF, true)\n-              .build());\n-\n-  Permission DEVELOPER =\n-      new Permission(\n-          \"pgm.dev\",\n-          PermissionDefault.FALSE,\n-          new ImmutableMap.Builder<String, Boolean>()\n-              .putAll(MODERATOR.getChildren())\n-              .put(GAMEPLAY, true)\n-              .put(DEBUG, true)\n-              .put(RELOAD, true)\n-              .build());\n-\n-  Permission ALL = new Permission(\"pgm.*\", PermissionDefault.OP, DEVELOPER.getChildren());\n-\n-  // Global-disable permission nodes\n-  Permission DISABLE =\n-      new Permission(\n-          \"pgm.disable\",\n-          PermissionDefault.NOT_OP,\n-          new ImmutableMap.Builder<String, Boolean>()\n-              .put(\"worldedit.navigation.ceiling\", false)\n-              .put(\"worldedit.navigation.up\", false)\n-              .put(\"worldedit.calc\", false)\n-              .put(\"bukkit.command.kill\", false)\n-              .put(\"bukkit.command.me\", false)\n-              .put(\"bukkit.command.tell\", false)\n-              .put(\"commandbook.pong\", false)\n-              .put(\"commandbook.speed.flight\", false)\n-              .put(\"commandbook.speed.walk\", false)\n-              .build());\n-\n-  // Party-specific permission nodes\n-  Permission PARTICIPANT =\n-      new Permission(\n-          \"pgm.participant\",\n-          PermissionDefault.FALSE,\n-          new ImmutableMap.Builder<String, Boolean>()\n-              .putAll(DISABLE.getChildren())\n-              .put(\"worldedit.navigation.jumpto.tool\", false)\n-              .put(\"worldedit.navigation.thru.tool\", false)\n-              .put(\"commandbook.teleport\", false)\n-              .build());\n-  Permission OBSERVER =\n-      new Permission(\n-          \"pgm.observer\",\n-          PermissionDefault.FALSE,\n-          new ImmutableMap.Builder<String, Boolean>()\n-              .putAll(DISABLE.getChildren())\n-              .put(\"worldedit.navigation.*\", true)\n-              .put(\"commandbook.teleport\", true)\n-              .build());\n-\n-  static void registerAll() {\n-    Stream.of(DEFAULT, PREMIUM, MODERATOR, DEVELOPER, ALL, PARTICIPANT, OBSERVER)\n-        .forEachOrdered(Permissions::register);\n-  }\n-\n-  static Permission register(Permission permission) {\n-    PGM.get().getServer().getPluginManager().addPermission(permission);\n-    return permission;\n-  }\n-\n-  static Permission register(String node, PermissionDefault def) {\n-    Permission permission = PGM.get().getServer().getPluginManager().getPermission(node);\n-    if (permission == null) {\n-      permission = register(new Permission(node, def));\n-    }\n-    return permission;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mzk0Nw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383563947", "bodyText": "Not sure what the -w flag does, it's ambiguous.", "author": "Electroid", "createdAt": "2020-02-24T22:56:09Z", "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MzY3MA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383583670", "bodyText": "If it should also send the mute message as a warn to the player (title/dragon noise).\nEquivalent to doing 2 commands at once:\n/mute player reason\n/warn player reason", "author": "Pablete1234", "createdAt": "2020-02-24T23:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mzk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/community/ModerationCommands.java b/src/main/java/tc/oc/pgm/community/ModerationCommands.java\ndeleted file mode 100644\nindex 858b7aa..0000000\n--- a/src/main/java/tc/oc/pgm/community/ModerationCommands.java\n+++ /dev/null\n\n@@ -1,434 +0,0 @@\n-package tc.oc.pgm.community;\n-\n-import app.ashcon.intake.Command;\n-import app.ashcon.intake.parametric.annotation.Switch;\n-import app.ashcon.intake.parametric.annotation.Text;\n-import com.google.common.collect.Lists;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-import net.md_5.bungee.api.ChatColor;\n-import org.bukkit.BanList;\n-import org.bukkit.Bukkit;\n-import org.bukkit.command.CommandSender;\n-import org.bukkit.entity.Player;\n-import tc.oc.component.Component;\n-import tc.oc.component.render.ComponentRenderers;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.Config;\n-import tc.oc.pgm.api.Permissions;\n-import tc.oc.pgm.api.chat.Sound;\n-import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.events.PlayerPunishmentEvent;\n-import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n-import tc.oc.pgm.listeners.ChatDispatcher;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n-import tc.oc.util.components.PeriodFormats;\n-\n-public class ModerationCommands {\n-\n-  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n-\n-  private static final Component WARN_SYMBOL =\n-      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n-  private static final Component BROADCAST_DIV =\n-      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n-  private static final Component CONSOLE_NAME =\n-      new PersonalizedTranslatable(\"console\")\n-          .getPersonalizedText()\n-          .color(ChatColor.DARK_AQUA)\n-          .italic(true);\n-\n-  private final ChatDispatcher chat;\n-\n-  public ModerationCommands(ChatDispatcher chat) {\n-    this.chat = chat;\n-  }\n-\n-  @Command(\n-      aliases = {\"staff\", \"mods\", \"admins\"},\n-      desc = \"List the online staff members\")\n-  public void staff(CommandSender sender, Match match) {\n-    // List of online staff based off of permission\n-    List<Component> onlineStaff =\n-        match.getPlayers().stream()\n-            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n-            .map(player -> player.getStyledName(NameStyle.FANCY))\n-            .collect(Collectors.toList());\n-\n-    // FORMAT: Online Staff ({count}): {names}\n-    Component staffCount =\n-        new PersonalizedText(Integer.toString(onlineStaff.size()))\n-            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n-\n-    Component content =\n-        onlineStaff.isEmpty()\n-            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n-                .getPersonalizedText()\n-                .color(ChatColor.RED)\n-            : new Component(\n-                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n-\n-    Component staff =\n-        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY);\n-\n-    // Send message\n-    sender.sendMessage(staff);\n-  }\n-\n-  @Command(\n-      aliases = {\"mute\", \"m\"},\n-      usage = \"<player> <reason> -s (silent) -w (warn)\",\n-      desc = \"Mute a player\",\n-      perms = Permissions.MUTE)\n-  public void mute(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent,\n-      @Switch('w') boolean warn) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-\n-    if (chat.isMuted(targetMatchPlayer)) {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-      return;\n-    }\n-\n-    // if -w flag, also warn the player but don't broadcast warning\n-    if (warn) {\n-      warn(sender, target, match, reason, true);\n-    }\n-\n-    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n-      chat.addMuted(targetMatchPlayer);\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"unmute\", \"um\"},\n-      usage = \"<player>\",\n-      desc = \"Unmute a player\",\n-      perms = Permissions.MUTE)\n-  public void unMute(CommandSender sender, Player target, Match match) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    if (chat.isMuted(targetMatchPlayer)) {\n-      chat.removeMuted(targetMatchPlayer);\n-\n-      targetMatchPlayer.sendMessage(\n-          new PersonalizedTranslatable(\"moderation.unmute.target\")\n-              .getPersonalizedText()\n-              .color(ChatColor.GREEN));\n-\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .color(ChatColor.GRAY));\n-    } else {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"warn\", \"w\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Warn a player for bad behavior\",\n-      perms = Permissions.WARN)\n-  public void warn(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-\n-    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n-      sendWarning(targetMatchPlayer, reason);\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"kick\", \"k\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Kick a player from the server\",\n-      perms = Permissions.KICK)\n-  public void kick(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n-      target.kickPlayer(\n-          formatPunishmentScreen(\n-              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"ban\", \"permban\", \"pb\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Ban a player from the server forever\",\n-      perms = Permissions.BAN)\n-  public void ban(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    Component senderName = formatPunisherName(sender, match);\n-    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {\n-      banPlayer(target, reason, senderName, null);\n-      target.kickPlayer(formatPunishmentScreen(PunishmentType.BAN, senderName, reason, null));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"tempban\", \"tban\", \"tb\"},\n-      usage = \"<player> <time> <reason> -s (silent)\",\n-      desc = \"Ban a player from the server for a period of time\",\n-      perms = Permissions.BAN)\n-  public void tempBan(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      Duration banLength,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    PlayerTimedPunishmentEvent event =\n-        new PlayerTimedPunishmentEvent(\n-            sender, targetMatchPlayer, PunishmentType.TEMP_BAN, reason, silent, banLength);\n-    match.callEvent(event);\n-    if (!event.isCancelled()) {\n-      broadcastPunishment(event);\n-      banPlayer(target, reason, formatPunisherName(sender, match), event.getExpiryDate());\n-      target.kickPlayer(\n-          formatPunishmentScreen(\n-              PunishmentType.TEMP_BAN, formatPunisherName(sender, match), reason, banLength));\n-    } else if (event.getCancelMessage() != null) {\n-      sender.sendMessage(event.getCancelMessage());\n-    }\n-  }\n-\n-  private boolean punish(\n-      PunishmentType type,\n-      MatchPlayer target,\n-      CommandSender issuer,\n-      String reason,\n-      boolean silent) {\n-    PlayerPunishmentEvent event = new PlayerPunishmentEvent(issuer, target, type, reason, silent);\n-    target.getMatch().callEvent(event);\n-    if (event.isCancelled()) {\n-      if (event.getCancelMessage() != null) {\n-        issuer.sendMessage(event.getCancelMessage());\n-      }\n-    } else if (!silent) {\n-      broadcastPunishment(event);\n-    }\n-    return !event.isCancelled();\n-  }\n-\n-  public static enum PunishmentType {\n-    MUTE(false),\n-    WARN(false),\n-    KICK(true),\n-    BAN(true),\n-    TEMP_BAN(true);\n-\n-    private String PREFIX_TRANSLATE_KEY = \"moderation.type.\";\n-    private String SCREEN_TRANSLATE_KEY = \"moderation.screen.\";\n-\n-    private final boolean screen;\n-\n-    PunishmentType(boolean screen) {\n-      this.screen = screen;\n-    }\n-\n-    public Component getPunishmentPrefix() {\n-      return new PersonalizedTranslatable(PREFIX_TRANSLATE_KEY + name().toLowerCase())\n-          .getPersonalizedText()\n-          .color(ChatColor.RED);\n-    }\n-\n-    public Component getScreenComponent(Component reason) {\n-      if (!screen) return Components.blank();\n-      return new PersonalizedTranslatable(SCREEN_TRANSLATE_KEY + name().toLowerCase(), reason)\n-          .getPersonalizedText()\n-          .color(ChatColor.GOLD);\n-    }\n-  }\n-\n-  /*\n-   * Format Punisher Name\n-   */\n-  public static Component formatPunisherName(CommandSender sender, Match match) {\n-    if (sender != null && sender instanceof Player) {\n-      MatchPlayer matchPlayer = match.getPlayer((Player) sender);\n-      if (matchPlayer != null) return matchPlayer.getStyledName(NameStyle.FANCY);\n-    }\n-    return CONSOLE_NAME;\n-  }\n-\n-  /*\n-   * Format Reason\n-   */\n-  public static Component formatPunishmentReason(String reason) {\n-    return new PersonalizedText(reason).color(ChatColor.RED);\n-  }\n-\n-  /*\n-   * Formatting of Kick Screens (KICK/BAN/TEMPBAN)\n-   */\n-  public static String formatPunishmentScreen(\n-      PunishmentType type, Component punisher, String reason, @Nullable Duration expires) {\n-    List<Component> lines = Lists.newArrayList();\n-\n-    Component header =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLineHeading(\n-                Config.Moderation.getServerName(), ChatColor.DARK_GRAY));\n-\n-    Component footer =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLine(ChatColor.DARK_GRAY, ComponentUtils.MAX_CHAT_WIDTH));\n-\n-    Component rules = new PersonalizedText(Config.Moderation.getRulesLink()).color(ChatColor.AQUA);\n-\n-    lines.add(header); // Header Line (server name) - START\n-    lines.add(Components.blank());\n-    lines.add(type.getScreenComponent(formatPunishmentReason(reason))); // The reason\n-    lines.add(Components.blank());\n-\n-    // If punishment expires, inform user when\n-    if (expires != null) {\n-      Component timeLeft =\n-          PeriodFormats.briefNaturalApproximate(\n-              org.joda.time.Duration.standardSeconds(expires.getSeconds()));\n-      lines.add(\n-          new PersonalizedTranslatable(\"moderation.screen.expires\", timeLeft)\n-              .getPersonalizedText()\n-              .color(ChatColor.GRAY));\n-      lines.add(Components.blank());\n-    }\n-\n-    // Staff sign-off\n-    lines.add(\n-        new PersonalizedTranslatable(\"moderation.screen.signoff\", punisher)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY)); // The sign-off of who performed the punishment\n-\n-    // Link to rules for review by player\n-    if (Config.Moderation.isRuleLinkVisible()) {\n-      lines.add(Components.blank());\n-      lines.add(\n-          new PersonalizedTranslatable(\"moderation.screen.rulesLink\", rules)\n-              .getPersonalizedText()\n-              .color(ChatColor.GRAY)); // A link to the rules\n-    }\n-\n-    // Configurable last line (for appeal message or etc)\n-    if (Config.Moderation.isAppealVisible()\n-        && (type.equals(PunishmentType.BAN) || type.equals(PunishmentType.TEMP_BAN))) {\n-      lines.add(Components.blank());\n-      lines.add(new PersonalizedText(Config.Moderation.getAppealMessage()));\n-    }\n-\n-    lines.add(Components.blank());\n-    lines.add(footer); // Footer line - END\n-\n-    return Components.join(new PersonalizedText(\"\\n\" + ChatColor.RESET), lines).toLegacyText();\n-  }\n-\n-  /*\n-   * Sends a formatted title and plays a sound warning a user of their actions\n-   */\n-  private void sendWarning(MatchPlayer target, String reason) {\n-    Component titleWord =\n-        new PersonalizedTranslatable(\"moderation.warning\")\n-            .getPersonalizedText()\n-            .color(ChatColor.DARK_RED);\n-    Component title = new PersonalizedText(WARN_SYMBOL, titleWord, WARN_SYMBOL);\n-    Component subtitle = formatPunishmentReason(reason).color(ChatColor.GOLD);\n-\n-    target.showTitle(title, subtitle, 5, 200, 10);\n-    target.playSound(WARN_SOUND);\n-  }\n-\n-  private void broadcastPunishment(PlayerPunishmentEvent event) {\n-    broadcastPunishment(\n-        event.getType(),\n-        event.getPlayer().getMatch(),\n-        event.getSender(),\n-        event.getPlayer(),\n-        event.getReason(),\n-        event.isSilent());\n-  }\n-\n-  /*\n-   * Broadcasts a punishment\n-   */\n-  private void broadcastPunishment(\n-      PunishmentType type,\n-      Match match,\n-      CommandSender sender,\n-      MatchPlayer target,\n-      String reason,\n-      boolean silent) {\n-    Component prefix =\n-        new PersonalizedTranslatable(\"moderation.punishment.prefix\", type.getPunishmentPrefix())\n-            .getPersonalizedText()\n-            .color(ChatColor.GOLD);\n-    Component targetName = target.getStyledName(NameStyle.FANCY);\n-    Component reasonMsg = ModerationCommands.formatPunishmentReason(reason);\n-    Component formattedMsg =\n-        new PersonalizedText(\n-            prefix,\n-            Components.space(),\n-            ModerationCommands.formatPunisherName(sender, match),\n-            BROADCAST_DIV,\n-            targetName,\n-            BROADCAST_DIV,\n-            reasonMsg);\n-\n-    if (!silent) {\n-      match.sendMessage(formattedMsg);\n-    } else {\n-      // if silent flag present, only notify sender\n-      sender.sendMessage(formattedMsg);\n-    }\n-  }\n-\n-  /*\n-   * Bukkit method of banning players\n-   * NOTE: Will use this if not handled by other plugins\n-   */\n-  private void banPlayer(\n-      Player target, String reason, Component source, @Nullable Instant expires) {\n-    Bukkit.getBanList(BanList.Type.NAME)\n-        .addBan(\n-            target.getName(),\n-            reason,\n-            expires != null ? Date.from(expires) : null,\n-            ComponentRenderers.toLegacyText(source, target));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NDE0OA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383564148", "bodyText": "What's the point of a silent mute?", "author": "Electroid", "createdAt": "2020-02-24T22:56:34Z", "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NDMzMw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383584333", "bodyText": "Not telling the whole server you have muted someone.\nAll punishments, if not silent, send a global message announcing the punishment, like: \"Mod punishment Player for reason\"", "author": "Pablete1234", "createdAt": "2020-02-24T23:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NDE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/community/ModerationCommands.java b/src/main/java/tc/oc/pgm/community/ModerationCommands.java\ndeleted file mode 100644\nindex 858b7aa..0000000\n--- a/src/main/java/tc/oc/pgm/community/ModerationCommands.java\n+++ /dev/null\n\n@@ -1,434 +0,0 @@\n-package tc.oc.pgm.community;\n-\n-import app.ashcon.intake.Command;\n-import app.ashcon.intake.parametric.annotation.Switch;\n-import app.ashcon.intake.parametric.annotation.Text;\n-import com.google.common.collect.Lists;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-import net.md_5.bungee.api.ChatColor;\n-import org.bukkit.BanList;\n-import org.bukkit.Bukkit;\n-import org.bukkit.command.CommandSender;\n-import org.bukkit.entity.Player;\n-import tc.oc.component.Component;\n-import tc.oc.component.render.ComponentRenderers;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.Config;\n-import tc.oc.pgm.api.Permissions;\n-import tc.oc.pgm.api.chat.Sound;\n-import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.events.PlayerPunishmentEvent;\n-import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n-import tc.oc.pgm.listeners.ChatDispatcher;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n-import tc.oc.util.components.PeriodFormats;\n-\n-public class ModerationCommands {\n-\n-  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n-\n-  private static final Component WARN_SYMBOL =\n-      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n-  private static final Component BROADCAST_DIV =\n-      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n-  private static final Component CONSOLE_NAME =\n-      new PersonalizedTranslatable(\"console\")\n-          .getPersonalizedText()\n-          .color(ChatColor.DARK_AQUA)\n-          .italic(true);\n-\n-  private final ChatDispatcher chat;\n-\n-  public ModerationCommands(ChatDispatcher chat) {\n-    this.chat = chat;\n-  }\n-\n-  @Command(\n-      aliases = {\"staff\", \"mods\", \"admins\"},\n-      desc = \"List the online staff members\")\n-  public void staff(CommandSender sender, Match match) {\n-    // List of online staff based off of permission\n-    List<Component> onlineStaff =\n-        match.getPlayers().stream()\n-            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n-            .map(player -> player.getStyledName(NameStyle.FANCY))\n-            .collect(Collectors.toList());\n-\n-    // FORMAT: Online Staff ({count}): {names}\n-    Component staffCount =\n-        new PersonalizedText(Integer.toString(onlineStaff.size()))\n-            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n-\n-    Component content =\n-        onlineStaff.isEmpty()\n-            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n-                .getPersonalizedText()\n-                .color(ChatColor.RED)\n-            : new Component(\n-                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n-\n-    Component staff =\n-        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY);\n-\n-    // Send message\n-    sender.sendMessage(staff);\n-  }\n-\n-  @Command(\n-      aliases = {\"mute\", \"m\"},\n-      usage = \"<player> <reason> -s (silent) -w (warn)\",\n-      desc = \"Mute a player\",\n-      perms = Permissions.MUTE)\n-  public void mute(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent,\n-      @Switch('w') boolean warn) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-\n-    if (chat.isMuted(targetMatchPlayer)) {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-      return;\n-    }\n-\n-    // if -w flag, also warn the player but don't broadcast warning\n-    if (warn) {\n-      warn(sender, target, match, reason, true);\n-    }\n-\n-    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n-      chat.addMuted(targetMatchPlayer);\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"unmute\", \"um\"},\n-      usage = \"<player>\",\n-      desc = \"Unmute a player\",\n-      perms = Permissions.MUTE)\n-  public void unMute(CommandSender sender, Player target, Match match) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    if (chat.isMuted(targetMatchPlayer)) {\n-      chat.removeMuted(targetMatchPlayer);\n-\n-      targetMatchPlayer.sendMessage(\n-          new PersonalizedTranslatable(\"moderation.unmute.target\")\n-              .getPersonalizedText()\n-              .color(ChatColor.GREEN));\n-\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .color(ChatColor.GRAY));\n-    } else {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"warn\", \"w\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Warn a player for bad behavior\",\n-      perms = Permissions.WARN)\n-  public void warn(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-\n-    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n-      sendWarning(targetMatchPlayer, reason);\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"kick\", \"k\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Kick a player from the server\",\n-      perms = Permissions.KICK)\n-  public void kick(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n-      target.kickPlayer(\n-          formatPunishmentScreen(\n-              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"ban\", \"permban\", \"pb\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Ban a player from the server forever\",\n-      perms = Permissions.BAN)\n-  public void ban(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    Component senderName = formatPunisherName(sender, match);\n-    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {\n-      banPlayer(target, reason, senderName, null);\n-      target.kickPlayer(formatPunishmentScreen(PunishmentType.BAN, senderName, reason, null));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"tempban\", \"tban\", \"tb\"},\n-      usage = \"<player> <time> <reason> -s (silent)\",\n-      desc = \"Ban a player from the server for a period of time\",\n-      perms = Permissions.BAN)\n-  public void tempBan(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      Duration banLength,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    PlayerTimedPunishmentEvent event =\n-        new PlayerTimedPunishmentEvent(\n-            sender, targetMatchPlayer, PunishmentType.TEMP_BAN, reason, silent, banLength);\n-    match.callEvent(event);\n-    if (!event.isCancelled()) {\n-      broadcastPunishment(event);\n-      banPlayer(target, reason, formatPunisherName(sender, match), event.getExpiryDate());\n-      target.kickPlayer(\n-          formatPunishmentScreen(\n-              PunishmentType.TEMP_BAN, formatPunisherName(sender, match), reason, banLength));\n-    } else if (event.getCancelMessage() != null) {\n-      sender.sendMessage(event.getCancelMessage());\n-    }\n-  }\n-\n-  private boolean punish(\n-      PunishmentType type,\n-      MatchPlayer target,\n-      CommandSender issuer,\n-      String reason,\n-      boolean silent) {\n-    PlayerPunishmentEvent event = new PlayerPunishmentEvent(issuer, target, type, reason, silent);\n-    target.getMatch().callEvent(event);\n-    if (event.isCancelled()) {\n-      if (event.getCancelMessage() != null) {\n-        issuer.sendMessage(event.getCancelMessage());\n-      }\n-    } else if (!silent) {\n-      broadcastPunishment(event);\n-    }\n-    return !event.isCancelled();\n-  }\n-\n-  public static enum PunishmentType {\n-    MUTE(false),\n-    WARN(false),\n-    KICK(true),\n-    BAN(true),\n-    TEMP_BAN(true);\n-\n-    private String PREFIX_TRANSLATE_KEY = \"moderation.type.\";\n-    private String SCREEN_TRANSLATE_KEY = \"moderation.screen.\";\n-\n-    private final boolean screen;\n-\n-    PunishmentType(boolean screen) {\n-      this.screen = screen;\n-    }\n-\n-    public Component getPunishmentPrefix() {\n-      return new PersonalizedTranslatable(PREFIX_TRANSLATE_KEY + name().toLowerCase())\n-          .getPersonalizedText()\n-          .color(ChatColor.RED);\n-    }\n-\n-    public Component getScreenComponent(Component reason) {\n-      if (!screen) return Components.blank();\n-      return new PersonalizedTranslatable(SCREEN_TRANSLATE_KEY + name().toLowerCase(), reason)\n-          .getPersonalizedText()\n-          .color(ChatColor.GOLD);\n-    }\n-  }\n-\n-  /*\n-   * Format Punisher Name\n-   */\n-  public static Component formatPunisherName(CommandSender sender, Match match) {\n-    if (sender != null && sender instanceof Player) {\n-      MatchPlayer matchPlayer = match.getPlayer((Player) sender);\n-      if (matchPlayer != null) return matchPlayer.getStyledName(NameStyle.FANCY);\n-    }\n-    return CONSOLE_NAME;\n-  }\n-\n-  /*\n-   * Format Reason\n-   */\n-  public static Component formatPunishmentReason(String reason) {\n-    return new PersonalizedText(reason).color(ChatColor.RED);\n-  }\n-\n-  /*\n-   * Formatting of Kick Screens (KICK/BAN/TEMPBAN)\n-   */\n-  public static String formatPunishmentScreen(\n-      PunishmentType type, Component punisher, String reason, @Nullable Duration expires) {\n-    List<Component> lines = Lists.newArrayList();\n-\n-    Component header =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLineHeading(\n-                Config.Moderation.getServerName(), ChatColor.DARK_GRAY));\n-\n-    Component footer =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLine(ChatColor.DARK_GRAY, ComponentUtils.MAX_CHAT_WIDTH));\n-\n-    Component rules = new PersonalizedText(Config.Moderation.getRulesLink()).color(ChatColor.AQUA);\n-\n-    lines.add(header); // Header Line (server name) - START\n-    lines.add(Components.blank());\n-    lines.add(type.getScreenComponent(formatPunishmentReason(reason))); // The reason\n-    lines.add(Components.blank());\n-\n-    // If punishment expires, inform user when\n-    if (expires != null) {\n-      Component timeLeft =\n-          PeriodFormats.briefNaturalApproximate(\n-              org.joda.time.Duration.standardSeconds(expires.getSeconds()));\n-      lines.add(\n-          new PersonalizedTranslatable(\"moderation.screen.expires\", timeLeft)\n-              .getPersonalizedText()\n-              .color(ChatColor.GRAY));\n-      lines.add(Components.blank());\n-    }\n-\n-    // Staff sign-off\n-    lines.add(\n-        new PersonalizedTranslatable(\"moderation.screen.signoff\", punisher)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY)); // The sign-off of who performed the punishment\n-\n-    // Link to rules for review by player\n-    if (Config.Moderation.isRuleLinkVisible()) {\n-      lines.add(Components.blank());\n-      lines.add(\n-          new PersonalizedTranslatable(\"moderation.screen.rulesLink\", rules)\n-              .getPersonalizedText()\n-              .color(ChatColor.GRAY)); // A link to the rules\n-    }\n-\n-    // Configurable last line (for appeal message or etc)\n-    if (Config.Moderation.isAppealVisible()\n-        && (type.equals(PunishmentType.BAN) || type.equals(PunishmentType.TEMP_BAN))) {\n-      lines.add(Components.blank());\n-      lines.add(new PersonalizedText(Config.Moderation.getAppealMessage()));\n-    }\n-\n-    lines.add(Components.blank());\n-    lines.add(footer); // Footer line - END\n-\n-    return Components.join(new PersonalizedText(\"\\n\" + ChatColor.RESET), lines).toLegacyText();\n-  }\n-\n-  /*\n-   * Sends a formatted title and plays a sound warning a user of their actions\n-   */\n-  private void sendWarning(MatchPlayer target, String reason) {\n-    Component titleWord =\n-        new PersonalizedTranslatable(\"moderation.warning\")\n-            .getPersonalizedText()\n-            .color(ChatColor.DARK_RED);\n-    Component title = new PersonalizedText(WARN_SYMBOL, titleWord, WARN_SYMBOL);\n-    Component subtitle = formatPunishmentReason(reason).color(ChatColor.GOLD);\n-\n-    target.showTitle(title, subtitle, 5, 200, 10);\n-    target.playSound(WARN_SOUND);\n-  }\n-\n-  private void broadcastPunishment(PlayerPunishmentEvent event) {\n-    broadcastPunishment(\n-        event.getType(),\n-        event.getPlayer().getMatch(),\n-        event.getSender(),\n-        event.getPlayer(),\n-        event.getReason(),\n-        event.isSilent());\n-  }\n-\n-  /*\n-   * Broadcasts a punishment\n-   */\n-  private void broadcastPunishment(\n-      PunishmentType type,\n-      Match match,\n-      CommandSender sender,\n-      MatchPlayer target,\n-      String reason,\n-      boolean silent) {\n-    Component prefix =\n-        new PersonalizedTranslatable(\"moderation.punishment.prefix\", type.getPunishmentPrefix())\n-            .getPersonalizedText()\n-            .color(ChatColor.GOLD);\n-    Component targetName = target.getStyledName(NameStyle.FANCY);\n-    Component reasonMsg = ModerationCommands.formatPunishmentReason(reason);\n-    Component formattedMsg =\n-        new PersonalizedText(\n-            prefix,\n-            Components.space(),\n-            ModerationCommands.formatPunisherName(sender, match),\n-            BROADCAST_DIV,\n-            targetName,\n-            BROADCAST_DIV,\n-            reasonMsg);\n-\n-    if (!silent) {\n-      match.sendMessage(formattedMsg);\n-    } else {\n-      // if silent flag present, only notify sender\n-      sender.sendMessage(formattedMsg);\n-    }\n-  }\n-\n-  /*\n-   * Bukkit method of banning players\n-   * NOTE: Will use this if not handled by other plugins\n-   */\n-  private void banPlayer(\n-      Player target, String reason, Component source, @Nullable Instant expires) {\n-    Bukkit.getBanList(BanList.Type.NAME)\n-        .addBan(\n-            target.getName(),\n-            reason,\n-            expires != null ? Date.from(expires) : null,\n-            ComponentRenderers.toLegacyText(source, target));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTIwOA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565208", "bodyText": "Should this be a Cache instead? Maybe only keep reports for the last hour? If the server stays up for a day, doesn't make sense to show reports from the previous day.", "author": "Electroid", "createdAt": "2020-02-24T22:59:18Z", "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "diffHunk": "@@ -27,22 +35,26 @@\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n import tc.oc.pgm.events.PlayerReportEvent;\n-import tc.oc.util.components.Components;\n+import tc.oc.pgm.util.PrettyPaginatedComponentResults;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.PeriodFormats;\n \n-public class ModerationCommands {\n+public class ReportCommands {\n+\n+  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n \n   private static final int REPORT_COOLDOWN_SECONDS = 15;\n \n-  private static final Cache<UUID, Instant> LAST_REPORT_SENT =\n+  private final Cache<UUID, Instant> LAST_REPORT_SENT =\n       CacheBuilder.newBuilder().expireAfterWrite(REPORT_COOLDOWN_SECONDS, TimeUnit.SECONDS).build();\n \n-  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n+  private final List<Report> RECENT_REPORTS = Lists.newArrayList();", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/community/ReportCommands.java b/src/main/java/tc/oc/pgm/community/ReportCommands.java\ndeleted file mode 100644\nindex 2deb86f..0000000\n--- a/src/main/java/tc/oc/pgm/community/ReportCommands.java\n+++ /dev/null\n\n@@ -1,268 +0,0 @@\n-package tc.oc.pgm.community;\n-\n-import app.ashcon.intake.Command;\n-import app.ashcon.intake.CommandException;\n-import app.ashcon.intake.bukkit.parametric.Type;\n-import app.ashcon.intake.bukkit.parametric.annotation.Fallback;\n-import app.ashcon.intake.parametric.annotation.Default;\n-import app.ashcon.intake.parametric.annotation.Switch;\n-import app.ashcon.intake.parametric.annotation.Text;\n-import com.google.common.cache.Cache;\n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.collect.Lists;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import net.md_5.bungee.api.ChatColor;\n-import net.md_5.bungee.api.chat.HoverEvent.Action;\n-import org.bukkit.Bukkit;\n-import org.bukkit.command.CommandSender;\n-import org.bukkit.entity.Player;\n-import tc.oc.component.Component;\n-import tc.oc.component.render.ComponentRenderers;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.api.Permissions;\n-import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.chat.Sound;\n-import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.api.setting.SettingKey;\n-import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.events.PlayerReportEvent;\n-import tc.oc.pgm.util.PrettyPaginatedComponentResults;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.PeriodFormats;\n-\n-public class ReportCommands {\n-\n-  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n-\n-  private static final int REPORT_COOLDOWN_SECONDS = 15;\n-\n-  private final Cache<UUID, Instant> LAST_REPORT_SENT =\n-      CacheBuilder.newBuilder().expireAfterWrite(REPORT_COOLDOWN_SECONDS, TimeUnit.SECONDS).build();\n-\n-  private final List<Report> RECENT_REPORTS = Lists.newArrayList();\n-\n-  @Command(\n-      aliases = {\"report\"},\n-      usage = \"<player> <reason>\",\n-      desc = \"Report a player who is breaking the rules\")\n-  public void report(\n-      CommandSender commandSender,\n-      MatchPlayer matchPlayer,\n-      Match match,\n-      Player player,\n-      @Text String reason)\n-      throws CommandException {\n-    if (!commandSender.hasPermission(Permissions.STAFF) && commandSender instanceof Player) {\n-      // Check for cooldown\n-      Instant lastReport = LAST_REPORT_SENT.getIfPresent(matchPlayer.getId());\n-      if (lastReport != null) {\n-        Duration timeSinceReport = Duration.between(lastReport, Instant.now());\n-        long secondsRemaining = REPORT_COOLDOWN_SECONDS - timeSinceReport.getSeconds();\n-        if (secondsRemaining > 0) {\n-          Component secondsComponent = new PersonalizedText(Long.toString(secondsRemaining));\n-          Component secondsLeftComponent =\n-              new PersonalizedTranslatable(\n-                      secondsRemaining != 1\n-                          ? \"countdown.pluralCompound\"\n-                          : \"countdown.singularCompound\",\n-                      secondsComponent)\n-                  .getPersonalizedText()\n-                  .color(ChatColor.AQUA);\n-          commandSender.sendMessage(\n-              new PersonalizedTranslatable(\"command.cooldown\", secondsLeftComponent)\n-                  .getPersonalizedText()\n-                  .color(ChatColor.RED));\n-          return;\n-        }\n-      } else {\n-        // Player has no cooldown, so add one\n-        LAST_REPORT_SENT.put(matchPlayer.getId(), Instant.now());\n-      }\n-    }\n-\n-    MatchPlayer accused = match.getPlayer(player);\n-    PlayerReportEvent event = new PlayerReportEvent(commandSender, accused, reason);\n-    match.callEvent(event);\n-\n-    if (event.isCancelled()) {\n-      if (event.getCancelMessage() != null) {\n-        commandSender.sendMessage(event.getCancelMessage());\n-      }\n-      return;\n-    }\n-\n-    commandSender.sendMessage(\n-        new PersonalizedText(\n-            new PersonalizedText(new PersonalizedTranslatable(\"misc.thankYou\"), ChatColor.GREEN),\n-            new PersonalizedText(\" \"),\n-            new PersonalizedText(\n-                new PersonalizedTranslatable(\"command.report.acknowledge\"), ChatColor.GOLD)));\n-\n-    final Component component =\n-        new PersonalizedTranslatable(\n-            \"command.report.notify\",\n-            matchPlayer == null\n-                ? new PersonalizedText(\"Console\", ChatColor.AQUA, ChatColor.ITALIC)\n-                : matchPlayer.getStyledName(NameStyle.FANCY),\n-            accused.getStyledName(NameStyle.FANCY),\n-            new PersonalizedText(reason.trim(), ChatColor.WHITE));\n-\n-    RECENT_REPORTS.add(\n-        new Report(\n-            player.getName(),\n-            reason,\n-            accused.getStyledName(NameStyle.CONCISE),\n-            matchPlayer.getStyledName(NameStyle.CONCISE)));\n-\n-    final Component prefixedComponent =\n-        new PersonalizedText(\n-            new PersonalizedText(\"[\"),\n-            new PersonalizedText(\"A\", ChatColor.GOLD),\n-            new PersonalizedText(\"] \"),\n-            new PersonalizedText(component, ChatColor.YELLOW));\n-\n-    match.getPlayers().stream()\n-        .filter(viewer -> viewer.getBukkit().hasPermission(Permissions.ADMINCHAT))\n-        .forEach(\n-            viewer -> {\n-              // Play sound for viewers of reports\n-              if (viewer.getSettings().getValue(SettingKey.SOUNDS).equals(SettingValue.SOUNDS_ON)) {\n-                viewer.playSound(REPORT_NOTIFY_SOUND);\n-              }\n-              viewer.sendMessage(prefixedComponent);\n-            });\n-    Audience.get(Bukkit.getConsoleSender()).sendMessage(component);\n-  }\n-\n-  @Command(\n-      aliases = {\"reports\", \"reps\", \"reporthistory\"},\n-      desc = \"Display a list of recent reports\",\n-      usage = \"(page) -t [target player]\",\n-      flags = \"t\",\n-      perms = Permissions.STAFF)\n-  public void reportHistory(\n-      Audience audience,\n-      CommandSender sender,\n-      @Default(\"1\") int page,\n-      @Fallback(Type.NULL) @Switch('t') String target)\n-      throws CommandException {\n-    if (RECENT_REPORTS.isEmpty()) {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\"moderation.reports.none\")\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-      return;\n-    }\n-\n-    List<Report> reportList = RECENT_REPORTS;\n-    if (target != null) {\n-      reportList =\n-          RECENT_REPORTS.stream()\n-              .filter(r -> r.getId().equalsIgnoreCase(target))\n-              .collect(Collectors.toList());\n-    }\n-\n-    Collections.sort(reportList); // Sort list so most recent show up first\n-\n-    Component headerResultCount =\n-        new PersonalizedText(Long.toString(reportList.size())).color(ChatColor.RED);\n-\n-    int perPage = 6;\n-    int pages = (reportList.size() + perPage - 1) / perPage;\n-\n-    Component pageNum =\n-        new PersonalizedTranslatable(\n-                \"command.paginatedResult.page\",\n-                new PersonalizedText(Integer.toString(page)).color(ChatColor.RED),\n-                new PersonalizedText(Integer.toString(pages)).color(ChatColor.RED))\n-            .add(ChatColor.AQUA);\n-\n-    Component header =\n-        new PersonalizedTranslatable(\"moderation.reports.header\", headerResultCount, pageNum)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY);\n-\n-    Component formattedHeader =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLineHeading(\n-                ComponentRenderers.toLegacyText(header, sender), ChatColor.RED));\n-\n-    new PrettyPaginatedComponentResults<Report>(formattedHeader, perPage) {\n-      @Override\n-      public Component format(Report data, int index) {\n-        Component timeAgo =\n-            PeriodFormats.relativePastApproximate(\n-                    org.joda.time.Instant.ofEpochMilli(data.getTimeSent().toEpochMilli()))\n-                .color(ChatColor.DARK_AQUA);\n-        Component hover =\n-            new PersonalizedTranslatable(\"moderation.reports.hover\", data.getSenderName())\n-                .getPersonalizedText()\n-                .color(ChatColor.GRAY);\n-        Component formatted =\n-            new PersonalizedTranslatable(\n-                \"moderation.reports.format\",\n-                timeAgo,\n-                data.getTargetName(),\n-                new PersonalizedText(data.getReason()).italic(true).color(ChatColor.WHITE));\n-\n-        return formatted.hoverEvent(Action.SHOW_TEXT, hover.render(sender));\n-      }\n-    }.display(audience, reportList, page);\n-  }\n-\n-  public static class Report implements Comparable<Report> {\n-    private final String id;\n-    private final String reason;\n-    private final Component targetName;\n-    private final Component sender;\n-    private final Instant timeSent;\n-\n-    public Report(String id, String reason, Component targetName, Component sender) {\n-      this.id = id;\n-      this.reason = reason;\n-      this.targetName = targetName;\n-      this.sender = sender;\n-      this.timeSent = Instant.now();\n-    }\n-\n-    public String getId() {\n-      return id;\n-    }\n-\n-    public String getReason() {\n-      return reason;\n-    }\n-\n-    public Component getTargetName() {\n-      return targetName;\n-    }\n-\n-    public Component getSenderName() {\n-      return sender;\n-    }\n-\n-    public Instant getTimeSent() {\n-      return timeSent;\n-    }\n-\n-    @Override\n-    public int compareTo(Report o) {\n-      if (getTimeSent().equals(o.getTimeSent())) {\n-        return 0;\n-      } else if (getTimeSent().isBefore(o.getTimeSent())) {\n-        return 1;\n-      } else {\n-        return -1;\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTYyNQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565625", "bodyText": "I think this can be simplified to Instant.compare(getTimeSent(), o.getTimeSent())", "author": "Electroid", "createdAt": "2020-02-24T23:00:27Z", "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "diffHunk": "@@ -125,35 +144,125 @@ public static void report(\n   }\n \n   @Command(\n-      aliases = {\"staff\", \"mods\", \"admins\"},\n-      desc = \"List the online staff members\")\n-  public void staff(CommandSender sender, Match match) {\n-    // List of online staff\n-    List<Component> onlineStaff =\n-        match.getPlayers().stream()\n-            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n-            .map(player -> player.getStyledName(NameStyle.FANCY))\n-            .collect(Collectors.toList());\n-\n-    // FORMAT: Online Staff ({count}): {names}\n-    Component staffCount =\n-        new PersonalizedText(Integer.toString(onlineStaff.size()))\n-            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n-\n-    Component content =\n-        onlineStaff.isEmpty()\n-            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n-                .getPersonalizedText()\n-                .color(ChatColor.RED)\n-            : new Component(\n-                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+      aliases = {\"reports\", \"reps\", \"reporthistory\"},\n+      desc = \"Display a list of recent reports\",\n+      usage = \"(page) -t [target player]\",\n+      flags = \"t\",\n+      perms = Permissions.STAFF)\n+  public void reportHistory(\n+      Audience audience,\n+      CommandSender sender,\n+      @Default(\"1\") int page,\n+      @Fallback(Type.NULL) @Switch('t') String target)\n+      throws CommandException {\n+    if (RECENT_REPORTS.isEmpty()) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.reports.none\")\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    List<Report> reportList = RECENT_REPORTS;\n+    if (target != null) {\n+      reportList =\n+          RECENT_REPORTS.stream()\n+              .filter(r -> r.getId().equalsIgnoreCase(target))\n+              .collect(Collectors.toList());\n+    }\n \n-    Component staff =\n-        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+    Collections.sort(reportList); // Sort list so most recent show up first\n+\n+    Component headerResultCount =\n+        new PersonalizedText(Long.toString(reportList.size())).color(ChatColor.RED);\n+\n+    int perPage = 6;\n+    int pages = (reportList.size() + perPage - 1) / perPage;\n+\n+    Component pageNum =\n+        new PersonalizedTranslatable(\n+                \"command.paginatedResult.page\",\n+                new PersonalizedText(Integer.toString(page)).color(ChatColor.RED),\n+                new PersonalizedText(Integer.toString(pages)).color(ChatColor.RED))\n+            .add(ChatColor.AQUA);\n+\n+    Component header =\n+        new PersonalizedTranslatable(\"moderation.reports.header\", headerResultCount, pageNum)\n             .getPersonalizedText()\n             .color(ChatColor.GRAY);\n \n-    // Send message\n-    sender.sendMessage(staff);\n+    Component formattedHeader =\n+        new PersonalizedText(\n+            ComponentUtils.horizontalLineHeading(\n+                ComponentRenderers.toLegacyText(header, sender), ChatColor.RED));\n+\n+    new PrettyPaginatedComponentResults<Report>(formattedHeader, perPage) {\n+      @Override\n+      public Component format(Report data, int index) {\n+        Component timeAgo =\n+            PeriodFormats.relativePastApproximate(\n+                    org.joda.time.Instant.ofEpochMilli(data.getTimeSent().toEpochMilli()))\n+                .color(ChatColor.DARK_AQUA);\n+        Component hover =\n+            new PersonalizedTranslatable(\"moderation.reports.hover\", data.getSenderName())\n+                .getPersonalizedText()\n+                .color(ChatColor.GRAY);\n+        Component formatted =\n+            new PersonalizedTranslatable(\n+                \"moderation.reports.format\",\n+                timeAgo,\n+                data.getTargetName(),\n+                new PersonalizedText(data.getReason()).italic(true).color(ChatColor.WHITE));\n+\n+        return formatted.hoverEvent(Action.SHOW_TEXT, hover.render(sender));\n+      }\n+    }.display(audience, reportList, page);\n+  }\n+\n+  public static class Report implements Comparable<Report> {\n+    private final String id;\n+    private final String reason;\n+    private final Component targetName;\n+    private final Component sender;\n+    private final Instant timeSent;\n+\n+    public Report(String id, String reason, Component targetName, Component sender) {\n+      this.id = id;\n+      this.reason = reason;\n+      this.targetName = targetName;\n+      this.sender = sender;\n+      this.timeSent = Instant.now();\n+    }\n+\n+    public String getId() {\n+      return id;\n+    }\n+\n+    public String getReason() {\n+      return reason;\n+    }\n+\n+    public Component getTargetName() {\n+      return targetName;\n+    }\n+\n+    public Component getSenderName() {\n+      return sender;\n+    }\n+\n+    public Instant getTimeSent() {\n+      return timeSent;\n+    }\n+\n+    @Override\n+    public int compareTo(Report o) {\n+      if (getTimeSent().equals(o.getTimeSent())) {\n+        return 0;\n+      } else if (getTimeSent().isBefore(o.getTimeSent())) {\n+        return 1;\n+      } else {\n+        return -1;\n+      }", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MjkxMw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383582913", "bodyText": "Can be simplified to return timeSent.compareTo(o.timeSent);", "author": "Pablete1234", "createdAt": "2020-02-24T23:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTYyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/community/ReportCommands.java b/src/main/java/tc/oc/pgm/community/ReportCommands.java\ndeleted file mode 100644\nindex 2deb86f..0000000\n--- a/src/main/java/tc/oc/pgm/community/ReportCommands.java\n+++ /dev/null\n\n@@ -1,268 +0,0 @@\n-package tc.oc.pgm.community;\n-\n-import app.ashcon.intake.Command;\n-import app.ashcon.intake.CommandException;\n-import app.ashcon.intake.bukkit.parametric.Type;\n-import app.ashcon.intake.bukkit.parametric.annotation.Fallback;\n-import app.ashcon.intake.parametric.annotation.Default;\n-import app.ashcon.intake.parametric.annotation.Switch;\n-import app.ashcon.intake.parametric.annotation.Text;\n-import com.google.common.cache.Cache;\n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.collect.Lists;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import net.md_5.bungee.api.ChatColor;\n-import net.md_5.bungee.api.chat.HoverEvent.Action;\n-import org.bukkit.Bukkit;\n-import org.bukkit.command.CommandSender;\n-import org.bukkit.entity.Player;\n-import tc.oc.component.Component;\n-import tc.oc.component.render.ComponentRenderers;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.api.Permissions;\n-import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.chat.Sound;\n-import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.api.setting.SettingKey;\n-import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.events.PlayerReportEvent;\n-import tc.oc.pgm.util.PrettyPaginatedComponentResults;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.PeriodFormats;\n-\n-public class ReportCommands {\n-\n-  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n-\n-  private static final int REPORT_COOLDOWN_SECONDS = 15;\n-\n-  private final Cache<UUID, Instant> LAST_REPORT_SENT =\n-      CacheBuilder.newBuilder().expireAfterWrite(REPORT_COOLDOWN_SECONDS, TimeUnit.SECONDS).build();\n-\n-  private final List<Report> RECENT_REPORTS = Lists.newArrayList();\n-\n-  @Command(\n-      aliases = {\"report\"},\n-      usage = \"<player> <reason>\",\n-      desc = \"Report a player who is breaking the rules\")\n-  public void report(\n-      CommandSender commandSender,\n-      MatchPlayer matchPlayer,\n-      Match match,\n-      Player player,\n-      @Text String reason)\n-      throws CommandException {\n-    if (!commandSender.hasPermission(Permissions.STAFF) && commandSender instanceof Player) {\n-      // Check for cooldown\n-      Instant lastReport = LAST_REPORT_SENT.getIfPresent(matchPlayer.getId());\n-      if (lastReport != null) {\n-        Duration timeSinceReport = Duration.between(lastReport, Instant.now());\n-        long secondsRemaining = REPORT_COOLDOWN_SECONDS - timeSinceReport.getSeconds();\n-        if (secondsRemaining > 0) {\n-          Component secondsComponent = new PersonalizedText(Long.toString(secondsRemaining));\n-          Component secondsLeftComponent =\n-              new PersonalizedTranslatable(\n-                      secondsRemaining != 1\n-                          ? \"countdown.pluralCompound\"\n-                          : \"countdown.singularCompound\",\n-                      secondsComponent)\n-                  .getPersonalizedText()\n-                  .color(ChatColor.AQUA);\n-          commandSender.sendMessage(\n-              new PersonalizedTranslatable(\"command.cooldown\", secondsLeftComponent)\n-                  .getPersonalizedText()\n-                  .color(ChatColor.RED));\n-          return;\n-        }\n-      } else {\n-        // Player has no cooldown, so add one\n-        LAST_REPORT_SENT.put(matchPlayer.getId(), Instant.now());\n-      }\n-    }\n-\n-    MatchPlayer accused = match.getPlayer(player);\n-    PlayerReportEvent event = new PlayerReportEvent(commandSender, accused, reason);\n-    match.callEvent(event);\n-\n-    if (event.isCancelled()) {\n-      if (event.getCancelMessage() != null) {\n-        commandSender.sendMessage(event.getCancelMessage());\n-      }\n-      return;\n-    }\n-\n-    commandSender.sendMessage(\n-        new PersonalizedText(\n-            new PersonalizedText(new PersonalizedTranslatable(\"misc.thankYou\"), ChatColor.GREEN),\n-            new PersonalizedText(\" \"),\n-            new PersonalizedText(\n-                new PersonalizedTranslatable(\"command.report.acknowledge\"), ChatColor.GOLD)));\n-\n-    final Component component =\n-        new PersonalizedTranslatable(\n-            \"command.report.notify\",\n-            matchPlayer == null\n-                ? new PersonalizedText(\"Console\", ChatColor.AQUA, ChatColor.ITALIC)\n-                : matchPlayer.getStyledName(NameStyle.FANCY),\n-            accused.getStyledName(NameStyle.FANCY),\n-            new PersonalizedText(reason.trim(), ChatColor.WHITE));\n-\n-    RECENT_REPORTS.add(\n-        new Report(\n-            player.getName(),\n-            reason,\n-            accused.getStyledName(NameStyle.CONCISE),\n-            matchPlayer.getStyledName(NameStyle.CONCISE)));\n-\n-    final Component prefixedComponent =\n-        new PersonalizedText(\n-            new PersonalizedText(\"[\"),\n-            new PersonalizedText(\"A\", ChatColor.GOLD),\n-            new PersonalizedText(\"] \"),\n-            new PersonalizedText(component, ChatColor.YELLOW));\n-\n-    match.getPlayers().stream()\n-        .filter(viewer -> viewer.getBukkit().hasPermission(Permissions.ADMINCHAT))\n-        .forEach(\n-            viewer -> {\n-              // Play sound for viewers of reports\n-              if (viewer.getSettings().getValue(SettingKey.SOUNDS).equals(SettingValue.SOUNDS_ON)) {\n-                viewer.playSound(REPORT_NOTIFY_SOUND);\n-              }\n-              viewer.sendMessage(prefixedComponent);\n-            });\n-    Audience.get(Bukkit.getConsoleSender()).sendMessage(component);\n-  }\n-\n-  @Command(\n-      aliases = {\"reports\", \"reps\", \"reporthistory\"},\n-      desc = \"Display a list of recent reports\",\n-      usage = \"(page) -t [target player]\",\n-      flags = \"t\",\n-      perms = Permissions.STAFF)\n-  public void reportHistory(\n-      Audience audience,\n-      CommandSender sender,\n-      @Default(\"1\") int page,\n-      @Fallback(Type.NULL) @Switch('t') String target)\n-      throws CommandException {\n-    if (RECENT_REPORTS.isEmpty()) {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\"moderation.reports.none\")\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-      return;\n-    }\n-\n-    List<Report> reportList = RECENT_REPORTS;\n-    if (target != null) {\n-      reportList =\n-          RECENT_REPORTS.stream()\n-              .filter(r -> r.getId().equalsIgnoreCase(target))\n-              .collect(Collectors.toList());\n-    }\n-\n-    Collections.sort(reportList); // Sort list so most recent show up first\n-\n-    Component headerResultCount =\n-        new PersonalizedText(Long.toString(reportList.size())).color(ChatColor.RED);\n-\n-    int perPage = 6;\n-    int pages = (reportList.size() + perPage - 1) / perPage;\n-\n-    Component pageNum =\n-        new PersonalizedTranslatable(\n-                \"command.paginatedResult.page\",\n-                new PersonalizedText(Integer.toString(page)).color(ChatColor.RED),\n-                new PersonalizedText(Integer.toString(pages)).color(ChatColor.RED))\n-            .add(ChatColor.AQUA);\n-\n-    Component header =\n-        new PersonalizedTranslatable(\"moderation.reports.header\", headerResultCount, pageNum)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY);\n-\n-    Component formattedHeader =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLineHeading(\n-                ComponentRenderers.toLegacyText(header, sender), ChatColor.RED));\n-\n-    new PrettyPaginatedComponentResults<Report>(formattedHeader, perPage) {\n-      @Override\n-      public Component format(Report data, int index) {\n-        Component timeAgo =\n-            PeriodFormats.relativePastApproximate(\n-                    org.joda.time.Instant.ofEpochMilli(data.getTimeSent().toEpochMilli()))\n-                .color(ChatColor.DARK_AQUA);\n-        Component hover =\n-            new PersonalizedTranslatable(\"moderation.reports.hover\", data.getSenderName())\n-                .getPersonalizedText()\n-                .color(ChatColor.GRAY);\n-        Component formatted =\n-            new PersonalizedTranslatable(\n-                \"moderation.reports.format\",\n-                timeAgo,\n-                data.getTargetName(),\n-                new PersonalizedText(data.getReason()).italic(true).color(ChatColor.WHITE));\n-\n-        return formatted.hoverEvent(Action.SHOW_TEXT, hover.render(sender));\n-      }\n-    }.display(audience, reportList, page);\n-  }\n-\n-  public static class Report implements Comparable<Report> {\n-    private final String id;\n-    private final String reason;\n-    private final Component targetName;\n-    private final Component sender;\n-    private final Instant timeSent;\n-\n-    public Report(String id, String reason, Component targetName, Component sender) {\n-      this.id = id;\n-      this.reason = reason;\n-      this.targetName = targetName;\n-      this.sender = sender;\n-      this.timeSent = Instant.now();\n-    }\n-\n-    public String getId() {\n-      return id;\n-    }\n-\n-    public String getReason() {\n-      return reason;\n-    }\n-\n-    public Component getTargetName() {\n-      return targetName;\n-    }\n-\n-    public Component getSenderName() {\n-      return sender;\n-    }\n-\n-    public Instant getTimeSent() {\n-      return timeSent;\n-    }\n-\n-    @Override\n-    public int compareTo(Report o) {\n-      if (getTimeSent().equals(o.getTimeSent())) {\n-        return 0;\n-      } else if (getTimeSent().isBefore(o.getTimeSent())) {\n-        return 1;\n-      } else {\n-        return -1;\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTkzOA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565938", "bodyText": "Keep all of these files, including events, in the tc.oc.pgm.community package.\nSo this would be tc.oc.pgm.community.events", "author": "Electroid", "createdAt": "2020-02-24T23:01:11Z", "path": "src/main/java/tc/oc/pgm/events/PlayerPunishmentEvent.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package tc.oc.pgm.events;", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/events/PlayerPunishmentEvent.java b/src/main/java/tc/oc/pgm/events/PlayerPunishmentEvent.java\ndeleted file mode 100644\nindex 4ffbbda..0000000\n--- a/src/main/java/tc/oc/pgm/events/PlayerPunishmentEvent.java\n+++ /dev/null\n\n@@ -1,63 +0,0 @@\n-package tc.oc.pgm.events;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-import org.bukkit.command.CommandSender;\n-import org.bukkit.event.HandlerList;\n-import tc.oc.pgm.api.event.ExtendedCancellable;\n-import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.community.ModerationCommands.PunishmentType;\n-\n-/** Called when a punishment command is run * */\n-public class PlayerPunishmentEvent extends ExtendedCancellable {\n-\n-  private final CommandSender sender;\n-  private final MatchPlayer player;\n-  private final PunishmentType punishment;\n-  private final String reason;\n-  private final boolean silent;\n-\n-  public PlayerPunishmentEvent(\n-      CommandSender sender,\n-      MatchPlayer player,\n-      PunishmentType punishment,\n-      String reason,\n-      boolean silent) {\n-    this.sender = checkNotNull(sender);\n-    this.player = checkNotNull(player);\n-    this.punishment = checkNotNull(punishment);\n-    this.reason = checkNotNull(reason);\n-    this.silent = checkNotNull(silent);\n-  }\n-\n-  public CommandSender getSender() {\n-    return sender;\n-  }\n-\n-  public PunishmentType getType() {\n-    return punishment;\n-  }\n-\n-  public MatchPlayer getPlayer() {\n-    return player;\n-  }\n-\n-  public String getReason() {\n-    return reason;\n-  }\n-\n-  public boolean isSilent() {\n-    return silent;\n-  }\n-\n-  private static final HandlerList handlers = new HandlerList();\n-\n-  @Override\n-  public HandlerList getHandlers() {\n-    return handlers;\n-  }\n-\n-  public static HandlerList getHandlerList() {\n-    return handlers;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NjMyOA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383566328", "bodyText": "Instead of having 2 events, remove this and add a Duration field to PlayerPunishmentEvent.\nIf the ban is permanent, then the Duration is MAX_VALUE.", "author": "Electroid", "createdAt": "2020-02-24T23:02:17Z", "path": "src/main/java/tc/oc/pgm/events/PlayerTimedPunishmentEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package tc.oc.pgm.events;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import org.bukkit.command.CommandSender;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.ModerationCommands.PunishmentType;\n+\n+/** Called when a punishment that expires after a duration of time is created * */\n+public class PlayerTimedPunishmentEvent extends PlayerPunishmentEvent {", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/events/PlayerTimedPunishmentEvent.java b/src/main/java/tc/oc/pgm/events/PlayerTimedPunishmentEvent.java\ndeleted file mode 100644\nindex cb62580..0000000\n--- a/src/main/java/tc/oc/pgm/events/PlayerTimedPunishmentEvent.java\n+++ /dev/null\n\n@@ -1,34 +0,0 @@\n-package tc.oc.pgm.events;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-import java.time.Duration;\n-import java.time.Instant;\n-import org.bukkit.command.CommandSender;\n-import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.community.ModerationCommands.PunishmentType;\n-\n-/** Called when a punishment that expires after a duration of time is created * */\n-public class PlayerTimedPunishmentEvent extends PlayerPunishmentEvent {\n-\n-  private final Duration time;\n-\n-  public PlayerTimedPunishmentEvent(\n-      CommandSender sender,\n-      MatchPlayer player,\n-      PunishmentType punishment,\n-      String reason,\n-      boolean silent,\n-      Duration expires) {\n-    super(sender, player, punishment, reason, silent);\n-    this.time = checkNotNull(expires);\n-  }\n-\n-  public Duration getPunishmentLength() {\n-    return time;\n-  }\n-\n-  public Instant getExpiryDate() {\n-    return Instant.now().plus(time);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383867514", "bodyText": "This will punish the player with Duration.ZERO, shouldn't this be defined with Duration.MAX_VALUE?", "author": "Electroid", "createdAt": "2020-02-25T13:09:47Z", "path": "src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {", "originalCommit": "e53fa85e5c58273ff3917c108dadd05a836b6396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAwMDUwNA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384000504", "bodyText": "I should have made a comment regarding this, but from what I understand there is no Duration.MAX_VALUE See here\nBut basically I\u2019m using the logic so that: if a punishment has a duration then it must be able to expire, otherwise a zero value represents infinity.", "author": "applenick", "createdAt": "2020-02-25T16:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODQ0Mw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384088443", "bodyText": "Ah ok, that works", "author": "Electroid", "createdAt": "2020-02-25T19:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "a4293abcff754bfdcc456c77698ba27b892da98a", "chunk": "diff --git a/src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java b/src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java\ndeleted file mode 100644\nindex 71868c0..0000000\n--- a/src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java\n+++ /dev/null\n\n@@ -1,436 +0,0 @@\n-package tc.oc.pgm.community.commands;\n-\n-import app.ashcon.intake.Command;\n-import app.ashcon.intake.parametric.annotation.Switch;\n-import app.ashcon.intake.parametric.annotation.Text;\n-import com.google.common.collect.Lists;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-import net.md_5.bungee.api.ChatColor;\n-import org.bukkit.BanList;\n-import org.bukkit.Bukkit;\n-import org.bukkit.command.CommandSender;\n-import org.bukkit.entity.Player;\n-import tc.oc.component.Component;\n-import tc.oc.component.render.ComponentRenderers;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.Config;\n-import tc.oc.pgm.api.Permissions;\n-import tc.oc.pgm.api.chat.Sound;\n-import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n-import tc.oc.pgm.listeners.ChatDispatcher;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n-import tc.oc.util.components.PeriodFormats;\n-\n-public class ModerationCommands {\n-\n-  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n-\n-  private static final Component WARN_SYMBOL =\n-      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n-  private static final Component BROADCAST_DIV =\n-      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n-  private static final Component CONSOLE_NAME =\n-      new PersonalizedTranslatable(\"console\")\n-          .getPersonalizedText()\n-          .color(ChatColor.DARK_AQUA)\n-          .italic(true);\n-\n-  private final ChatDispatcher chat;\n-\n-  public ModerationCommands(ChatDispatcher chat) {\n-    this.chat = chat;\n-  }\n-\n-  @Command(\n-      aliases = {\"staff\", \"mods\", \"admins\"},\n-      desc = \"List the online staff members\")\n-  public void staff(CommandSender sender, Match match) {\n-    // List of online staff based off of permission\n-    List<Component> onlineStaff =\n-        match.getPlayers().stream()\n-            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n-            .map(player -> player.getStyledName(NameStyle.FANCY))\n-            .collect(Collectors.toList());\n-\n-    // FORMAT: Online Staff ({count}): {names}\n-    Component staffCount =\n-        new PersonalizedText(Integer.toString(onlineStaff.size()))\n-            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n-\n-    Component content =\n-        onlineStaff.isEmpty()\n-            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n-                .getPersonalizedText()\n-                .color(ChatColor.RED)\n-            : new Component(\n-                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n-\n-    Component staff =\n-        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY);\n-\n-    // Send message\n-    sender.sendMessage(staff);\n-  }\n-\n-  @Command(\n-      aliases = {\"mute\", \"m\"},\n-      usage = \"<player> <reason> -s (silent) -w (warn)\",\n-      desc = \"Mute a player\",\n-      perms = Permissions.MUTE)\n-  public void mute(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent,\n-      @Switch('w') boolean warn) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-\n-    if (chat.isMuted(targetMatchPlayer)) {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-      return;\n-    }\n-\n-    // if -w flag, also warn the player but don't broadcast warning\n-    if (warn) {\n-      warn(sender, target, match, reason, true);\n-    }\n-\n-    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n-      chat.addMuted(targetMatchPlayer);\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"unmute\", \"um\"},\n-      usage = \"<player>\",\n-      desc = \"Unmute a player\",\n-      perms = Permissions.MUTE)\n-  public void unMute(CommandSender sender, Player target, Match match) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    if (chat.isMuted(targetMatchPlayer)) {\n-      chat.removeMuted(targetMatchPlayer);\n-\n-      targetMatchPlayer.sendMessage(\n-          new PersonalizedTranslatable(\"moderation.unmute.target\")\n-              .getPersonalizedText()\n-              .color(ChatColor.GREEN));\n-\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .color(ChatColor.GRAY));\n-    } else {\n-      sender.sendMessage(\n-          new PersonalizedTranslatable(\n-                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n-              .getPersonalizedText()\n-              .color(ChatColor.RED));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"warn\", \"w\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Warn a player for bad behavior\",\n-      perms = Permissions.WARN)\n-  public void warn(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-\n-    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n-      sendWarning(targetMatchPlayer, reason);\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"kick\", \"k\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Kick a player from the server\",\n-      perms = Permissions.KICK)\n-  public void kick(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n-      target.kickPlayer(\n-          formatPunishmentScreen(\n-              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"ban\", \"permban\", \"pb\"},\n-      usage = \"<player> <reason> -s (silent)\",\n-      desc = \"Ban a player from the server forever\",\n-      perms = Permissions.BAN)\n-  public void ban(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    Component senderName = formatPunisherName(sender, match);\n-    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {\n-      banPlayer(target, reason, senderName, null);\n-      target.kickPlayer(formatPunishmentScreen(PunishmentType.BAN, senderName, reason, null));\n-    }\n-  }\n-\n-  @Command(\n-      aliases = {\"tempban\", \"tban\", \"tb\"},\n-      usage = \"<player> <time> <reason> -s (silent)\",\n-      desc = \"Ban a player from the server for a period of time\",\n-      perms = Permissions.BAN)\n-  public void tempBan(\n-      CommandSender sender,\n-      Player target,\n-      Match match,\n-      Duration banLength,\n-      @Text String reason,\n-      @Switch('s') boolean silent) {\n-    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n-    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, banLength, silent)) {\n-      banPlayer(target, reason, formatPunisherName(sender, match), Instant.now().plus(banLength));\n-      target.kickPlayer(\n-          formatPunishmentScreen(\n-              PunishmentType.BAN, formatPunisherName(sender, match), reason, banLength));\n-    }\n-  }\n-\n-  private boolean punish(\n-      PunishmentType type,\n-      MatchPlayer target,\n-      CommandSender issuer,\n-      String reason,\n-      boolean silent) {\n-    return punish(type, target, issuer, reason, Duration.ZERO, silent);\n-  }\n-\n-  private boolean punish(\n-      PunishmentType type,\n-      MatchPlayer target,\n-      CommandSender issuer,\n-      String reason,\n-      Duration duration,\n-      boolean silent) {\n-    PlayerPunishmentEvent event =\n-        new PlayerPunishmentEvent(issuer, target, type, reason, duration, silent);\n-    target.getMatch().callEvent(event);\n-    if (event.isCancelled()) {\n-      if (event.getCancelMessage() != null) {\n-        issuer.sendMessage(event.getCancelMessage());\n-      }\n-    } else if (!silent) {\n-      broadcastPunishment(event);\n-    }\n-    return !event.isCancelled();\n-  }\n-\n-  public static enum PunishmentType {\n-    MUTE(false),\n-    WARN(false),\n-    KICK(true),\n-    BAN(true);\n-\n-    private String PREFIX_TRANSLATE_KEY = \"moderation.type.\";\n-    private String SCREEN_TRANSLATE_KEY = \"moderation.screen.\";\n-\n-    private final boolean screen;\n-\n-    PunishmentType(boolean screen) {\n-      this.screen = screen;\n-    }\n-\n-    public Component getPunishmentPrefix() {\n-      return new PersonalizedTranslatable(PREFIX_TRANSLATE_KEY + name().toLowerCase())\n-          .getPersonalizedText()\n-          .color(ChatColor.RED);\n-    }\n-\n-    public Component getScreenComponent(Component reason) {\n-      if (!screen) return Components.blank();\n-      return new PersonalizedTranslatable(SCREEN_TRANSLATE_KEY + name().toLowerCase(), reason)\n-          .getPersonalizedText()\n-          .color(ChatColor.GOLD);\n-    }\n-  }\n-\n-  /*\n-   * Format Punisher Name\n-   */\n-  public static Component formatPunisherName(CommandSender sender, Match match) {\n-    if (sender != null && sender instanceof Player) {\n-      MatchPlayer matchPlayer = match.getPlayer((Player) sender);\n-      if (matchPlayer != null) return matchPlayer.getStyledName(NameStyle.FANCY);\n-    }\n-    return CONSOLE_NAME;\n-  }\n-\n-  /*\n-   * Format Reason\n-   */\n-  public static Component formatPunishmentReason(String reason) {\n-    return new PersonalizedText(reason).color(ChatColor.RED);\n-  }\n-\n-  /*\n-   * Formatting of Kick Screens (KICK/BAN/TEMPBAN)\n-   */\n-  public static String formatPunishmentScreen(\n-      PunishmentType type, Component punisher, String reason, @Nullable Duration expires) {\n-    List<Component> lines = Lists.newArrayList();\n-\n-    Component header =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLineHeading(\n-                Config.Moderation.getServerName(), ChatColor.DARK_GRAY));\n-\n-    Component footer =\n-        new PersonalizedText(\n-            ComponentUtils.horizontalLine(ChatColor.DARK_GRAY, ComponentUtils.MAX_CHAT_WIDTH));\n-\n-    Component rules = new PersonalizedText(Config.Moderation.getRulesLink()).color(ChatColor.AQUA);\n-\n-    lines.add(header); // Header Line (server name) - START\n-    lines.add(Components.blank());\n-    lines.add(type.getScreenComponent(formatPunishmentReason(reason))); // The reason\n-    lines.add(Components.blank());\n-\n-    // If punishment expires, inform user when\n-    if (expires != null) {\n-      Component timeLeft =\n-          PeriodFormats.briefNaturalApproximate(\n-              org.joda.time.Duration.standardSeconds(expires.getSeconds()));\n-      lines.add(\n-          new PersonalizedTranslatable(\"moderation.screen.expires\", timeLeft)\n-              .getPersonalizedText()\n-              .color(ChatColor.GRAY));\n-      lines.add(Components.blank());\n-    }\n-\n-    // Staff sign-off\n-    lines.add(\n-        new PersonalizedTranslatable(\"moderation.screen.signoff\", punisher)\n-            .getPersonalizedText()\n-            .color(ChatColor.GRAY)); // The sign-off of who performed the punishment\n-\n-    // Link to rules for review by player\n-    if (Config.Moderation.isRuleLinkVisible()) {\n-      lines.add(Components.blank());\n-      lines.add(\n-          new PersonalizedTranslatable(\"moderation.screen.rulesLink\", rules)\n-              .getPersonalizedText()\n-              .color(ChatColor.GRAY)); // A link to the rules\n-    }\n-\n-    // Configurable last line (for appeal message or etc)\n-    if (Config.Moderation.isAppealVisible() && type.equals(PunishmentType.BAN)) {\n-      lines.add(Components.blank());\n-      lines.add(new PersonalizedText(Config.Moderation.getAppealMessage()));\n-    }\n-\n-    lines.add(Components.blank());\n-    lines.add(footer); // Footer line - END\n-\n-    return Components.join(new PersonalizedText(\"\\n\" + ChatColor.RESET), lines).toLegacyText();\n-  }\n-\n-  /*\n-   * Sends a formatted title and plays a sound warning a user of their actions\n-   */\n-  private void sendWarning(MatchPlayer target, String reason) {\n-    Component titleWord =\n-        new PersonalizedTranslatable(\"moderation.warning\")\n-            .getPersonalizedText()\n-            .color(ChatColor.DARK_RED);\n-    Component title = new PersonalizedText(WARN_SYMBOL, titleWord, WARN_SYMBOL);\n-    Component subtitle = formatPunishmentReason(reason).color(ChatColor.GOLD);\n-\n-    target.showTitle(title, subtitle, 5, 200, 10);\n-    target.playSound(WARN_SOUND);\n-  }\n-\n-  private void broadcastPunishment(PlayerPunishmentEvent event) {\n-    broadcastPunishment(\n-        event.getType(),\n-        event.getPlayer().getMatch(),\n-        event.getSender(),\n-        event.getPlayer(),\n-        event.getReason(),\n-        event.isSilent());\n-  }\n-\n-  /*\n-   * Broadcasts a punishment\n-   */\n-  private void broadcastPunishment(\n-      PunishmentType type,\n-      Match match,\n-      CommandSender sender,\n-      MatchPlayer target,\n-      String reason,\n-      boolean silent) {\n-    Component prefix =\n-        new PersonalizedText(\n-            new PersonalizedText(\"[\").color(ChatColor.GOLD),\n-            type.getPunishmentPrefix(),\n-            new PersonalizedText(\"]\").color(ChatColor.GOLD));\n-    Component targetName = target.getStyledName(NameStyle.FANCY);\n-    Component reasonMsg = ModerationCommands.formatPunishmentReason(reason);\n-    Component formattedMsg =\n-        new PersonalizedText(\n-            prefix,\n-            Components.space(),\n-            ModerationCommands.formatPunisherName(sender, match),\n-            BROADCAST_DIV,\n-            targetName,\n-            BROADCAST_DIV,\n-            reasonMsg);\n-\n-    if (!silent) {\n-      match.sendMessage(formattedMsg);\n-    } else {\n-      // if silent flag present, only notify sender\n-      sender.sendMessage(formattedMsg);\n-    }\n-  }\n-\n-  /*\n-   * Bukkit method of banning players\n-   * NOTE: Will use this if not handled by other plugins\n-   */\n-  private void banPlayer(\n-      Player target, String reason, Component source, @Nullable Instant expires) {\n-    Bukkit.getBanList(BanList.Type.NAME)\n-        .addBan(\n-            target.getName(),\n-            reason,\n-            expires != null ? Date.from(expires) : null,\n-            ComponentRenderers.toLegacyText(source, target));\n-  }\n-}\n"}}, {"oid": "a4293abcff754bfdcc456c77698ba27b892da98a", "url": "https://github.com/PGMDev/PGM/commit/a4293abcff754bfdcc456c77698ba27b892da98a", "message": "Add moderation commands\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-02-26T08:10:56Z", "type": "commit"}, {"oid": "a4293abcff754bfdcc456c77698ba27b892da98a", "url": "https://github.com/PGMDev/PGM/commit/a4293abcff754bfdcc456c77698ba27b892da98a", "message": "Add moderation commands\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-02-26T08:10:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMTM2MQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384331361", "bodyText": "Just commenting for visibility", "author": "applenick", "createdAt": "2020-02-26T08:19:03Z", "path": "core/src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.CommandException;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import com.google.common.net.InetAddresses;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentRenderers;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.PeriodFormats;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.named.NameStyle;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {\n+      banPlayer(target, reason, senderName, null);\n+      target.kickPlayer(formatPunishmentScreen(PunishmentType.BAN, senderName, reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"tempban\", \"tban\", \"tb\"},\n+      usage = \"<player> <time> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server for a period of time\",\n+      perms = Permissions.BAN)\n+  public void tempBan(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      Duration banLength,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, banLength, silent)) {\n+      banPlayer(target, reason, formatPunisherName(sender, match), Instant.now().plus(banLength));\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.BAN, formatPunisherName(sender, match), reason, banLength));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ipban\", \"banip\", \"ipb\"},\n+      usage = \"<player|ip address> <reason>\",\n+      desc = \"IP Ban a player from the server\",\n+      perms = Permissions.BAN)\n+  public void ipBan(", "originalCommit": "a4293abcff754bfdcc456c77698ba27b892da98a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}