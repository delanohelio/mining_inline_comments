{"pr_number": 689, "pr_title": "Add a match state filter", "pr_createdAt": "2020-11-01T20:45:49Z", "pr_url": "https://github.com/PGMDev/PGM/pull/689", "timeline": [{"oid": "c8fe28b830c056e474e342fb30e17665ba641f30", "url": "https://github.com/PGMDev/PGM/commit/c8fe28b830c056e474e342fb30e17665ba641f30", "message": "Add old 1.4.2 support\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-03T19:03:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2NzY2Mw==", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r516967663", "bodyText": "I don't get the obsession for a predicate here. Just use a Set<MatchPhase>", "author": "Pablete1234", "createdAt": "2020-11-03T21:32:24Z", "path": "core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package tc.oc.pgm.filters;\n+\n+import java.util.function.Predicate;\n+import tc.oc.pgm.api.filter.query.MatchQuery;\n+import tc.oc.pgm.api.match.Match;\n+\n+public class MatchStateFilter extends TypedFilter<MatchQuery> {\n+\n+  private final Predicate<Match> matchPredicate;\n+\n+  public MatchStateFilter(Predicate<Match> matchPredicate) {", "originalCommit": "c8fe28b830c056e474e342fb30e17665ba641f30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTE2OA==", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r517419168", "bodyText": "See my other comment, this constructor can then be MatchPhaseFilter(MatchPhase)", "author": "Electroid", "createdAt": "2020-11-04T15:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2NzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MzQ0MQ==", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r518653441", "bodyText": "Yes! Predicate was an old thing before i actually used all MatchPhases (was using method refrences instead like Match::isRunning etc.)", "author": "KingOfSquares", "createdAt": "2020-11-06T10:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2NzY2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1c4874cf8de3b511926688ba0708fb0e2efe288e", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java b/core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java\ndeleted file mode 100644\nindex 3719158..0000000\n--- a/core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java\n+++ /dev/null\n\n@@ -1,24 +0,0 @@\n-package tc.oc.pgm.filters;\n-\n-import java.util.function.Predicate;\n-import tc.oc.pgm.api.filter.query.MatchQuery;\n-import tc.oc.pgm.api.match.Match;\n-\n-public class MatchStateFilter extends TypedFilter<MatchQuery> {\n-\n-  private final Predicate<Match> matchPredicate;\n-\n-  public MatchStateFilter(Predicate<Match> matchPredicate) {\n-    this.matchPredicate = matchPredicate;\n-  }\n-\n-  @Override\n-  public Class<? extends MatchQuery> getQueryType() {\n-    return MatchQuery.class;\n-  }\n-\n-  @Override\n-  protected QueryResponse queryTyped(MatchQuery query) {\n-    return QueryResponse.fromBoolean(matchPredicate.test(query.getMatch()));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxODYzOQ==", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r517418639", "bodyText": "Seems like this should be a private function parseMatchPhase(String) -> MatchPhase", "author": "Electroid", "createdAt": "2020-11-04T15:16:27Z", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -443,4 +446,52 @@ public StructuralLoadFilter parseStructuralLoad(Element el) throws InvalidXMLExc\n   public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n+\n+  @MethodParser(\"match-state\")\n+  public MatchStateFilter parseMatchState(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(el.getValue(), el);\n+  }\n+\n+  @MethodParser(\"match-started\")\n+  public MatchStateFilter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(\"started\", el);\n+  }\n+\n+  @MethodParser(\"match-running\")\n+  public MatchStateFilter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(\"running\", el);\n+  }\n+\n+  @MethodParser(\"match-finished\")\n+  public MatchStateFilter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(\"finished\", el);\n+  }\n+\n+  public MatchStateFilter parseMatchStateFilter(String matchState, Element el)\n+      throws InvalidXMLException {\n+\n+    Predicate<Match> matchPredicate = null;\n+\n+    switch (matchState) {\n+      case \"running\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.RUNNING;\n+        break;\n+      case \"finished\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.FINISHED;\n+        break;\n+      case \"starting\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.STARTING;\n+        break;\n+      case \"before\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.IDLE;\n+        break;\n+      case \"started\":\n+        matchPredicate =\n+            m -> m.getPhase() == MatchPhase.RUNNING || m.getPhase() == MatchPhase.FINISHED;\n+    }\n+    if (matchPredicate == null)\n+      throw new InvalidXMLException(\"Invalid or no match state found\", el);", "originalCommit": "c8fe28b830c056e474e342fb30e17665ba641f30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c4874cf8de3b511926688ba0708fb0e2efe288e", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\nindex 18b5e43..965879d 100644\n--- a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n+++ b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n\n@@ -447,51 +450,54 @@ public abstract class FilterParser {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n \n-  @MethodParser(\"match-state\")\n-  public MatchStateFilter parseMatchState(Element el) throws InvalidXMLException {\n-    return parseMatchStateFilter(el.getValue(), el);\n+  @MethodParser(\"score\")\n+  public ScoreFilter parseScoreFilter(Element el) throws InvalidXMLException {\n+    return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n+  }\n+\n+  @MethodParser(\"match-phase\")\n+  public Filter parseMatchPhase(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(el.getValue(), el);\n   }\n \n   @MethodParser(\"match-started\")\n-  public MatchStateFilter parseMatchStarted(Element el) throws InvalidXMLException {\n-    return parseMatchStateFilter(\"started\", el);\n+  public Filter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"started\", el);\n   }\n \n   @MethodParser(\"match-running\")\n-  public MatchStateFilter parseMatchRunning(Element el) throws InvalidXMLException {\n-    return parseMatchStateFilter(\"running\", el);\n+  public Filter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"running\", el);\n   }\n \n   @MethodParser(\"match-finished\")\n-  public MatchStateFilter parseMatchFinished(Element el) throws InvalidXMLException {\n-    return parseMatchStateFilter(\"finished\", el);\n+  public Filter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"finished\", el);\n   }\n \n-  public MatchStateFilter parseMatchStateFilter(String matchState, Element el)\n-      throws InvalidXMLException {\n+  private Filter parseMatchPhaseFilter(String matchState, Element el) throws InvalidXMLException {\n \n-    Predicate<Match> matchPredicate = null;\n+    MatchPhase matchPhase = null;\n \n     switch (matchState) {\n       case \"running\":\n-        matchPredicate = m -> m.getPhase() == MatchPhase.RUNNING;\n+        matchPhase = MatchPhase.RUNNING;\n         break;\n       case \"finished\":\n-        matchPredicate = m -> m.getPhase() == MatchPhase.FINISHED;\n+        matchPhase = MatchPhase.FINISHED;\n         break;\n       case \"starting\":\n-        matchPredicate = m -> m.getPhase() == MatchPhase.STARTING;\n+        matchPhase = MatchPhase.STARTING;\n         break;\n-      case \"before\":\n-        matchPredicate = m -> m.getPhase() == MatchPhase.IDLE;\n+      case \"idle\":\n+        matchPhase = MatchPhase.IDLE;\n         break;\n       case \"started\":\n-        matchPredicate =\n-            m -> m.getPhase() == MatchPhase.RUNNING || m.getPhase() == MatchPhase.FINISHED;\n+        return AnyFilter.of(\n+            new MatchPhaseFilter(MatchPhase.RUNNING), new MatchPhaseFilter(MatchPhase.FINISHED));\n     }\n-    if (matchPredicate == null)\n-      throw new InvalidXMLException(\"Invalid or no match state found\", el);\n+    if (matchPhase == null) throw new InvalidXMLException(\"Invalid or no match state found\", el);\n \n-    return new MatchStateFilter(matchPredicate);\n+    return new MatchPhaseFilter(matchPhase);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxNDY0Mw==", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r521514643", "bodyText": "I have an idea to make this easier:\n\nChange the signature of parseMatchPhaseFilter return a generic Filter\nChange MatchPhaseFilter to only accept 1 MatchPhase and not a Set\nFor the \"started\" case, return an OrFilter(MatchPhaseFilter(RUNNING), MatchPhaseFilter(FINISHED))\n\nSee what I'm getting at?", "author": "Electroid", "createdAt": "2020-11-11T17:19:46Z", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -443,4 +442,52 @@ public StructuralLoadFilter parseStructuralLoad(Element el) throws InvalidXMLExc\n   public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n+\n+  @MethodParser(\"match-phase\")\n+  public MatchPhaseFilter parseMatchPhase(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(el.getValue(), el);\n+  }\n+\n+  @MethodParser(\"match-started\")\n+  public MatchPhaseFilter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"started\", el);\n+  }\n+\n+  @MethodParser(\"match-running\")\n+  public MatchPhaseFilter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"running\", el);\n+  }\n+\n+  @MethodParser(\"match-finished\")\n+  public MatchPhaseFilter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"finished\", el);\n+  }\n+\n+  private MatchPhaseFilter parseMatchPhaseFilter(String matchState, Element el)", "originalCommit": "ee908b4f1f1b88727c69e937abf73d8544c4490c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0ODkyNA==", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r522848924", "bodyText": "Yes! Great idea \ud83d\udc4d", "author": "KingOfSquares", "createdAt": "2020-11-13T10:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxNDY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1c4874cf8de3b511926688ba0708fb0e2efe288e", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\nindex 159cfb5..965879d 100644\n--- a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n+++ b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n\n@@ -443,51 +450,54 @@ public abstract class FilterParser {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n \n+  @MethodParser(\"score\")\n+  public ScoreFilter parseScoreFilter(Element el) throws InvalidXMLException {\n+    return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n+  }\n+\n   @MethodParser(\"match-phase\")\n-  public MatchPhaseFilter parseMatchPhase(Element el) throws InvalidXMLException {\n+  public Filter parseMatchPhase(Element el) throws InvalidXMLException {\n     return parseMatchPhaseFilter(el.getValue(), el);\n   }\n \n   @MethodParser(\"match-started\")\n-  public MatchPhaseFilter parseMatchStarted(Element el) throws InvalidXMLException {\n+  public Filter parseMatchStarted(Element el) throws InvalidXMLException {\n     return parseMatchPhaseFilter(\"started\", el);\n   }\n \n   @MethodParser(\"match-running\")\n-  public MatchPhaseFilter parseMatchRunning(Element el) throws InvalidXMLException {\n+  public Filter parseMatchRunning(Element el) throws InvalidXMLException {\n     return parseMatchPhaseFilter(\"running\", el);\n   }\n \n   @MethodParser(\"match-finished\")\n-  public MatchPhaseFilter parseMatchFinished(Element el) throws InvalidXMLException {\n+  public Filter parseMatchFinished(Element el) throws InvalidXMLException {\n     return parseMatchPhaseFilter(\"finished\", el);\n   }\n \n-  private MatchPhaseFilter parseMatchPhaseFilter(String matchState, Element el)\n-      throws InvalidXMLException {\n+  private Filter parseMatchPhaseFilter(String matchState, Element el) throws InvalidXMLException {\n \n-    Set<MatchPhase> matchPhases = new HashSet<>();\n+    MatchPhase matchPhase = null;\n \n     switch (matchState) {\n       case \"running\":\n-        matchPhases.add(MatchPhase.RUNNING);\n+        matchPhase = MatchPhase.RUNNING;\n         break;\n       case \"finished\":\n-        matchPhases.add(MatchPhase.FINISHED);\n+        matchPhase = MatchPhase.FINISHED;\n         break;\n       case \"starting\":\n-        matchPhases.add(MatchPhase.STARTING);\n+        matchPhase = MatchPhase.STARTING;\n         break;\n       case \"idle\":\n-        matchPhases.add(MatchPhase.IDLE);\n+        matchPhase = MatchPhase.IDLE;\n         break;\n       case \"started\":\n-        matchPhases.add(MatchPhase.RUNNING);\n-        matchPhases.add(MatchPhase.FINISHED);\n-        break;\n+        return AnyFilter.of(\n+            new MatchPhaseFilter(MatchPhase.RUNNING), new MatchPhaseFilter(MatchPhase.FINISHED));\n     }\n-    if (matchPhases.isEmpty()) throw new InvalidXMLException(\"Invalid or no match state found\", el);\n+    if (matchPhase == null) throw new InvalidXMLException(\"Invalid or no match state found\", el);\n \n-    return new MatchPhaseFilter(matchPhases);\n+    return new MatchPhaseFilter(matchPhase);\n   }\n }\n"}}, {"oid": "1c4874cf8de3b511926688ba0708fb0e2efe288e", "url": "https://github.com/PGMDev/PGM/commit/1c4874cf8de3b511926688ba0708fb0e2efe288e", "message": "refactor\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-03T21:55:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwODcwMg==", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r541508702", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  case \"running\":\n          \n          \n            \n                    matchPhase = MatchPhase.RUNNING;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"finished\":\n          \n          \n            \n                    matchPhase = MatchPhase.FINISHED;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"starting\":\n          \n          \n            \n                    matchPhase = MatchPhase.STARTING;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"idle\":\n          \n          \n            \n                    matchPhase = MatchPhase.IDLE;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"started\":\n          \n          \n            \n                    return AnyFilter.of(\n          \n          \n            \n                        new MatchPhaseFilter(MatchPhase.RUNNING), new MatchPhaseFilter(MatchPhase.FINISHED));\n          \n          \n            \n                  case \"running\": return MatchPhaseFilter.RUNNING;\n          \n          \n            \n                  case \"finished\": return MatchPhaseFilter.FINISHED;\n          \n          \n            \n                // ...\n          \n      \n    \n    \n  \n\nAs suggested in discord you should make static final fields in MatchPhaseFilter and reuse the same instances", "author": "Pablete1234", "createdAt": "2020-12-12T05:44:11Z", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -453,4 +454,50 @@ public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n   public ScoreFilter parseScoreFilter(Element el) throws InvalidXMLException {\n     return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n   }\n+\n+  @MethodParser(\"match-phase\")\n+  public Filter parseMatchPhase(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(el.getValue(), el);\n+  }\n+\n+  @MethodParser(\"match-started\")\n+  public Filter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"started\", el);\n+  }\n+\n+  @MethodParser(\"match-running\")\n+  public Filter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"running\", el);\n+  }\n+\n+  @MethodParser(\"match-finished\")\n+  public Filter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"finished\", el);\n+  }\n+\n+  private Filter parseMatchPhaseFilter(String matchState, Element el) throws InvalidXMLException {\n+\n+    MatchPhase matchPhase = null;\n+\n+    switch (matchState) {\n+      case \"running\":\n+        matchPhase = MatchPhase.RUNNING;\n+        break;\n+      case \"finished\":\n+        matchPhase = MatchPhase.FINISHED;\n+        break;\n+      case \"starting\":\n+        matchPhase = MatchPhase.STARTING;\n+        break;\n+      case \"idle\":\n+        matchPhase = MatchPhase.IDLE;\n+        break;\n+      case \"started\":\n+        return AnyFilter.of(\n+            new MatchPhaseFilter(MatchPhase.RUNNING), new MatchPhaseFilter(MatchPhase.FINISHED));", "originalCommit": "1c4874cf8de3b511926688ba0708fb0e2efe288e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5eaf5a697a1ef3a161aabe0eccec50ebb328dadf", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\nindex 965879d..44a6462 100644\n--- a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n+++ b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n\n@@ -455,49 +460,65 @@ public abstract class FilterParser {\n     return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n   }\n \n-  @MethodParser(\"match-phase\")\n-  public Filter parseMatchPhase(Element el) throws InvalidXMLException {\n-    return parseMatchPhaseFilter(el.getValue(), el);\n-  }\n-\n-  @MethodParser(\"match-started\")\n-  public Filter parseMatchStarted(Element el) throws InvalidXMLException {\n-    return parseMatchPhaseFilter(\"started\", el);\n-  }\n-\n-  @MethodParser(\"match-running\")\n-  public Filter parseMatchRunning(Element el) throws InvalidXMLException {\n-    return parseMatchPhaseFilter(\"running\", el);\n-  }\n-\n-  @MethodParser(\"match-finished\")\n-  public Filter parseMatchFinished(Element el) throws InvalidXMLException {\n-    return parseMatchPhaseFilter(\"finished\", el);\n-  }\n+  @MethodParser(\"match-state\")\n+  public MatchStateFilter parseMatchStateFilter(Element el) throws InvalidXMLException {\n+    String state = el.getValue();\n \n-  private Filter parseMatchPhaseFilter(String matchState, Element el) throws InvalidXMLException {\n+    Predicate<Match> matchPredicate = null;\n \n-    MatchPhase matchPhase = null;\n-\n-    switch (matchState) {\n+    switch (state) {\n       case \"running\":\n-        matchPhase = MatchPhase.RUNNING;\n+      case \"started\":\n+        matchPredicate = Match::isRunning;\n         break;\n       case \"finished\":\n-        matchPhase = MatchPhase.FINISHED;\n-        break;\n-      case \"starting\":\n-        matchPhase = MatchPhase.STARTING;\n+        matchPredicate = Match::isFinished;\n         break;\n-      case \"idle\":\n-        matchPhase = MatchPhase.IDLE;\n+      case \"loaded\":\n+        matchPredicate = Match::isLoaded;\n         break;\n-      case \"started\":\n-        return AnyFilter.of(\n-            new MatchPhaseFilter(MatchPhase.RUNNING), new MatchPhaseFilter(MatchPhase.FINISHED));\n+      case \"before\":\n+        matchPredicate = match -> !match.isRunning() && !match.isFinished();\n+    }\n+    if (matchPredicate == null)\n+      throw new InvalidXMLException(\"Invalid or no match state found\", el);\n+\n+    return new MatchStateFilter(matchPredicate);\n+  }\n+\n+  // Methods for parsing QueryModifiers\n+\n+  @MethodParser(\"offset\")\n+  public LocationQueryModifier parseOffsetFilter(Element el) throws InvalidXMLException {\n+    String value = el.getAttributeValue(\"vector\");\n+    if (value == null) throw new InvalidXMLException(\"No vector provided\", el);\n+    // Check vector format\n+    Vector vector = XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n+\n+    String[] coords = value.split(\"\\\\s*,\\\\s*\");\n+\n+    boolean[] relative = new boolean[3];\n+\n+    Boolean local = null;\n+    for (int i = 0; i < coords.length; i++) {\n+      String coord = coords[i];\n+\n+      if (local == null) {\n+        local = coord.startsWith(\"^\");\n+      }\n+\n+      if (coord.startsWith(\"^\") != local)\n+        throw new InvalidXMLException(\"Cannot mix world & local coordinates\", el);\n+\n+      relative[i] = coord.startsWith(\"~\");\n     }\n-    if (matchPhase == null) throw new InvalidXMLException(\"Invalid or no match state found\", el);\n \n-    return new MatchPhaseFilter(matchPhase);\n+    if (local == null) throw new InvalidXMLException(\"No coordinates provided\", el);\n+\n+    if (local) {\n+      return new LocalLocationQueryModifier(parseChild(el), vector);\n+    } else {\n+      return new WorldLocationQueryModifier(parseChild(el), vector, relative);\n+    }\n   }\n }\n"}}, {"oid": "5eaf5a697a1ef3a161aabe0eccec50ebb328dadf", "url": "https://github.com/PGMDev/PGM/commit/5eaf5a697a1ef3a161aabe0eccec50ebb328dadf", "message": "Add a match state filter\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:00:17Z", "type": "commit"}, {"oid": "8db6400361b2dd33d1b18c05f0807a4b8fbd0ce6", "url": "https://github.com/PGMDev/PGM/commit/8db6400361b2dd33d1b18c05f0807a4b8fbd0ce6", "message": "Add old 1.4.2 support\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:00:17Z", "type": "commit"}, {"oid": "d6053c3eaf60370908456ac520019bd3f8ba2929", "url": "https://github.com/PGMDev/PGM/commit/d6053c3eaf60370908456ac520019bd3f8ba2929", "message": "MatchStateFilter -> MatchPhaseFilter\n- Rework logic\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:00:17Z", "type": "commit"}, {"oid": "3235df6a5ce9b24101910708a35266510f809ce7", "url": "https://github.com/PGMDev/PGM/commit/3235df6a5ce9b24101910708a35266510f809ce7", "message": "Change parsing logic\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:00:17Z", "type": "commit"}, {"oid": "d7b1e82b3cd8e4142f284815bf803408dcf63e91", "url": "https://github.com/PGMDev/PGM/commit/d7b1e82b3cd8e4142f284815bf803408dcf63e91", "message": "refactor\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:00:17Z", "type": "commit"}, {"oid": "edc9769b93b4f5422cf05dae80821dece29e2c9e", "url": "https://github.com/PGMDev/PGM/commit/edc9769b93b4f5422cf05dae80821dece29e2c9e", "message": "pre-initialize match state filters\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:00:17Z", "type": "commit"}, {"oid": "edc9769b93b4f5422cf05dae80821dece29e2c9e", "url": "https://github.com/PGMDev/PGM/commit/edc9769b93b4f5422cf05dae80821dece29e2c9e", "message": "pre-initialize match state filters\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:00:17Z", "type": "forcePushed"}]}