{"pr_number": 671, "pr_title": "Add offset filter", "pr_createdAt": "2020-10-04T17:31:06Z", "pr_url": "https://github.com/PGMDev/PGM/pull/671", "timeline": [{"oid": "dba65089275671e1438a4741ae17916edfc4a0d2", "url": "https://github.com/PGMDev/PGM/commit/dba65089275671e1438a4741ae17916edfc4a0d2", "message": "Properly implement local locations\n- OffsetFilter -> LocationQueryModifier\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-10-07T22:00:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5Nzg5OQ==", "url": "https://github.com/PGMDev/PGM/pull/671#discussion_r501697899", "bodyText": "You're losing pitch & yaw information when doing this.\nUse location.set(x,y,z) to keep yaw/pitch, but watch out of unintended side-effects, i doubt it will be a thing since player#getLocation always returns a new location, but if other places create this location it could be keeping it modified even after leaving the child filter.\nAlternatively just copy pitch & yaw alongisde world", "author": "Pablete1234", "createdAt": "2020-10-08T12:56:40Z", "path": "core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package tc.oc.pgm.filters;\n+\n+import javax.annotation.Nullable;\n+import org.bukkit.Location;\n+import org.bukkit.event.Event;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.filter.query.LocationQuery;\n+import tc.oc.pgm.filters.query.BlockQuery;\n+\n+public class LocationQueryModifier extends QueryModifier<LocationQuery> {\n+\n+  private final String[] coords;\n+  private final boolean local;\n+  Filter child;\n+\n+  public LocationQueryModifier(Filter child, String[] coords, boolean local) {\n+    super(child);\n+    this.coords = coords;\n+    this.local = local;\n+    this.child = child;\n+  }\n+\n+  @Override\n+  protected LocationQuery modifyQuery(LocationQuery query) {\n+    Location location = query.getLocation();\n+\n+    Vector newVector;\n+\n+    if (local) {\n+      newVector = parseLocalLocation(query.getLocation(), coords[0], coords[1], coords[2]);\n+    } else {\n+      newVector =\n+          new Vector(\n+              parseRelativeLocation(coords[0], location.getX()),\n+              parseRelativeLocation(coords[1], location.getY()),\n+              parseRelativeLocation(coords[2], location.getZ()));\n+    }\n+\n+    return new BlockQueryCustomLocation(\n+        query.getEvent(), newVector.toLocation(query.getMatch().getWorld()));", "originalCommit": "dba65089275671e1438a4741ae17916edfc4a0d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NTIxNw==", "url": "https://github.com/PGMDev/PGM/pull/671#discussion_r501785217", "bodyText": "this is solved with a clone(), good catch!", "author": "KingOfSquares", "createdAt": "2020-10-08T14:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5Nzg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e12b44dbb2b016aae94e5cba86b171ceaf2d3ff", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java b/core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java\ndeleted file mode 100644\nindex 61d590bd..00000000\n--- a/core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java\n+++ /dev/null\n\n@@ -1,96 +0,0 @@\n-package tc.oc.pgm.filters;\n-\n-import javax.annotation.Nullable;\n-import org.bukkit.Location;\n-import org.bukkit.event.Event;\n-import org.bukkit.util.Vector;\n-import tc.oc.pgm.api.filter.Filter;\n-import tc.oc.pgm.api.filter.query.LocationQuery;\n-import tc.oc.pgm.filters.query.BlockQuery;\n-\n-public class LocationQueryModifier extends QueryModifier<LocationQuery> {\n-\n-  private final String[] coords;\n-  private final boolean local;\n-  Filter child;\n-\n-  public LocationQueryModifier(Filter child, String[] coords, boolean local) {\n-    super(child);\n-    this.coords = coords;\n-    this.local = local;\n-    this.child = child;\n-  }\n-\n-  @Override\n-  protected LocationQuery modifyQuery(LocationQuery query) {\n-    Location location = query.getLocation();\n-\n-    Vector newVector;\n-\n-    if (local) {\n-      newVector = parseLocalLocation(query.getLocation(), coords[0], coords[1], coords[2]);\n-    } else {\n-      newVector =\n-          new Vector(\n-              parseRelativeLocation(coords[0], location.getX()),\n-              parseRelativeLocation(coords[1], location.getY()),\n-              parseRelativeLocation(coords[2], location.getZ()));\n-    }\n-\n-    return new BlockQueryCustomLocation(\n-        query.getEvent(), newVector.toLocation(query.getMatch().getWorld()));\n-  }\n-\n-  private double parseRelativeLocation(String coordinate, double originalLocationCoordinate) {\n-    if (coordinate.startsWith(\"~\")) {\n-      return originalLocationCoordinate + Double.parseDouble(coordinate.substring(1));\n-    }\n-    return Double.parseDouble(coordinate);\n-  }\n-\n-  private Vector parseLocalLocation(Location origin, String x, String y, String z) {\n-\n-    double x1 = Double.parseDouble(x.substring(1));\n-    double y1 = Double.parseDouble(y.substring(1));\n-    double z1 = Double.parseDouble(z.substring(1));\n-    Vector dirZ = origin.getDirection().normalize();\n-    Location newLoc = origin.clone().add(dirZ.multiply(z1));\n-\n-    float yaw = newLoc.getYaw() - 90;\n-    Vector dirX = new Vector(-Math.sin(Math.toRadians(yaw)), 0, Math.cos(Math.toRadians(yaw)));\n-    newLoc = newLoc.add(dirX.multiply(x1));\n-\n-    float pitch = newLoc.getPitch() - 90;\n-    Vector dirY = new Vector(0, -Math.sin(Math.toRadians(pitch)), Math.cos(Math.toRadians(pitch)));\n-    newLoc = newLoc.add(dirY.multiply(y1));\n-\n-    return new Vector(newLoc.getX(), newLoc.getY(), newLoc.getZ());\n-  }\n-\n-  @Override\n-  public Class<? extends LocationQuery> getQueryType() {\n-    return LocationQuery.class;\n-  }\n-\n-  /**\n-   * We transform all incoming {@link LocationQuery}s to this query before passing it onwards. This\n-   * action might discard some information (entities, damage causes...) but the use of this modifier\n-   * implies a need for checking the modified location for something else then the origin of the\n-   * query.\n-   */\n-  private static final class BlockQueryCustomLocation extends BlockQuery {\n-\n-    private final Location modifiedLocation;\n-\n-    public BlockQueryCustomLocation(@Nullable Event event, Location modifiedLocation) {\n-      super(event, modifiedLocation.getBlock());\n-      this.modifiedLocation = modifiedLocation;\n-    }\n-\n-    /** This is the precise location, getBlock()#getLocation() and similar will NOT be precise */\n-    @Override\n-    public Location getLocation() {\n-      return modifiedLocation;\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNzE5MA==", "url": "https://github.com/PGMDev/PGM/pull/671#discussion_r508907190", "bodyText": "Break this up into multiple classes, right now you are parsing this field during every query. Same with the relative vs. absolute coordinates. Do parsing at XML time, but it creates different classes with different functionality.", "author": "Electroid", "createdAt": "2020-10-20T23:55:30Z", "path": "core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package tc.oc.pgm.filters;\n+\n+import javax.annotation.Nullable;\n+import org.bukkit.Location;\n+import org.bukkit.event.Event;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.filter.query.LocationQuery;\n+import tc.oc.pgm.filters.query.BlockQuery;\n+\n+public class LocationQueryModifier extends QueryModifier<LocationQuery> {\n+\n+  private final String[] coords;", "originalCommit": "5f8e79419a74533669f5e6f45c9254ce6cc1b7ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e12b44dbb2b016aae94e5cba86b171ceaf2d3ff", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java b/core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java\ndeleted file mode 100644\nindex 2fba39d6..00000000\n--- a/core/src/main/java/tc/oc/pgm/filters/LocationQueryModifier.java\n+++ /dev/null\n\n@@ -1,97 +0,0 @@\n-package tc.oc.pgm.filters;\n-\n-import javax.annotation.Nullable;\n-import org.bukkit.Location;\n-import org.bukkit.event.Event;\n-import org.bukkit.util.Vector;\n-import tc.oc.pgm.api.filter.Filter;\n-import tc.oc.pgm.api.filter.query.LocationQuery;\n-import tc.oc.pgm.filters.query.BlockQuery;\n-\n-public class LocationQueryModifier extends QueryModifier<LocationQuery> {\n-\n-  private final String[] coords;\n-  private final boolean local;\n-  Filter child;\n-\n-  public LocationQueryModifier(Filter child, String[] coords, boolean local) {\n-    super(child);\n-    this.coords = coords;\n-    this.local = local;\n-    this.child = child;\n-  }\n-\n-  @Override\n-  protected LocationQuery modifyQuery(LocationQuery query) {\n-    Location location = query.getLocation();\n-\n-    Location newLocation;\n-\n-    if (local) {\n-      newLocation = parseLocalLocation(location, coords[0], coords[1], coords[2]);\n-    } else {\n-      newLocation =\n-          location\n-              .clone()\n-              .set(\n-                  parseRelativeCoordinate(coords[0], location.getX()),\n-                  parseRelativeCoordinate(coords[1], location.getY()),\n-                  parseRelativeCoordinate(coords[2], location.getZ()));\n-    }\n-\n-    return new BlockQueryCustomLocation(query.getEvent(), newLocation);\n-  }\n-\n-  private double parseRelativeCoordinate(String coordinate, double originalLocationCoordinate) {\n-    if (coordinate.startsWith(\"~\")) {\n-      return originalLocationCoordinate + Double.parseDouble(coordinate.substring(1));\n-    }\n-    return Double.parseDouble(coordinate);\n-  }\n-\n-  private Location parseLocalLocation(Location origin, String x, String y, String z) {\n-\n-    double x1 = Double.parseDouble(x.substring(1));\n-    double y1 = Double.parseDouble(y.substring(1));\n-    double z1 = Double.parseDouble(z.substring(1));\n-    Vector dirZ = origin.getDirection().normalize();\n-    Location newLoc = origin.clone().add(dirZ.multiply(z1));\n-\n-    float yaw = newLoc.getYaw() - 90;\n-    Vector dirX = new Vector(-Math.sin(Math.toRadians(yaw)), 0, Math.cos(Math.toRadians(yaw)));\n-    newLoc = newLoc.add(dirX.multiply(x1));\n-\n-    float pitch = newLoc.getPitch() - 90;\n-    Vector dirY = new Vector(0, -Math.sin(Math.toRadians(pitch)), Math.cos(Math.toRadians(pitch)));\n-    newLoc = newLoc.add(dirY.multiply(y1));\n-\n-    return newLoc;\n-  }\n-\n-  @Override\n-  public Class<? extends LocationQuery> getQueryType() {\n-    return LocationQuery.class;\n-  }\n-\n-  /**\n-   * We transform all incoming {@link LocationQuery}s to this query before passing it onwards. This\n-   * action might discard some information (entities, damage causes...) but the use of this modifier\n-   * implies a need for checking the modified location for something else then the origin of the\n-   * query.\n-   */\n-  private static final class BlockQueryCustomLocation extends BlockQuery {\n-\n-    private final Location modifiedLocation;\n-\n-    public BlockQueryCustomLocation(@Nullable Event event, Location modifiedLocation) {\n-      super(event, modifiedLocation.getBlock());\n-      this.modifiedLocation = modifiedLocation;\n-    }\n-\n-    /** This is the precise location, getBlock()#getLocation() and similar will NOT be precise */\n-    @Override\n-    public Location getLocation() {\n-      return modifiedLocation;\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYwMDAxNw==", "url": "https://github.com/PGMDev/PGM/pull/671#discussion_r525600017", "bodyText": "I belive you could just pass this vector arround instead of a double[] with 3 values.\nIn case of the WorldLocationQueryModifier, pass both the vector and if x, y or z are relative or absolute", "author": "Pablete1234", "createdAt": "2020-11-17T23:45:46Z", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -443,4 +446,46 @@ public StructuralLoadFilter parseStructuralLoad(Element el) throws InvalidXMLExc\n   public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n+\n+  // Methods for parsing QueryModifiers\n+\n+  @MethodParser(\"offset\")\n+  public LocationQueryModifier parseOffsetFilter(Element el) throws InvalidXMLException {\n+    String value = el.getAttributeValue(\"location\");\n+    // Check vector format\n+    XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));", "originalCommit": "dbd3c102aaa5b07c45925fbbc3e5b08edaef4662", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e12b44dbb2b016aae94e5cba86b171ceaf2d3ff", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\nindex 208a66fc..ef0199fc 100644\n--- a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n+++ b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n\n@@ -447,45 +460,8 @@ public abstract class FilterParser {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n \n-  // Methods for parsing QueryModifiers\n-\n-  @MethodParser(\"offset\")\n-  public LocationQueryModifier parseOffsetFilter(Element el) throws InvalidXMLException {\n-    String value = el.getAttributeValue(\"location\");\n-    // Check vector format\n-    XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n-\n-    String[] coords = value.split(\"\\\\s*,\\\\s*\");\n-\n-    Boolean local = null;\n-    for (String coord : coords) {\n-      if (local == null) {\n-        local = coord.startsWith(\"^\");\n-      }\n-\n-      if (coord.startsWith(\"^\") != local)\n-        throw new InvalidXMLException(\"Cannot mix world & local coordinates\", el);\n-    }\n-\n-    if (local == null) throw new InvalidXMLException(\"No coordinates provided\", el);\n-\n-    if (local) {\n-      double[] coordinates = new double[3];\n-      coordinates[0] = Double.parseDouble(coords[0].substring(1));\n-      coordinates[1] = Double.parseDouble(coords[1].substring(1));\n-      coordinates[2] = Double.parseDouble(coords[2].substring(1));\n-      return new LocalLocationQueryModifier(parseChild(el), coordinates);\n-    } else {\n-      boolean[] relative = new boolean[3];\n-      double[] coordinates = new double[3];\n-      for (int i = 0; i < coords.length; i++) {\n-        String coord = coords[i];\n-        boolean isRelative = coord.startsWith(\"~\");\n-        relative[i] = isRelative;\n-        coordinates[i] = Double.parseDouble(isRelative ? coord.substring(1) : coord);\n-      }\n-\n-      return new WorldLocationQueryModifier(parseChild(el), coordinates, relative);\n-    }\n+  @MethodParser(\"score\")\n+  public ScoreFilter parseScoreFilter(Element el) throws InvalidXMLException {\n+    return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n   }\n }\n"}}, {"oid": "3e12b44dbb2b016aae94e5cba86b171ceaf2d3ff", "url": "https://github.com/PGMDev/PGM/commit/3e12b44dbb2b016aae94e5cba86b171ceaf2d3ff", "message": "Add offset filter\n\nSigned-off-by: KingSimon <manmusic979@gmail.com>\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-12-03T21:57:55Z", "type": "commit"}, {"oid": "07fe6109cb6fa2719282c80ccede8bdf8d7604cd", "url": "https://github.com/PGMDev/PGM/commit/07fe6109cb6fa2719282c80ccede8bdf8d7604cd", "message": "Properly implement local locations\n- OffsetFilter -> LocationQueryModifier\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-12-03T21:58:23Z", "type": "commit"}, {"oid": "626f143441ab468d67ddc4148c252ae9b10a7f86", "url": "https://github.com/PGMDev/PGM/commit/626f143441ab468d67ddc4148c252ae9b10a7f86", "message": "Keep correct yaw and pitch after modification\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-03T21:58:23Z", "type": "commit"}, {"oid": "020530c5a952207c8e9b059e0246390f13e3c467", "url": "https://github.com/PGMDev/PGM/commit/020530c5a952207c8e9b059e0246390f13e3c467", "message": "Split the LocationQueryModifier into two separate ones\n- All string -> coordinate is done at XML parsing time\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-03T21:58:23Z", "type": "commit"}, {"oid": "b1c121aed7538e6349795b16bdaba4f574444b5d", "url": "https://github.com/PGMDev/PGM/commit/b1c121aed7538e6349795b16bdaba4f574444b5d", "message": "Use Vector instead of double array\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-03T22:05:07Z", "type": "commit"}, {"oid": "b1c121aed7538e6349795b16bdaba4f574444b5d", "url": "https://github.com/PGMDev/PGM/commit/b1c121aed7538e6349795b16bdaba4f574444b5d", "message": "Use Vector instead of double array\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-03T22:05:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxNzc3NQ==", "url": "https://github.com/PGMDev/PGM/pull/671#discussion_r535717775", "bodyText": "You're already running an XMLUtils.parseVector all the way at the top, no need to parse individual coords in substrings", "author": "Pablete1234", "createdAt": "2020-12-03T23:19:11Z", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -453,4 +457,46 @@ public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n   public ScoreFilter parseScoreFilter(Element el) throws InvalidXMLException {\n     return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n   }\n+\n+  // Methods for parsing QueryModifiers\n+\n+  @MethodParser(\"offset\")\n+  public LocationQueryModifier parseOffsetFilter(Element el) throws InvalidXMLException {\n+    String value = el.getAttributeValue(\"location\");\n+    // Check vector format\n+    XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n+\n+    String[] coords = value.split(\"\\\\s*,\\\\s*\");\n+\n+    Boolean local = null;\n+    for (String coord : coords) {\n+      if (local == null) {\n+        local = coord.startsWith(\"^\");\n+      }\n+\n+      if (coord.startsWith(\"^\") != local)\n+        throw new InvalidXMLException(\"Cannot mix world & local coordinates\", el);\n+    }\n+\n+    if (local == null) throw new InvalidXMLException(\"No coordinates provided\", el);\n+\n+    if (local) {\n+      double x = Double.parseDouble(coords[0].substring(1));\n+      double y = Double.parseDouble(coords[1].substring(1));\n+      double z = Double.parseDouble(coords[2].substring(1));\n+      return new LocalLocationQueryModifier(parseChild(el), new Vector(x, y, z));", "originalCommit": "b1c121aed7538e6349795b16bdaba4f574444b5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAyNjkxOQ==", "url": "https://github.com/PGMDev/PGM/pull/671#discussion_r537026919", "bodyText": "Right, forgot about that", "author": "KingOfSquares", "createdAt": "2020-12-06T12:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxNzc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e4f723d342bdd40f22fee4737a3e00ffc847f26d", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\nindex 2e5da62a..4362d191 100644\n--- a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n+++ b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n\n@@ -464,39 +464,34 @@ public abstract class FilterParser {\n   public LocationQueryModifier parseOffsetFilter(Element el) throws InvalidXMLException {\n     String value = el.getAttributeValue(\"location\");\n     // Check vector format\n-    XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n+    Vector vector = XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n \n     String[] coords = value.split(\"\\\\s*,\\\\s*\");\n \n+    boolean[] relative = new boolean[3];\n+\n     Boolean local = null;\n-    for (String coord : coords) {\n+    for (int i = 0; i < coords.length; i++) {\n+      String coord = coords[i];\n+\n       if (local == null) {\n         local = coord.startsWith(\"^\");\n       }\n \n       if (coord.startsWith(\"^\") != local)\n         throw new InvalidXMLException(\"Cannot mix world & local coordinates\", el);\n+\n+      relative[i] = coord.startsWith(\"~\");\n+\n     }\n \n     if (local == null) throw new InvalidXMLException(\"No coordinates provided\", el);\n \n     if (local) {\n-      double x = Double.parseDouble(coords[0].substring(1));\n-      double y = Double.parseDouble(coords[1].substring(1));\n-      double z = Double.parseDouble(coords[2].substring(1));\n-      return new LocalLocationQueryModifier(parseChild(el), new Vector(x, y, z));\n+      return new LocalLocationQueryModifier(parseChild(el), vector);\n     } else {\n-      boolean[] relative = new boolean[3];\n-      double[] coordinates = new double[3];\n-      for (int i = 0; i < coords.length; i++) {\n-        String coord = coords[i];\n-        boolean isRelative = coord.startsWith(\"~\");\n-        relative[i] = isRelative;\n-        coordinates[i] = Double.parseDouble(isRelative ? coord.substring(1) : coord);\n-      }\n-\n       return new WorldLocationQueryModifier(\n-          parseChild(el), new Vector(coordinates[0], coordinates[1], coordinates[2]), relative);\n+          parseChild(el), vector, relative);\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxODA3NQ==", "url": "https://github.com/PGMDev/PGM/pull/671#discussion_r535718075", "bodyText": "kinda same thing here, no need for coordinates, just use the vector and just check for ~", "author": "Pablete1234", "createdAt": "2020-12-03T23:19:52Z", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -453,4 +457,46 @@ public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n   public ScoreFilter parseScoreFilter(Element el) throws InvalidXMLException {\n     return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n   }\n+\n+  // Methods for parsing QueryModifiers\n+\n+  @MethodParser(\"offset\")\n+  public LocationQueryModifier parseOffsetFilter(Element el) throws InvalidXMLException {\n+    String value = el.getAttributeValue(\"location\");\n+    // Check vector format\n+    XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n+\n+    String[] coords = value.split(\"\\\\s*,\\\\s*\");\n+\n+    Boolean local = null;\n+    for (String coord : coords) {\n+      if (local == null) {\n+        local = coord.startsWith(\"^\");\n+      }\n+\n+      if (coord.startsWith(\"^\") != local)\n+        throw new InvalidXMLException(\"Cannot mix world & local coordinates\", el);\n+    }\n+\n+    if (local == null) throw new InvalidXMLException(\"No coordinates provided\", el);\n+\n+    if (local) {\n+      double x = Double.parseDouble(coords[0].substring(1));\n+      double y = Double.parseDouble(coords[1].substring(1));\n+      double z = Double.parseDouble(coords[2].substring(1));\n+      return new LocalLocationQueryModifier(parseChild(el), new Vector(x, y, z));\n+    } else {\n+      boolean[] relative = new boolean[3];\n+      double[] coordinates = new double[3];\n+      for (int i = 0; i < coords.length; i++) {\n+        String coord = coords[i];\n+        boolean isRelative = coord.startsWith(\"~\");\n+        relative[i] = isRelative;\n+        coordinates[i] = Double.parseDouble(isRelative ? coord.substring(1) : coord);\n+      }\n+\n+      return new WorldLocationQueryModifier(\n+          parseChild(el), new Vector(coordinates[0], coordinates[1], coordinates[2]), relative);", "originalCommit": "b1c121aed7538e6349795b16bdaba4f574444b5d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e4f723d342bdd40f22fee4737a3e00ffc847f26d", "chunk": "diff --git a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\nindex 2e5da62a..4362d191 100644\n--- a/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n+++ b/core/src/main/java/tc/oc/pgm/filters/FilterParser.java\n\n@@ -464,39 +464,34 @@ public abstract class FilterParser {\n   public LocationQueryModifier parseOffsetFilter(Element el) throws InvalidXMLException {\n     String value = el.getAttributeValue(\"location\");\n     // Check vector format\n-    XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n+    Vector vector = XMLUtils.parseVector(new Node(el), value.replaceAll(\"[\\\\^~]\", \"\"));\n \n     String[] coords = value.split(\"\\\\s*,\\\\s*\");\n \n+    boolean[] relative = new boolean[3];\n+\n     Boolean local = null;\n-    for (String coord : coords) {\n+    for (int i = 0; i < coords.length; i++) {\n+      String coord = coords[i];\n+\n       if (local == null) {\n         local = coord.startsWith(\"^\");\n       }\n \n       if (coord.startsWith(\"^\") != local)\n         throw new InvalidXMLException(\"Cannot mix world & local coordinates\", el);\n+\n+      relative[i] = coord.startsWith(\"~\");\n+\n     }\n \n     if (local == null) throw new InvalidXMLException(\"No coordinates provided\", el);\n \n     if (local) {\n-      double x = Double.parseDouble(coords[0].substring(1));\n-      double y = Double.parseDouble(coords[1].substring(1));\n-      double z = Double.parseDouble(coords[2].substring(1));\n-      return new LocalLocationQueryModifier(parseChild(el), new Vector(x, y, z));\n+      return new LocalLocationQueryModifier(parseChild(el), vector);\n     } else {\n-      boolean[] relative = new boolean[3];\n-      double[] coordinates = new double[3];\n-      for (int i = 0; i < coords.length; i++) {\n-        String coord = coords[i];\n-        boolean isRelative = coord.startsWith(\"~\");\n-        relative[i] = isRelative;\n-        coordinates[i] = Double.parseDouble(isRelative ? coord.substring(1) : coord);\n-      }\n-\n       return new WorldLocationQueryModifier(\n-          parseChild(el), new Vector(coordinates[0], coordinates[1], coordinates[2]), relative);\n+          parseChild(el), vector, relative);\n     }\n   }\n }\n"}}, {"oid": "e4f723d342bdd40f22fee4737a3e00ffc847f26d", "url": "https://github.com/PGMDev/PGM/commit/e4f723d342bdd40f22fee4737a3e00ffc847f26d", "message": "stash\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-05T00:41:10Z", "type": "commit"}, {"oid": "9ca4828f512b4bc076dbf6ae595b864c24af0b89", "url": "https://github.com/PGMDev/PGM/commit/9ca4828f512b4bc076dbf6ae595b864c24af0b89", "message": "Make Vector once\n- Add helpful check if someone forgets providing a offset vector\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-06T12:23:14Z", "type": "commit"}]}