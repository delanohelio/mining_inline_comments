{"pr_number": 629, "pr_title": "Add capability of loading local formatting pattern files", "pr_createdAt": "2020-06-19T15:04:52Z", "pr_url": "https://github.com/vmware/singleton/pull/629", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMDE4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453000181", "bodyText": "Why do we need a method that is specific to getting the En locale partterns?", "author": "jessiejuachon", "createdAt": "2020-07-10T18:17:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,21 +4,39 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import java.util.Map;\n-\n-import org.json.simple.JSONObject;\n-\n+import com.vmware.i18n.PatternUtil;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+\n+import java.util.Map;\n \n public class LocalPatternOpt {\n \n-    public JSONObject getPatternsByLocale(String locale) {\n+    public JSONObject getEnPatterns(String locale) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjE0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455902147", "bodyText": "This follows the old workflow, remove this after implementing new workflow.", "author": "huihuiw01", "createdAt": "2020-07-16T16:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMDE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\nindex 79a8856c..4e110a9a 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n\n@@ -4,39 +4,52 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n+import com.vmware.i18n.dto.LocaleDataDTO;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.i18n.PatternUtil;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n import org.json.simple.JSONObject;\n import org.json.simple.parser.JSONParser;\n import org.json.simple.parser.ParseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import java.util.Map;\n \n-public class LocalPatternOpt {\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n-    public JSONObject getEnPatterns(String locale) {\n-        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n-        if (patterns == null) {\n-            return null;\n-        } else {\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n-        }\n+public class LocalPatternOpt implements PatternOpt{\n+    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n+\n+    public JSONObject getPatterns(String locale) {\n+        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n+\n+    @Override\n+    public JSONObject getPatterns(String language, String region) {\n+        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n+        String normalizedLocale = resultData.getLocale();\n+        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\");\n-        String patternStr = PatternUtil.getPatternFromLib(locale, null);\n+    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || normalizedLocale.isEmpty())\n+            return null;\n+        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n         Map<String, Object> patterns = null;\n         try {\n             patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n         } catch (ParseException e) {\n             e.printStackTrace();\n+            logger.error(e.getMessage());\n         }\n-        if (patterns == null) {\n-            return null;\n-        } else {\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n-        }\n+        return patterns == null? null : (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNzM0OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453007348", "bodyText": "Why not patterns = getPatterns(LocaleUtility.getDefaultLocale())?", "author": "jessiejuachon", "createdAt": "2020-07-10T18:32:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjk1MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455902950", "bodyText": "This follows the old workflow, change to use default locale after implementing new workflow.", "author": "huihuiw01", "createdAt": "2020-07-16T16:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNzM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 51d62a59..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -27,95 +21,114 @@ public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(locale);\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            new PatternCacheService().addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, patterns);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for default locale's pattern as fallback!\", language, region);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(language, region, patterns);\n+                logger.debug(\"Default locale's pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        String key = language + \"-\" + region;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(language, region);\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            new PatternCacheService().addPatterns(key, patterns);\n+            formattingCacheService.addPatterns(language, region, patterns);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n-            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n-    private JSONObject getPatternsFromBundle(String locale) {\n+    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(locale);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n \n-    private JSONObject getPatternsFromBundle(String language, String region) {\n+    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        Locale locale = new Locale(language, region);\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-                language = language.replace(\"_\", \"-\");\n-                LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-                String localeStr = resultData.getLocale();\n-                logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, localeStr);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(localeStr);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwODQyOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453008429", "bodyText": "Why not patterns = getPatterns(LocaleUtility.getDefaultLocale())?", "author": "jessiejuachon", "createdAt": "2020-07-10T18:35:03Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMzU1MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455903551", "bodyText": "This follows the old workflow, change to use default locale after implementing new workflow.", "author": "huihuiw01", "createdAt": "2020-07-16T16:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwODQyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 51d62a59..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -27,95 +21,114 @@ public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(locale);\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            new PatternCacheService().addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, patterns);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for default locale's pattern as fallback!\", language, region);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(language, region, patterns);\n+                logger.debug(\"Default locale's pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        String key = language + \"-\" + region;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(language, region);\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            new PatternCacheService().addPatterns(key, patterns);\n+            formattingCacheService.addPatterns(language, region, patterns);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n-            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n-    private JSONObject getPatternsFromBundle(String locale) {\n+    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(locale);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n \n-    private JSONObject getPatternsFromBundle(String language, String region) {\n+    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        Locale locale = new Locale(language, region);\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-                language = language.replace(\"_\", \"-\");\n-                LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-                String localeStr = resultData.getLocale();\n-                logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, localeStr);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(localeStr);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxMzMyOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453013328", "bodyText": "This does not follow the client workflow design. Always try to fetch from the service first even for the default locale, so remove the if-statement block.", "author": "jessiejuachon", "createdAt": "2020-07-10T18:43:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 51d62a59..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -27,95 +21,114 @@ public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(locale);\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            new PatternCacheService().addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, patterns);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for default locale's pattern as fallback!\", language, region);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(language, region, patterns);\n+                logger.debug(\"Default locale's pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        String key = language + \"-\" + region;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(language, region);\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            new PatternCacheService().addPatterns(key, patterns);\n+            formattingCacheService.addPatterns(language, region, patterns);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n-            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n-    private JSONObject getPatternsFromBundle(String locale) {\n+    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(locale);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n \n-    private JSONObject getPatternsFromBundle(String language, String region) {\n+    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        Locale locale = new Locale(language, region);\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-                language = language.replace(\"_\", \"-\");\n-                LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-                String localeStr = resultData.getLocale();\n-                logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, localeStr);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(localeStr);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxNzE4OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453017189", "bodyText": "Do not use if-else statements to get the message origin from the msgOriginsQueue because the order may change in the future. in other words, .get(0) may not always return DataSourceEnum.VIP even if online mode is supported.\nInstead, iterate over msgOriginsQueue. See ComponentService.fetchMessages for reference to do this. Add a createPatternOpt method inside DataSourceEnum.Bundle which will return new LocalePatternOpt(). Add the same method inside DataSourceEnum.VIP which will return new RemotePatternOpt(). Use this DataSourceEnum.createPatternOpt just like in ComponentService.fetchMessages.\nIf you follow the above, the fallback from online to offline mode (and to any other mode added in the queue in the future) will naturally happen without having to modify this method.", "author": "jessiejuachon", "createdAt": "2020-07-10T18:48:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 51d62a59..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -27,95 +21,114 @@ public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(locale);\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            new PatternCacheService().addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, patterns);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for default locale's pattern as fallback!\", language, region);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(language, region, patterns);\n+                logger.debug(\"Default locale's pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        String key = language + \"-\" + region;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(language, region);\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            new PatternCacheService().addPatterns(key, patterns);\n+            formattingCacheService.addPatterns(language, region, patterns);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n-            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n-    private JSONObject getPatternsFromBundle(String locale) {\n+    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(locale);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n \n-    private JSONObject getPatternsFromBundle(String language, String region) {\n+    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        Locale locale = new Locale(language, region);\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-                language = language.replace(\"_\", \"-\");\n-                LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-                String localeStr = resultData.getLocale();\n-                logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, localeStr);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(localeStr);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyNjAwNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453026005", "bodyText": "(Same comment as above)\nThis does not follow the client workflow design. Always try to fetch from the service first even for the default locale, so remove the if-statement block.", "author": "jessiejuachon", "createdAt": "2020-07-10T19:00:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n+                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n+                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n             } else {\n-                patterns = new LocalPatternOpt().getPatternsByLocale(locale);\n+                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n             }\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String language, String region) {\n         JSONObject patterns = null;\n-        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-        \tpatterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n+        Locale locale = new Locale(language, region);\n+        if (LocaleUtility.isDefaultLocale(locale)) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 51d62a59..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -27,95 +21,114 @@ public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(locale);\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            new PatternCacheService().addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, patterns);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for default locale's pattern as fallback!\", language, region);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(language, region, patterns);\n+                logger.debug(\"Default locale's pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        String key = language + \"-\" + region;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(language, region);\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            new PatternCacheService().addPatterns(key, patterns);\n+            formattingCacheService.addPatterns(language, region, patterns);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n-            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n-    private JSONObject getPatternsFromBundle(String locale) {\n+    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(locale);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n \n-    private JSONObject getPatternsFromBundle(String language, String region) {\n+    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        Locale locale = new Locale(language, region);\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-                language = language.replace(\"_\", \"-\");\n-                LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-                String localeStr = resultData.getLocale();\n-                logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, localeStr);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(localeStr);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyNjY1OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453026659", "bodyText": "(Same comment as above)\nDo not use if-else statements to get the message origin from the msgOriginsQueue because the order may change in the future. in other words, .get(0) may not always return DataSourceEnum.VIP even if online mode is supported.\nInstead, iterate over msgOriginsQueue. See ComponentService.fetchMessages for reference to do this. Add a createPatternOpt method inside DataSourceEnum.Bundle which will return new LocalePatternOpt(). Add the same method inside DataSourceEnum.VIP which will return new RemotePatternOpt(). Use this DataSourceEnum.createPatternOpt just like in ComponentService.fetchMessages.\nIf you follow the above, the fallback from online to offline mode (and to any other mode added in the queue in the future) will naturally happen without having to modify this method.", "author": "jessiejuachon", "createdAt": "2020-07-10T19:01:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n+                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n+                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n             } else {\n-                patterns = new LocalPatternOpt().getPatternsByLocale(locale);\n+                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n             }\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String language, String region) {\n         JSONObject patterns = null;\n-        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-        \tpatterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n+        Locale locale = new Locale(language, region);\n+        if (LocaleUtility.isDefaultLocale(locale)) {\n+            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+            patterns = new LocalPatternOpt()\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            patterns = new LocalPatternOpt().getPatternsByLocale(ConstantsKeys.EN);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 51d62a59..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -27,95 +21,114 @@ public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(locale);\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            new PatternCacheService().addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, patterns);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for default locale's pattern as fallback!\", language, region);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(language, region, patterns);\n+                logger.debug(\"Default locale's pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        String key = language + \"-\" + region;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(language, region);\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            new PatternCacheService().addPatterns(key, patterns);\n+            formattingCacheService.addPatterns(language, region, patterns);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n-            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n-    private JSONObject getPatternsFromBundle(String locale) {\n+    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(locale);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n \n-    private JSONObject getPatternsFromBundle(String language, String region) {\n+    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        Locale locale = new Locale(language, region);\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-                language = language.replace(\"_\", \"-\");\n-                LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-                String localeStr = resultData.getLocale();\n-                logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, localeStr);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(localeStr);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyODgxNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456128814", "bodyText": "Put this fallback logic in LocaleMessage so that this method here in LocaleService is always for the requested language only.\nOnce you move the fallback logic into LocaleMessage, update the cache in there in such a way that the key with the requested language is mapped to the FormatCacheItem of the fallback language.\nc.put(<cacheKeyOfRequestedLanguage>, new FormatCacheItem(<displayMapofFallbackLanguage>));\nWithout the above proposed changes, your code will always try to fetch the requested locale first before using the fallback locale that is already in the cache. With the above proposed changes, any succeeding calls for the requested language will immediately return the cached fallback locale until it expires.\nNote: You can either put the above logic in LocaleMessage as I propose (just like how it is in TranslationMessage.getMessages), or create another method here in LocaleService to keep the logic in the \"service layer\".", "author": "jessiejuachon", "createdAt": "2020-07-16T23:13:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt().getRegions(language);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+        }\n+        return regions;\n+    }\n+\n+    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(language == null || language.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        dispMap = getSupportedDisplayNames(language);\n+        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex c23e502c..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -23,119 +19,110 @@ import java.util.Map;\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private LocaleDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            if(language != null && !language.isEmpty()) {\n-                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n-                respMap.put(language, regionMap);\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n             }\n         }\n-        return respMap;\n+        return regionMap;\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language){\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n-        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                    + language);\n-            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n         if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n             return regionMap;\n         }\n-        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (c != null && tmpMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-            c.put(REGION_PREFIX + language, cacheItem);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n             return regionMap;\n         }\n-        if (!LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n-            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        }\n         return regionMap;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> regions = null;\n         if (!msgSourceQueueIter.hasNext())\n             return regions;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt().getRegions(language);\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n         if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n         return regions;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+    public Map<String, String> getDisplayNames(String locale) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if(language == null || language.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n             return dispMap;\n         }\n-        dispMap = getSupportedDisplayNames(language);\n-        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n             Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n         }\n         return dispMap;\n     }\n \n-    private Map<String, String> getSupportedDisplayNames(String language) {\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.trace(\"Look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        String productName = VIPCfg.getInstance().getProductName();\n-        String version = VIPCfg.getInstance().getVersion();\n-        String cacheKey = productName + ConstantsKeys.UNDERLINE + version + ConstantsKeys.UNDERLINE + DISPN_PREFIX + language;\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(cacheKey);\n-            dispMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n         if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, language);\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n         //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, language);\n-            dispMap = JSONUtils.map2SortMap(dispMap);\n-            c.put(cacheKey, new FormatCacheItem(dispMap));\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, language);\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        return null;\n+        return dispMap;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext())\n             return dispMap;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0MDAyNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456140024", "bodyText": "Are the language names coming from the offline CLDR?", "author": "jessiejuachon", "createdAt": "2020-07-16T23:49:34Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExNDg3Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r457114877", "bodyText": "Yes, because in online mode Singleton service get the language names from CLDR, so for offline mode I change the code to get the language names from CLDR, too.", "author": "huihuiw01", "createdAt": "2020-07-20T07:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0MDAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -36,89 +27,72 @@ import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePath\n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n-\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n-\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";\n-\tprivate static final String LANGUAGES_PREFIX = \"languages_\";\n     private static final String BUNDLE_PREFIX = \"messages_\";\n \tprivate static final String BUNDLE_SUFFIX = \".json\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-    \tJSONObject languagesNames = getLanguagesNames(displayLanguage);\n \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate LocaleDTO dto = null;\n+\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n+\t\treturn supportedLanguageNames;\n     }\n \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n-\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t\t}\n-\t\t\t\treturn \"\";\n-\t\t\t}).forEach(language -> {\n-\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n-\t\t\t\t\tif (languagesNames != null) {\n-\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-        }\n-    }\n-\n-    private JSONObject getLanguagesNames(String displayLanguage){\n-\t\tJSONObject languagesNames = null;\n-\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n-\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n-\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n-\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n-\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n-\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n-\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn languagesNames;\n-\n+\t\treturn null;\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n-\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n-\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n \t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n \t\tJSONObject languagesData = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0MTE5Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456141197", "bodyText": "Why not use responseData.isEmpty()  instead of \"\".equalsIgnoreCase(responseData)?\nI saw other instances of this too.", "author": "jessiejuachon", "createdAt": "2020-07-16T23:53:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -28,11 +26,14 @@\n     public RemoteLocaleOpt() {\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language) {\n+    public Map<String, String> getRegions(String language) {\n+        logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", language);\n     \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n                 V2URL.getRegionListURL(language, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n                 ConstantsKeys.GET, null);\n     \tString responseData = (String) response.get(URLUtils.BODY);\n+        if(responseData == null || \"\".equalsIgnoreCase(responseData))", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java\nindex 2c215a0f..2bc9dd97 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java\n\n@@ -23,16 +24,19 @@ public class RemoteLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(RemoteLocaleOpt.class.getName());\n \n-    public RemoteLocaleOpt() {\n+    private LocaleDTO dto = null;\n+\n+    public RemoteLocaleOpt(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String language) {\n-        logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", language);\n+    public Map<String, String> getRegions(String locale) {\n+        logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n     \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(language, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n                 ConstantsKeys.GET, null);\n     \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || \"\".equalsIgnoreCase(responseData))\n+        if(responseData == null || responseData.isEmpty())\n             return null;\n         Map<String, String> respMap = null;\n         try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0NTA0MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456145040", "bodyText": "Put this fallback logic in PatternMessage so that this method here in PatternService is always for the requested language only.\nOnce you move the fallback logic into PatternMessage, update the cache in there in such a way that the key with the requested language is mapped to the FormatCacheItem of the fallback language.\nnew PatternCacheService().addPatterns(<keyOfRequestedLanguage>, <patternsOfDefaultLanguage>);\nWithout the above proposed changes, your code will always try to fetch the requested locale first before using the fallback locale that is already in the cache. With the above proposed changes, any succeeding calls for the requested language will immediately return the cached fallback locale until it expires.\nNote: You can either put the above logic in PatternMessage as I propose (just like how it is in TranslationMessage.getMessages), or create another method here in PatternService to keep the logic in the \"service layer\".", "author": "jessiejuachon", "createdAt": "2020-07-17T00:06:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 3a60ce22..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -19,14 +19,30 @@ import java.util.Locale;\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n-    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n             return null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0NTQwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456145400", "bodyText": "Same comment as above (line 50)", "author": "jessiejuachon", "createdAt": "2020-07-17T00:07:16Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = PATTERNS_PREFIX + language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 3a60ce22..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -19,14 +19,30 @@ import java.util.Locale;\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n-    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n             return null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0NzE2MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456147161", "bodyText": "Can this be private now? If yes, please change it to private.", "author": "jessiejuachon", "createdAt": "2020-07-17T00:13:35Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,17 +4,51 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n+import com.vmware.i18n.dto.LocaleDataDTO;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.Map;\n \n-import org.json.simple.JSONObject;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+public class LocalPatternOpt implements PatternOpt{\n+    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-public class LocalPatternOpt {\n+    public JSONObject getPatterns(String locale) {\n+        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n+\n+    @Override\n+    public JSONObject getPatterns(String language, String region) {\n+        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n+        String normalizedLocale = resultData.getLocale();\n+        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n+    public JSONObject getPatternsByLocale(String normalizedLocale) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\nindex af220142..4e110a9a 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n\n@@ -39,8 +39,8 @@ public class LocalPatternOpt implements PatternOpt{\n         return getPatternsByLocale(normalizedLocale);\n     }\n \n-    public JSONObject getPatternsByLocale(String normalizedLocale) {\n-        if(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || normalizedLocale.isEmpty())\n             return null;\n         String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n         Map<String, Object> patterns = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5NTYzNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455495637", "bodyText": "Don't need this method because client should get the locale from language and region in offline mode.\nIn general, Getting Pattern by locale is enough.", "author": "Xiaochao8", "createdAt": "2020-07-16T03:59:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n+                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n+                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n             } else {\n-                patterns = new LocalPatternOpt().getPatternsByLocale(locale);\n+                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n             }\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String language, String region) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU3OTczNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465579736", "bodyText": "Yeah, but this depends on doing locale fallback/normalization first, and currently locale fallback/normalization is based on cldr locale related data. So this means L2 data needed for locale fallback/normalization must be always included in Java client package.\nBut currently to reduce the size of Java client package, pattern data is put into a separate jar, and for online mode this jar isn't neccessary. If product choose online mode and don't add this jar, change as your suggestion will lead to program broken.\nSo I prefer to remove this after we can guarantee data needed for locale fallback/normalization is always included or we define new locale fallback/normalization rule which doesn't relies on cldr data.", "author": "huihuiw01", "createdAt": "2020-08-05T09:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5NTYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 51d62a59..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -27,95 +21,114 @@ public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(locale);\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            new PatternCacheService().addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, patterns);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for default locale's pattern as fallback!\", language, region);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(language, region, patterns);\n+                logger.debug(\"Default locale's pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        String key = language + \"-\" + region;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n-        patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n         if (patterns != null) {\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n             return patterns;\n         }\n-        patterns = getPatternsFromBundle(language, region);\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (patterns != null) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            new PatternCacheService().addPatterns(key, patterns);\n+            formattingCacheService.addPatterns(language, region, patterns);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n             return patterns;\n         }\n-        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n-            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n-            patterns = getPatterns(ConstantsKeys.EN);\n-        }\n-        return patterns;\n+        return null;\n     }\n \n-    private JSONObject getPatternsFromBundle(String locale) {\n+    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(locale);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n \n-    private JSONObject getPatternsFromBundle(String language, String region) {\n+    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         JSONObject patterns = null;\n-        Locale locale = new Locale(language, region);\n-        if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-            patterns = new LocalPatternOpt()\n-                    .getEnPatterns(ConstantsKeys.EN);\n-        } else {\n-            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n-                logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-                patterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n-            } else {\n-                logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-                language = language.replace(\"_\", \"-\");\n-                LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-                String localeStr = resultData.getLocale();\n-                logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, localeStr);\n-                patterns = new LocalPatternOpt().getPatternsByLocale(localeStr);\n-            }\n+        if (!msgSourceQueueIter.hasNext())\n+            return patterns;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n+        if (patterns == null || patterns.isEmpty()) {\n+            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n         }\n         return patterns;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjAyNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456216027", "bodyText": "Need to log this?", "author": "Xiaochao8", "createdAt": "2020-07-17T04:47:32Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n+\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n+\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t}\n+\t\treturn languagesNames;\n+\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n+\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n+\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\t\t\treturn null;\n+\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\tJSONObject languagesData = null;\n+\t\ttry {\n+\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -36,89 +27,72 @@ import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePath\n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n-\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n-\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";\n-\tprivate static final String LANGUAGES_PREFIX = \"languages_\";\n     private static final String BUNDLE_PREFIX = \"messages_\";\n \tprivate static final String BUNDLE_SUFFIX = \".json\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-    \tJSONObject languagesNames = getLanguagesNames(displayLanguage);\n \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate LocaleDTO dto = null;\n+\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n+\t\treturn supportedLanguageNames;\n     }\n \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n-\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t\t}\n-\t\t\t\treturn \"\";\n-\t\t\t}).forEach(language -> {\n-\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n-\t\t\t\t\tif (languagesNames != null) {\n-\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-        }\n-    }\n-\n-    private JSONObject getLanguagesNames(String displayLanguage){\n-\t\tJSONObject languagesNames = null;\n-\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n-\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n-\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n-\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n-\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n-\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n-\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn languagesNames;\n-\n+\t\treturn null;\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n-\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n-\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n \t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n \t\tJSONObject languagesData = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjA1OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456216058", "bodyText": "Need to log this?", "author": "Xiaochao8", "createdAt": "2020-07-17T04:47:37Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n+\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n+\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t}\n+\t\treturn languagesNames;\n+\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n+\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n+\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\t\t\treturn null;\n+\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\tJSONObject languagesData = null;\n+\t\ttry {\n+\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\tif (languagesData == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t}\n+\n+\tpublic JSONObject getRegions(String displayLanguage) {\n+\t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", displayLanguage);\n+\t\tJSONObject regionsData = null;\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n+\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\t\t\treturn null;\n+\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\ttry {\n+\t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -36,89 +27,72 @@ import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePath\n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n-\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n-\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";\n-\tprivate static final String LANGUAGES_PREFIX = \"languages_\";\n     private static final String BUNDLE_PREFIX = \"messages_\";\n \tprivate static final String BUNDLE_SUFFIX = \".json\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-    \tJSONObject languagesNames = getLanguagesNames(displayLanguage);\n \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate LocaleDTO dto = null;\n+\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n+\t\treturn supportedLanguageNames;\n     }\n \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n-\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t\t}\n-\t\t\t\treturn \"\";\n-\t\t\t}).forEach(language -> {\n-\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n-\t\t\t\t\tif (languagesNames != null) {\n-\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-        }\n-    }\n-\n-    private JSONObject getLanguagesNames(String displayLanguage){\n-\t\tJSONObject languagesNames = null;\n-\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n-\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n-\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n-\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n-\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n-\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n-\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn languagesNames;\n-\n+\t\treturn null;\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n-\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n-\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n \t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n \t\tJSONObject languagesData = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjA4NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456216085", "bodyText": "Need to log this?", "author": "Xiaochao8", "createdAt": "2020-07-17T04:47:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,17 +4,51 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n+import com.vmware.i18n.dto.LocaleDataDTO;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.Map;\n \n-import org.json.simple.JSONObject;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+public class LocalPatternOpt implements PatternOpt{\n+    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-public class LocalPatternOpt {\n+    public JSONObject getPatterns(String locale) {\n+        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n+\n+    @Override\n+    public JSONObject getPatterns(String language, String region) {\n+        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n+        String normalizedLocale = resultData.getLocale();\n+        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n+    public JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+            return null;\n+        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n+        Map<String, Object> patterns = null;\n+        try {\n+            patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n+        } catch (ParseException e) {\n+            e.printStackTrace();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\nindex af220142..4e110a9a 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n\n@@ -39,8 +39,8 @@ public class LocalPatternOpt implements PatternOpt{\n         return getPatternsByLocale(normalizedLocale);\n     }\n \n-    public JSONObject getPatternsByLocale(String normalizedLocale) {\n-        if(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || normalizedLocale.isEmpty())\n             return null;\n         String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n         Map<String, Object> patterns = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxOTE1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456219154", "bodyText": "Printf-style format strings should be used correctly (squid:S3457)", "author": "Xiaochao8", "createdAt": "2020-07-17T05:00:40Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex c23e502c..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -23,119 +19,110 @@ import java.util.Map;\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private LocaleDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            if(language != null && !language.isEmpty()) {\n-                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n-                respMap.put(language, regionMap);\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n             }\n         }\n-        return respMap;\n+        return regionMap;\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language){\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n-        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                    + language);\n-            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n         if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n             return regionMap;\n         }\n-        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (c != null && tmpMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-            c.put(REGION_PREFIX + language, cacheItem);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n             return regionMap;\n         }\n-        if (!LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n-            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        }\n         return regionMap;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> regions = null;\n         if (!msgSourceQueueIter.hasNext())\n             return regions;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt().getRegions(language);\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n         if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n         return regions;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+    public Map<String, String> getDisplayNames(String locale) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if(language == null || language.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n             return dispMap;\n         }\n-        dispMap = getSupportedDisplayNames(language);\n-        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n             Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n         }\n         return dispMap;\n     }\n \n-    private Map<String, String> getSupportedDisplayNames(String language) {\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.trace(\"Look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        String productName = VIPCfg.getInstance().getProductName();\n-        String version = VIPCfg.getInstance().getVersion();\n-        String cacheKey = productName + ConstantsKeys.UNDERLINE + version + ConstantsKeys.UNDERLINE + DISPN_PREFIX + language;\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(cacheKey);\n-            dispMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n         if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, language);\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n         //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, language);\n-            dispMap = JSONUtils.map2SortMap(dispMap);\n-            c.put(cacheKey, new FormatCacheItem(dispMap));\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, language);\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        return null;\n+        return dispMap;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext())\n             return dispMap;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNjE3OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456226178", "bodyText": "should  here be English?", "author": "Xiaochao8", "createdAt": "2020-07-17T05:28:59Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -80,7 +77,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n     \n     private List<Locale> getSupportedLocales() {\n     \tMap<String, String> supportedLanguages = DataSourceEnum.Bundle.createLocaleOpt()\n-    \t\t\t.getLanguages(dto.getLocale());\n+    \t\t\t.getSupportedLanguages(dto.getLocale());", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3MTU5NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458171595", "bodyText": "I only change the method's name, as discussed offline, here should not call 'getSupportedLanguages' in LocalLocaleOpt, but implement get supported locales in a new class 'LocalProductOpt', and call that.", "author": "huihuiw01", "createdAt": "2020-07-21T15:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNjE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg4NDcwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458884700", "bodyText": "I have implemented as above reply.", "author": "huihuiw01", "createdAt": "2020-07-22T15:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNjE3OA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java\nindex 765d0c50..417f9c3b 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java\n\n@@ -76,10 +76,10 @@ public class LocalMessagesOpt implements Opt, MessageOpt {\n     }\n     \n     private List<Locale> getSupportedLocales() {\n-    \tMap<String, String> supportedLanguages = DataSourceEnum.Bundle.createLocaleOpt()\n-    \t\t\t.getSupportedLanguages(dto.getLocale());\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+    \t\t\t.getSupportedLocales();\n     \tList<Locale> supportedLocales = new LinkedList<Locale>();\n-    \tfor (String languageTag : supportedLanguages.keySet()) {\n+    \tfor (String languageTag : supportedLanguages) {\n     \t\tsupportedLocales.add(Locale.forLanguageTag(languageTag));\n     \t}\n     \treturn supportedLocales;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2ODUwNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456268505", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    language = language.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                   language = language.replace(\"_\", \"-\").toLowerCase();", "author": "Xiaochao8", "createdAt": "2020-07-17T07:29:58Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5OTQyMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459199423", "bodyText": "Look like no change.", "author": "huihuiw01", "createdAt": "2020-07-23T03:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2ODUwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex c23e502c..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -23,119 +19,110 @@ import java.util.Map;\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private LocaleDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            if(language != null && !language.isEmpty()) {\n-                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n-                respMap.put(language, regionMap);\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n             }\n         }\n-        return respMap;\n+        return regionMap;\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language){\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n-        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                    + language);\n-            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n         if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n             return regionMap;\n         }\n-        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (c != null && tmpMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-            c.put(REGION_PREFIX + language, cacheItem);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n             return regionMap;\n         }\n-        if (!LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n-            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        }\n         return regionMap;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> regions = null;\n         if (!msgSourceQueueIter.hasNext())\n             return regions;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt().getRegions(language);\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n         if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n         return regions;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+    public Map<String, String> getDisplayNames(String locale) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if(language == null || language.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n             return dispMap;\n         }\n-        dispMap = getSupportedDisplayNames(language);\n-        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n             Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n         }\n         return dispMap;\n     }\n \n-    private Map<String, String> getSupportedDisplayNames(String language) {\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.trace(\"Look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        String productName = VIPCfg.getInstance().getProductName();\n-        String version = VIPCfg.getInstance().getVersion();\n-        String cacheKey = productName + ConstantsKeys.UNDERLINE + version + ConstantsKeys.UNDERLINE + DISPN_PREFIX + language;\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(cacheKey);\n-            dispMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n         if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, language);\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n         //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, language);\n-            dispMap = JSONUtils.map2SortMap(dispMap);\n-            c.put(cacheKey, new FormatCacheItem(dispMap));\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, language);\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        return null;\n+        return dispMap;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext())\n             return dispMap;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzY2Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456273666", "bodyText": "Could remove this class?", "author": "Xiaochao8", "createdAt": "2020-07-17T07:40:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/util/PatternBundleUtil.java", "diffHunk": "@@ -8,13 +8,11 @@\n \n public class PatternBundleUtil {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/util/PatternBundleUtil.java b/src/main/java/com/vmware/vipclient/i18n/util/PatternBundleUtil.java\ndeleted file mode 100644\nindex 53d136bc..00000000\n--- a/src/main/java/com/vmware/vipclient/i18n/util/PatternBundleUtil.java\n+++ /dev/null\n\n@@ -1,23 +0,0 @@\n-/*\n- * Copyright 2019 VMware, Inc.\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package com.vmware.vipclient.i18n.util;\n-\n-import org.json.simple.JSONObject;\n-\n-public class PatternBundleUtil {\n-\n-    public static JSONObject readJSONFile(String filePath, String locale) {\n-        JSONObject jsonObj = null;\n-        String basePath = PatternBundleUtil.class.getProtectionDomain()\n-                .getCodeSource().getLocation().getPath();\n-        filePath = FormatUtils.format(filePath, locale);\n-        if (basePath.lastIndexOf(\".jar\") > 0) {\n-            jsonObj = FileUtil.readJarJsonFile(basePath, filePath);\n-        } else {\n-            jsonObj = FileUtil.readLocalJsonFile(filePath);\n-        }\n-        return jsonObj;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3OTY3MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456279671", "bodyText": "Is it correct fallback here?\nAfter normalizing locale, fallback is unnecessary.", "author": "Xiaochao8", "createdAt": "2020-07-17T07:52:58Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNTMzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458215336", "bodyText": "I agree. A fallback logic must be applied only when the initial fetch for the requested displayLanguage fails.", "author": "jessiejuachon", "createdAt": "2020-07-21T16:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3OTY3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -36,89 +27,72 @@ import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePath\n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n-\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n-\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";\n-\tprivate static final String LANGUAGES_PREFIX = \"languages_\";\n     private static final String BUNDLE_PREFIX = \"messages_\";\n \tprivate static final String BUNDLE_SUFFIX = \".json\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-    \tJSONObject languagesNames = getLanguagesNames(displayLanguage);\n \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate LocaleDTO dto = null;\n+\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n+\t\treturn supportedLanguageNames;\n     }\n \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n-\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t\t}\n-\t\t\t\treturn \"\";\n-\t\t\t}).forEach(language -> {\n-\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n-\t\t\t\t\tif (languagesNames != null) {\n-\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-        }\n-    }\n-\n-    private JSONObject getLanguagesNames(String displayLanguage){\n-\t\tJSONObject languagesNames = null;\n-\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n-\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n-\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n-\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n-\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n-\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n-\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn languagesNames;\n-\n+\t\treturn null;\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n-\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n-\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n \t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n \t\tJSONObject languagesData = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDkzOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456290939", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n          \n          \n            \n                private Map<String, String> getTerritoriesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {", "author": "Xiaochao8", "createdAt": "2020-07-17T08:15:26Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzMzYyNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458133624", "bodyText": "Unified the methods' name with 'Region'", "author": "huihuiw01", "createdAt": "2020-07-21T14:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex c23e502c..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -23,119 +19,110 @@ import java.util.Map;\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private LocaleDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            if(language != null && !language.isEmpty()) {\n-                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n-                respMap.put(language, regionMap);\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n             }\n         }\n-        return respMap;\n+        return regionMap;\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language){\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n-        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                    + language);\n-            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n         if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n             return regionMap;\n         }\n-        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (c != null && tmpMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-            c.put(REGION_PREFIX + language, cacheItem);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n             return regionMap;\n         }\n-        if (!LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n-            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        }\n         return regionMap;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> regions = null;\n         if (!msgSourceQueueIter.hasNext())\n             return regions;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt().getRegions(language);\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n         if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n         return regions;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+    public Map<String, String> getDisplayNames(String locale) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if(language == null || language.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n             return dispMap;\n         }\n-        dispMap = getSupportedDisplayNames(language);\n-        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n             Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n         }\n         return dispMap;\n     }\n \n-    private Map<String, String> getSupportedDisplayNames(String language) {\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.trace(\"Look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        String productName = VIPCfg.getInstance().getProductName();\n-        String version = VIPCfg.getInstance().getVersion();\n-        String cacheKey = productName + ConstantsKeys.UNDERLINE + version + ConstantsKeys.UNDERLINE + DISPN_PREFIX + language;\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(cacheKey);\n-            dispMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n         if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, language);\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n         //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, language);\n-            dispMap = JSONUtils.map2SortMap(dispMap);\n-            c.put(cacheKey, new FormatCacheItem(dispMap));\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, language);\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        return null;\n+        return dispMap;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext())\n             return dispMap;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MTYwNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456291604", "bodyText": "Change all region to Territory?", "author": "Xiaochao8", "createdAt": "2020-07-17T08:16:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1OTYzNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458159634", "bodyText": "Since the client API exposed to developer is getRegionList, so unified 'Territory' to 'region'.", "author": "huihuiw01", "createdAt": "2020-07-21T14:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MTYwNA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex c23e502c..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -23,119 +19,110 @@ import java.util.Map;\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private LocaleDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            if(language != null && !language.isEmpty()) {\n-                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n-                respMap.put(language, regionMap);\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n             }\n         }\n-        return respMap;\n+        return regionMap;\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language){\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n-        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                    + language);\n-            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n         if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n             return regionMap;\n         }\n-        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (c != null && tmpMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-            c.put(REGION_PREFIX + language, cacheItem);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n             return regionMap;\n         }\n-        if (!LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n-            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        }\n         return regionMap;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> regions = null;\n         if (!msgSourceQueueIter.hasNext())\n             return regions;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt().getRegions(language);\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n         if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n         return regions;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+    public Map<String, String> getDisplayNames(String locale) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if(language == null || language.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n             return dispMap;\n         }\n-        dispMap = getSupportedDisplayNames(language);\n-        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n             Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n         }\n         return dispMap;\n     }\n \n-    private Map<String, String> getSupportedDisplayNames(String language) {\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.trace(\"Look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        String productName = VIPCfg.getInstance().getProductName();\n-        String version = VIPCfg.getInstance().getVersion();\n-        String cacheKey = productName + ConstantsKeys.UNDERLINE + version + ConstantsKeys.UNDERLINE + DISPN_PREFIX + language;\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(cacheKey);\n-            dispMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n         if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, language);\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n         //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, language);\n-            dispMap = JSONUtils.map2SortMap(dispMap);\n-            c.put(cacheKey, new FormatCacheItem(dispMap));\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, language);\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        return null;\n+        return dispMap;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext())\n             return dispMap;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MzAyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456293022", "bodyText": "change to \"Argument is empty\"?", "author": "Xiaochao8", "createdAt": "2020-07-17T08:19:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt().getRegions(language);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+        }\n+        return regions;\n+    }\n+\n+    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(language == null || language.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex c23e502c..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -23,119 +19,110 @@ import java.util.Map;\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private LocaleDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            if(language != null && !language.isEmpty()) {\n-                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n-                respMap.put(language, regionMap);\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n             }\n         }\n-        return respMap;\n+        return regionMap;\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language){\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n-        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                    + language);\n-            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n         if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n             return regionMap;\n         }\n-        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (c != null && tmpMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-            c.put(REGION_PREFIX + language, cacheItem);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n             return regionMap;\n         }\n-        if (!LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n-            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        }\n         return regionMap;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> regions = null;\n         if (!msgSourceQueueIter.hasNext())\n             return regions;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt().getRegions(language);\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n         if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n         return regions;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+    public Map<String, String> getDisplayNames(String locale) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if(language == null || language.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n             return dispMap;\n         }\n-        dispMap = getSupportedDisplayNames(language);\n-        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n             Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n         }\n         return dispMap;\n     }\n \n-    private Map<String, String> getSupportedDisplayNames(String language) {\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.trace(\"Look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        String productName = VIPCfg.getInstance().getProductName();\n-        String version = VIPCfg.getInstance().getVersion();\n-        String cacheKey = productName + ConstantsKeys.UNDERLINE + version + ConstantsKeys.UNDERLINE + DISPN_PREFIX + language;\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(cacheKey);\n-            dispMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n         if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, language);\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n         //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, language);\n-            dispMap = JSONUtils.map2SortMap(dispMap);\n-            c.put(cacheKey, new FormatCacheItem(dispMap));\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, language);\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        return null;\n+        return dispMap;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext())\n             return dispMap;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTQyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456295422", "bodyText": "Now client supports multiple configurations, can't get product and version in this way.", "author": "Xiaochao8", "createdAt": "2020-07-17T08:23:49Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt().getRegions(language);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+        }\n+        return regions;\n+    }\n+\n+    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(language == null || language.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        dispMap = getSupportedDisplayNames(language);\n+        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+        }\n+        return dispMap;\n+    }\n+\n+    private Map<String, String> getSupportedDisplayNames(String language) {\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        logger.trace(\"Look for displayNames from cache\");\n         Cache c = VIPCfg.getInstance().getCacheManager()\n                 .getCache(VIPCfg.CACHE_L2);\n+        String productName = VIPCfg.getInstance().getProductName();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex c23e502c..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -23,119 +19,110 @@ import java.util.Map;\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private LocaleDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(LocaleDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            if(language != null && !language.isEmpty()) {\n-                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n-                respMap.put(language, regionMap);\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n             }\n         }\n-        return respMap;\n+        return regionMap;\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language){\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n-        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                    + language);\n-            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n         if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n             return regionMap;\n         }\n-        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (c != null && tmpMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-            c.put(REGION_PREFIX + language, cacheItem);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n             return regionMap;\n         }\n-        if (!LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n-            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        }\n         return regionMap;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> regions = null;\n         if (!msgSourceQueueIter.hasNext())\n             return regions;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt().getRegions(language);\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n         if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n         return regions;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+    public Map<String, String> getDisplayNames(String locale) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if(language == null || language.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n             return dispMap;\n         }\n-        dispMap = getSupportedDisplayNames(language);\n-        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n             Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n         }\n         return dispMap;\n     }\n \n-    private Map<String, String> getSupportedDisplayNames(String language) {\n-        language = language.replace(\"_\", \"-\").toLowerCase();\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.trace(\"Look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        String productName = VIPCfg.getInstance().getProductName();\n-        String version = VIPCfg.getInstance().getVersion();\n-        String cacheKey = productName + ConstantsKeys.UNDERLINE + version + ConstantsKeys.UNDERLINE + DISPN_PREFIX + language;\n-        if (c != null) {\n-            FormatCacheItem cacheItem = (FormatCacheItem) c.get(cacheKey);\n-            dispMap = cacheItem == null ? null : cacheItem.getCachedData();\n-        }\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n         if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, language);\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n         //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n         if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, language);\n-            dispMap = JSONUtils.map2SortMap(dispMap);\n-            c.put(cacheKey, new FormatCacheItem(dispMap));\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, language);\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        return null;\n+        return dispMap;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext())\n             return dispMap;\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMzI2Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456313266", "bodyText": "unused lines?", "author": "Xiaochao8", "createdAt": "2020-07-17T08:56:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -13,24 +27,25 @@\n import java.nio.file.Paths;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.Locale;\n import java.util.Map;\n import java.util.stream.Stream;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n+\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n+\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -6,29 +6,20 @@ package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n import com.vmware.i18n.PatternUtil;\n import com.vmware.i18n.utils.CommonUtil;\n-import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n-import com.vmware.vipclient.i18n.messages.service.PatternCacheService;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n import org.json.simple.JSONObject;\n import org.json.simple.parser.JSONParser;\n import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n-import java.util.stream.Stream;\n \n import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTYwMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456315603", "bodyText": "Should call ProductService/LocalProductOpt to get this information rather than getting directly.", "author": "Xiaochao8", "createdAt": "2020-07-17T09:01:30Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNzQ0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458217447", "bodyText": "@Xiaochao8 , what does the logic here have to do with \"product\"?", "author": "jessiejuachon", "createdAt": "2020-07-21T16:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -36,89 +27,72 @@ import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePath\n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n-\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n-\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";\n-\tprivate static final String LANGUAGES_PREFIX = \"languages_\";\n     private static final String BUNDLE_PREFIX = \"messages_\";\n \tprivate static final String BUNDLE_SUFFIX = \".json\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-    \tJSONObject languagesNames = getLanguagesNames(displayLanguage);\n \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate LocaleDTO dto = null;\n+\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n+\t\treturn supportedLanguageNames;\n     }\n \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n-\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t\t}\n-\t\t\t\treturn \"\";\n-\t\t\t}).forEach(language -> {\n-\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n-\t\t\t\t\tif (languagesNames != null) {\n-\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-        }\n-    }\n-\n-    private JSONObject getLanguagesNames(String displayLanguage){\n-\t\tJSONObject languagesNames = null;\n-\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n-\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n-\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n-\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n-\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n-\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n-\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn languagesNames;\n-\n+\t\treturn null;\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n-\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n-\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n \t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n \t\tJSONObject languagesData = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzc1NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456317755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n          \n          \n            \n                \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p ->p.toFile().isFile())) {", "author": "Xiaochao8", "createdAt": "2020-07-17T09:05:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -36,89 +27,72 @@ import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePath\n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n-\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n-\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";\n-\tprivate static final String LANGUAGES_PREFIX = \"languages_\";\n     private static final String BUNDLE_PREFIX = \"messages_\";\n \tprivate static final String BUNDLE_SUFFIX = \".json\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-    \tJSONObject languagesNames = getLanguagesNames(displayLanguage);\n \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate LocaleDTO dto = null;\n+\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n+\t\treturn supportedLanguageNames;\n     }\n \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n-\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t\t}\n-\t\t\t\treturn \"\";\n-\t\t\t}).forEach(language -> {\n-\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n-\t\t\t\t\tif (languagesNames != null) {\n-\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-        }\n-    }\n-\n-    private JSONObject getLanguagesNames(String displayLanguage){\n-\t\tJSONObject languagesNames = null;\n-\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n-\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n-\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n-\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n-\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n-\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n-\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn languagesNames;\n-\n+\t\treturn null;\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n-\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n-\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n \t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n \t\tJSONObject languagesData = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NTQxNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456975415", "bodyText": "Suggest move fallback to PatternMessage class. There should a interface to get exact pattern data without fallback.", "author": "Xiaochao8", "createdAt": "2020-07-20T00:25:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = PATTERNS_PREFIX + language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 3a60ce22..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -19,14 +19,30 @@ import java.util.Locale;\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n-    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n             return null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NjI4Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456976283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (patterns == null) {\n          \n          \n            \n            return patterns == null ? null : (JSONObject) patterns.get(PatternKeys.CATEGORIES);", "author": "Xiaochao8", "createdAt": "2020-07-20T00:32:35Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,17 +4,51 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n+import com.vmware.i18n.dto.LocaleDataDTO;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.Map;\n \n-import org.json.simple.JSONObject;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+public class LocalPatternOpt implements PatternOpt{\n+    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-public class LocalPatternOpt {\n+    public JSONObject getPatterns(String locale) {\n+        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n+\n+    @Override\n+    public JSONObject getPatterns(String language, String region) {\n+        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n+        String normalizedLocale = resultData.getLocale();\n+        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n+    public JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+            return null;\n+        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n+        Map<String, Object> patterns = null;\n+        try {\n+            patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n+        } catch (ParseException e) {\n+            e.printStackTrace();\n+        }\n         if (patterns == null) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\nindex af220142..4e110a9a 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n\n@@ -39,8 +39,8 @@ public class LocalPatternOpt implements PatternOpt{\n         return getPatternsByLocale(normalizedLocale);\n     }\n \n-    public JSONObject getPatternsByLocale(String normalizedLocale) {\n-        if(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || normalizedLocale.isEmpty())\n             return null;\n         String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n         Map<String, Object> patterns = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MjEzMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456982133", "bodyText": "Move this into PatternCacheService", "author": "Xiaochao8", "createdAt": "2020-07-20T01:13:53Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NzQ3Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458157472", "bodyText": "As explained offline, I think these logic should be here, or no logic in service layer code, but many logic in cache service code, so abort this suggestion. Only move the cache key generation code to PatternCacheService.", "author": "huihuiw01", "createdAt": "2020-07-21T14:49:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MjEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\nindex 3a60ce22..4f0535bb 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java\n\n@@ -19,14 +19,30 @@ import java.util.Locale;\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n-    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatterns(locale);\n+        JSONObject patterns = getPatternsByLocale(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        JSONObject patterns = getPatternsByLocale(locale);\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for default locale's pattern as fallback!\", locale);\n+            patterns = getPatternsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale, patterns);\n+                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n+                return patterns;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public JSONObject getPatternsByLocale(String locale) {\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n             return null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzE4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456983181", "bodyText": "Suggest to do this in PatternMessage or PatternService.", "author": "Xiaochao8", "createdAt": "2020-07-20T01:20:51Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n+\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n+\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t}\n+\t\treturn languagesNames;\n+\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n+\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU4NjU3MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465586571", "bodyText": "This is locale related code, so your suggestion should be 'do this in LocaleMessage or LocaleService.', right?\nThe reason of can't resolve it now is the same with below comment:\nDon't need this method because client should get the locale from language and region in offline mode.\nIn general, Getting Pattern by locale is enough.\nCurrently locale fallback/normalization is based on cldr locale related data. So this means L2 data needed for locale fallback/normalization must be always included in Java client package.\nBut currently to reduce the size of Java client package, pattern data is put into a separate jar, and for online mode this jar isn't neccessary. If product choose online mode and don't add this jar, change as your suggestion will lead to program broken.\nSo I prefer to remove this after we can guarantee data needed for locale fallback/normalization is always included or we define new locale fallback/normalization rule which doesn't relies on cldr data.", "author": "huihuiw01", "createdAt": "2020-08-05T09:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 81839165..5e81adfe 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -36,89 +27,72 @@ import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePath\n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n-\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n-\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";\n-\tprivate static final String LANGUAGES_PREFIX = \"languages_\";\n     private static final String BUNDLE_PREFIX = \"messages_\";\n \tprivate static final String BUNDLE_SUFFIX = \".json\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-    \tJSONObject languagesNames = getLanguagesNames(displayLanguage);\n \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate LocaleDTO dto = null;\n+\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n+\t\treturn supportedLanguageNames;\n     }\n \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n-\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t\t}\n-\t\t\t\treturn \"\";\n-\t\t\t}).forEach(language -> {\n-\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n-\t\t\t\t\tif (languagesNames != null) {\n-\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-        }\n-    }\n-\n-    private JSONObject getLanguagesNames(String displayLanguage){\n-\t\tJSONObject languagesNames = null;\n-\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n-\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n-\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n-\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n-\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n \t\t\treturn languagesNames;\n \t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n-\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n-\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn languagesNames;\n-\n+\t\treturn null;\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n-\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n-\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n \t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n \t\tJSONObject languagesData = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTg0Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459571846", "bodyText": "Let's not have anything hardcoded to English.\nIn this case, you can leave the dto's display locale as null. It will be handled in the service layer. See code suggestion in LocaleService.", "author": "jessiejuachon", "createdAt": "2020-07-23T16:21:13Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -56,9 +72,7 @@ public LocaleMessage() {\n      * @return a list contains the supported language tags\n      */\n     public List<String> getSupportedLanguageTagList() {\n-        Map<String, String> languageTagMap = new LocaleService()\n-                .getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag(), \n-                \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        Map<String, String> languageTagMap = getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag());", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -72,10 +71,9 @@ public class LocaleMessage implements Message {\n      * @return a list contains the supported language tags\n      */\n     public List<String> getSupportedLanguageTagList() {\n-        Map<String, String> languageTagMap = getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag());\n+        Map<String, String> languageTagMap = getDisplayNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n         Collection<String> keyCollection = languageTagMap.keySet();\n-        List<String> languageTagList = new ArrayList<String>(keyCollection);\n-        return languageTagList;\n+        return new ArrayList<String>(keyCollection);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0OTc5Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459749797", "bodyText": "Use the suggested LocaleDTO that also has the locale (display locale's language tag) property in it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LocaleService(BaseDTO dto) {\n          \n          \n            \n                public LocaleService(LocaleDTO dto) {", "author": "jessiejuachon", "createdAt": "2020-07-23T21:54:34Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex fcfdb2c9..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -6,25 +6,43 @@ package com.vmware.vipclient.i18n.messages.service;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.HashMap;\n import java.util.ListIterator;\n+import java.util.Locale;\n import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n     public static final String DISPN_PREFIX  = \"dispn_\";\n-    private BaseDTO dto = null;\n+    private LocaleDTO dto = null;\n \n-    public LocaleService(BaseDTO dto) {\n+    public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegionsFromCLDR(String locale){\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    public Map<String, String> getRegionsByLocale(String locale){\n         locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMDQ0OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459810449", "bodyText": "See #673 for reference\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if (!msgSourceQueueIter.hasNext())\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n          \n          \n            \n                    dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n          \n          \n            \n                    if (dispMap == null || dispMap.isEmpty()) {\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n            }\n          \n          \n            \n               private Map<String, String> getSupportedLanguagesFromDS(String displayLanguageTag, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if (!msgSourceQueueIter.hasNext()) {\n          \n          \n            \n                        logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    DataSourceEnum dataSource = msgSourceQueueIter.next();\n          \n          \n            \n                    dispMap = dataSource.createLocaleOpt().getSupportedLanguages(displayLanguageTag);\n          \n          \n            \n                    if (dispMap == null || dispMap.isEmpty()) {\n          \n          \n            \n                        logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(displayLanguageTag, msgSourceQueueIter);\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T01:18:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n         }\n-        return respMap;\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        \n-        if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+        return regions;\n+    }\n+\n+    public Map<String, String> getSupportedDisplayNames(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        String productName = dto.getProductID();\n+        String version = dto.getVersion();\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n+            return dispMap;\n+        }\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }\n \n+\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if (!msgSourceQueueIter.hasNext())\n+            return dispMap;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        if (dispMap == null || dispMap.isEmpty()) {\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        }\n+        return dispMap;\n+    }\n }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex fcfdb2c9..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -6,25 +6,43 @@ package com.vmware.vipclient.i18n.messages.service;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.HashMap;\n import java.util.ListIterator;\n+import java.util.Locale;\n import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n     public static final String DISPN_PREFIX  = \"dispn_\";\n-    private BaseDTO dto = null;\n+    private LocaleDTO dto = null;\n \n-    public LocaleService(BaseDTO dto) {\n+    public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegionsFromCLDR(String locale){\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    public Map<String, String> getRegionsByLocale(String locale){\n         locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMTE4Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459811183", "bodyText": "See #673 for reference\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Map<String, String> getSupportedDisplayNames(String locale) {\n          \n          \n            \n                    locale = locale.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n          \n          \n            \n                    String productName = dto.getProductID();\n          \n          \n            \n                    String version = dto.getVersion();\n          \n          \n            \n                    FormattingCacheService formattingCacheService = new FormattingCacheService();\n          \n          \n            \n                    dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n          \n          \n            \n                    if (dispMap != null) {\n          \n          \n            \n                        logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    //cacheItem = new FormatCacheItem();\n          \n          \n            \n                    dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                    if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                        logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, locale);\n          \n          \n            \n                        formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n                public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n            \n          \n          \n            \n                    // if display language is null, just proceed to the next available fallback locale\n          \n          \n            \n                    if (displayLanguageTag == null) {\n          \n          \n            \n                        if (fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                    //TODO This will be implemented in Huihui's PR\n          \n          \n            \n                    /*\n          \n          \n            \n                    logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n          \n          \n            \n                    String productName = dto.getProductID();\n          \n          \n            \n                    String version = dto.getVersion();\n          \n          \n            \n                    FormattingCacheService formattingCacheService = new FormattingCacheService();\n          \n          \n            \n                    FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n          \n          \n            \n                    if (cacheItem != null) {\n          \n          \n            \n                        logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n          \n          \n            \n                        dispMap = cacheItem.getCachedData();\n          \n          \n            \n                        if (cacheItem.isExpired()) {\n          \n          \n            \n                            populateCacheTask(displayLanguageTag);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                    */\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                        if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n          \n          \n            \n                            if (dispMap != null && !dispMap.isEmpty()) {\n          \n          \n            \n                                // TODO: Huihui has implemented this in another PR\n          \n          \n            \n                                /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                                logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    //}\n          \n          \n            \n            \n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void populateCacheTask(String displayLanguageTag) {\n          \n          \n            \n                    Callable<Map<String, String>> callable = () -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                            // To make sure that the thread will close\n          \n          \n            \n                            // even when an exception is thrown\n          \n          \n            \n                            return null;\n          \n          \n            \n                        }\n          \n          \n            \n                    };\n          \n          \n            \n                    FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n          \n          \n            \n                    Thread thread = new Thread(task);\n          \n          \n            \n                    thread.start();\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T01:22:18Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n         }\n-        return respMap;\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        \n-        if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+        return regions;\n+    }\n+\n+    public Map<String, String> getSupportedDisplayNames(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        String productName = dto.getProductID();\n+        String version = dto.getVersion();\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n+            return dispMap;\n+        }\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxOTQ1MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465619450", "bodyText": "As we discussed offline, will add cache update in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-05T10:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMTE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex fcfdb2c9..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -6,25 +6,43 @@ package com.vmware.vipclient.i18n.messages.service;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.HashMap;\n import java.util.ListIterator;\n+import java.util.Locale;\n import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n     public static final String DISPN_PREFIX  = \"dispn_\";\n-    private BaseDTO dto = null;\n+    private LocaleDTO dto = null;\n \n-    public LocaleService(BaseDTO dto) {\n+    public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegionsFromCLDR(String locale){\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    public Map<String, String> getRegionsByLocale(String locale){\n         locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNjkzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459816936", "bodyText": "Remove locale parameter, make it a property of LocaleDTO.\nSee code suggestion for getSupportedLanguagesFromDS below for reference", "author": "jessiejuachon", "createdAt": "2020-07-24T01:50:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n         }\n-        return respMap;\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        \n-        if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+        return regions;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MDE3NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465750175", "bodyText": "As we discussed offline, add a new class LocaleDTO in case parameter increase, but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.", "author": "huihuiw01", "createdAt": "2020-08-05T14:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNjkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex fcfdb2c9..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -6,25 +6,43 @@ package com.vmware.vipclient.i18n.messages.service;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.HashMap;\n import java.util.ListIterator;\n+import java.util.Locale;\n import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n     public static final String DISPN_PREFIX  = \"dispn_\";\n-    private BaseDTO dto = null;\n+    private LocaleDTO dto = null;\n \n-    public LocaleService(BaseDTO dto) {\n+    public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegionsFromCLDR(String locale){\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    public Map<String, String> getRegionsByLocale(String locale){\n         locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNzYyMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459817620", "bodyText": "Remove locale parameter, make it a property of LocaleDTO.\nUse fallbackLocalesIter as parameter and recursively call the method to apply locale fallback logic.\nSee code suggestion for getSupportedDisplayNames below for reference", "author": "jessiejuachon", "createdAt": "2020-07-24T01:53:40Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxODA1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465618054", "bodyText": "Remove locale parameter, make it a property of LocaleDTO.\nAs we discussed offline, add a new class LocaleDTO in case parameter increase, but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.\n\n\nUse fallbackLocalesIter as parameter and recursively call the method to apply locale fallback logic.\nI can get the fallback iterator in service layer, no need to get it in message layer and pass it, xiaochao also suggest this.", "author": "huihuiw01", "createdAt": "2020-08-05T10:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNzYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex fcfdb2c9..34995c86 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -6,25 +6,43 @@ package com.vmware.vipclient.i18n.messages.service;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.HashMap;\n import java.util.ListIterator;\n+import java.util.Locale;\n import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n     public static final String DISPN_PREFIX  = \"dispn_\";\n-    private BaseDTO dto = null;\n+    private LocaleDTO dto = null;\n \n-    public LocaleService(BaseDTO dto) {\n+    public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegionsFromCLDR(String locale){\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    public Map<String, String> getRegionsByLocale(String locale){\n         locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> regionMap = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyMzUwNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459823506", "bodyText": "Fallback and caching logic must be handled in the service layer, not in here. See my code suggestion in LocaeService.getSupportedDisplayNames (renamed it to getSupportedLanguages).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if(locale == null || locale.isEmpty()) {\n          \n          \n            \n                        logger.warn(\"Locale is empty!\");\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    BaseDTO dto = new BaseDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    dispMap = localeService.getSupportedDisplayNames(locale);\n          \n          \n            \n                    if(dispMap != null && !dispMap.isEmpty()){\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (!LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);\n          \n          \n            \n                        Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n          \n          \n            \n                        dispMap = localeService.getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n          \n          \n            \n                        if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                            new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                            logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n          \n          \n            \n                                    dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(LocaleDTO dto) {\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return new LocaleService(dto).getSupportedLanguages(LocaleUtility.getFallbackLocales().iterator());\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T02:22:05Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = localeService.getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n+        }\n+        return dispMap;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -88,35 +86,15 @@ public class LocaleMessage implements Message {\n     public List<String> getSupportedDisplayNameList(String displayLocale) {\n         Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n-    }\n-\n-    private Map<String, String> getRegionsFromCLDR(String locale){\n-        Map<String, String> regionMap = null;\n-        LocaleService localeService = new LocaleService(null);\n-        regionMap = localeService.getRegionsFromCLDR(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n-            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n-            }\n-        }\n-        return regionMap;\n+        return new ArrayList<String>(valueCollection);\n     }\n \n     private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n-            return dispMap;\n+            return null;\n         }\n-        BaseDTO dto = new BaseDTO();\n+        LocaleDTO dto = new LocaleDTO();\n         if(cfg != null) {\n             dto.setProductID(cfg.getProductName());\n             dto.setVersion(cfg.getVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDM2MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459824360", "bodyText": "Use LocaleDTO to hold the display locale. Do not pass it as a parameter here.\nMove the locale fallback and caching logic in the service layer (See my comments in LocaleService).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getRegionsFromCLDR(String locale){\n          \n          \n            \n                    Map<String, String> regionMap = null;\n          \n          \n            \n                    LocaleService localeService = new LocaleService(null);\n          \n          \n            \n                    regionMap = localeService.getRegionsFromCLDR(locale);\n          \n          \n            \n                    if (regionMap != null) {\n          \n          \n            \n                        return regionMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (!LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n          \n          \n            \n                        regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n          \n          \n            \n                        if (regionMap != null) {\n          \n          \n            \n                            new FormattingCacheService().addRegions(locale, regionMap);\n          \n          \n            \n                            logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return regionMap;\n          \n          \n            \n                }\n          \n          \n            \n                private Map<String, String> getRegionsFromCLDR(LocaleDTO dto) {\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return new LocaleService(dto). getRegionsFromCLDR(LocaleUtility.getFallbackLocales().iterator());\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T02:26:35Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxNTI3MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465615270", "bodyText": "resolved:\nMove the locale fallback and caching logic in the service layer\nnot resolved:\nUse LocaleDTO to hold the display locale. Do not pass it as a parameter here.\nAs we discussed offline,  add a new class LocaleDTO in case parameter increase,  but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.", "author": "huihuiw01", "createdAt": "2020-08-05T10:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -88,35 +86,15 @@ public class LocaleMessage implements Message {\n     public List<String> getSupportedDisplayNameList(String displayLocale) {\n         Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n-    }\n-\n-    private Map<String, String> getRegionsFromCLDR(String locale){\n-        Map<String, String> regionMap = null;\n-        LocaleService localeService = new LocaleService(null);\n-        regionMap = localeService.getRegionsFromCLDR(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n-            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n-            }\n-        }\n-        return regionMap;\n+        return new ArrayList<String>(valueCollection);\n     }\n \n     private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n-            return dispMap;\n+            return null;\n         }\n-        BaseDTO dto = new BaseDTO();\n+        LocaleDTO dto = new LocaleDTO();\n         if(cfg != null) {\n             dto.setProductID(cfg.getProductName());\n             dto.setVersion(cfg.getVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDg0NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459824844", "bodyText": "Use LocaleDTO to hold the display language tag instead of passing as a parameter.\nRefer to LocaleDTO in #673\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Map<String, String> regionMap = getRegionsFromCLDR(locale);\n          \n          \n            \n                     LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    dto.setDisplayLanguage(locale);\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    } else {\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    Map<String, String> regionMap = getRegionsFromCLDR(dto);", "author": "jessiejuachon", "createdAt": "2020-07-24T02:29:20Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -33,8 +43,15 @@ public LocaleMessage() {\n      * @return map the key is the supported language tag, value is all region data mapped by\n      *         language tag\n      */\n-    public Map<String, Map<String, String>> getRegionList(List<String> supportedLanguageList) {\n-        return new LocaleService().getTerritoriesFromCLDR(supportedLanguageList);\n+    public Map<String, Map<String, String>> getRegionList(List<String> localeList) {\n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String locale : localeList) {\n+            if(locale != null && !locale.isEmpty()) {\n+                Map<String, String> regionMap = getRegionsFromCLDR(locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0OTQzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465749436", "bodyText": "As we discussed offline, add a new class LocaleDTO in case parameter increase, but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.", "author": "huihuiw01", "createdAt": "2020-08-05T14:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDg0NA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -45,9 +43,10 @@ public class LocaleMessage implements Message {\n      */\n     public Map<String, Map<String, String>> getRegionList(List<String> localeList) {\n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        LocaleService localeService = new LocaleService(null);\n         for (String locale : localeList) {\n             if(locale != null && !locale.isEmpty()) {\n-                Map<String, String> regionMap = getRegionsFromCLDR(locale);\n+                Map<String, String> regionMap = localeService.getRegions(locale);\n                 respMap.put(locale, regionMap);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNTI0Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459825243", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n          \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(LocaleDTO dto) {", "author": "jessiejuachon", "createdAt": "2020-07-24T02:31:29Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\nindex 59c658af..c87ff900 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n\n@@ -13,8 +13,9 @@ import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteProductOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNTM1Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459825356", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n          \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(LocaleDTO dto) {", "author": "jessiejuachon", "createdAt": "2020-07-24T02:32:00Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\nindex 59c658af..c87ff900 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n\n@@ -13,8 +13,9 @@ import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteProductOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNTQwNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459825405", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract LocaleOpt createLocaleOpt(BaseDTO dto);\n          \n          \n            \n                public abstract LocaleOpt createLocaleOpt(LocaleDTO dto);", "author": "jessiejuachon", "createdAt": "2020-07-24T02:32:13Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new RemoteLocaleOpt(dto);\n \t\t}\n     };\n+    public abstract ProductOpt createProductOpt(BaseDTO dto);\n     public abstract MessageOpt createMessageOpt(MessagesDTO dto);\n-    public abstract LocaleOpt createLocaleOpt();\n+    public abstract PatternOpt createPatternOpt();\n+    public abstract LocaleOpt createLocaleOpt(BaseDTO dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\nindex 59c658af..c87ff900 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n\n@@ -13,8 +13,9 @@ import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteProductOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459826354", "bodyText": "See my comments in LocaleMessage regarding:\n\nmoving the fallback and caching logic in to the service layer\npassing Iterator iter = LocaleUtility.getFallbackLocales().iterator() to the service\nusing a PatternDTO to hold the locale parameter.", "author": "jessiejuachon", "createdAt": "2020-07-24T02:37:29Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -4,16 +4,20 @@\n  */\n package com.vmware.vipclient.i18n.base.instances;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import com.vmware.vipclient.i18n.messages.service.PatternService;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.messages.service.PatternService;\n+import java.util.Locale;\n \n /**\n  * provide api to get pattern data from remote or locale\n  */\n public class PatternMessage implements Message {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMDcyMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464730723", "bodyText": "Is locale (display language) always required for getPatternMessage? If yes, then ignore my comment above.", "author": "jessiejuachon", "createdAt": "2020-08-04T00:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwNDgxMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465604812", "bodyText": "Yeah, it's required for getPatternMessage, because it's required parameter when call Singleton service API.", "author": "huihuiw01", "createdAt": "2020-08-05T09:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxMDc0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465610747", "bodyText": "resolved:\n\nmoving the fallback and caching logic in to the service layer\n\nnot  resolved:\n\n\npassing Iterator iter = LocaleUtility.getFallbackLocales().iterator() to the service\nI can get the fallback iterator in service layer, no need to get it in message layer and pass it, xiaochao also suggest this.\n\n\nusing a PatternDTO to hold the locale parameter.\nCurrently only one parameter 'locale' is needed, and it's better passed as method parameter, so no need to define PatternDTO. As we discussed offline, you are also ok with this.", "author": "huihuiw01", "createdAt": "2020-08-05T09:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\nindex ee8e2672..91345032 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n\n@@ -4,9 +4,7 @@\n  */\n package com.vmware.vipclient.i18n.base.instances;\n \n-import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n import com.vmware.vipclient.i18n.messages.service.PatternService;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDgwMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459860802", "bodyText": "return FormatCacheItem. Inside FormatCacheItem, implement an isExpired() method that can be used in the service layer.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n          \n          \n            \n                    String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n          \n          \n            \n                    return getFormattings(cacheKey);\n          \n          \n            \n                }\n          \n          \n            \n                public FormatCacheItem getSupportedLanguages(BaseDTO dto, String locale) {\n          \n          \n            \n                    String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n          \n          \n            \n                    return getFormattings(cacheKey);\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T05:40:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.service;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+import org.json.simple.JSONObject;\n+\n+import java.util.Map;\n+\n+public class FormattingCacheService {\n+\n+    public FormattingCacheService() {\n+\n+    }\n+\n+    public void addPatterns(String locale, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addPatterns(String language, String region, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addLanguagesNames(String locale, Map<String, String> o) {\n+        String cacheKey = getLanguagesNamesCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addRegions(String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getRegionsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public JSONObject getPatterns(String locale) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public JSONObject getPatterns(String language, String region) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        return getFormattings(cacheKey);\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1Mzk2OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465553969", "bodyText": "This comment is related to cache update, as we discussed offline, cache update will be added in the next PR, so I will resolve this comment in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-05T08:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDgwMg=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java\ndeleted file mode 100644\nindex 7664f2b8..00000000\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java\n+++ /dev/null\n\n@@ -1,125 +0,0 @@\n-/*\n- * Copyright 2019 VMware, Inc.\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package com.vmware.vipclient.i18n.messages.service;\n-\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n-import org.json.simple.JSONObject;\n-\n-import java.util.Map;\n-\n-public class FormattingCacheService {\n-\n-    public FormattingCacheService() {\n-\n-    }\n-\n-    public void addPatterns(String locale, JSONObject o) {\n-        String cacheKey = getPatternsCacheKey(locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addPatterns(String language, String region, JSONObject o) {\n-        String cacheKey = getPatternsCacheKey(language, region);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n-        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addLanguagesNames(String locale, Map<String, String> o) {\n-        String cacheKey = getLanguagesNamesCacheKey(locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addRegions(String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n-        String cacheKey = getRegionsCacheKey(locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public JSONObject getPatterns(String locale) {\n-        String cacheKey = getPatternsCacheKey(locale);\n-        return getFormattingPatterns(cacheKey);\n-    }\n-\n-    public JSONObject getPatterns(String language, String region) {\n-        String cacheKey = getPatternsCacheKey(language, region);\n-        return getFormattingPatterns(cacheKey);\n-    }\n-\n-    public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n-        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n-        return getFormattings(cacheKey);\n-    }\n-\n-    public Map<String, String> getLanguagesNames(String locale) {\n-        String cacheKey = getLanguagesNamesCacheKey(locale);\n-        return getFormattings(cacheKey);\n-    }\n-\n-    public Map<String, String> getRegions(String locale) {\n-        String cacheKey = getRegionsCacheKey(locale);\n-        return getFormattings(cacheKey);\n-    }\n-\n-    private String getPatternsCacheKey(String locale){\n-        return ConstantsKeys.PATTERNS_PREFIX + locale;\n-    }\n-\n-    private String getPatternsCacheKey(String language, String region){\n-        return ConstantsKeys.PATTERNS_PREFIX + language + \"-\" + region;\n-    }\n-\n-    private String getSupportedLanguagesCacheKey(BaseDTO dto, String locale){\n-        return ConstantsKeys.DISPNS_PREFIX + dto.getProductID() + ConstantsKeys.UNDERLINE + dto.getVersion() + ConstantsKeys.UNDERLINE + locale;\n-    }\n-\n-    private String getLanguagesNamesCacheKey(String locale){\n-        return ConstantsKeys.LANGUAGES_PREFIX + locale;\n-    }\n-\n-    private String getRegionsCacheKey(String locale){\n-        return ConstantsKeys.REGIONS_PREFIX + locale;\n-    }\n-\n-    private JSONObject getFormattingPatterns(String key) {\n-        Map<String, String> o = getFormattings(key);\n-        if (o != null) {\n-            return new JSONObject(o);\n-        }\n-        return null;\n-    }\n-\n-    private void addFormattings(String key, Map<String, String> o) {\n-        if (null != key && null != o) {\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-                c.put(key, new FormatCacheItem(o));\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> getFormattings(String key) {\n-        Map<String, String> o = null;\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n-        \tif (cacheItem != null)\n-        \t\to = cacheItem.getCachedData();\n-        }\n-        return o;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MTgyNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459861826", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getFormattings(String key) {\n          \n          \n            \n                    Map<String, String> o = null;\n          \n          \n            \n                    Cache c = VIPCfg.getInstance().getCacheManager()\n          \n          \n            \n                            .getCache(VIPCfg.CACHE_L2);\n          \n          \n            \n                    if (c != null) {\n          \n          \n            \n                    \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n          \n          \n            \n                    \tif (cacheItem != null)\n          \n          \n            \n                    \t\to = cacheItem.getCachedData();\n          \n          \n            \n                    }\n          \n          \n            \n                    return o;\n          \n          \n            \n                }\n          \n          \n            \n                private FormatCacheItem getFormattings(String key) {\n          \n          \n            \n                    FormatCacheItem cacheItem  = null;\n          \n          \n            \n                    Cache c = VIPCfg.getInstance().getCacheManager()\n          \n          \n            \n                            .getCache(VIPCfg.CACHE_L2);\n          \n          \n            \n                    if (c != null) {\n          \n          \n            \n                    \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n          \n          \n            \n                    }\n          \n          \n            \n                    return cacheItem;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T05:44:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.service;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+import org.json.simple.JSONObject;\n+\n+import java.util.Map;\n+\n+public class FormattingCacheService {\n+\n+    public FormattingCacheService() {\n+\n+    }\n+\n+    public void addPatterns(String locale, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addPatterns(String language, String region, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addLanguagesNames(String locale, Map<String, String> o) {\n+        String cacheKey = getLanguagesNamesCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addRegions(String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getRegionsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public JSONObject getPatterns(String locale) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public JSONObject getPatterns(String language, String region) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        return getFormattings(cacheKey);\n+    }\n+\n+    public Map<String, String> getLanguagesNames(String locale) {\n+        String cacheKey = getLanguagesNamesCacheKey(locale);\n+        return getFormattings(cacheKey);\n+    }\n+\n+    public Map<String, String> getRegions(String locale) {\n+        String cacheKey = getRegionsCacheKey(locale);\n+        return getFormattings(cacheKey);\n+    }\n+\n+    private String getPatternsCacheKey(String locale){\n+        return ConstantsKeys.PATTERNS_PREFIX + locale;\n+    }\n+\n+    private String getPatternsCacheKey(String language, String region){\n+        return ConstantsKeys.PATTERNS_PREFIX + language + \"-\" + region;\n+    }\n+\n+    private String getSupportedLanguagesCacheKey(BaseDTO dto, String locale){\n+        return ConstantsKeys.DISPNS_PREFIX + dto.getProductID() + ConstantsKeys.UNDERLINE + dto.getVersion() + ConstantsKeys.UNDERLINE + locale;\n+    }\n+\n+    private String getLanguagesNamesCacheKey(String locale){\n+        return ConstantsKeys.LANGUAGES_PREFIX + locale;\n+    }\n+\n+    private String getRegionsCacheKey(String locale){\n+        return ConstantsKeys.REGIONS_PREFIX + locale;\n+    }\n+\n+    private JSONObject getFormattingPatterns(String key) {\n+        Map<String, String> o = getFormattings(key);\n+        if (o != null) {\n+            return new JSONObject(o);\n+        }\n+        return null;\n+    }\n+\n+    private void addFormattings(String key, Map<String, String> o) {\n+        if (null != key && null != o) {\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+                c.put(key, new FormatCacheItem(o));\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> getFormattings(String key) {\n+        Map<String, String> o = null;\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n+        \tif (cacheItem != null)\n+        \t\to = cacheItem.getCachedData();\n+        }\n+        return o;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1MzY4NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465553684", "bodyText": "This comment is related to cache update, as we discussed offline, cache update will be added in the next PR, so I will resolve this comment in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-05T08:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MTgyNg=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java\ndeleted file mode 100644\nindex 7664f2b8..00000000\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java\n+++ /dev/null\n\n@@ -1,125 +0,0 @@\n-/*\n- * Copyright 2019 VMware, Inc.\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package com.vmware.vipclient.i18n.messages.service;\n-\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n-import org.json.simple.JSONObject;\n-\n-import java.util.Map;\n-\n-public class FormattingCacheService {\n-\n-    public FormattingCacheService() {\n-\n-    }\n-\n-    public void addPatterns(String locale, JSONObject o) {\n-        String cacheKey = getPatternsCacheKey(locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addPatterns(String language, String region, JSONObject o) {\n-        String cacheKey = getPatternsCacheKey(language, region);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n-        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addLanguagesNames(String locale, Map<String, String> o) {\n-        String cacheKey = getLanguagesNamesCacheKey(locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public void addRegions(String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n-        String cacheKey = getRegionsCacheKey(locale);\n-        addFormattings(cacheKey, o);\n-    }\n-\n-    public JSONObject getPatterns(String locale) {\n-        String cacheKey = getPatternsCacheKey(locale);\n-        return getFormattingPatterns(cacheKey);\n-    }\n-\n-    public JSONObject getPatterns(String language, String region) {\n-        String cacheKey = getPatternsCacheKey(language, region);\n-        return getFormattingPatterns(cacheKey);\n-    }\n-\n-    public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n-        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n-        return getFormattings(cacheKey);\n-    }\n-\n-    public Map<String, String> getLanguagesNames(String locale) {\n-        String cacheKey = getLanguagesNamesCacheKey(locale);\n-        return getFormattings(cacheKey);\n-    }\n-\n-    public Map<String, String> getRegions(String locale) {\n-        String cacheKey = getRegionsCacheKey(locale);\n-        return getFormattings(cacheKey);\n-    }\n-\n-    private String getPatternsCacheKey(String locale){\n-        return ConstantsKeys.PATTERNS_PREFIX + locale;\n-    }\n-\n-    private String getPatternsCacheKey(String language, String region){\n-        return ConstantsKeys.PATTERNS_PREFIX + language + \"-\" + region;\n-    }\n-\n-    private String getSupportedLanguagesCacheKey(BaseDTO dto, String locale){\n-        return ConstantsKeys.DISPNS_PREFIX + dto.getProductID() + ConstantsKeys.UNDERLINE + dto.getVersion() + ConstantsKeys.UNDERLINE + locale;\n-    }\n-\n-    private String getLanguagesNamesCacheKey(String locale){\n-        return ConstantsKeys.LANGUAGES_PREFIX + locale;\n-    }\n-\n-    private String getRegionsCacheKey(String locale){\n-        return ConstantsKeys.REGIONS_PREFIX + locale;\n-    }\n-\n-    private JSONObject getFormattingPatterns(String key) {\n-        Map<String, String> o = getFormattings(key);\n-        if (o != null) {\n-            return new JSONObject(o);\n-        }\n-        return null;\n-    }\n-\n-    private void addFormattings(String key, Map<String, String> o) {\n-        if (null != key && null != o) {\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-                c.put(key, new FormatCacheItem(o));\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> getFormattings(String key) {\n-        Map<String, String> o = null;\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n-        \tif (cacheItem != null)\n-        \t\to = cacheItem.getCachedData();\n-        }\n-        return o;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwMzk5MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462103991", "bodyText": "Suggest to change to because class name of local ProductOpt is LocalProuctOpt\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ProductBasedOpt extends BaseOpt implements ProductOpt {\n          \n          \n            \n            public class RemoteProductOpt extends BaseOpt implements ProductOpt {", "author": "Xiaochao8", "createdAt": "2020-07-29T07:45:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java", "diffHunk": "@@ -4,19 +4,19 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import java.util.Map;\n-\n-import org.json.simple.JSONArray;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.Opt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONArray;\n+\n+import java.util.List;\n+import java.util.Map;\n \n-public class ProductBasedOpt extends BaseOpt implements Opt {\n+public class ProductBasedOpt extends BaseOpt implements ProductOpt {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java\nsimilarity index 95%\nrename from src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\nrename to src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java\nindex 64cf5e5d..57340fef 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java\n\n@@ -16,10 +16,10 @@ import org.json.simple.JSONArray;\n import java.util.List;\n import java.util.Map;\n \n-public class ProductBasedOpt extends BaseOpt implements ProductOpt {\n+public class RemoteProductOpt extends BaseOpt implements ProductOpt {\n     private BaseDTO dto = null;\n \n-    public ProductBasedOpt(BaseDTO dto) {\n+    public RemoteProductOpt(BaseDTO dto) {\n         this.dto = dto;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTQ5Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462105497", "bodyText": "Since we have more than one message such as Translation message and locale message.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract MessageOpt createMessageOpt(MessagesDTO dto);\n          \n          \n            \n                public abstract TranslationOpt createTranslationOpt(MessagesDTO dto);", "author": "Xiaochao8", "createdAt": "2020-07-29T07:48:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new RemoteLocaleOpt(dto);\n \t\t}\n     };\n+    public abstract ProductOpt createProductOpt(BaseDTO dto);\n     public abstract MessageOpt createMessageOpt(MessagesDTO dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMTk2OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462821969", "bodyText": "I don't make change to this code line, and this is L3 related code, wouldn't like to change them in L2 related PR.\nOr code changes may make reviewers confused.", "author": "huihuiw01", "createdAt": "2020-07-30T08:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\nindex 59c658af..c87ff900 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n\n@@ -13,8 +13,9 @@ import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteProductOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTkxMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462105911", "bodyText": "In my opinion, pattern is a kind of locale data. So these 2 interfaces may be merged.", "author": "Xiaochao8", "createdAt": "2020-07-29T07:49:32Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new RemoteLocaleOpt(dto);\n \t\t}\n     };\n+    public abstract ProductOpt createProductOpt(BaseDTO dto);\n     public abstract MessageOpt createMessageOpt(MessagesDTO dto);\n-    public abstract LocaleOpt createLocaleOpt();\n+    public abstract PatternOpt createPatternOpt();\n+    public abstract LocaleOpt createLocaleOpt(BaseDTO dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMjAyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462822022", "bodyText": "Pattern data is format data, not locale data. So they are different, shouldn't be put into one interface.\nBTW, on service side, they are are regarded as different resources and provided by different APIs and implemented by different interfaces.", "author": "huihuiw01", "createdAt": "2020-07-30T08:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTkxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\nindex 59c658af..c87ff900 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n\n@@ -13,8 +13,9 @@ import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteProductOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzU3Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462107572", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new ComponentBasedOpt(dto);\n          \n          \n            \n                        return new RemoteTranslationOpt(dto);", "author": "Xiaochao8", "createdAt": "2020-07-29T07:52:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMjA2NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462822065", "bodyText": "I don't make change to this code line, and this is L3 related code, wouldn't like to change them in L2 related PR.\nOr code changes may make reviewers confused.", "author": "huihuiw01", "createdAt": "2020-07-30T08:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzU3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\nindex 59c658af..c87ff900 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n\n@@ -13,8 +13,9 @@ import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteProductOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzg4Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462107883", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new LocalMessagesOpt(dto);\n          \n          \n            \n                        return new LocalTranslationOpt(dto);", "author": "Xiaochao8", "createdAt": "2020-07-29T07:53:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMjExNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462822116", "bodyText": "I don't make change to this code line, and this is L3 related code, wouldn't like to change them in L2 related PR.\nOr code changes may make reviewers confused.", "author": "huihuiw01", "createdAt": "2020-07-30T08:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\nindex 59c658af..c87ff900 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java\n\n@@ -13,8 +13,9 @@ import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteProductOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwOTM0OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462109348", "bodyText": "Suggest to move this into ProductOpt. It looks better to put all product related interfaces together.", "author": "Xiaochao8", "createdAt": "2020-07-29T07:55:34Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/LocaleOpt.java", "diffHunk": "@@ -7,5 +7,6 @@\n import java.util.Map;\n \n public interface LocaleOpt {\n-\tpublic Map<String, String> getLanguages(String displayLanguage);\n+\tpublic Map<String, String> getSupportedLanguages(String locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxODQ4Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462818487", "bodyText": "This method is to get supported languages(including language's displayName), corresponding to Singleton service API '/i18n/api/v2/locale/supportedLanguageList' under locale-api, different with get supported locales(only including language tag, no language's displayName).\nI add 'getSupportedLocales' method in ProductOpt, corresponding to Singleton service API '/i18n/api/v2/translation/products/{productName}/versions/{version}/localelist' under translation-product-api.\nOrganize them similar to Singleton service.", "author": "huihuiw01", "createdAt": "2020-07-30T07:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwOTM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/LocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/LocaleOpt.java\nindex 9b1dcd1b..fbfd63e6 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/LocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/LocaleOpt.java\n\n@@ -7,6 +7,5 @@ package com.vmware.vipclient.i18n.messages.api.opt;\n import java.util.Map;\n \n public interface LocaleOpt {\n-\tpublic Map<String, String> getSupportedLanguages(String locale);\n-\tpublic Map<String, String> getRegions(String locale);\n+\tpublic Map<String, String> getLanguages(String displayLanguage);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExMjc3Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462112776", "bodyText": "Why do this change?", "author": "Xiaochao8", "createdAt": "2020-07-29T08:01:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/I18nFactory.java", "diffHunk": "@@ -90,7 +90,7 @@ public Message getMessageInstance(Class c, VIPCfg cfg) {\n         if (null == cfg) {\n             key = c.getCanonicalName();\n         } else {\n-            key = cfg.getProductName();\n+            key = c.getCanonicalName() + \".\" + cfg.getProductName();", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyNDczMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462824731", "bodyText": "Because two different instances(TranslationMessage and LocaleMessage) support shared component, if not add class name, the key for two different instances is the same, one instance maybe covered by the other.", "author": "huihuiw01", "createdAt": "2020-07-30T08:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExMjc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/I18nFactory.java b/src/main/java/com/vmware/vipclient/i18n/I18nFactory.java\nindex b156b82a..9706a272 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/I18nFactory.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/I18nFactory.java\n\n@@ -90,7 +90,7 @@ public class I18nFactory {\n         if (null == cfg) {\n             key = c.getCanonicalName();\n         } else {\n-            key = c.getCanonicalName() + \".\" + cfg.getProductName();\n+            key = cfg.getProductName();\n         }\n         if (messages.containsKey(key)) {\n             return messages.get(key);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyOTI3Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462129272", "bodyText": "It has different reasons to failure, locale is just one of them. So I think that no fallback is acceptable.", "author": "Xiaochao8", "createdAt": "2020-07-29T08:29:08Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTIwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466675200", "bodyText": "Why \"no fallback is acceptable\"? If it fails for any reason, why not try the fallback locale?", "author": "jessiejuachon", "createdAt": "2020-08-06T20:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyOTI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -88,35 +86,15 @@ public class LocaleMessage implements Message {\n     public List<String> getSupportedDisplayNameList(String displayLocale) {\n         Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n-    }\n-\n-    private Map<String, String> getRegionsFromCLDR(String locale){\n-        Map<String, String> regionMap = null;\n-        LocaleService localeService = new LocaleService(null);\n-        regionMap = localeService.getRegionsFromCLDR(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n-            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n-            }\n-        }\n-        return regionMap;\n+        return new ArrayList<String>(valueCollection);\n     }\n \n     private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n-            return dispMap;\n+            return null;\n         }\n-        BaseDTO dto = new BaseDTO();\n+        LocaleDTO dto = new LocaleDTO();\n         if(cfg != null) {\n             dto.setProductID(cfg.getProductName());\n             dto.setVersion(cfg.getVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyOTk4Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462129987", "bodyText": "Default doesn't need to be English. Suggest to search English to see if other similar typos exist.", "author": "Xiaochao8", "createdAt": "2020-07-29T08:30:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -88,35 +86,15 @@ public class LocaleMessage implements Message {\n     public List<String> getSupportedDisplayNameList(String displayLocale) {\n         Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n-    }\n-\n-    private Map<String, String> getRegionsFromCLDR(String locale){\n-        Map<String, String> regionMap = null;\n-        LocaleService localeService = new LocaleService(null);\n-        regionMap = localeService.getRegionsFromCLDR(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n-            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n-            }\n-        }\n-        return regionMap;\n+        return new ArrayList<String>(valueCollection);\n     }\n \n     private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n-            return dispMap;\n+            return null;\n         }\n-        BaseDTO dto = new BaseDTO();\n+        LocaleDTO dto = new LocaleDTO();\n         if(cfg != null) {\n             dto.setProductID(cfg.getProductName());\n             dto.setVersion(cfg.getVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMDc0MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462130741", "bodyText": "Cache has been processed in service layer.", "author": "Xiaochao8", "createdAt": "2020-07-29T08:31:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = localeService.getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMjA2Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462832063", "bodyText": "This is changed according to Jessiely's suggestion, cache default locale's content as requested locale, or will always try to fetch the requested locale first before using the fallback locale that is already in the cache, which may increase product UI loading time.\nBelow is Jessiely's original words:\nPut this fallback logic in LocaleMessage so that this method here in LocaleService is always for the requested language only.\nOnce you move the fallback logic into LocaleMessage, update the cache in there in such a way that the key with the requested language is mapped to the FormatCacheItem of the fallback language.\nc.put(, new FormatCacheItem());\nWithout the above proposed changes, your code will always try to fetch the requested locale first before using the fallback locale that is already in the cache. With the above proposed changes, any succeeding calls for the requested language will immediately return the cached fallback locale until it expires.\nNote: You can either put the above logic in LocaleMessage as I propose (just like how it is in TranslationMessage.getMessages), or create another method here in LocaleService to keep the logic in the \"service layer\".", "author": "huihuiw01", "createdAt": "2020-07-30T08:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMDc0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -88,35 +86,15 @@ public class LocaleMessage implements Message {\n     public List<String> getSupportedDisplayNameList(String displayLocale) {\n         Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n-    }\n-\n-    private Map<String, String> getRegionsFromCLDR(String locale){\n-        Map<String, String> regionMap = null;\n-        LocaleService localeService = new LocaleService(null);\n-        regionMap = localeService.getRegionsFromCLDR(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n-            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n-            }\n-        }\n-        return regionMap;\n+        return new ArrayList<String>(valueCollection);\n     }\n \n     private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n-            return dispMap;\n+            return null;\n         }\n-        BaseDTO dto = new BaseDTO();\n+        LocaleDTO dto = new LocaleDTO();\n         if(cfg != null) {\n             dto.setProductID(cfg.getProductName());\n             dto.setVersion(cfg.getVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMjM5Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462132396", "bodyText": "Immediately return this expression instead of assigning it to the temporary variable \"languageTagList\".", "author": "Xiaochao8", "createdAt": "2020-07-29T08:33:52Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -88,35 +86,15 @@ public class LocaleMessage implements Message {\n     public List<String> getSupportedDisplayNameList(String displayLocale) {\n         Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n-    }\n-\n-    private Map<String, String> getRegionsFromCLDR(String locale){\n-        Map<String, String> regionMap = null;\n-        LocaleService localeService = new LocaleService(null);\n-        regionMap = localeService.getRegionsFromCLDR(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n-            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n-            }\n-        }\n-        return regionMap;\n+        return new ArrayList<String>(valueCollection);\n     }\n \n     private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n         if(locale == null || locale.isEmpty()) {\n             logger.warn(\"Locale is empty!\");\n-            return dispMap;\n+            return null;\n         }\n-        BaseDTO dto = new BaseDTO();\n+        LocaleDTO dto = new LocaleDTO();\n         if(cfg != null) {\n             dto.setProductID(cfg.getProductName());\n             dto.setVersion(cfg.getVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTQ3MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462175471", "bodyText": "It seems this class can have a static instance of PatternService.", "author": "Xiaochao8", "createdAt": "2020-07-29T09:46:16Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -26,7 +30,22 @@ public PatternMessage() {\n      * @return\n      */\n     public JSONObject getPatternMessage(Locale locale) {\n-        return new PatternService().getPatterns(locale.toLanguageTag());\n+        JSONObject patterns = null;\n+        PatternService ps = new PatternService();", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\nindex ee8e2672..91345032 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n\n@@ -30,22 +28,7 @@ public class PatternMessage implements Message {\n      * @return\n      */\n     public JSONObject getPatternMessage(Locale locale) {\n-        JSONObject patterns = null;\n-        PatternService ps = new PatternService();\n-        patterns = ps.getPatterns(locale.toLanguageTag());\n-        if (patterns != null) {\n-            return patterns;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = ps.getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale.toLanguageTag(), patterns);\n-                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n-                return patterns;\n-            }\n-        }\n-        return null;\n+        return new PatternService().getPatterns(locale.toLanguageTag());\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3Njg0NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462176844", "bodyText": "Is it necessary to store into cache?", "author": "Xiaochao8", "createdAt": "2020-07-29T09:48:43Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -26,7 +30,22 @@ public PatternMessage() {\n      * @return\n      */\n     public JSONObject getPatternMessage(Locale locale) {\n-        return new PatternService().getPatterns(locale.toLanguageTag());\n+        JSONObject patterns = null;\n+        PatternService ps = new PatternService();\n+        patterns = ps.getPatterns(locale.toLanguageTag());\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = ps.getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale.toLanguageTag(), patterns);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMjY5MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462832690", "bodyText": "Same reason as that for LocaleMessage.", "author": "huihuiw01", "createdAt": "2020-07-30T08:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3Njg0NA=="}], "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\nindex ee8e2672..91345032 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n\n@@ -30,22 +28,7 @@ public class PatternMessage implements Message {\n      * @return\n      */\n     public JSONObject getPatternMessage(Locale locale) {\n-        JSONObject patterns = null;\n-        PatternService ps = new PatternService();\n-        patterns = ps.getPatterns(locale.toLanguageTag());\n-        if (patterns != null) {\n-            return patterns;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n-            patterns = ps.getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale.toLanguageTag(), patterns);\n-                logger.debug(\"Default locale's pattern is cached for locale [{}]!\\n\\n\", locale);\n-                return patterns;\n-            }\n-        }\n-        return null;\n+        return new PatternService().getPatterns(locale.toLanguageTag());\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4Njk1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462186954", "bodyText": "Because this method is about translation. How about put all translation methods into ProductService?", "author": "Xiaochao8", "createdAt": "2020-07-29T10:05:47Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -25,30 +23,30 @@ public ProductService(MessagesDTO dto) {\n     }\n \n     // get supported components defined in vip service\n-    public JSONArray getComponentsFromRemoteVIP() {\n+    public List<String> getComponents() {\n         BaseDTO baseDTO = new BaseDTO();\n         baseDTO.setProductID(dto.getProductID());\n         baseDTO.setVersion(dto.getVersion());\n         ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getComponentsFromRemoteVIP();\n+        return dao.getComponents();\n     }\n \n     // get supported locales defined in vip service\n-    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+    public List<String> getSupportedLocales() {\n         BaseDTO baseDTO = new BaseDTO();\n         baseDTO.setProductID(dto.getProductID());\n         baseDTO.setVersion(dto.getVersion());\n         ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getSupportedLocalesFromRemoteVIP();\n+        return dao.getSupportedLocales();\n     }\n \n     public List<Map> getAllComponentTranslation() {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 175500bd..553fd176 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -27,7 +27,7 @@ public class ProductService {\n         BaseDTO baseDTO = new BaseDTO();\n         baseDTO.setProductID(dto.getProductID());\n         baseDTO.setVersion(dto.getVersion());\n-        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        RemoteProductOpt dao = new RemoteProductOpt(baseDTO);\n         return dao.getComponents();\n     }\n \n"}}, {"oid": "436d2269beca89dcae5fa3aed0c0940428bb367e", "url": "https://github.com/vmware/singleton/commit/436d2269beca89dcae5fa3aed0c0940428bb367e", "message": "fix NullPointerException in DateFormatting when default locale's pattern is not available", "committedDate": "2020-07-30T15:13:58Z", "type": "forcePushed"}, {"oid": "4867ae524a2b481d8ba4e1a1ae4084defbf90b5b", "url": "https://github.com/vmware/singleton/commit/4867ae524a2b481d8ba4e1a1ae4084defbf90b5b", "message": "fix NullPointerException in DateFormatting when default locale's pattern is not available", "committedDate": "2020-07-31T10:58:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMDI4NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462710285", "bodyText": "The comment needs update.", "author": "Xiaochao8", "createdAt": "2020-07-30T03:18:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -4,20 +4,30 @@\n  */\n package com.vmware.vipclient.i18n.base.instances;\n \n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import com.vmware.vipclient.i18n.messages.service.LocaleService;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.service.LocaleService;\n-\n /**\n  * This class is a utility class to provide APIs related locale of specific product supported\n  * by VIP, on behind the APIs will fetch data from VIP service and wrapper the result as basic\n  * java util class to be called by prodcut's codes.\n  */", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "436d2269beca89dcae5fa3aed0c0940428bb367e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex 9ea0f90d..6d83118e 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -5,8 +5,7 @@\n package com.vmware.vipclient.i18n.base.instances;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n-import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.service.LocaleService;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMDE2NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464710164", "bodyText": "Enable this test again. See my comments on not using vipconfig-offline.properties.", "author": "jessiejuachon", "createdAt": "2020-08-03T23:16:05Z", "path": "src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java", "diffHunk": "@@ -178,7 +185,7 @@ public void testGetPatternMessageWithBundle() {\n         Assert.assertEquals(\"\\\"\u6211\u7684\u786c\u76d8\\\"\u4e0a\u6709345,678\u4e2a\u6587\u4ef6\u3002\", pluralMessage6);\n     }\n \n-    @Test\n+   // @Test", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java b/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java\nindex 9a6180a2..e39228ed 100644\n--- a/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java\n+++ b/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java\n\n@@ -185,15 +183,6 @@ public class TranslationMessageTest extends BaseTestClass {\n         Assert.assertEquals(\"\\\"\u6211\u7684\u786c\u76d8\\\"\u4e0a\u6709345,678\u4e2a\u6587\u4ef6\u3002\", pluralMessage6);\n     }\n \n-   // @Test\n-    public void testGetComponentMessagesLocaleNotSupported() {\n-    \tString component = \"JAVA\";\n-    \tString message_en_US = \"User name\";\n-    \tString key = \"global_text_username\";\n-    \t// When requested locale is not supported, the default locale messages will be returned.\n-        Map<String, String> localeNotSupported = translation.getMessages(Locale.forLanguageTag(\"fil-PH\"), component);\n-        Assert.assertEquals(message_en_US, localeNotSupported.get(key));\n-    }\n     @Test\n     public void testGetComponentMessages() {\n         vipCfg.setPseudo(false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464712151", "bodyText": "Just pass a null here. Get the fallback locale when you are in the service layer.\nAlso, do not use LocaleUtility.getDefaultLocale(). Iterate over the fallback locale queue in the service layer because there may be more than one fallback/default locale in the future (see code suggestion in LocaleService as well).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, String> languageTagMap = getDisplayNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n          \n          \n            \n                    Map<String, String> languageTagMap = getDisplayNamesFromCLDR(null);\n          \n      \n    \n    \n  \n\nNote: Please also change in other places where you used LocaleUtility.getDefaultLocale().", "author": "jessiejuachon", "createdAt": "2020-08-03T23:22:31Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -56,12 +71,12 @@ public LocaleMessage() {\n      * @return a list contains the supported language tags\n      */\n     public List<String> getSupportedLanguageTagList() {\n-        Map<String, String> languageTagMap = new LocaleService()\n-                .getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag(), \n-                \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        Collection<String> keyCollection = languageTagMap.keySet();\n-        List<String> languageTagList = new ArrayList<String>(keyCollection);\n-        return languageTagList;\n+        Map<String, String> languageTagMap = getDisplayNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4Nzg1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465787854", "bodyText": "I can't pass null here, and use fallback locale in service layer.\nThe reason is for supportedLanguageList API in Singleton service, when locale parameter is empty, the behavior is get displayName with each languageTag, the logic is more complex than a detail locale, this method is just for return languageTag, so I think needn't execute that complex logic, pass default locale is better.\nCould you give me an example in what kind of situation there maybe more than one default locale?", "author": "huihuiw01", "createdAt": "2020-08-05T14:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NTMxOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466095318", "bodyText": "It looks this method can be removed because nobody uses it...", "author": "Xiaochao8", "createdAt": "2020-08-06T01:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMjM1OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466502358", "bodyText": "Yeah, maybe nobody use it, but since it's in a class exposed to user, so keep it.\nBut we may needn't spend much time or discussion on it.", "author": "huihuiw01", "createdAt": "2020-08-06T15:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODI5MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466698290", "bodyText": "@huihuiw01 , I am not asking you to pass null to the Singleton service. I am asking to pass null to getDisplayNamesFromCLDR(null), which will call LocaleService.getDisplayNames(null). When LocaleService.getDisplayNames receives a null value, it will get the next item from the fallback locales queue, and use that to pass to the Singleton service. See my code suggestion in LocaleService.getDisplayNames.", "author": "jessiejuachon", "createdAt": "2020-08-06T21:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex f0f9c357..f7e4f823 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -71,12 +56,12 @@ public class LocaleMessage implements Message {\n      * @return a list contains the supported language tags\n      */\n     public List<String> getSupportedLanguageTagList() {\n-        Map<String, String> languageTagMap = getDisplayNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-        if(languageTagMap != null) {\n-            Collection<String> keyCollection = languageTagMap.keySet();\n-            return new ArrayList<String>(keyCollection);\n-        }\n-        return new ArrayList();\n+        Map<String, String> languageTagMap = new LocaleService()\n+                .getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag(), \n+                \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        Collection<String> keyCollection = languageTagMap.keySet();\n+        List<String> languageTagList = new ArrayList<String>(keyCollection);\n+        return languageTagList;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxNTQ5Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464715496", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n          \n          \n            \n                    if(locale == null || locale.isEmpty()) {\n          \n          \n            \n                        logger.warn(\"Locale is empty!\");\n          \n          \n            \n                        return null;\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return localeService.getDisplayNames(locale);\n          \n          \n            \n                }\n          \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n          \n          \n            \n                    LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return localeService.getDisplayNames(locale);\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-03T23:33:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +86,37 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n+        if(dispNameMap != null) {\n+            Collection<String> valueCollection = dispNameMap.values();\n+            return new ArrayList<String>(valueCollection);\n+        }\n+        return new ArrayList();\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        LocaleDTO dto = new LocaleDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        return localeService.getDisplayNames(locale);\n     }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex f0f9c357..f7e4f823 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -86,37 +71,12 @@ public class LocaleMessage implements Message {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLocale) {\n-        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n-        if(dispNameMap != null) {\n-            Collection<String> valueCollection = dispNameMap.values();\n-            return new ArrayList<String>(valueCollection);\n-        }\n-        return new ArrayList();\n-    }\n-\n-    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        if(locale == null || locale.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n-            return null;\n-        }\n-        LocaleDTO dto = new LocaleDTO();\n-        if(cfg != null) {\n-            dto.setProductID(cfg.getProductName());\n-            dto.setVersion(cfg.getVersion());\n-        }else{\n-            dto.setProductID(VIPCfg.getInstance().getProductName());\n-            dto.setVersion(VIPCfg.getInstance().getVersion());\n-        }\n-        LocaleService localeService = new LocaleService(dto);\n-        return localeService.getDisplayNames(locale);\n+    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n+        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n+        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        Collection<String> valueCollection = dispNameMap.values();\n+        List<String> dispNameList = new ArrayList<String>(valueCollection);\n+        return dispNameList;\n     }\n \n-    public VIPCfg getCfg() {\n-        return this.cfg;\n-    }\n-\n-    public void setCfg(final VIPCfg cfg) {\n-        this.cfg = cfg;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMDEwOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464720108", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Map<String, String> getDisplayNames(String locale) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    dispMap = getSupportedDisplayNamesByLocale(locale);\n          \n          \n            \n                    if(dispMap != null && !dispMap.isEmpty()){\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (!LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n          \n          \n            \n                        Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n          \n          \n            \n                        dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n          \n          \n            \n                        if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                            new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                            logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n          \n          \n            \n                                    dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                        }\n          \n          \n            \n                public Map<String, String> getDisplayNames(String locale) {\n          \n          \n            \n                    Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n          \n          \n            \n                    return this.getDisplayNames(fallbackLocalesIter);\n          \n          \n            \n                }\n          \n          \n            \n                public Map<String, String> getDisplayNames(String locale, Iterator<Locale> fallbackLocalesIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if (locale == null) {\n          \n          \n            \n                        if (fallbackLocalesIter != null && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            locale = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        }\n          \n          \n            \n                    } \n          \n          \n            \n                    dispMap = getSupportedDisplayNamesByLocale(locale);\n          \n          \n            \n                    if(dispMap == null || dispMap.isEmpty()) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}]\", locale);\n          \n          \n            \n                        return getDisplayNames(null, fallbackLocalesIter);\n          \n          \n            \n                    } \n          \n          \n            \n                    new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-03T23:49:27Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzU3Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466503577", "bodyText": "Will do in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-06T15:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMDEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex f4075647..254fd9d2 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,125 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n+    public LocaleService() {\n     }\n \n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext())\n-            return regions;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n-            return dispMap;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNjYwNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464726604", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-04T00:12:54Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }\n-        };\n-        FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n-        Thread thread = new Thread(task);\n-        thread.start();\n+        }\n+        return dispMap;\n     }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex f4075647..254fd9d2 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,125 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n+    public LocaleService() {\n     }\n \n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext())\n-            return regions;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n-            return dispMap;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNzQwOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464727409", "bodyText": "See code suggestion for getDisplayNames. Iterate over the fall back locale queue instead of calling LocaleUtility.getDefaultLocale().", "author": "jessiejuachon", "createdAt": "2020-08-04T00:15:39Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzY2NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466503665", "bodyText": "Will do in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-06T15:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNzQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex f4075647..254fd9d2 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,125 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n+    public LocaleService() {\n     }\n \n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext())\n-            return regions;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n-            return dispMap;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyODQ1OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464728458", "bodyText": "I still do not see my previous code suggestion\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n          \n          \n            \n                        logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);", "author": "jessiejuachon", "createdAt": "2020-08-04T00:19:27Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }\n-        };\n-        FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n-        Thread thread = new Thread(task);\n-        thread.start();\n+        }\n+        return dispMap;\n     }\n \n-    private Map<String, String> getSupportedLanguagesFromDS(String displayLanguageTag, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(displayLanguageTag);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, msgSourceQueueIter);\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n-        }\n-        return respMap;\n-    }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n-        }\n-        \n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if (!msgSourceQueueIter.hasNext())\n+            return dispMap;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjI3MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465736270", "bodyText": "Actually I resolve this in cache update commit, since I plan to put cache update in a new PR, so I reset that commit, after reset the change reset, too. So I resolve this in this PR again.", "author": "huihuiw01", "createdAt": "2020-08-05T13:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyODQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex f4075647..254fd9d2 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,125 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n+    public LocaleService() {\n     }\n \n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext())\n-            return regions;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n-            return dispMap;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyODcwNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464728704", "bodyText": "I still do not see my previous code suggestion\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!msgSourceQueueIter.hasNext())\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    if (!msgSourceQueueIter.hasNext()) {\n          \n          \n            \n                        logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }", "author": "jessiejuachon", "createdAt": "2020-08-04T00:20:21Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }\n-        };\n-        FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n-        Thread thread = new Thread(task);\n-        thread.start();\n+        }\n+        return dispMap;\n     }\n \n-    private Map<String, String> getSupportedLanguagesFromDS(String displayLanguageTag, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(displayLanguageTag);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, msgSourceQueueIter);\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n-        }\n-        return respMap;\n-    }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n-        }\n-        \n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if (!msgSourceQueueIter.hasNext())\n+            return dispMap;", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex f4075647..254fd9d2 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,125 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n+    public LocaleService() {\n     }\n \n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext())\n-            return regions;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n-            return dispMap;\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNTE2MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464735160", "bodyText": "No need for this check because there is already a check on line 91 when method is called recursively", "author": "jessiejuachon", "createdAt": "2020-08-04T00:43:47Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -106,4 +81,28 @@ public JSONArray getSupportedLocalesFromRemoteVIP() {\n         return components;\n     }\n \n+    /**\n+     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n+     *\n+     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n+     * @return list of locales of the product specified in the dto object\n+     */\n+    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n+        if (!msgSourceQueueIter.hasNext()) { return null; }\n+\n+        DataSourceEnum dataSource = msgSourceQueueIter.next();\n+        ProductOpt opt = dataSource.createProductOpt(dto);\n+        List<String> locales = opt.getSupportedLocales();\n+        // If failed to get components from the data source\n+        if (locales.isEmpty()) {\n+            // Try the next dataSource in the queue\n+            if (msgSourceQueueIter.hasNext()) {", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyOTQ2OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465829468", "bodyText": "Write the same with you, just copy 'getComponents' method which already exsits in this class.", "author": "huihuiw01", "createdAt": "2020-08-05T15:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNTE2MA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 2d6b4d82..452af45d 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -4,105 +4,63 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n \n public class ProductService {\n-    private BaseDTO dto = null;\n-    Logger logger = LoggerFactory.getLogger(ProductService.class);\n+    private MessagesDTO dto = null;\n \n-    public ProductService(BaseDTO dto) {\n+    public ProductService(MessagesDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n-     *\n-     * @return translated messages of all components of a product locale specified in the dto object\n-     */\n-    public List<Map> getAllComponentTranslation() {\n-        List<Map> list = new ArrayList<Map>();\n-        LocaleDTO localeDTO = new LocaleDTO();\n-        List<String> locales = this.getSupportedLocales(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        List<String> components = this.getComponents(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        if (locales != null) {\n-            for (String languageTag : locales) {\n-                for (Object component : components) {\n-                    MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n-                            dto.getProductID(), dto.getVersion());\n-                    Map<String, String> retMap = new ComponentService(msgDTO).getMessages(null).getCachedData();\n-                    if (retMap != null) {\n-                        list.add(retMap);\n-                    }\n-                }\n-            }\n-        }\n-        return list;\n+    // get supported components defined in vip service\n+    public JSONArray getComponentsFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getComponentsFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n-     * @return list of components of the product specified in the dto object\n-     */\n-    public List<String> getComponents (Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext())\n-            return null;\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> components = opt.getComponents();\n-        // If failed to get components from the data source\n-        if (components.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                components = getComponents(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n-            }\n-        }\n-        return components;\n+    // get supported locales defined in vip service\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getSupportedLocalesFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n-     * @return list of locales of the product specified in the dto object\n-     */\n-    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext()) { return null; }\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> locales = opt.getSupportedLocales();\n-        // If failed to get components from the data source\n-        if (locales.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                locales = getSupportedLocales(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n+    public List<Map> getAllComponentTranslation() {\n+        List<Map> list = new ArrayList<Map>();\n+        Object[] locales = {};\n+        Object[] components = {};\n+        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n+            locales = this.getSupportedLocalesFromRemoteVIP().toArray();\n+            components = this.getComponentsFromRemoteVIP()\n+                    .toArray();\n+        }\n+        for (Object locale : locales) {\n+            for (Object component : components) {\n+                dto.setComponent(((String) component).trim());\n+                dto.setLocale(LocaleUtility.fmtToMappedLocale((String) locale).toString().trim());\n+                Map<String, String> retMap = new ComponentService(dto).getMessages().getCachedData();\n+                if (retMap != null) {\n+                    list.add(retMap);\n+                }\n             }\n         }\n-        return locales;\n+        return list;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1OTkyNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464759924", "bodyText": "This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example.", "author": "jessiejuachon", "createdAt": "2020-08-04T02:19:54Z", "path": "src/test/java/com/vmware/vip/i18n/DateFormatUtilOfflineTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.base.instances.DateFormatting;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Date;\n+import java.util.Locale;\n+\n+public class DateFormatUtilOfflineTest extends BaseTestClass {\n+\n+    final String fullDateForEn = \"Monday, November 20, 2017\";\n+    final String longDateForEn = \"November 20, 2017\";\n+    final String mediumDateForEn = \"Nov 20, 2017\";\n+    final String shortDateForEn = \"11/20/17\";\n+    final String fullTimeForEn = \"1:39:24 PM GMT+08:00\";\n+    final String longTimeForEn = \"1:39:24 PM GMT+8\";\n+    final String mediumTimeForEn = \"1:39:24 PM\";\n+    final String shortTimeForEn = \"1:39 PM\";\n+    final String fullForEn = \"Monday, November 20, 2017 at 1:39:24 PM GMT+08:00\";\n+    final String longForEn = \"November 20, 2017 at 1:39:24 PM GMT+8\";\n+    final String mediumForEn = \"Nov 20, 2017, 1:39:24 PM\";\n+    final String shortForEn = \"11/20/17, 1:39 PM\";\n+\n+    final String fullDateForZh = \"2017\u5e7411\u670820\u65e5\u661f\u671f\u4e00\";\n+    final String longDateForZh = \"2017\u5e7411\u670820\u65e5\";\n+    final String mediumDateForZh = \"2017\u5e7411\u670820\u65e5\";\n+    final String shortDateForZh = \"2017/11/20\";\n+    final String fullTimeForZh = \"GMT+08:00 \u4e0b\u53481:39:24\";\n+    final String longTimeForZh = \"GMT+8 \u4e0b\u53481:39:24\";\n+    final String mediumTimeForZh = \"\u4e0b\u53481:39:24\";\n+    final String shortTimeForZh = \"\u4e0b\u53481:39\";\n+    final String fullForZh = \"2017\u5e7411\u670820\u65e5\u661f\u671f\u4e00 GMT+08:00 \u4e0b\u53481:39:24\";\n+    final String longForZh = \"2017\u5e7411\u670820\u65e5 GMT+8 \u4e0b\u53481:39:24\";\n+    final String mediumForZh = \"2017\u5e7411\u670820\u65e5 \u4e0b\u53481:39:24\";\n+    final String shortForZh = \"2017/11/20 \u4e0b\u53481:39\";\n+\n+    final String fullDateForFr = \"lundi 20 novembre 2017\";\n+    final String longDateForFr = \"20 novembre 2017\";\n+    final String mediumDateForFr = \"20 nov. 2017\";\n+    final String shortDateForFr = \"20/11/2017\";\n+    final String fullTimeForFr = \"13:39:24 GMT+08:00\";\n+    final String longTimeForFr = \"13:39:24 GMT+8\";\n+    final String mediumTimeForFr = \"13:39:24\";\n+    final String shortTimeForFr = \"13:39\";\n+    final String fullForFr = \"lundi 20 novembre 2017 \u00e0 13:39:24 GMT+08:00\";\n+    final String longForFr = \"20 novembre 2017 \u00e0 13:39:24 GMT+8\";\n+    final String mediumForFr = \"20 nov. 2017 \u00e0 13:39:24\";\n+    final String shortForFr = \"20/11/2017 13:39\";\n+\n+    final long timestamp = 1511156364801l;\n+    final String timeZone = \"GMT+8\";\n+    Date date = new Date(timestamp);\n+\n+    DateFormatting dateFormatI18n;\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0MjAwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742000", "bodyText": "As we discussed offline, unit tests is for testing different scenarios, not for mock real scenarios,  re-initialize is acceptable. And use  properties is more convenient, or we need do setMsgOriginsQueue in many places to re-initialize data source.\nSo I clear data source queue before each initiallization by calling clearDataSource method in the constructor of parent class of all test classes 'BaseTestClass', and problem is resolved.", "author": "huihuiw01", "createdAt": "2020-08-05T13:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1OTkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/test/java/com/vmware/vip/i18n/DateFormatUtilOfflineTest.java b/src/test/java/com/vmware/vip/i18n/DateFormatUtilOfflineTest.java\ndeleted file mode 100644\nindex 2eb2bcb0..00000000\n--- a/src/test/java/com/vmware/vip/i18n/DateFormatUtilOfflineTest.java\n+++ /dev/null\n\n@@ -1,302 +0,0 @@\n-/*\n- * Copyright 2019 VMware, Inc.\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package com.vmware.vip.i18n;\n-\n-import com.vmware.vipclient.i18n.I18nFactory;\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n-import com.vmware.vipclient.i18n.base.instances.DateFormatting;\n-import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.util.Date;\n-import java.util.Locale;\n-\n-public class DateFormatUtilOfflineTest extends BaseTestClass {\n-\n-    final String fullDateForEn = \"Monday, November 20, 2017\";\n-    final String longDateForEn = \"November 20, 2017\";\n-    final String mediumDateForEn = \"Nov 20, 2017\";\n-    final String shortDateForEn = \"11/20/17\";\n-    final String fullTimeForEn = \"1:39:24 PM GMT+08:00\";\n-    final String longTimeForEn = \"1:39:24 PM GMT+8\";\n-    final String mediumTimeForEn = \"1:39:24 PM\";\n-    final String shortTimeForEn = \"1:39 PM\";\n-    final String fullForEn = \"Monday, November 20, 2017 at 1:39:24 PM GMT+08:00\";\n-    final String longForEn = \"November 20, 2017 at 1:39:24 PM GMT+8\";\n-    final String mediumForEn = \"Nov 20, 2017, 1:39:24 PM\";\n-    final String shortForEn = \"11/20/17, 1:39 PM\";\n-\n-    final String fullDateForZh = \"2017\u5e7411\u670820\u65e5\u661f\u671f\u4e00\";\n-    final String longDateForZh = \"2017\u5e7411\u670820\u65e5\";\n-    final String mediumDateForZh = \"2017\u5e7411\u670820\u65e5\";\n-    final String shortDateForZh = \"2017/11/20\";\n-    final String fullTimeForZh = \"GMT+08:00 \u4e0b\u53481:39:24\";\n-    final String longTimeForZh = \"GMT+8 \u4e0b\u53481:39:24\";\n-    final String mediumTimeForZh = \"\u4e0b\u53481:39:24\";\n-    final String shortTimeForZh = \"\u4e0b\u53481:39\";\n-    final String fullForZh = \"2017\u5e7411\u670820\u65e5\u661f\u671f\u4e00 GMT+08:00 \u4e0b\u53481:39:24\";\n-    final String longForZh = \"2017\u5e7411\u670820\u65e5 GMT+8 \u4e0b\u53481:39:24\";\n-    final String mediumForZh = \"2017\u5e7411\u670820\u65e5 \u4e0b\u53481:39:24\";\n-    final String shortForZh = \"2017/11/20 \u4e0b\u53481:39\";\n-\n-    final String fullDateForFr = \"lundi 20 novembre 2017\";\n-    final String longDateForFr = \"20 novembre 2017\";\n-    final String mediumDateForFr = \"20 nov. 2017\";\n-    final String shortDateForFr = \"20/11/2017\";\n-    final String fullTimeForFr = \"13:39:24 GMT+08:00\";\n-    final String longTimeForFr = \"13:39:24 GMT+8\";\n-    final String mediumTimeForFr = \"13:39:24\";\n-    final String shortTimeForFr = \"13:39\";\n-    final String fullForFr = \"lundi 20 novembre 2017 \u00e0 13:39:24 GMT+08:00\";\n-    final String longForFr = \"20 novembre 2017 \u00e0 13:39:24 GMT+8\";\n-    final String mediumForFr = \"20 nov. 2017 \u00e0 13:39:24\";\n-    final String shortForFr = \"20/11/2017 13:39\";\n-\n-    final long timestamp = 1511156364801l;\n-    final String timeZone = \"GMT+8\";\n-    Date date = new Date(timestamp);\n-\n-    DateFormatting dateFormatI18n;\n-\n-    @Before\n-    public void init() {\n-        VIPCfg gc = VIPCfg.getInstance();\n-        try {\n-            gc.initialize(\"vipconfig-offline\");\n-        } catch (VIPClientInitException e) {\n-            logger.error(e.getMessage());\n-        }\n-        gc.initializeVIPService();\n-        gc.createFormattingCache(FormattingCache.class);\n-        I18nFactory i18n = I18nFactory.getInstance(gc);\n-        dateFormatI18n = (DateFormatting) i18n.getFormattingInstance(DateFormatting.class);\n-    }\n-\n-    @Test\n-    public void testFormatDateWithLocale() {\n-\n-        Locale locale = new Locale(\"en\", \"US\");\n-        Assert.assertEquals(fullDateForEn, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, locale));\n-        Assert.assertEquals(longDateForEn, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, locale));\n-        Assert.assertEquals(mediumDateForEn, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, locale));\n-        Assert.assertEquals(shortDateForEn, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, locale));\n-        Assert.assertEquals(fullTimeForEn, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, locale));\n-        Assert.assertEquals(longTimeForEn, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, locale));\n-        Assert.assertEquals(mediumTimeForEn, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, locale));\n-        Assert.assertEquals(shortTimeForEn, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, locale));\n-        Assert.assertEquals(fullForEn, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, locale));\n-        Assert.assertEquals(longForEn, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, locale));\n-        Assert.assertEquals(mediumForEn, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, locale));\n-        Assert.assertEquals(shortForEn, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, locale));\n-\n-        locale = new Locale(\"zh\", \"CN\");\n-        Assert.assertEquals(fullDateForZh, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, locale));\n-        Assert.assertEquals(longDateForZh, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, locale));\n-        Assert.assertEquals(mediumDateForZh, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, locale));\n-        Assert.assertEquals(shortDateForZh, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, locale));\n-        Assert.assertEquals(fullTimeForZh, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, locale));\n-        Assert.assertEquals(longTimeForZh, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, locale));\n-        Assert.assertEquals(mediumTimeForZh, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, locale));\n-        Assert.assertEquals(shortTimeForZh, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, locale));\n-        Assert.assertEquals(fullForZh, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, locale));\n-        Assert.assertEquals(longForZh, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, locale));\n-        Assert.assertEquals(mediumForZh, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, locale));\n-        Assert.assertEquals(shortForZh, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, locale));\n-\n-        locale = new Locale(\"fr\", \"\");\n-        Assert.assertEquals(fullDateForFr, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, locale));\n-        Assert.assertEquals(longDateForFr, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, locale));\n-        Assert.assertEquals(mediumDateForFr, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, locale));\n-        Assert.assertEquals(shortDateForFr, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, locale));\n-        Assert.assertEquals(fullTimeForFr, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, locale));\n-        Assert.assertEquals(longTimeForFr, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, locale));\n-        Assert.assertEquals(mediumTimeForFr, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, locale));\n-        Assert.assertEquals(shortTimeForFr, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, locale));\n-        Assert.assertEquals(fullForFr, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, locale));\n-        Assert.assertEquals(longForFr, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, locale));\n-        Assert.assertEquals(mediumForFr, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, locale));\n-        Assert.assertEquals(shortForFr, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, locale));\n-\n-        //Test invalid locale fallback to en\n-        locale = new Locale(\"aa\", \"\");\n-        Assert.assertEquals(fullDateForEn, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, locale));\n-        Assert.assertEquals(longDateForEn, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, locale));\n-        Assert.assertEquals(mediumDateForEn, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, locale));\n-        Assert.assertEquals(shortDateForEn, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, locale));\n-        Assert.assertEquals(fullTimeForEn, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, locale));\n-        Assert.assertEquals(longTimeForEn, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, locale));\n-        Assert.assertEquals(mediumTimeForEn, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, locale));\n-        Assert.assertEquals(shortTimeForEn, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, locale));\n-        Assert.assertEquals(fullForEn, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, locale));\n-        Assert.assertEquals(longForEn, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, locale));\n-        Assert.assertEquals(mediumForEn, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, locale));\n-        Assert.assertEquals(shortForEn, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, locale));\n-    }\n-\n-    @Test\n-    public void testFormatDateWithLanguageRegion() {\n-        String language = \"en\";\n-        String region = \"US\";\n-        Assert.assertEquals(fullDateForEn, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, language, region));\n-        Assert.assertEquals(longDateForEn, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, language, region));\n-        Assert.assertEquals(mediumDateForEn, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, language, region));\n-        Assert.assertEquals(shortDateForEn, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, language, region));\n-        Assert.assertEquals(fullTimeForEn, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, language, region));\n-        Assert.assertEquals(longTimeForEn, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, language, region));\n-        Assert.assertEquals(mediumTimeForEn, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, language, region));\n-        Assert.assertEquals(shortTimeForEn, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, language, region));\n-        Assert.assertEquals(fullForEn, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, language, region));\n-        Assert.assertEquals(longForEn, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, language, region));\n-        Assert.assertEquals(mediumForEn, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, language, region));\n-        Assert.assertEquals(shortForEn, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, language, region));\n-\n-        language = \"zh-Hans\";\n-        region = \"CN\";\n-        Assert.assertEquals(fullDateForZh, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, language, region));\n-        Assert.assertEquals(longDateForZh, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, language, region));\n-        Assert.assertEquals(mediumDateForZh, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, language, region));\n-        Assert.assertEquals(shortDateForZh, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, language, region));\n-        Assert.assertEquals(fullTimeForZh, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, language, region));\n-        Assert.assertEquals(longTimeForZh, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, language, region));\n-        Assert.assertEquals(mediumTimeForZh, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, language, region));\n-        Assert.assertEquals(shortTimeForZh, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, language, region));\n-        Assert.assertEquals(fullForZh, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, language, region));\n-        Assert.assertEquals(longForZh, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, language, region));\n-        Assert.assertEquals(mediumForZh, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, language, region));\n-        Assert.assertEquals(shortForZh, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, language, region));\n-\n-        language = \"fr\";\n-        region = \"FR\";\n-        // final Locale frLocale = new Locale(\"fr\", \"\");\n-        Assert.assertEquals(fullDateForFr, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, language, region));\n-        Assert.assertEquals(longDateForFr, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, language, region));\n-        Assert.assertEquals(mediumDateForFr, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, language, region));\n-        Assert.assertEquals(shortDateForFr, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, language, region));\n-        Assert.assertEquals(fullTimeForFr, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, language, region));\n-        Assert.assertEquals(longTimeForFr, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, language, region));\n-        Assert.assertEquals(mediumTimeForFr, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, language, region));\n-        Assert.assertEquals(shortTimeForFr, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, language, region));\n-        Assert.assertEquals(fullForFr, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, language, region));\n-        Assert.assertEquals(longForFr, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, language, region));\n-        Assert.assertEquals(mediumForFr, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, language, region));\n-        Assert.assertEquals(shortForFr, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, language, region));\n-\n-        //Test invalid locale fallback to en\n-        language = \"aa\";\n-        region = \"US\";\n-        Assert.assertEquals(fullDateForEn, dateFormatI18n.formatDate(date,\n-                \"fullDate\", timeZone, language, region));\n-        Assert.assertEquals(longDateForEn, dateFormatI18n.formatDate(date,\n-                \"longDate\", timeZone, language, region));\n-        Assert.assertEquals(mediumDateForEn, dateFormatI18n.formatDate(\n-                date, \"mediumDate\", timeZone, language, region));\n-        Assert.assertEquals(shortDateForEn, dateFormatI18n.formatDate(date,\n-                \"shortDate\", timeZone, language, region));\n-        Assert.assertEquals(fullTimeForEn, dateFormatI18n.formatDate(date,\n-                \"fullTime\", timeZone, language, region));\n-        Assert.assertEquals(longTimeForEn, dateFormatI18n.formatDate(date,\n-                \"longTime\", timeZone, language, region));\n-        Assert.assertEquals(mediumTimeForEn, dateFormatI18n.formatDate(\n-                date, \"mediumTime\", timeZone, language, region));\n-        Assert.assertEquals(shortTimeForEn, dateFormatI18n.formatDate(date,\n-                \"shortTime\", timeZone, language, region));\n-        Assert.assertEquals(fullForEn, dateFormatI18n.formatDate(date,\n-                \"full\", timeZone, language, region));\n-        Assert.assertEquals(longForEn, dateFormatI18n.formatDate(date,\n-                \"long\", timeZone, language, region));\n-        Assert.assertEquals(mediumForEn, dateFormatI18n.formatDate(date,\n-                \"medium\", timeZone, language, region));\n-        Assert.assertEquals(shortForEn, dateFormatI18n.formatDate(date,\n-                \"short\", timeZone, language, region));\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDAzNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464760035", "bodyText": "Same comment: \"This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example. \"", "author": "jessiejuachon", "createdAt": "2020-08-04T02:20:17Z", "path": "src/test/java/com/vmware/vip/i18n/MessageFormatOfflineTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import com.vmware.vipclient.i18n.l2.text.MessageFormat;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.text.FieldPosition;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+public class MessageFormatOfflineTest extends BaseTestClass {\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0MjU2OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742568", "bodyText": "Same resolution as above.", "author": "huihuiw01", "createdAt": "2020-08-05T13:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/test/java/com/vmware/vip/i18n/MessageFormatOfflineTest.java b/src/test/java/com/vmware/vip/i18n/MessageFormatOfflineTest.java\ndeleted file mode 100644\nindex 14631501..00000000\n--- a/src/test/java/com/vmware/vip/i18n/MessageFormatOfflineTest.java\n+++ /dev/null\n\n@@ -1,101 +0,0 @@\n-/*\n- * Copyright 2019 VMware, Inc.\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package com.vmware.vip.i18n;\n-\n-import com.vmware.vipclient.i18n.I18nFactory;\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n-import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n-import com.vmware.vipclient.i18n.l2.text.MessageFormat;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.text.FieldPosition;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-\n-public class MessageFormatOfflineTest extends BaseTestClass {\n-\n-    @Before\n-    public void init() {\n-        VIPCfg gc = VIPCfg.getInstance();\n-        try {\n-            gc.initialize(\"vipconfig-offline\");\n-        } catch (VIPClientInitException e) {\n-            logger.error(e.getMessage());\n-        }\n-        gc.initializeVIPService();\n-        gc.createFormattingCache(FormattingCache.class);\n-        I18nFactory i18n = I18nFactory.getInstance(gc);\n-    }\n-\n-    @Test\n-    public void testFormat() {\n-        String message1 = \"{num_files, plural, \"\n-                + \"=0{There are no files on disk \\\"{disk_name}\\\".}\"\n-                + \"=1{There is one file on disk \\\"{disk_name}\\\".}\"\n-                + \"other{There are # files on disk \\\"{disk_name}\\\".}}\";\n-        MessageFormat msgFmt1 = new MessageFormat(message1, Locale.ENGLISH);\n-        Map<String, Object> args = new HashMap<String, Object>();\n-        args.put(\"num_files\", 0);//\n-        args.put(\"disk_name\", \"MyDisk\");\n-        Assert.assertEquals(\"There are no files on disk \\\"MyDisk\\\".\",\n-                msgFmt1.format(args, new StringBuilder(), new FieldPosition(0)).toString());\n-        args.put(\"num_files\", 1);\n-        Assert.assertEquals(\"There is one file on disk \\\"MyDisk\\\".\",\n-                msgFmt1.format(args, new StringBuilder(), new FieldPosition(0)).toString());\n-        args.put(\"num_files\", 345678);\n-        Assert.assertEquals(\"There are 345,678 files on disk \\\"MyDisk\\\".\",\n-                msgFmt1.format(args, new StringBuilder(), new FieldPosition(0)).toString());\n-\n-        String message2 = \"{num_files, plural, \" +\n-                \"one{There is one file on disk \\\"{disk_name}\\\".}\" +\n-                \"other{There are # files on disk \\\"{disk_name}\\\".}}\";\n-        MessageFormat msgFmt2 = new MessageFormat(message2, Locale.ENGLISH);\n-        args.put(\"num_files\", 0);\n-        Assert.assertEquals(\"There are 0 files on disk \\\"MyDisk\\\".\",\n-                msgFmt2.format(args, new StringBuilder(), new FieldPosition(0)).toString());\n-        args.put(\"num_files\", 1);\n-        Assert.assertEquals(\"There is one file on disk \\\"MyDisk\\\".\",\n-                msgFmt2.format(args, new StringBuilder(), new FieldPosition(0)).toString());\n-        args.put(\"num_files\", 345678);\n-        Assert.assertEquals(\"There are 345,678 files on disk \\\"MyDisk\\\".\",\n-                msgFmt2.format(args, new StringBuilder(), new FieldPosition(0)).toString());\n-\n-        String message3 = \"There {0, plural, one{is one file} other{are # files}} on disk \\\"{1}\\\".\";// {1, number}\n-        MessageFormat msgFmt3 = new MessageFormat(message3, Locale.ENGLISH);\n-        Assert.assertEquals(\"There are 0 files on disk \\\"MyDisk\\\".\",\n-                msgFmt3.format(new Object[] { 0, \"MyDisk\" }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"There is one file on disk \\\"MyDisk\\\".\",\n-                msgFmt3.format(new Object[] { 1, \"MyDisk\" }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"There are 345,678 files on disk \\\"MyDisk\\\".\", msgFmt3\n-                .format(new Object[] { 345678, \"MyDisk\" }, new StringBuilder(), new FieldPosition(0)).toString());\n-\n-        String msgPatSl = \"{0,plural, one{# pes} two{# psa} few{# psi} other{# psov}}\";\n-        MessageFormat msgFmt4 = new MessageFormat(msgPatSl, new Locale(\"sl\"));\n-        Assert.assertEquals(\"0 psov\",\n-                msgFmt4.format(new Object[] { 0 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"1 pes\",\n-                msgFmt4.format(new Object[] { 1 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"2 psa\",\n-                msgFmt4.format(new Object[] { 2 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"3 psi\",\n-                msgFmt4.format(new Object[] { 3 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"4 psi\",\n-                msgFmt4.format(new Object[] { 4 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"5 psov\",\n-                msgFmt4.format(new Object[] { 5 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"10 psov\",\n-                msgFmt4.format(new Object[] { 10 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"100 psov\",\n-                msgFmt4.format(new Object[] { 100 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"101 pes\",\n-                msgFmt4.format(new Object[] { 101 }, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"102 psa\",\n-                msgFmt4.format(new Object[] { 102 }, new StringBuilder(), new FieldPosition(0)).toString());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDE4NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464760184", "bodyText": "Same comment: \"This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example. \"", "author": "jessiejuachon", "createdAt": "2020-08-04T02:20:48Z", "path": "src/test/java/com/vmware/vip/i18n/NumberFormatUtilOfflineTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.base.instances.NumberFormatting;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Locale;\n+\n+public class NumberFormatUtilOfflineTest extends BaseTestClass {\n+\n+    NumberFormatting numberFormatI18n;\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0MjY0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742647", "bodyText": "Same resolution as above.", "author": "huihuiw01", "createdAt": "2020-08-05T13:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDE4NA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/test/java/com/vmware/vip/i18n/NumberFormatUtilOfflineTest.java b/src/test/java/com/vmware/vip/i18n/NumberFormatUtilOfflineTest.java\ndeleted file mode 100644\nindex 6179ab63..00000000\n--- a/src/test/java/com/vmware/vip/i18n/NumberFormatUtilOfflineTest.java\n+++ /dev/null\n\n@@ -1,272 +0,0 @@\n-/*\n- * Copyright 2019 VMware, Inc.\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package com.vmware.vip.i18n;\n-\n-import com.vmware.vipclient.i18n.I18nFactory;\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n-import com.vmware.vipclient.i18n.base.instances.NumberFormatting;\n-import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.util.Locale;\n-\n-public class NumberFormatUtilOfflineTest extends BaseTestClass {\n-\n-    NumberFormatting numberFormatI18n;\n-\n-    @Before\n-    public void init() {\n-        VIPCfg gc = VIPCfg.getInstance();\n-        try {\n-            gc.initialize(\"vipconfig-offline\");\n-        } catch (VIPClientInitException e) {\n-            logger.error(e.getMessage());\n-        }\n-        gc.initializeVIPService();\n-        gc.createFormattingCache(FormattingCache.class);\n-        I18nFactory i18n = I18nFactory.getInstance(gc);\n-        numberFormatI18n = (NumberFormatting) i18n.getFormattingInstance(NumberFormatting.class);\n-    }\n-\n-    @Test\n-    public void testRegionFormatNumber() {\n-        long num1 = 201703;\n-        double num2 = 201703.54;\n-        String num3 = \"201703.5416926\";\n-\n-        String language = \"zh-Hans\";\n-        String region = \"CN\";\n-\n-        Assert.assertEquals(\"201,703\", numberFormatI18n.formatNumber(num1,\n-                language, region));\n-        Assert.assertEquals(\"201,703\", numberFormatI18n.formatNumber(num1,\n-                -1, language, region));\n-        Assert.assertEquals(\"201,703.00\", numberFormatI18n.formatNumber(num1,\n-                2, language, region));\n-        Assert.assertEquals(\"201,703.00000\", numberFormatI18n.formatNumber(num1,\n-                5, language, region));\n-\n-        Assert.assertEquals(\"201,703.54\", numberFormatI18n.formatNumber(num2,\n-                language, region));\n-        Assert.assertEquals(\"201,704\", numberFormatI18n.formatNumber(num2,\n-                -1, language, region));\n-        Assert.assertEquals(\"201,703.54\", numberFormatI18n.formatNumber(num2,\n-                2, language, region));\n-        Assert.assertEquals(\"201,703.54000\", numberFormatI18n.formatNumber(num2,\n-                5, language, region));\n-\n-        Assert.assertEquals(\"201,703.542\", numberFormatI18n.formatNumber(num3,\n-                language, region));\n-        Assert.assertEquals(\"201,704\", numberFormatI18n.formatNumber(num3,\n-                -1, language, region));\n-        Assert.assertEquals(\"201,703.54\", numberFormatI18n.formatNumber(num3,\n-                2, language, region));\n-        Assert.assertEquals(\"201,703.54169\", numberFormatI18n.formatNumber(num3,\n-                5, language, region));\n-\n-        String frlanguage = \"fr\";\n-        String frregion = \"FR\";\n-\n-        Assert.assertEquals(\"201\u00a0703\", numberFormatI18n.formatNumber(num1,\n-                frlanguage, frregion));\n-        Assert.assertEquals(\"201\u00a0703\", numberFormatI18n.formatNumber(num1,\n-                -10, frlanguage, frregion));\n-        Assert.assertEquals(\"201\u00a0703,000\", numberFormatI18n.formatNumber(num1,\n-                3, frlanguage, frregion));\n-        Assert.assertEquals(\"201\u00a0703,0000\", numberFormatI18n.formatNumber(num1,\n-                4, frlanguage, frregion));\n-    }\n-\n-    @Test\n-    public void testFormatNumber() {\n-        long num1 = 201703;\n-        double num2 = 201703.54;\n-        String num3 = \"201703.5416926\";\n-\n-        final Locale zhLocale = new Locale(\"zh\", \"CN\");\n-        Assert.assertEquals(\"201,703\", numberFormatI18n.formatNumber(num1,\n-                zhLocale));\n-        Assert.assertEquals(\"201,703\", numberFormatI18n.formatNumber(num1,\n-                -1, zhLocale));\n-        Assert.assertEquals(\"201,703.00\", numberFormatI18n.formatNumber(num1,\n-                2, zhLocale));\n-        Assert.assertEquals(\"201,703.00000\", numberFormatI18n.formatNumber(num1,\n-                5, zhLocale));\n-\n-        Assert.assertEquals(\"201,703.54\", numberFormatI18n.formatNumber(num2,\n-                zhLocale));\n-        Assert.assertEquals(\"201,704\", numberFormatI18n.formatNumber(num2,\n-                -1, zhLocale));\n-        Assert.assertEquals(\"201,703.54\", numberFormatI18n.formatNumber(num2,\n-                2, zhLocale));\n-        Assert.assertEquals(\"201,703.54000\", numberFormatI18n.formatNumber(num2,\n-                5, zhLocale));\n-\n-        Assert.assertEquals(\"201,703.542\", numberFormatI18n.formatNumber(num3,\n-                zhLocale));\n-        Assert.assertEquals(\"201,704\", numberFormatI18n.formatNumber(num3,\n-                -1, zhLocale));\n-        Assert.assertEquals(\"201,703.54\", numberFormatI18n.formatNumber(num3,\n-                2, zhLocale));\n-        Assert.assertEquals(\"201,703.54169\", numberFormatI18n.formatNumber(num3,\n-                5, zhLocale));\n-\n-        final Locale frLocale = new Locale(\"fr\", \"\");\n-        Assert.assertEquals(\"201\u00a0703\", numberFormatI18n.formatNumber(num1,\n-                frLocale));\n-        Assert.assertEquals(\"201\u00a0703\", numberFormatI18n.formatNumber(num1,\n-                -10, frLocale));\n-        Assert.assertEquals(\"201\u00a0703,000\", numberFormatI18n.formatNumber(num1,\n-                3, frLocale));\n-        Assert.assertEquals(\"201\u00a0703,0000\", numberFormatI18n.formatNumber(num1,\n-                4, frLocale));\n-    }\n-\n-    @Test\n-    public void testFormatPercent() {\n-        double num1 = 0.354;\n-\n-        final Locale zhLocale = new Locale(\"zh\", \"CN\");\n-        Assert.assertEquals(\"35%\", numberFormatI18n.formatPercent(num1,\n-                zhLocale));\n-        Assert.assertEquals(\"35%\", numberFormatI18n.formatPercent(num1,\n-                -1, zhLocale));\n-        Assert.assertEquals(\"35.40%\", numberFormatI18n.formatPercent(num1,\n-                2, zhLocale));\n-\n-        final Locale frLocale = new Locale(\"fr\", \"\");\n-        Assert.assertEquals(\"35\u00a0%\", numberFormatI18n.formatPercent(num1,\n-                frLocale));\n-        Assert.assertEquals(\"35\u00a0%\", numberFormatI18n.formatPercent(num1,\n-                -3, frLocale));\n-        Assert.assertEquals(\"35,40000\u00a0%\", numberFormatI18n.formatPercent(num1,\n-                5, frLocale));\n-    }\n-\n-    @Test\n-    public void testRegionFormatPercent() {\n-        double num1 = 0.354;\n-\n-        String language = \"zh-Hans\";\n-        String region = \"CN\";\n-        ;\n-        Assert.assertEquals(\"35%\", numberFormatI18n.formatPercent(num1,\n-                language, region));\n-        Assert.assertEquals(\"35%\", numberFormatI18n.formatPercent(num1,\n-                -1, language, region));\n-        Assert.assertEquals(\"35.40%\", numberFormatI18n.formatPercent(num1,\n-                2, language, region));\n-\n-        String frlanguage = \"fr\";\n-        String frregion = \"FR\";\n-\n-        Assert.assertEquals(\"35\u00a0%\", numberFormatI18n.formatPercent(num1,\n-                frlanguage, frregion));\n-        Assert.assertEquals(\"35\u00a0%\", numberFormatI18n.formatPercent(num1,\n-                -3, frlanguage, frregion));\n-        Assert.assertEquals(\"35,40000\u00a0%\", numberFormatI18n.formatPercent(num1,\n-                5, frlanguage, frregion));\n-    }\n-\n-    @Test\n-    public void testFormatCurrency() {\n-        String currencyCode = \"JPY\";\n-        long num1 = 201703;\n-        double num2 = 201703.54;\n-        String num3 = \"201704.5456926\";\n-\n-        final Locale zhLocale = new Locale(\"zh\", \"CN\");\n-        Assert.assertEquals(\"US$201,703.00\", numberFormatI18n.formatCurrency(\n-                num1, zhLocale));\n-        Assert.assertEquals(\"JP\u00a5201,703\", numberFormatI18n.formatCurrency(\n-                num1, currencyCode, zhLocale));\n-        /*\n-         * Assert.assertEquals(\"\uffe5201,703\", numberFormatI18n.formatCurrency(\n-         * num1, -1, zhLocale));\n-         * Assert.assertEquals(\"\uffe5201,703.0\", numberFormatI18n.formatCurrency(\n-         * num1, 1, zhLocale));\n-         * Assert.assertEquals(\"\uffe5201,703.00000\", numberFormatI18n\n-         * .formatCurrency(num1, 5, zhLocale));\n-         */\n-\n-        Assert.assertEquals(\"US$201,703.54\", numberFormatI18n.formatCurrency(\n-                num2, zhLocale));\n-        Assert.assertEquals(\"JP\u00a5201,704\", numberFormatI18n.formatCurrency(\n-                num2, currencyCode, zhLocale));\n-        /*\n-         * Assert.assertEquals(\"\uffe5201,704\", numberFormatI18n.formatCurrency(\n-         * num2, -1, zhLocale));\n-         * Assert.assertEquals(\"\uffe5201,703.5\", numberFormatI18n.formatCurrency(\n-         * num2, 1, zhLocale));\n-         * Assert.assertEquals(\"\uffe5201,703.54000\", numberFormatI18n\n-         * .formatCurrency(num2, 5, zhLocale));\n-         */\n-\n-        Assert.assertEquals(\"US$201,704.55\", numberFormatI18n.formatCurrency(\n-                num3, zhLocale));\n-        Assert.assertEquals(\"JP\u00a5201,705\", numberFormatI18n.formatCurrency(\n-                num3, currencyCode, zhLocale));\n-        /*\n-         * Assert.assertEquals(\"\uffe5201,704\", numberFormatI18n.formatCurrency(\n-         * num3, -1, zhLocale));\n-         * Assert.assertEquals(\"\uffe5201,703.5\", numberFormatI18n.formatCurrency(\n-         * num3, 1, zhLocale));\n-         * Assert.assertEquals(\"\uffe5201,703.54169\", numberFormatI18n\n-         * .formatCurrency(num3, 5, zhLocale));\n-         */\n-\n-        final Locale frLocale = new Locale(\"fr\", \"\");\n-        Assert.assertEquals(\"201\u00a0703,00\u00a0$US\", numberFormatI18n\n-                .formatCurrency(num1, frLocale));\n-        Assert.assertEquals(\"201\u00a0703\u00a0JPY\", numberFormatI18n\n-                .formatCurrency(num1, currencyCode, frLocale));\n-        /*\n-         * Assert.assertEquals(\"201\u00a0703\u00a0\u20ac\", numberFormatI18n.formatCurrency(\n-         * num1, -1, frLocale));\n-         * Assert.assertEquals(\"201\u00a0703,00\u00a0\u20ac\", numberFormatI18n\n-         * .formatCurrency(num1, 2, frLocale));\n-         * Assert.assertEquals(\"201\u00a0703,00000\u00a0\u20ac\", numberFormatI18n\n-         * .formatCurrency(num1, 5, frLocale));\n-         */\n-    }\n-\n-    @Test\n-    public void testRegionFormatCurrency() {\n-        String currencyCode = \"JPY\";\n-        long num1 = 201703;\n-        double num2 = 201703.54;\n-        String num3 = \"201704.5456926\";\n-\n-        String language = \"zh-Hans\";\n-        String region = \"CN\";\n-\n-        Assert.assertEquals(\"US$201,703.00\", numberFormatI18n.formatCurrency(\n-                num1, language, region));\n-        Assert.assertEquals(\"JP\u00a5201,703\", numberFormatI18n.formatCurrency(\n-                num1, currencyCode, language, region));\n-\n-        Assert.assertEquals(\"US$201,703.54\", numberFormatI18n.formatCurrency(\n-                num2, language, region));\n-        Assert.assertEquals(\"JP\u00a5201,704\", numberFormatI18n.formatCurrency(\n-                num2, currencyCode, language, region));\n-\n-        Assert.assertEquals(\"US$201,704.55\", numberFormatI18n.formatCurrency(\n-                num3, language, region));\n-        Assert.assertEquals(\"JP\u00a5201,705\", numberFormatI18n.formatCurrency(\n-                num3, currencyCode, language, region));\n-\n-        String frlanguage = \"fr\";\n-        String frregion = \"FR\";\n-\n-        Assert.assertEquals(\"201\u00a0703,00\u00a0$US\", numberFormatI18n\n-                .formatCurrency(num1, frlanguage, frregion));\n-        Assert.assertEquals(\"201\u00a0703\u00a0JPY\", numberFormatI18n\n-                .formatCurrency(num1, currencyCode, frlanguage, frregion));\n-\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDIzMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464760230", "bodyText": "Same comment: \"This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example. \"", "author": "jessiejuachon", "createdAt": "2020-08-04T02:21:00Z", "path": "src/test/java/com/vmware/vip/i18n/PluralFormatOfflineTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import com.vmware.vipclient.i18n.l2.text.PluralFormat;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.text.FieldPosition;\n+import java.util.Locale;\n+\n+public class PluralFormatOfflineTest extends BaseTestClass {\n+\n+    public PluralFormatOfflineTest() {\n+        // TODO Auto-generated constructor stub\n+    }\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0Mjc1Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742752", "bodyText": "Same resolution as above.", "author": "huihuiw01", "createdAt": "2020-08-05T13:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDIzMA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/test/java/com/vmware/vip/i18n/PluralFormatOfflineTest.java b/src/test/java/com/vmware/vip/i18n/PluralFormatOfflineTest.java\ndeleted file mode 100644\nindex cb94e584..00000000\n--- a/src/test/java/com/vmware/vip/i18n/PluralFormatOfflineTest.java\n+++ /dev/null\n\n@@ -1,63 +0,0 @@\n-/*\n- * Copyright 2019 VMware, Inc.\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package com.vmware.vip.i18n;\n-\n-import com.vmware.vipclient.i18n.I18nFactory;\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n-import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n-import com.vmware.vipclient.i18n.l2.text.PluralFormat;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.text.FieldPosition;\n-import java.util.Locale;\n-\n-public class PluralFormatOfflineTest extends BaseTestClass {\n-\n-    public PluralFormatOfflineTest() {\n-        // TODO Auto-generated constructor stub\n-    }\n-\n-    @Before\n-    public void init() {\n-        VIPCfg gc = VIPCfg.getInstance();\n-        try {\n-            gc.initialize(\"vipconfig-offline\");\n-        } catch (VIPClientInitException e) {\n-            logger.error(e.getMessage());\n-        }\n-        gc.initializeVIPService();\n-        gc.createFormattingCache(FormattingCache.class);\n-        I18nFactory i18n = I18nFactory.getInstance(gc);\n-    }\n-\n-    @Test\n-    public void testFormat() {\n-        String patEn = \"one{one dog} other{# dogs}\"; // English 'dog'\n-        String patSl = \"one{# pes} two{# psa} few{# psi} other{# psov}\"; // Slovenian translation of dog in Plural Form\n-\n-        // Create a new PluralFormat for a given locale locale and pattern string\n-        PluralFormat plfmtEn = new PluralFormat(new Locale(\"en\"), patEn);\n-        PluralFormat plfmtSl = new PluralFormat(new Locale(\"sl\"), patSl);\n-        // Assert.assertEquals(\"0 dogs\", plfmtEn.format(0).toString());\n-        // Assert.assertEquals(\"one dog\", plfmtEn.format(1).toString());\n-        // Assert.assertEquals(\"345,678 dogs\", plfmtEn.format(345678).toString());\n-        Assert.assertEquals(\"0 dogs\", plfmtEn.format(0, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"one dog\", plfmtEn.format(1, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"345,678 dogs\",\n-                plfmtEn.format(345678, new StringBuilder(), new FieldPosition(0)).toString());\n-\n-        Assert.assertEquals(\"0 psov\", plfmtSl.format(0, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"1 pes\", plfmtSl.format(1, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"2 psa\", plfmtSl.format(2, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"3 psi\", plfmtSl.format(3, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"4 psi\", plfmtSl.format(4, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"5 psov\", plfmtSl.format(5, new StringBuilder(), new FieldPosition(0)).toString());\n-        Assert.assertEquals(\"345.678 psov\",\n-                plfmtSl.format(345678, new StringBuilder(), new FieldPosition(0)).toString());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc5MDg3Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464790876", "bodyText": "Just like what I put in the Javadoc comment of this method,  the plan is to deprecate this V2URL endpoint on service side because it is but a subset of V2URL.getSupportedLanguageListURL (language tags only instead of tags + display names). So call RemoteLocaleOpt.getSupportedLanguages(default locale) in here and just grab the keySet().\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public List<String> getSupportedLocales() {\n          \n          \n            \n                    JSONArray msgObject = new JSONArray();\n          \n          \n            \n                    String responseStr = \"\";\n          \n          \n            \n                    Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(V2URL.getSupportedLocaleListURL(\n          \n          \n            \n                public List<String> getSupportedLocales() {\n          \n          \n            \n                    Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n          \n          \n            \n                    return getSupportedLocales(fallbackLocalesIter);\n          \n          \n            \n                }\n          \n          \n            \n                private List<String> getSupportedLocales(Iterator<Locale> fallbackLocalesIter) {\n          \n          \n            \n                    if (fallbackLocalesIter != null && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                        String locale = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        Map<String, String> supportedLocales = RemoteLocaleOpt.getSupportedLanguages(locale);\n          \n          \n            \n                        if (supportedLocales == null || supportedLocales.isEmpty()) {\n          \n          \n            \n                            return getSupportedLocales(fallbackLocalesIter);\n          \n          \n            \n                        }\n          \n          \n            \n                        return supportedLocales.keySet();\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-04T04:23:51Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java", "diffHunk": "@@ -52,7 +52,7 @@ public ProductBasedOpt(BaseDTO dto) {\n      * @see com.vmware.vipclient.i18n.messages.dao.ILocaleDao#getSupportedLocales()\n      * @deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt#getSupportedLanguages(String)()}\n      */\n-    @Deprecated public JSONArray getSupportedLocalesFromRemoteVIP() {\n+    public List<String> getSupportedLocales() {\n         JSONArray msgObject = new JSONArray();\n         String responseStr = \"\";\n         Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(V2URL.getSupportedLocaleListURL(", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNzA4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466117081", "bodyText": "I prefer to deprecate this V2URL endpoint after V3 API is available.\nLooks like V3 API url is different with V2, after V3 is available, this need to be changed again.", "author": "huihuiw01", "createdAt": "2020-08-06T03:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc5MDg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\nsimilarity index 80%\nrename from src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java\nrename to src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\nindex 0f4dea44..3e71fbb0 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\n\n@@ -46,13 +45,12 @@ public class RemoteProductOpt extends BaseOpt implements ProductOpt {\n         return msgObject;\n     }\n \n-    /**\n+    /*\n      * get supported locales from vip(non-Javadoc)\n      * \n      * @see com.vmware.vipclient.i18n.messages.dao.ILocaleDao#getSupportedLocales()\n-     * @deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt#getSupportedLanguages(String)()}\n      */\n-    public List<String> getSupportedLocales() {\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n         JSONArray msgObject = new JSONArray();\n         String responseStr = \"\";\n         Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(V2URL.getSupportedLocaleListURL(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0NzI4OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464847289", "bodyText": "It's better to solve the problem instead of commenting it.", "author": "Xiaochao8", "createdAt": "2020-08-04T07:15:12Z", "path": "src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java", "diffHunk": "@@ -178,7 +185,7 @@ public void testGetPatternMessageWithBundle() {\n         Assert.assertEquals(\"\\\"\u6211\u7684\u786c\u76d8\\\"\u4e0a\u6709345,678\u4e2a\u6587\u4ef6\u3002\", pluralMessage6);\n     }\n \n-    @Test", "originalCommit": "a456440e78eee1bb7b0e1079dab66174a1648710", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java b/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java\nindex 9a6180a2..e39228ed 100644\n--- a/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java\n+++ b/src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java\n\n@@ -185,15 +183,6 @@ public class TranslationMessageTest extends BaseTestClass {\n         Assert.assertEquals(\"\\\"\u6211\u7684\u786c\u76d8\\\"\u4e0a\u6709345,678\u4e2a\u6587\u4ef6\u3002\", pluralMessage6);\n     }\n \n-   // @Test\n-    public void testGetComponentMessagesLocaleNotSupported() {\n-    \tString component = \"JAVA\";\n-    \tString message_en_US = \"User name\";\n-    \tString key = \"global_text_username\";\n-    \t// When requested locale is not supported, the default locale messages will be returned.\n-        Map<String, String> localeNotSupported = translation.getMessages(Locale.forLanguageTag(\"fil-PH\"), component);\n-        Assert.assertEquals(message_en_US, localeNotSupported.get(key));\n-    }\n     @Test\n     public void testGetComponentMessages() {\n         vipCfg.setPseudo(false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0OTk1NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464849955", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n              LocaleDTO dto = new LocaleDTO(cfg)", "author": "Xiaochao8", "createdAt": "2020-08-04T07:20:39Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +86,37 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n+        if(dispNameMap != null) {\n+            Collection<String> valueCollection = dispNameMap.values();\n+            return new ArrayList<String>(valueCollection);\n+        }\n+        return new ArrayList();\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        LocaleDTO dto = new LocaleDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\nindex f0f9c357..f7e4f823 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java\n\n@@ -86,37 +71,12 @@ public class LocaleMessage implements Message {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLocale) {\n-        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n-        if(dispNameMap != null) {\n-            Collection<String> valueCollection = dispNameMap.values();\n-            return new ArrayList<String>(valueCollection);\n-        }\n-        return new ArrayList();\n-    }\n-\n-    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n-        if(locale == null || locale.isEmpty()) {\n-            logger.warn(\"Locale is empty!\");\n-            return null;\n-        }\n-        LocaleDTO dto = new LocaleDTO();\n-        if(cfg != null) {\n-            dto.setProductID(cfg.getProductName());\n-            dto.setVersion(cfg.getVersion());\n-        }else{\n-            dto.setProductID(VIPCfg.getInstance().getProductName());\n-            dto.setVersion(VIPCfg.getInstance().getVersion());\n-        }\n-        LocaleService localeService = new LocaleService(dto);\n-        return localeService.getDisplayNames(locale);\n+    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n+        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n+        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        Collection<String> valueCollection = dispNameMap.values();\n+        List<String> dispNameList = new ArrayList<String>(valueCollection);\n+        return dispNameList;\n     }\n \n-    public VIPCfg getCfg() {\n-        return this.cfg;\n-    }\n-\n-    public void setCfg(final VIPCfg cfg) {\n-        this.cfg = cfg;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg1MDQ0MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464850441", "bodyText": "Remove this line.", "author": "Xiaochao8", "createdAt": "2020-08-04T07:21:44Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -28,45 +30,18 @@ public ProductService(BaseDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * get supported components defined in vip service\n-     * @return JSONArray\n-     * @deprecated Replaced by {@link #getComponents(Iterator<>)}\n-     */\n-    @Deprecated\n-    public JSONArray getComponentsFromRemoteVIP() {\n-        BaseDTO baseDTO = new BaseDTO();\n-        baseDTO.setProductID(dto.getProductID());\n-        baseDTO.setVersion(dto.getVersion());\n-        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getComponentsFromRemoteVIP();\n-    }\n-\n-    /**\n-     * get supported locales defined in vip service\n-     * @deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.service.LocaleService#getSupportedLanguages(Iterator<>)}\n-     */\n-    @Deprecated\n-    public JSONArray getSupportedLocalesFromRemoteVIP() {\n-        BaseDTO baseDTO = new BaseDTO();\n-        baseDTO.setProductID(dto.getProductID());\n-        baseDTO.setVersion(dto.getVersion());\n-        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getSupportedLocalesFromRemoteVIP();\n-    }\n-\n     /**\n      * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n      *\n      * @return translated messages of all components of a product locale specified in the dto object\n      */\n     public List<Map> getAllComponentTranslation() {\n         List<Map> list = new ArrayList<Map>();\n-        LocaleDTO localeDTO = new LocaleDTO(dto.getProductID(), dto.getVersion());\n-        Map<String, String> locales = new LocaleService(localeDTO).getSupportedLanguages();\n+        LocaleDTO localeDTO = new LocaleDTO();", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 2d6b4d82..452af45d 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -4,105 +4,63 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n \n public class ProductService {\n-    private BaseDTO dto = null;\n-    Logger logger = LoggerFactory.getLogger(ProductService.class);\n+    private MessagesDTO dto = null;\n \n-    public ProductService(BaseDTO dto) {\n+    public ProductService(MessagesDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n-     *\n-     * @return translated messages of all components of a product locale specified in the dto object\n-     */\n-    public List<Map> getAllComponentTranslation() {\n-        List<Map> list = new ArrayList<Map>();\n-        LocaleDTO localeDTO = new LocaleDTO();\n-        List<String> locales = this.getSupportedLocales(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        List<String> components = this.getComponents(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        if (locales != null) {\n-            for (String languageTag : locales) {\n-                for (Object component : components) {\n-                    MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n-                            dto.getProductID(), dto.getVersion());\n-                    Map<String, String> retMap = new ComponentService(msgDTO).getMessages(null).getCachedData();\n-                    if (retMap != null) {\n-                        list.add(retMap);\n-                    }\n-                }\n-            }\n-        }\n-        return list;\n+    // get supported components defined in vip service\n+    public JSONArray getComponentsFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getComponentsFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n-     * @return list of components of the product specified in the dto object\n-     */\n-    public List<String> getComponents (Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext())\n-            return null;\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> components = opt.getComponents();\n-        // If failed to get components from the data source\n-        if (components.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                components = getComponents(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n-            }\n-        }\n-        return components;\n+    // get supported locales defined in vip service\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getSupportedLocalesFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n-     * @return list of locales of the product specified in the dto object\n-     */\n-    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext()) { return null; }\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> locales = opt.getSupportedLocales();\n-        // If failed to get components from the data source\n-        if (locales.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                locales = getSupportedLocales(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n+    public List<Map> getAllComponentTranslation() {\n+        List<Map> list = new ArrayList<Map>();\n+        Object[] locales = {};\n+        Object[] components = {};\n+        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n+            locales = this.getSupportedLocalesFromRemoteVIP().toArray();\n+            components = this.getComponentsFromRemoteVIP()\n+                    .toArray();\n+        }\n+        for (Object locale : locales) {\n+            for (Object component : components) {\n+                dto.setComponent(((String) component).trim());\n+                dto.setLocale(LocaleUtility.fmtToMappedLocale((String) locale).toString().trim());\n+                Map<String, String> retMap = new ComponentService(dto).getMessages().getCachedData();\n+                if (retMap != null) {\n+                    list.add(retMap);\n+                }\n             }\n         }\n-        return locales;\n+        return list;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4MzUxNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465083517", "bodyText": "are -> is", "author": "Xiaochao8", "createdAt": "2020-08-04T14:16:25Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -36,6 +42,10 @@ public JSONObject getPatternMessage(Locale locale) {\n      * @return\n      */\n     public JSONObject getPatternMessage(String language, String region) {\n+        if((language == null || language.isEmpty()) || (region == null || region.isEmpty())) {\n+            logger.warn(\"Either language or region are empty!\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\nindex 852d7770..09f2c8d7 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java\n\n@@ -42,10 +36,6 @@ public class PatternMessage implements Message {\n      * @return\n      */\n     public JSONObject getPatternMessage(String language, String region) {\n-        if((language == null || language.isEmpty()) || (region == null || region.isEmpty())) {\n-            logger.warn(\"Either language or region are empty!\");\n-            return null;\n-        }\n         return new PatternService().getPatterns(language, region);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyMTcyOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465121728", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\ttry {\n          \n          \n            \n            \t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n          \n          \n            \n            \t\t} catch (ParseException e) {\n          \n          \n            \n            \t\t\te.printStackTrace();\n          \n          \n            \n            \t\t\tlogger.error(e.getMessage());\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif (regionsData == null) {\n          \n          \n            \n            \t\t\treturn null;\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\treturn (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n          \n          \n            \n                    try {\n          \n          \n            \n                        regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n          \n          \n            \n                        return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n          \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                        logger.error(e.getMessage());\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return null;", "author": "Xiaochao8", "createdAt": "2020-08-04T15:07:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -4,65 +4,129 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.stream.Stream;\n-\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-   \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate static final String BUNDLE_SUFFIX = \".json\";\n+\n+\tprivate LocaleDTO dto = null;\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n+\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n+\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n-    }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n-        }\n+\t\treturn supportedLanguageNames;\n     }\n \n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n+\t\t\treturn null;\n+\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\tJSONObject languagesData = null;\n+\t\ttry {\n+\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tlogger.error(e.getMessage());\n+\t\t}\n+\t\tif (languagesData == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t}\n+\n+\tpublic JSONObject getRegions(String locale) {\n+\t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n+\t\tJSONObject regionsData = null;\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n+\t\t\treturn null;\n+\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\ttry {\n+\t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tlogger.error(e.getMessage());\n+\t\t}\n+\t\tif (regionsData == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (JSONObject) regionsData.get(PatternKeys.TERRITORIES);", "originalCommit": "1610a70670615d27073abf930cc7274dd1653a9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 244b349b5..c1ef1c722 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -4,129 +4,65 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import com.vmware.i18n.PatternUtil;\n-import com.vmware.i18n.utils.CommonUtil;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n-import org.json.simple.JSONObject;\n-import org.json.simple.parser.JSONParser;\n-import org.json.simple.parser.ParseException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n+import java.util.stream.Stream;\n \n-import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n-import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n-\tprivate static final String BUNDLE_SUFFIX = \".json\";\n-\n-\tprivate LocaleDTO dto = null;\n-\n-\tpublic LocalLocaleOpt(LocaleDTO dto) {\n-\t\tthis.dto = dto;\n-\t}\n+    \n+    @Override\n+    public Map<String, String> getLanguages(String displayLanguage) {\n+   \n+    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n+\t\ttry {\n+\t\t\t\n+\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\t\t\t\n+\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n+\t\t\t\t\tgetResource(path.toString()).toURI();\n \n-\t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n-\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n-\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n-\t\t\t\t.getSupportedLocales();\n-\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n-\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n-\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n-\t\t\tfor(String language : supportedLanguages){\n-\t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t    \tif (uri.getScheme().equals(\"jar\")) {\n+\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+\t    \t\t\tpath = fileSystem.getPath(path.toString());\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t}\n+\t\t\t} else {\n+\t\t\t\tpath = Paths.get(uri);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n \t\t\t}\n+\t    \t\n+\t\t} catch (Exception e) {\n+\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-\t\treturn supportedLanguageNames;\n+    \treturn supportedLocales;\n+    }\n+    \n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n+    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+        \tlistOfFiles.map(file -> {\n+\t\t\t\tString fileName = file.getFileName().toString();\n+\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+        }\n     }\n \n-\t/*private Map<String, String> getLanguagesNames(String locale){\n-\t\tMap<String, String> languagesNames = null;\n-\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n-\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n-\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-\t\t\tif (languagesNames != null) {\n-\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n-\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n-\t\t\t}\n-\t\t}\n-\t\treturn languagesNames;\n-\t}*/\n-\n-    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n-\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n-\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n-\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n-\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\tJSONObject languagesData = null;\n-\t\ttry {\n-\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-\t\t} catch (ParseException e) {\n-\t\t\te.printStackTrace();\n-\t\t\tlogger.error(e.getMessage());\n-\t\t}\n-\t\tif (languagesData == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n-\t}\n-\n-\tpublic JSONObject getRegions(String locale) {\n-\t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n-\t\tJSONObject regionsData = null;\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\ttry {\n-\t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-\t\t} catch (ParseException e) {\n-\t\t\te.printStackTrace();\n-\t\t\tlogger.error(e.getMessage());\n-\t\t}\n-\t\tif (regionsData == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyMzM0OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465123348", "bodyText": "Since the '@deprecated' is removed, this 'Deprecated' needs to be removed as well.", "author": "Xiaochao8", "createdAt": "2020-08-04T15:09:29Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java", "diffHunk": "@@ -29,7 +29,7 @@ public ProductBasedOpt(BaseDTO dto) {\n      * @see com.vmware.vipclient.i18n.messages.dao.IComponentDao#getComponents()\n      * @Deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.api.opt.server.RemoteComponentOpt#getComponents()}", "originalCommit": "1610a70670615d27073abf930cc7274dd1653a9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\nsimilarity index 80%\nrename from src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java\nrename to src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\nindex 0f4dea449..3e71fbb01 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java\n\n@@ -5,31 +5,30 @@\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n+\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.Opt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import org.json.simple.JSONArray;\n-\n-import java.util.List;\n \n-public class RemoteProductOpt extends BaseOpt implements ProductOpt {\n+public class ProductBasedOpt extends BaseOpt implements Opt {\n     private BaseDTO dto = null;\n \n-    public RemoteProductOpt(BaseDTO dto) {\n+    public ProductBasedOpt(BaseDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n+    /*\n      * get supported components from vip(non-Javadoc)\n      * \n      * @see com.vmware.vipclient.i18n.messages.dao.IComponentDao#getComponents()\n-     * @Deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.api.opt.server.RemoteComponentOpt#getComponents()}\n      */\n-    public List<String> getComponents() {\n+    public JSONArray getComponentsFromRemoteVIP() {\n         JSONArray msgObject = new JSONArray();\n         String responseStr = \"\";\n         Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyNzg4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465127881", "bodyText": "Because this is an interface, please keep msgSourceQueueIter internally. Don't include it as a parameter.\nThe upper layer don't need to know this.", "author": "Xiaochao8", "createdAt": "2020-08-04T15:15:40Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -106,4 +81,28 @@ public JSONArray getSupportedLocalesFromRemoteVIP() {\n         return components;\n     }\n \n+    /**\n+     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n+     *\n+     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n+     * @return list of locales of the product specified in the dto object\n+     */\n+    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {", "originalCommit": "1610a70670615d27073abf930cc7274dd1653a9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 2d6b4d820..452af45d0 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -4,105 +4,63 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n \n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n \n public class ProductService {\n-    private BaseDTO dto = null;\n-    Logger logger = LoggerFactory.getLogger(ProductService.class);\n+    private MessagesDTO dto = null;\n \n-    public ProductService(BaseDTO dto) {\n+    public ProductService(MessagesDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n-     *\n-     * @return translated messages of all components of a product locale specified in the dto object\n-     */\n-    public List<Map> getAllComponentTranslation() {\n-        List<Map> list = new ArrayList<Map>();\n-        LocaleDTO localeDTO = new LocaleDTO();\n-        List<String> locales = this.getSupportedLocales(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        List<String> components = this.getComponents(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        if (locales != null) {\n-            for (String languageTag : locales) {\n-                for (Object component : components) {\n-                    MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n-                            dto.getProductID(), dto.getVersion());\n-                    Map<String, String> retMap = new ComponentService(msgDTO).getMessages(null).getCachedData();\n-                    if (retMap != null) {\n-                        list.add(retMap);\n-                    }\n-                }\n-            }\n-        }\n-        return list;\n+    // get supported components defined in vip service\n+    public JSONArray getComponentsFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getComponentsFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n-     * @return list of components of the product specified in the dto object\n-     */\n-    public List<String> getComponents (Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext())\n-            return null;\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> components = opt.getComponents();\n-        // If failed to get components from the data source\n-        if (components.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                components = getComponents(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n-            }\n-        }\n-        return components;\n+    // get supported locales defined in vip service\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getSupportedLocalesFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n-     * @return list of locales of the product specified in the dto object\n-     */\n-    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext()) { return null; }\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> locales = opt.getSupportedLocales();\n-        // If failed to get components from the data source\n-        if (locales.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                locales = getSupportedLocales(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n+    public List<Map> getAllComponentTranslation() {\n+        List<Map> list = new ArrayList<Map>();\n+        Object[] locales = {};\n+        Object[] components = {};\n+        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n+            locales = this.getSupportedLocalesFromRemoteVIP().toArray();\n+            components = this.getComponentsFromRemoteVIP()\n+                    .toArray();\n+        }\n+        for (Object locale : locales) {\n+            for (Object component : components) {\n+                dto.setComponent(((String) component).trim());\n+                dto.setLocale(LocaleUtility.fmtToMappedLocale((String) locale).toString().trim());\n+                Map<String, String> retMap = new ComponentService(dto).getMessages().getCachedData();\n+                if (retMap != null) {\n+                    list.add(retMap);\n+                }\n             }\n         }\n-        return locales;\n+        return list;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNjM5OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466706398", "bodyText": "There are 2 items in the below suggestion:\n\nUse of fallbackLocalesIter\nCache update using populateCacheTask.\n\nYou had mentioned you wanted to do #2 (cache update) in next PR, in which case just remove populateCacheTask from code suggestion below and log an issue in github.\nBut what about #1 (using fallbackLocalesIter) ?  Do you also want to do this in the next PR even if it has nothing to do with cache update? That is fine, just log another issuein github.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    dispMap = getSupportedDisplayNamesByLocale(locale);\n          \n          \n            \n                    if(dispMap != null && !dispMap.isEmpty()){\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (locale != null && !locale.isEmpty() && !LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n          \n          \n            \n                        Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n          \n          \n            \n                        dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n          \n          \n            \n                        if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                            new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                            logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n          \n          \n            \n                                    dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                    // if display language is null, just proceed to the next available fallback locale\n          \n          \n            \n                    if (locale == null) {\n          \n          \n            \n                        if (fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            locale = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    locale = locale.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                    logger.debug(\"Look for supported languages from cache for locale [{}]\", locale);\n          \n          \n            \n                    String productName = dto.getProductID();\n          \n          \n            \n                    String version = dto.getVersion();\n          \n          \n            \n                    FormattingCacheService formattingCacheService = new FormattingCacheService();\n          \n          \n            \n                    FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n          \n          \n            \n                    if (cacheItem != null) {\n          \n          \n            \n                        logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n          \n          \n            \n                        dispMap = cacheItem.getCachedData();\n          \n          \n            \n                        if (cacheItem.isExpired()) {\n          \n          \n            \n                            populateCacheTask(locale);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                    \n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                        if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n          \n          \n            \n                            if (dispMap != null && !dispMap.isEmpty()) {\n          \n          \n            \n                                formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                                logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    //}\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n                private void populateCacheTask(String locale) {\n          \n          \n            \n                    Callable<Map<String, String>> callable = () -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            Map<String, String> dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                            // To make sure that the thread will close\n          \n          \n            \n                            // even when an exception is thrown\n          \n          \n            \n                            return null;\n          \n          \n            \n                        }\n          \n          \n            \n                    };\n          \n          \n            \n                    FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n          \n          \n            \n                    Thread thread = new Thread(task);\n          \n          \n            \n                    thread.start();\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-06T21:52:52Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,136 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n+    public LocaleService() {\n     }\n+\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext()) {\n+            logger.error(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED_ALL));\n+            return regions;\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString()));\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        }\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (locale != null && !locale.isEmpty() && !LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNjI1MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466936250", "bodyText": "Use of fallbackLocalesIter\nresolved", "author": "huihuiw01", "createdAt": "2020-08-07T09:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNjM5OA=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex 4efe0f1fb..254fd9d21 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,136 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n     public LocaleService() {\n     }\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n-    }\n-\n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED_ALL));\n-            return regions;\n-        }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString()));\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (locale != null && !locale.isEmpty() && !LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2NDQxOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466764419", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (components.isEmpty()) {\n          \n          \n            \n                        if (components == null || components.isEmpty()) {", "author": "Xiaochao8", "createdAt": "2020-08-07T01:04:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -58,23 +56,17 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n      * @return list of components of the product specified in the dto object\n      */\n-    public List<String> getComponents (Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext())\n-            return null;\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> components = opt.getComponents();\n-        // If failed to get components from the data source\n-        if (components.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                components = getComponents(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n+    public List<String> getComponents(){\n+        List<String> components = null;\n+        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n+        while((components == null || components.isEmpty()) && msgSourceQueueIter.hasNext()){\n+            DataSourceEnum dataSource = msgSourceQueueIter.next();\n+            ProductOpt opt = dataSource.createProductOpt(dto);\n+            components = opt.getComponents();\n+            // If failed to get components from the data source, log the error.\n+            if (components.isEmpty()) {", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNDM0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466934347", "bodyText": "Actually \u2018components\u2019 won't be null as opt.getComponents() method new ArrayList and won't return null.", "author": "huihuiw01", "createdAt": "2020-08-07T09:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2NDQxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 10f422087..452af45d0 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -4,92 +4,63 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n+\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n \n public class ProductService {\n-    private BaseDTO dto = null;\n-    Logger logger = LoggerFactory.getLogger(ProductService.class);\n+    private MessagesDTO dto = null;\n \n-    public ProductService(BaseDTO dto) {\n+    public ProductService(MessagesDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n-     *\n-     * @return translated messages of all components of a product locale specified in the dto object\n-     */\n-    public List<Map> getAllComponentTranslation() {\n-        List<Map> list = new ArrayList<Map>();\n-        List<String> locales = this.getSupportedLocales();\n-        List<String> components = this.getComponents();\n-        if (locales != null && components != null) {\n-            for (String languageTag : locales) {\n-                for (Object component : components) {\n-                    MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n-                            dto.getProductID(), dto.getVersion());\n-                    Map<String, String> retMap = new ComponentService(msgDTO).getMessages(null).getCachedData();\n-                    if (retMap != null) {\n-                        list.add(retMap);\n-                    }\n-                }\n-            }\n-        }\n-        return list;\n+    // get supported components defined in vip service\n+    public JSONArray getComponentsFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getComponentsFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of components of the product specified in the dto object\n-     */\n-    public List<String> getComponents(){\n-        List<String> components = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((components == null || components.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            components = opt.getComponents();\n-            // If failed to get components from the data source, log the error.\n-            if (components.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n-            }\n-        }\n-        return components;\n+    // get supported locales defined in vip service\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getSupportedLocalesFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of locales of the product specified in the dto object\n-     */\n-    public List<String> getSupportedLocales(){\n-        List<String> locales = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            locales = opt.getSupportedLocales();\n-            // If failed to get locales from the data source, log the error.\n-            if (locales.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));\n+    public List<Map> getAllComponentTranslation() {\n+        List<Map> list = new ArrayList<Map>();\n+        Object[] locales = {};\n+        Object[] components = {};\n+        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n+            locales = this.getSupportedLocalesFromRemoteVIP().toArray();\n+            components = this.getComponentsFromRemoteVIP()\n+                    .toArray();\n+        }\n+        for (Object locale : locales) {\n+            for (Object component : components) {\n+                dto.setComponent(((String) component).trim());\n+                dto.setLocale(LocaleUtility.fmtToMappedLocale((String) locale).toString().trim());\n+                Map<String, String> retMap = new ComponentService(dto).getMessages().getCachedData();\n+                if (retMap != null) {\n+                    list.add(retMap);\n+                }\n             }\n         }\n-        return locales;\n+        return list;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2ODcyMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466768721", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSONObject regionsData = null;\n          \n          \n            \n            \t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n          \n          \n            \n            \t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n          \n          \n            \n            \t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n          \n          \n            \n            \t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:20:25Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -96,37 +95,33 @@ private JSONObject getLanguagesNamesFromBundle(String locale) {\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n-\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\tJSONObject languagesData = null;\n-\t\ttry {\n-\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-\t\t} catch (ParseException e) {\n+        try {\n+            JSONObject languagesData = null;\n+            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+            languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-\t\tif (languagesData == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+        return null;\n \t}\n \n \tpublic JSONObject getRegions(String locale) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n-\t\tJSONObject regionsData = null;\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n-\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\ttry {\n+        try {\n+            JSONObject regionsData = null;\n+\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n \t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex 5f859bb33..c1ef1c722 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -4,124 +4,65 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import com.vmware.i18n.PatternUtil;\n-import com.vmware.i18n.utils.CommonUtil;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import org.json.simple.JSONObject;\n-import org.json.simple.parser.JSONParser;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n-import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n-\tprivate static final String BUNDLE_SUFFIX = \".json\";\n-\n-\tprivate LocaleDTO dto = null;\n-\n-\tpublic LocalLocaleOpt(LocaleDTO dto) {\n-\t\tthis.dto = dto;\n-\t}\n-\n-\t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n-\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n-\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n-\t\t\t\t.getSupportedLocales();\n-\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n-\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n-\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n-\t\t\tfor(String language : supportedLanguages){\n-\t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n-\t\t\t}\n-\t\t}\n-\t\treturn supportedLanguageNames;\n-    }\n+    \n+    @Override\n+    public Map<String, String> getLanguages(String displayLanguage) {\n+   \n+    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n+\t\ttry {\n+\t\t\t\n+\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\t\t\t\n+\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n+\t\t\t\t\tgetResource(path.toString()).toURI();\n \n-\t/*private Map<String, String> getLanguagesNames(String locale){\n-\t\tMap<String, String> languagesNames = null;\n-\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n-\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n-\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-\t\t\tif (languagesNames != null) {\n-\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n-\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t    \tif (uri.getScheme().equals(\"jar\")) {\n+\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+\t    \t\t\tpath = fileSystem.getPath(path.toString());\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t}\n+\t\t\t} else {\n+\t\t\t\tpath = Paths.get(uri);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n \t\t\t}\n-\t\t}\n-\t\treturn languagesNames;\n-\t}*/\n-\n-    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n-\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n-\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n-\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n-\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            JSONObject languagesData = null;\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-            languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t    \t\n \t\t} catch (Exception e) {\n-\t\t\te.printStackTrace();\n-\t\t\tlogger.error(e.getMessage());\n+\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-        return null;\n-\t}\n+    \treturn supportedLocales;\n+    }\n+    \n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n+    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+        \tlistOfFiles.map(file -> {\n+\t\t\t\tString fileName = file.getFileName().toString();\n+\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+        }\n+    }\n \n-\tpublic JSONObject getRegions(String locale) {\n-\t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n-\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            JSONObject regionsData = null;\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n-\t\t} catch (Exception e) {\n-\t\t\te.printStackTrace();\n-\t\t\tlogger.error(e.getMessage());\n-\t\t}\n-\t\treturn null;\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2ODkxMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466768912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> patterns = null;\n          \n          \n            \n                        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n          \n          \n            \n                        patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n          \n          \n            \n                        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n          \n          \n            \n                        Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:20:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -42,14 +41,15 @@ public JSONObject getPatterns(String language, String region) {\n     private JSONObject getPatternsByLocale(String normalizedLocale) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n             return null;\n-        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n-        Map<String, Object> patterns = null;\n         try {\n+            Map<String, Object> patterns = null;\n+            String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             patterns = (Map<String, Object>) new JSONParser().parse(patternStr);", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\nindex ef96d3868..4342baf87 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java\n\n@@ -4,52 +4,21 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import com.vmware.i18n.PatternUtil;\n-import com.vmware.i18n.dto.LocaleDataDTO;\n-import com.vmware.i18n.utils.CommonUtil;\n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n-import org.json.simple.JSONObject;\n-import org.json.simple.parser.JSONParser;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.Map;\n \n-import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n-import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n-\n-public class LocalPatternOpt implements PatternOpt{\n-    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n+import org.json.simple.JSONObject;\n \n-    public JSONObject getPatterns(String locale) {\n-        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n-        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n-        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n-    }\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n \n-    @Override\n-    public JSONObject getPatterns(String language, String region) {\n-        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n-        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n-        String normalizedLocale = resultData.getLocale();\n-        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n-    }\n+public class LocalPatternOpt {\n \n-    private JSONObject getPatternsByLocale(String normalizedLocale) {\n-        if(normalizedLocale == null || normalizedLocale.isEmpty())\n+    public JSONObject getPatternsByLocale(String locale) {\n+        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n+        if (patterns == null) {\n             return null;\n-        try {\n-            Map<String, Object> patterns = null;\n-            String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n-            patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n+        } else {\n             return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            logger.error(e.getMessage());\n         }\n-        return null;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MTYwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466771600", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n          \n          \n            \n                        logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:31:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -116,11 +124,14 @@ public LocaleService(LocaleDTO dto) {\n \n     private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n+        if (!msgSourceQueueIter.hasNext()) {\n+            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex 4efe0f1fb..254fd9d21 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,136 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n     public LocaleService() {\n     }\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n-    }\n-\n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED_ALL));\n-            return regions;\n-        }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString()));\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (locale != null && !locale.isEmpty() && !LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MjAzOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466772039", "bodyText": "Suggest log in this way. FromatUtils is heavy and unnecessary.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n          \n          \n            \n                        logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:32:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -116,11 +124,14 @@ public LocaleService(LocaleDTO dto) {\n \n     private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n+        if (!msgSourceQueueIter.hasNext()) {\n+            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n             return dispMap;\n+        }\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n         dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex 4efe0f1fb..254fd9d21 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,136 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n     public LocaleService() {\n     }\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n-    }\n-\n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        if (!LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n-            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n+            }\n             if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+                respMap.put(language, regionMap);\n+                continue;\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED_ALL));\n-            return regions;\n-        }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString()));\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        if (locale != null && !locale.isEmpty() && !LocaleUtility.isDefaultLocale(locale)) {\n-            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n-            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        dto.getProductID(), dto.getVersion(), locale);\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n+        return respMap;\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        //cacheItem = new FormatCacheItem();\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n-    }\n-\n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MzMyMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466773321", "bodyText": "It's sure that component and locale are normalized. Don't need to do further procession.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n          \n          \n            \n                                MessagesDTO msgDTO = new MessagesDTO(component, languageTag, dto.getProductID(), dto.getVersion());", "author": "Xiaochao8", "createdAt": "2020-08-07T01:37:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -37,10 +36,9 @@ public ProductService(BaseDTO dto) {\n      */\n     public List<Map> getAllComponentTranslation() {\n         List<Map> list = new ArrayList<Map>();\n-        LocaleDTO localeDTO = new LocaleDTO();\n-        List<String> locales = this.getSupportedLocales(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        List<String> components = this.getComponents(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        if (locales != null) {\n+        List<String> locales = this.getSupportedLocales();\n+        List<String> components = this.getComponents();\n+        if (locales != null && components != null) {\n             for (String languageTag : locales) {\n                 for (Object component : components) {\n                     MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNTk0Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466935942", "bodyText": "Don't make this change as this is L3 code and not sure whether there will be error or not if don't do such process.", "author": "huihuiw01", "createdAt": "2020-08-07T09:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MzMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 10f422087..452af45d0 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -4,92 +4,63 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n+\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n \n public class ProductService {\n-    private BaseDTO dto = null;\n-    Logger logger = LoggerFactory.getLogger(ProductService.class);\n+    private MessagesDTO dto = null;\n \n-    public ProductService(BaseDTO dto) {\n+    public ProductService(MessagesDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n-     *\n-     * @return translated messages of all components of a product locale specified in the dto object\n-     */\n-    public List<Map> getAllComponentTranslation() {\n-        List<Map> list = new ArrayList<Map>();\n-        List<String> locales = this.getSupportedLocales();\n-        List<String> components = this.getComponents();\n-        if (locales != null && components != null) {\n-            for (String languageTag : locales) {\n-                for (Object component : components) {\n-                    MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n-                            dto.getProductID(), dto.getVersion());\n-                    Map<String, String> retMap = new ComponentService(msgDTO).getMessages(null).getCachedData();\n-                    if (retMap != null) {\n-                        list.add(retMap);\n-                    }\n-                }\n-            }\n-        }\n-        return list;\n+    // get supported components defined in vip service\n+    public JSONArray getComponentsFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getComponentsFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of components of the product specified in the dto object\n-     */\n-    public List<String> getComponents(){\n-        List<String> components = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((components == null || components.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            components = opt.getComponents();\n-            // If failed to get components from the data source, log the error.\n-            if (components.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n-            }\n-        }\n-        return components;\n+    // get supported locales defined in vip service\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getSupportedLocalesFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of locales of the product specified in the dto object\n-     */\n-    public List<String> getSupportedLocales(){\n-        List<String> locales = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            locales = opt.getSupportedLocales();\n-            // If failed to get locales from the data source, log the error.\n-            if (locales.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));\n+    public List<Map> getAllComponentTranslation() {\n+        List<Map> list = new ArrayList<Map>();\n+        Object[] locales = {};\n+        Object[] components = {};\n+        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n+            locales = this.getSupportedLocalesFromRemoteVIP().toArray();\n+            components = this.getComponentsFromRemoteVIP()\n+                    .toArray();\n+        }\n+        for (Object locale : locales) {\n+            for (Object component : components) {\n+                dto.setComponent(((String) component).trim());\n+                dto.setLocale(LocaleUtility.fmtToMappedLocale((String) locale).toString().trim());\n+                Map<String, String> retMap = new ComponentService(dto).getMessages().getCachedData();\n+                if (retMap != null) {\n+                    list.add(retMap);\n+                }\n             }\n         }\n-        return locales;\n+        return list;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NTg1Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466775857", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (locales.isEmpty()) {\n          \n          \n            \n                        if (locales==null || locales.isEmpty()) {", "author": "Xiaochao8", "createdAt": "2020-08-07T01:47:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -84,23 +76,18 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n      * @return list of locales of the product specified in the dto object\n      */\n-    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext()) { return null; }\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> locales = opt.getSupportedLocales();\n-        // If failed to get components from the data source\n-        if (locales.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                locales = getSupportedLocales(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n+    public List<String> getSupportedLocales(){\n+        List<String> locales = null;\n+        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n+        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n+            DataSourceEnum dataSource = msgSourceQueueIter.next();\n+            ProductOpt opt = dataSource.createProductOpt(dto);\n+            locales = opt.getSupportedLocales();\n+            // If failed to get locales from the data source, log the error.\n+            if (locales.isEmpty()) {", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNDkxOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466934918", "bodyText": "Actually \u2018locales\u2019 won't be null as opt.getSupportedLocales() method new ArrayList and won't return null.", "author": "huihuiw01", "createdAt": "2020-08-07T09:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NTg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 10f422087..452af45d0 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -4,92 +4,63 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n+\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n \n public class ProductService {\n-    private BaseDTO dto = null;\n-    Logger logger = LoggerFactory.getLogger(ProductService.class);\n+    private MessagesDTO dto = null;\n \n-    public ProductService(BaseDTO dto) {\n+    public ProductService(MessagesDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n-     *\n-     * @return translated messages of all components of a product locale specified in the dto object\n-     */\n-    public List<Map> getAllComponentTranslation() {\n-        List<Map> list = new ArrayList<Map>();\n-        List<String> locales = this.getSupportedLocales();\n-        List<String> components = this.getComponents();\n-        if (locales != null && components != null) {\n-            for (String languageTag : locales) {\n-                for (Object component : components) {\n-                    MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n-                            dto.getProductID(), dto.getVersion());\n-                    Map<String, String> retMap = new ComponentService(msgDTO).getMessages(null).getCachedData();\n-                    if (retMap != null) {\n-                        list.add(retMap);\n-                    }\n-                }\n-            }\n-        }\n-        return list;\n+    // get supported components defined in vip service\n+    public JSONArray getComponentsFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getComponentsFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of components of the product specified in the dto object\n-     */\n-    public List<String> getComponents(){\n-        List<String> components = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((components == null || components.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            components = opt.getComponents();\n-            // If failed to get components from the data source, log the error.\n-            if (components.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n-            }\n-        }\n-        return components;\n+    // get supported locales defined in vip service\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getSupportedLocalesFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of locales of the product specified in the dto object\n-     */\n-    public List<String> getSupportedLocales(){\n-        List<String> locales = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            locales = opt.getSupportedLocales();\n-            // If failed to get locales from the data source, log the error.\n-            if (locales.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));\n+    public List<Map> getAllComponentTranslation() {\n+        List<Map> list = new ArrayList<Map>();\n+        Object[] locales = {};\n+        Object[] components = {};\n+        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n+            locales = this.getSupportedLocalesFromRemoteVIP().toArray();\n+            components = this.getComponentsFromRemoteVIP()\n+                    .toArray();\n+        }\n+        for (Object locale : locales) {\n+            for (Object component : components) {\n+                dto.setComponent(((String) component).trim());\n+                dto.setLocale(LocaleUtility.fmtToMappedLocale((String) locale).toString().trim());\n+                Map<String, String> retMap = new ComponentService(dto).getMessages().getCachedData();\n+                if (retMap != null) {\n+                    list.add(retMap);\n+                }\n             }\n         }\n-        return locales;\n+        return list;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NjAxMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466776013", "bodyText": "FormatUtils.format is heavy and unnecessary.", "author": "Xiaochao8", "createdAt": "2020-08-07T01:48:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -84,23 +76,18 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n      * @return list of locales of the product specified in the dto object\n      */\n-    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext()) { return null; }\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> locales = opt.getSupportedLocales();\n-        // If failed to get components from the data source\n-        if (locales.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                locales = getSupportedLocales(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n+    public List<String> getSupportedLocales(){\n+        List<String> locales = null;\n+        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n+        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n+            DataSourceEnum dataSource = msgSourceQueueIter.next();\n+            ProductOpt opt = dataSource.createProductOpt(dto);\n+            locales = opt.getSupportedLocales();\n+            // If failed to get locales from the data source, log the error.\n+            if (locales.isEmpty()) {\n+                logger.error(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\nindex 10f422087..452af45d0 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java\n\n@@ -4,92 +4,63 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.json.simple.JSONArray;\n+\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n \n public class ProductService {\n-    private BaseDTO dto = null;\n-    Logger logger = LoggerFactory.getLogger(ProductService.class);\n+    private MessagesDTO dto = null;\n \n-    public ProductService(BaseDTO dto) {\n+    public ProductService(MessagesDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n-     *\n-     * @return translated messages of all components of a product locale specified in the dto object\n-     */\n-    public List<Map> getAllComponentTranslation() {\n-        List<Map> list = new ArrayList<Map>();\n-        List<String> locales = this.getSupportedLocales();\n-        List<String> components = this.getComponents();\n-        if (locales != null && components != null) {\n-            for (String languageTag : locales) {\n-                for (Object component : components) {\n-                    MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n-                            dto.getProductID(), dto.getVersion());\n-                    Map<String, String> retMap = new ComponentService(msgDTO).getMessages(null).getCachedData();\n-                    if (retMap != null) {\n-                        list.add(retMap);\n-                    }\n-                }\n-            }\n-        }\n-        return list;\n+    // get supported components defined in vip service\n+    public JSONArray getComponentsFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getComponentsFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of components of the product specified in the dto object\n-     */\n-    public List<String> getComponents(){\n-        List<String> components = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((components == null || components.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            components = opt.getComponents();\n-            // If failed to get components from the data source, log the error.\n-            if (components.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n-            }\n-        }\n-        return components;\n+    // get supported locales defined in vip service\n+    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+        BaseDTO baseDTO = new BaseDTO();\n+        baseDTO.setProductID(dto.getProductID());\n+        baseDTO.setVersion(dto.getVersion());\n+        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n+        return dao.getSupportedLocalesFromRemoteVIP();\n     }\n \n-    /**\n-     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n-     *\n-     * @return list of locales of the product specified in the dto object\n-     */\n-    public List<String> getSupportedLocales(){\n-        List<String> locales = null;\n-        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            locales = opt.getSupportedLocales();\n-            // If failed to get locales from the data source, log the error.\n-            if (locales.isEmpty()) {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));\n+    public List<Map> getAllComponentTranslation() {\n+        List<Map> list = new ArrayList<Map>();\n+        Object[] locales = {};\n+        Object[] components = {};\n+        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n+            locales = this.getSupportedLocalesFromRemoteVIP().toArray();\n+            components = this.getComponentsFromRemoteVIP()\n+                    .toArray();\n+        }\n+        for (Object locale : locales) {\n+            for (Object component : components) {\n+                dto.setComponent(((String) component).trim());\n+                dto.setLocale(LocaleUtility.fmtToMappedLocale((String) locale).toString().trim());\n+                Map<String, String> retMap = new ComponentService(dto).getMessages().getCachedData();\n+                if (retMap != null) {\n+                    list.add(retMap);\n+                }\n             }\n         }\n-        return locales;\n+        return list;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNTMyNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r467535327", "bodyText": "This logic is scattered across multiple files. It's redundant and error-prone. It's better to merge this kind of logic into one.", "author": "Xiaochao8", "createdAt": "2020-08-09T04:39:55Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,146 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n+    public LocaleService() {\n     }\n+\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n+        while (fallbackLocalesIter.hasNext()) {", "originalCommit": "fe81284c2dea1187a885e048eb8579f253958bac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\nindex 358271b9c..254fd9d21 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java\n\n@@ -4,146 +4,92 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.util.HashMap;\n-import java.util.Iterator;\n+import java.util.List;\n import java.util.ListIterator;\n-import java.util.Locale;\n import java.util.Map;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+\n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private LocaleDTO dto = null;\n+    private static final String REGION_PREFIX = \"region_\";\n+    public static final String DISPN_PREFIX  = \"dispn_\";\n \n     public LocaleService() {\n     }\n \n-    public LocaleService(LocaleDTO dto) {\n-        this.dto = dto;\n-    }\n-\n-    public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n-        }\n-        Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n-        while (fallbackLocalesIter.hasNext()) {\n-            String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n-            if(fallbackLocale.equalsIgnoreCase(locale))\n-                continue;\n-            logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                break;\n+    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n+            List<String> languages) {\n+        \n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String language : languages) {\n+            language = language.toLowerCase();\n+            Map<String, String> regionMap = null;\n+            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                        + language);    \n+                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n             }\n-        }\n-        return regionMap;\n-    }\n-\n-    public Map<String, String> getRegionsByLocale(String locale){\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n-        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n-            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n-        }\n-        return regionMap;\n-    }\n-\n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n-        }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n-        }\n-        return regions;\n-    }\n-\n-    public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n-        }\n-        Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n-        while (fallbackLocalesIter.hasNext()) {\n-            String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n-            if(fallbackLocale.equalsIgnoreCase(locale))\n+            if (regionMap != null) {\n+                respMap.put(language, regionMap);\n                 continue;\n-            logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n-                break;\n+            }\n+            logger.trace(\"get region list of '\" + language\n+                    + \"' data from backend\");\n+            Map<String, String> tmpMap = new RemoteLocaleOpt()\n+\t\t\t\t        .getTerritoriesFromCLDR(language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            respMap.put(language, regionMap);\n+            if (c != null) {\n+            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n-        return dispMap;\n-    }\n-\n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n-            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n+        return respMap;\n     }\n \n-\n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL);\n-            return dispMap;\n+    public Map<String, String> getDisplayNamesFromCLDR(String language, \n+    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n+    \tif (!msgSourceQueueIter.hasNext()) \n+    \t\treturn dispMap;\n+        \n+        logger.trace(\"look for displayNames from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n+        \tif (cacheItem == null) {\n+        \t\tcacheItem = new FormatCacheItem();\n+        \t}\n+            dispMap = cacheItem.getCachedData();\n+            if (dispMap.isEmpty()) {\n+            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n+                dispMap = JSONUtils.map2SortMap(tmpMap);\n+                if (dispMap != null && dispMap.size() > 0) {\n+                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n+                }\n+            }\n         }\n-        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        \n         if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString());\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n         }\n         return dispMap;\n     }\n+\n }\n"}}, {"oid": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "url": "https://github.com/vmware/singleton/commit/4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "message": "add L2 pattern files and make some change to support loading them correctly", "committedDate": "2020-08-18T13:49:59Z", "type": "commit"}, {"oid": "d6b11b3add639da4e746fa8aab2e215e12bbb9e8", "url": "https://github.com/vmware/singleton/commit/d6b11b3add639da4e746fa8aab2e215e12bbb9e8", "message": "On offline mode read pattern data from separate jar", "committedDate": "2020-08-18T13:55:34Z", "type": "commit"}, {"oid": "f82003b26bbb7739f9d354f3a2b8bd1ce0db5542", "url": "https://github.com/vmware/singleton/commit/f82003b26bbb7739f9d354f3a2b8bd1ce0db5542", "message": "Optimize get pattern code & add unit tests for offline mode", "committedDate": "2020-08-18T13:58:08Z", "type": "commit"}, {"oid": "d5790aec436d38628b0d086ef92979d76561a24e", "url": "https://github.com/vmware/singleton/commit/d5790aec436d38628b0d086ef92979d76561a24e", "message": "Enable offline mode support for getSupportedLanguages and getRegionList API", "committedDate": "2020-08-18T13:59:09Z", "type": "commit"}, {"oid": "231bd39c4326128f71deda96d99aff5dbbc2f708", "url": "https://github.com/vmware/singleton/commit/231bd39c4326128f71deda96d99aff5dbbc2f708", "message": "Adjust L2 API according to new workflow", "committedDate": "2020-08-18T14:01:11Z", "type": "commit"}, {"oid": "671b3fceff372567e10cb93b88f5f47d6a6bf953", "url": "https://github.com/vmware/singleton/commit/671b3fceff372567e10cb93b88f5f47d6a6bf953", "message": "fix review comments: mainly move fallback logic to outer layer and other minor comments", "committedDate": "2020-08-18T14:01:40Z", "type": "commit"}, {"oid": "b59a7cdcfc78a84c5823bbd141b5ce20eca1c795", "url": "https://github.com/vmware/singleton/commit/b59a7cdcfc78a84c5823bbd141b5ce20eca1c795", "message": "Change supportedLanguage API to support multiple configurations", "committedDate": "2020-08-18T14:03:10Z", "type": "commit"}, {"oid": "cd5289331ed321a95336669f593f7f8c9bd7a0de", "url": "https://github.com/vmware/singleton/commit/cd5289331ed321a95336669f593f7f8c9bd7a0de", "message": "fix CI reported issue: add license and copyright header for new added files", "committedDate": "2020-08-18T14:05:19Z", "type": "commit"}, {"oid": "8896f73098e8569649033d9095c7e0054a3fe1f7", "url": "https://github.com/vmware/singleton/commit/8896f73098e8569649033d9095c7e0054a3fe1f7", "message": "fix review comments: move fallback logic to service layer", "committedDate": "2020-08-18T14:05:45Z", "type": "commit"}, {"oid": "e47bb729b3571dc516310a71dcd4ab702c9300e5", "url": "https://github.com/vmware/singleton/commit/e47bb729b3571dc516310a71dcd4ab702c9300e5", "message": "fix review comment: use LocaleDTO instead of BaseDTO as data transfer object for parameter scalability", "committedDate": "2020-08-18T14:06:22Z", "type": "commit"}, {"oid": "b19fc1f37d93876786f30b64927983aaeb0d59bf", "url": "https://github.com/vmware/singleton/commit/b19fc1f37d93876786f30b64927983aaeb0d59bf", "message": "fix some minor review comments", "committedDate": "2020-08-18T14:06:41Z", "type": "commit"}, {"oid": "9246c42b1d99ae1c44651be6084f38619328d4ad", "url": "https://github.com/vmware/singleton/commit/9246c42b1d99ae1c44651be6084f38619328d4ad", "message": "fix NullPointerException in DateFormatting when default locale's pattern is not available", "committedDate": "2020-08-18T14:08:10Z", "type": "commit"}, {"oid": "1737b297212b80a5d0440dd03c441e1f7dda7183", "url": "https://github.com/vmware/singleton/commit/1737b297212b80a5d0440dd03c441e1f7dda7183", "message": "fix unit tests failure problems reported in CI", "committedDate": "2020-08-18T14:08:45Z", "type": "commit"}, {"oid": "966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "url": "https://github.com/vmware/singleton/commit/966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "message": "fix CI failure problem: add license header for sample-client-app/build.gradle", "committedDate": "2020-08-19T06:34:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3MDQyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473170422", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void getComponents(Path path, List<String> components) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> p.toFile().isDirectory())) {\n          \n          \n            \n                        listOfFiles.map(file -> {\n          \n          \n            \n                            return file.getFileName().toString();\n          \n          \n            \n                        }).forEach(component -> {\n          \n          \n            \n                            if(component != null && !component.isEmpty()) {\n          \n          \n            \n                                components.add(component);\n          \n          \n            \n                            }\n          \n          \n            \n                        });\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            }\n          \n          \n            \n                private void getComponents(Path path, List<String> components) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.list(path).filter(p -> !Files.isRegularFile(p))) {\n          \n          \n            \n                        listOfFiles.forEach(s -> components.add(s.getFileName().toString()));\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-19T16:38:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.local;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class LocalProductOpt implements ProductOpt {\n+    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private static final String BUNDLE_PREFIX = \"messages_\";\n+    private static final String BUNDLE_SUFFIX = \".json\";\n+\n+    private BaseDTO dto = null;\n+\n+    public LocalProductOpt(BaseDTO dto) {\n+        this.dto = dto;\n+    }\n+\n+    public List<String> getSupportedLocales() {\n+        List<String> supportedLocales = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getSupportedLocales(path, supportedLocales);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getSupportedLocales(path, supportedLocales);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return supportedLocales;\n+    }\n+\n+    public List<String> getComponents() {\n+        List<String> components = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getComponents(path, components);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getComponents(path, components);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return components;\n+    }\n+\n+    private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+            listOfFiles.map(file -> {\n+                String fileName = file.getFileName().toString();\n+                if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+                    return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+                }\n+                return \"\";\n+            }).forEach(language -> {\n+                if(language != null && !language.isEmpty()) {\n+                    supportedLocales.add(language);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void getComponents(Path path, List<String> components) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> p.toFile().isDirectory())) {\n+            listOfFiles.map(file -> {\n+                return file.getFileName().toString();\n+            }).forEach(component -> {\n+                if(component != null && !component.isEmpty()) {\n+                    components.add(component);\n+                }\n+            });\n+        }\n+    }\n+}", "originalCommit": "966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b7d7ab9d9cc4fdf4fbdba0051adee87c837af2f", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\nindex 6c89ae1f7..a84d61f68 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\n\n@@ -23,7 +23,7 @@ import java.util.List;\n import java.util.stream.Stream;\n \n public class LocalProductOpt implements ProductOpt {\n-    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n     private static final String BUNDLE_SUFFIX = \".json\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3NTY0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473175647", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n          \n          \n            \n                        listOfFiles.map(file -> {\n          \n          \n            \n                            String fileName = file.getFileName().toString();\n          \n          \n            \n                            if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n          \n          \n            \n                                return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n          \n          \n            \n                            }\n          \n          \n            \n                            return \"\";\n          \n          \n            \n                        }).forEach(language -> {\n          \n          \n            \n                            if(language != null && !language.isEmpty()) {\n          \n          \n            \n                                supportedLocales.add(language);\n          \n          \n            \n                            }\n          \n          \n            \n                        });\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p) && p.getFileName().toString().startsWith(BUNDLE_PREFIX) && p.getFileName().toString().endsWith(BUNDLE_SUFFIX))) {\n          \n          \n            \n                        listOfFiles.map(file -> {\n          \n          \n            \n                            return file.getFileName().toString().substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n          \n          \n            \n                        }).forEach(language -> {\n          \n          \n            \n                            supportedLocales.add(language);\n          \n          \n            \n                        });\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-19T16:47:20Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.local;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class LocalProductOpt implements ProductOpt {\n+    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private static final String BUNDLE_PREFIX = \"messages_\";\n+    private static final String BUNDLE_SUFFIX = \".json\";\n+\n+    private BaseDTO dto = null;\n+\n+    public LocalProductOpt(BaseDTO dto) {\n+        this.dto = dto;\n+    }\n+\n+    public List<String> getSupportedLocales() {\n+        List<String> supportedLocales = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getSupportedLocales(path, supportedLocales);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getSupportedLocales(path, supportedLocales);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return supportedLocales;\n+    }\n+\n+    public List<String> getComponents() {\n+        List<String> components = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getComponents(path, components);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getComponents(path, components);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return components;\n+    }\n+\n+    private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+            listOfFiles.map(file -> {\n+                String fileName = file.getFileName().toString();\n+                if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+                    return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+                }\n+                return \"\";\n+            }).forEach(language -> {\n+                if(language != null && !language.isEmpty()) {\n+                    supportedLocales.add(language);\n+                }\n+            });\n+        }\n+    }", "originalCommit": "966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU3OTE4Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473579182", "bodyText": "These two conditions are for filtering file name, not for filter path,\nfileName.getFileName().startsWith(BUNDLE_PREFIX) && fileName.getFileName().endsWith(BUNDLE_SUFFIX)\nor locale list will be empty because no path meet these conditions.", "author": "huihuiw01", "createdAt": "2020-08-20T04:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3NTY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1NjAzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r474156036", "bodyText": "I made a mistake of not adding .toString() to p.getFileName(). I have updated the code suggestion.\nFiles.walk will iterate over ALL paths -- all folders AND files inside the root path and  the root path itself. So yes, it will apply to files as well.  The .filter part will check if each item is a file (not a folder) that starts with BUNDLE_PREFIX and ends with BUNDLE_SUFFIX. If one of these conditions fail, the item will not be included in listOfFiles. This way, you do not need the if statement.\nYou also do not need to return an empty String so that you can remove if(language != null && !language.isEmpty())\nTest the code suggestion above and see if it works. I have tested it and seems to be no problem.", "author": "jessiejuachon", "createdAt": "2020-08-20T17:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3NTY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3b7d7ab9d9cc4fdf4fbdba0051adee87c837af2f", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\nindex 6c89ae1f7..a84d61f68 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\n\n@@ -23,7 +23,7 @@ import java.util.List;\n import java.util.stream.Stream;\n \n public class LocalProductOpt implements ProductOpt {\n-    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n     private static final String BUNDLE_SUFFIX = \".json\";\n \n"}}, {"oid": "3b7d7ab9d9cc4fdf4fbdba0051adee87c837af2f", "url": "https://github.com/vmware/singleton/commit/3b7d7ab9d9cc4fdf4fbdba0051adee87c837af2f", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_addPatternFiles", "committedDate": "2020-08-19T17:13:50Z", "type": "commit"}, {"oid": "98ae1b411ebd4b2abe1c9bd5295a80b2dcf7c77b", "url": "https://github.com/vmware/singleton/commit/98ae1b411ebd4b2abe1c9bd5295a80b2dcf7c77b", "message": "Comment out the failed unit test", "committedDate": "2020-08-19T17:16:17Z", "type": "commit"}, {"oid": "c93e4a5953d5ab216bb2cca73ffad6cadac56d56", "url": "https://github.com/vmware/singleton/commit/c93e4a5953d5ab216bb2cca73ffad6cadac56d56", "message": "fix bugs reported in CI code scan", "committedDate": "2020-08-19T17:17:28Z", "type": "commit"}, {"oid": "1a3a60154b4acbd1da1ed0fafa4b76491a4f6671", "url": "https://github.com/vmware/singleton/commit/1a3a60154b4acbd1da1ed0fafa4b76491a4f6671", "message": "fix unit test failures", "committedDate": "2020-08-19T17:18:30Z", "type": "commit"}, {"oid": "aa05d390658d0a34dd9f40cc4d16e2e1ee8a3270", "url": "https://github.com/vmware/singleton/commit/aa05d390658d0a34dd9f40cc4d16e2e1ee8a3270", "message": "resolve the failed unit test which is commented out earlier", "committedDate": "2020-08-19T17:20:16Z", "type": "commit"}, {"oid": "a99124825d99b1d0106e00baddc768ac63784f54", "url": "https://github.com/vmware/singleton/commit/a99124825d99b1d0106e00baddc768ac63784f54", "message": "fix NullPointerException in NumberFormatService when no pattern data found", "committedDate": "2020-08-19T17:21:40Z", "type": "commit"}, {"oid": "c6e55dadaf7646faf5a16245b0a53680af16ec6d", "url": "https://github.com/vmware/singleton/commit/c6e55dadaf7646faf5a16245b0a53680af16ec6d", "message": "fix review comment: add failed log", "committedDate": "2020-08-19T17:23:09Z", "type": "commit"}, {"oid": "62c4d18380fa82f27e134fe9e4ce3229b3b382ad", "url": "https://github.com/vmware/singleton/commit/62c4d18380fa82f27e134fe9e4ce3229b3b382ad", "message": "fix review comments", "committedDate": "2020-08-19T17:23:54Z", "type": "commit"}, {"oid": "5b94af00b5bb68c2dec3ea766faf3c754473b182", "url": "https://github.com/vmware/singleton/commit/5b94af00b5bb68c2dec3ea766faf3c754473b182", "message": "fix some minor review comments", "committedDate": "2020-08-19T17:27:18Z", "type": "commit"}, {"oid": "e2348d4319ce569fffd95f51cf0f837bd7bbcdd6", "url": "https://github.com/vmware/singleton/commit/e2348d4319ce569fffd95f51cf0f837bd7bbcdd6", "message": "fix review comment: use fallback iterator instead of default locale when do fallback", "committedDate": "2020-08-19T17:28:10Z", "type": "commit"}, {"oid": "cac8e89f782d2c9655aaf97a08c7678fe73a2cca", "url": "https://github.com/vmware/singleton/commit/cac8e89f782d2c9655aaf97a08c7678fe73a2cca", "message": "Correct one error message", "committedDate": "2020-08-19T17:29:04Z", "type": "commit"}, {"oid": "2a0fb4bf89cff86f7da727d8fe95029b3edac3c9", "url": "https://github.com/vmware/singleton/commit/2a0fb4bf89cff86f7da727d8fe95029b3edac3c9", "message": "resolve problem which leads to sample-app smoke test failure", "committedDate": "2020-08-19T17:30:04Z", "type": "commit"}, {"oid": "b24297d64dc07954534384fc70bb4e400cccc86c", "url": "https://github.com/vmware/singleton/commit/b24297d64dc07954534384fc70bb4e400cccc86c", "message": "fetch pattern jar package from mavenCentral", "committedDate": "2020-08-19T17:33:39Z", "type": "commit"}, {"oid": "2f2c76ef824d424ef3888589166265937643edc2", "url": "https://github.com/vmware/singleton/commit/2f2c76ef824d424ef3888589166265937643edc2", "message": "fix CI failure problem: add license header for sample-client-app/build.gradle", "committedDate": "2020-08-19T17:34:11Z", "type": "commit"}, {"oid": "2f2c76ef824d424ef3888589166265937643edc2", "url": "https://github.com/vmware/singleton/commit/2f2c76ef824d424ef3888589166265937643edc2", "message": "fix CI failure problem: add license header for sample-client-app/build.gradle", "committedDate": "2020-08-19T17:34:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ4MDgzNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473480835", "bodyText": "There are 2 GET_LOCALES_FAILED. This must have caused a compile error, right?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";", "author": "jessiejuachon", "createdAt": "2020-08-20T00:41:54Z", "path": "src/main/java/com/vmware/vipclient/i18n/common/ConstantsMsg.java", "diffHunk": "@@ -17,5 +17,9 @@\n     public static final String GET_MESSAGE_FAILED   = \"Failed to get any message for key: {0} of component {1}, requested locale: {2}\";\r\n     public static final String GET_LANGUAGES_FAILED   = \"Failed to get supported languages from {0} data source\";\r\n     public static final String GET_LANGUAGES_FAILED_ALL   = \"Failed to get supported languages from any data source\";\r\n+    public static final String GET_REGIONS_FAILED   = \"Failed to get regions from {0} data source\";\r\n+    public static final String GET_REGIONS_FAILED_ALL   = \"Failed to get regions from any data source\";\r\n+    public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";\r\n     public static final String GET_COMPONENTS_FAILED   = \"Failed to get list of components from {0} data source\";\r\n+    public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";\r", "originalCommit": "2f2c76ef824d424ef3888589166265937643edc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae7c31aae3f5a7a42caad5bff413edf1499d57a5", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/common/ConstantsMsg.java b/src/main/java/com/vmware/vipclient/i18n/common/ConstantsMsg.java\nindex 91e3906ef..f77a80a5a 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/common/ConstantsMsg.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/common/ConstantsMsg.java\n\n@@ -21,5 +21,4 @@ public class ConstantsMsg {\n     public static final String GET_REGIONS_FAILED_ALL   = \"Failed to get regions from any data source\";\n     public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";\n     public static final String GET_COMPONENTS_FAILED   = \"Failed to get list of components from {0} data source\";\n-    public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwOTMxNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473509315", "bodyText": "Can this be removed since it is commented out?", "author": "jessiejuachon", "createdAt": "2020-08-20T01:26:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -4,65 +4,122 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.stream.Stream;\n-\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-   \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate static final String BUNDLE_SUFFIX = \".json\";\n+\n+\tprivate LocaleDTO dto = null;\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n+\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n+\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n-    }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n-        }\n+\t\treturn supportedLanguageNames;\n     }\n \n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/", "originalCommit": "2f2c76ef824d424ef3888589166265937643edc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e9d8ea1dc9790b297339f0a2c25824b5e38287e", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\nindex fca439642..087f27f83 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java\n\n@@ -53,23 +53,6 @@ public class LocalLocaleOpt implements LocaleOpt{\n \t\treturn supportedLanguageNames;\n     }\n \n-\t/*private Map<String, String> getLanguagesNames(String locale){\n-\t\tMap<String, String> languagesNames = null;\n-\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n-\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n-\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n-\t\t\tif (languagesNames != null) {\n-\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n-\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n-\t\t\t}\n-\t\t}\n-\t\treturn languagesNames;\n-\t}*/\n-\n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n \t\tMap<String, String> languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n"}}, {"oid": "ae7c31aae3f5a7a42caad5bff413edf1499d57a5", "url": "https://github.com/vmware/singleton/commit/ae7c31aae3f5a7a42caad5bff413edf1499d57a5", "message": "Fixing failing CI", "committedDate": "2020-08-20T01:32:24Z", "type": "commit"}, {"oid": "6e9d8ea1dc9790b297339f0a2c25824b5e38287e", "url": "https://github.com/vmware/singleton/commit/6e9d8ea1dc9790b297339f0a2c25824b5e38287e", "message": "fix review comments", "committedDate": "2020-08-20T04:07:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5MzEwMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r471893103", "bodyText": "Use arguments instead of a concatenation.", "author": "Xiaochao8", "createdAt": "2020-08-18T03:31:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -78,6 +78,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n     private List<Locale> getSupportedLocales() {\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n     \t\t\t.getSupportedLocales();\n+        logger.debug(\"supported languages: \"+supportedLanguages.toString());", "originalCommit": "f114f0f559367dd7cc4ee9ca3150dd689f767dee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java\nindex c81fcd356..bbf76ba5d 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java\n\n@@ -76,11 +79,10 @@ public class LocalMessagesOpt implements Opt, MessageOpt {\n     }\n     \n     private List<Locale> getSupportedLocales() {\n-\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n-    \t\t\t.getSupportedLocales();\n-        logger.debug(\"supported languages: \"+supportedLanguages.toString());\n+    \tMap<String, String> supportedLanguages = DataSourceEnum.Bundle.createLocaleOpt()\n+    \t\t\t.getLanguages(dto.getLocale());\n     \tList<Locale> supportedLocales = new LinkedList<Locale>();\n-    \tfor (String languageTag : supportedLanguages) {\n+    \tfor (String languageTag : supportedLanguages.keySet()) {\n     \t\tsupportedLocales.add(Locale.forLanguageTag(languageTag));\n     \t}\n     \treturn supportedLocales;\n"}}, {"oid": "9a91587ec36dc64cb607d2a1aff0e6a6c6ab66f1", "url": "https://github.com/vmware/singleton/commit/9a91587ec36dc64cb607d2a1aff0e6a6c6ab66f1", "message": "fix review comment: optimize one log", "committedDate": "2020-08-20T08:06:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1Njc4Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r474156787", "bodyText": "Use Files.list here because Files.walk iterates recursively which we do not need here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> !Files.isRegularFile(p))) {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.list(path).filter(p -> !Files.isRegularFile(p))) {", "author": "jessiejuachon", "createdAt": "2020-08-20T17:31:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.local;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class LocalProductOpt implements ProductOpt {\n+    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private static final String BUNDLE_PREFIX = \"messages_\";\n+    private static final String BUNDLE_SUFFIX = \".json\";\n+\n+    private BaseDTO dto = null;\n+\n+    public LocalProductOpt(BaseDTO dto) {\n+        this.dto = dto;\n+    }\n+\n+    public List<String> getSupportedLocales() {\n+        List<String> supportedLocales = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getSupportedLocales(path, supportedLocales);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getSupportedLocales(path, supportedLocales);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return supportedLocales;\n+    }\n+\n+    public List<String> getComponents() {\n+        List<String> components = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getComponents(path, components);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getComponents(path, components);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return components;\n+    }\n+\n+    private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+            listOfFiles.map(file -> {\n+                String fileName = file.getFileName().toString();\n+                if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+                    return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+                }\n+                return \"\";\n+            }).forEach(language -> {\n+                if(language != null && !language.isEmpty()) {\n+                    supportedLocales.add(language);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void getComponents(Path path, List<String> components) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> !Files.isRegularFile(p))) {", "originalCommit": "9a91587ec36dc64cb607d2a1aff0e6a6c6ab66f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e4b755a1287b032521b8217613c348e74a8e902", "chunk": "diff --git a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\nindex 99aea53d2..bd698bd90 100644\n--- a/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\n+++ b/src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java\n\n@@ -100,7 +100,7 @@ public class LocalProductOpt implements ProductOpt {\n     }\n \n     private void getComponents(Path path, List<String> components) throws IOException {\n-        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> !Files.isRegularFile(p))) {\n+        try (Stream<Path> listOfFiles = Files.list(path).filter(p -> !Files.isRegularFile(p))) {\n             listOfFiles.forEach(s -> {\n                     components.add(s.getFileName().toString());\n             });\n"}}, {"oid": "9e4b755a1287b032521b8217613c348e74a8e902", "url": "https://github.com/vmware/singleton/commit/9e4b755a1287b032521b8217613c348e74a8e902", "message": "Use Files.list which is non-recursive when getting offline component list", "committedDate": "2020-08-20T17:52:42Z", "type": "commit"}, {"oid": "fa86a44140e1c1ba395f449ad7abac3af7f8f1c4", "url": "https://github.com/vmware/singleton/commit/fa86a44140e1c1ba395f449ad7abac3af7f8f1c4", "message": "fix review comment: optimize code for getting supported locales", "committedDate": "2020-08-21T01:26:45Z", "type": "commit"}, {"oid": "c95636a9bad9af9fb5eea483d4e92dc133e58dbd", "url": "https://github.com/vmware/singleton/commit/c95636a9bad9af9fb5eea483d4e92dc133e58dbd", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_addPatternFiles", "committedDate": "2020-08-21T01:35:17Z", "type": "commit"}]}