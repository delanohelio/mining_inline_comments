{"pr_number": 2700, "pr_title": "Layers creator classes", "pr_createdAt": "2020-08-13T21:25:20Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2700", "timeline": [{"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "url": "https://github.com/GoogleContainerTools/jib/commit/5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "message": "Layers creator classes\n\nThere are still some quirks to layer creation that we will have\nto work out\n- includes on file patterns can end up \"excluding\" directories\n  which will have to be readded, or we can ignore includes\n  directives on directories and end up with empty directories\n  everywhere\n- directories between a target and root will be configured to\n  have the default properties of ReproducibleLayerBuilder rather\n  that what is configured by the user. This can be dealt with\n  by populating directories from root.", "committedDate": "2020-08-14T17:24:32Z", "type": "commit"}, {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "url": "https://github.com/GoogleContainerTools/jib/commit/5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "message": "Layers creator classes\n\nThere are still some quirks to layer creation that we will have\nto work out\n- includes on file patterns can end up \"excluding\" directories\n  which will have to be readded, or we can ignore includes\n  directives on directories and end up with empty directories\n  everywhere\n- directories between a target and root will be configured to\n  have the default properties of ReproducibleLayerBuilder rather\n  that what is configured by the user. This can be dealt with\n  by populating directories from root.", "committedDate": "2020-08-14T17:24:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyMDM5MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471520391", "bodyText": "are we missing a word here?", "author": "mpeddada1", "createdAt": "2020-08-17T14:32:14Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNTcxNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472525716", "bodyText": "lol, yes oops", "author": "loosebazooka", "createdAt": "2020-08-18T22:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyMDM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyNzQ5NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471527494", "bodyText": "would it be possible to put this if-else logic in a separate method? Might help reduce nesting", "author": "mpeddada1", "createdAt": "2020-08-17T14:42:46Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNTY1Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472525656", "bodyText": "I cleaned it up a little.", "author": "loosebazooka", "createdAt": "2020-08-18T22:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyNzQ5NA=="}], "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MDI1MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471560251", "bodyText": "could you elaborate more on this or provide an example?", "author": "mpeddada1", "createdAt": "2020-08-17T15:31:33Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNzQ5NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472527495", "bodyText": "hrmm.. yeah lemme go update this comment", "author": "loosebazooka", "createdAt": "2020-08-18T22:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MDI1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU5NjcyMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471596721", "bodyText": "Nit: I think this casting (Predicate<Path>) is unnecessary (unless for documentation purposes).\nI see excludes always takes precedence. Just my personal preference in style, but how about this?\n                  .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n                  .filter(\n                      path ->\n                          // if there are no includes directives, include everything\n                          includes.isEmpty()\n                              // TODO: for directories that fail to match the \"include\" directive on\n                              // TODO: files, populate the directories somehow or just never apply\n                              // TODO: includes to directories\n                              // if there are includes directives, only include those specified\n                              || includes.stream().anyMatch(include -> include.matches(path)))", "author": "chanseokoh", "createdAt": "2020-08-17T16:29:08Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0Njk3NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471646975", "bodyText": "Just do dest = dest.resolve(src.getFileName()) and use dest below?", "author": "chanseokoh", "createdAt": "2020-08-17T17:28:34Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNDYwMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472514601", "bodyText": "I would like to limit how much I change dest, rather not it be a changed var. (I should use final, but not google style)", "author": "loosebazooka", "createdAt": "2020-08-18T21:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0Njk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNDQ0Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472524447", "bodyText": "I think I'll just use a ?: for this?", "author": "loosebazooka", "createdAt": "2020-08-18T22:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0Njk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NDY1Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471654657", "bodyText": "! ... isEmpty()?", "author": "chanseokoh", "createdAt": "2020-08-17T17:41:42Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NjI5MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471656290", "bodyText": "Maybe this part can be factored out as toPathMatchers(List<String> globPatterns) (or globPatternsToPathMatchers()) and reused?", "author": "chanseokoh", "createdAt": "2020-08-17T17:44:57Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNTQ0Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472515446", "bodyText": "yeah, also wondering if there's a way to combine path matchers like spring has for https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/PathMatcher.html#combine-java.lang.String-java.lang.String-", "author": "loosebazooka", "createdAt": "2020-08-18T21:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NjI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODA4Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471658086", "bodyText": "Worth thinking about allowing to add an empty layer. But I think Jib will simply drop empty layers anyway, if I'm not mistaken.", "author": "chanseokoh", "createdAt": "2020-08-17T17:48:09Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })\n+                  .forEach(layerBuiler::addEntry);\n+            }\n+          } else { // other\n+            throw new UnsupportedOperationException(\n+                \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+          }\n+          copySpec.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        }\n+        fileLayer.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        layers.add(layerBuiler.build());", "originalCommit": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyOTU5Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472529593", "bodyText": "added todo, and bug in tracker bug", "author": "loosebazooka", "createdAt": "2020-08-18T22:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MTkwMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474151900", "bodyText": "Oh interesting, I didn't know empty layers were possible", "author": "mpeddada1", "createdAt": "2020-08-20T17:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "chunk": "diff --git a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\nindex b60777bd5..ca16a2fb4 100644\n--- a/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n+++ b/jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java\n\n@@ -20,7 +20,7 @@ import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n-import com.google.common.base.Predicate;\n+import com.google.common.annotations.VisibleForTesting;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n"}}, {"oid": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "url": "https://github.com/GoogleContainerTools/jib/commit/bb000213fac4bfef2adf1670ed2a78f681ed2d90", "message": "cleanup", "committedDate": "2020-08-18T22:29:01Z", "type": "commit"}, {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e", "url": "https://github.com/GoogleContainerTools/jib/commit/f8b873ac5896a801ce8e457fae7c88760e69c23e", "message": "formatting", "committedDate": "2020-08-18T22:33:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyNTY3Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474125672", "bodyText": "Does calling assertEquals not log the actual vs expected value? Maybe Assert.assertThat(ImmutableSet.copyOf(layer.getEntries)).containsExactly(expectedEntry1, expectedEntry2) could help.", "author": "mpeddada1", "createdAt": "2020-08-20T16:41:58Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {\n+    return Paths.get(Resources.getResource(LAYERS_TEST_RESOURCE_DIR + testName).toURI());\n+  }\n+\n+  @Test\n+  public void testToLayers_properties() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"propertiesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 4);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"level 0 passthrough\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"700\", 0, \"0:0\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"000\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"level 1 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 1000, \"1:1\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 1000, \"1:1\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"level 2 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"722\", 2000, \"2:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"222\", 2000, \"2:2\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"partial overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 2000, \"0:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 2000, \"0:2\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_includeExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"includesExcludesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 5);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"includes and excludes\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/ie/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"includes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/io/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"excludes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"excludes only shortcut\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(4),\n+        \"excludes only wrong\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(\n+                testRoot,\n+                \"project/excludedDir/exclude.me\",\n+                \"/target/eo/excludedDir/exclude.me\",\n+                \"644\",\n+                0,\n+                \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_file() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/default\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 1);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"default\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"toFile.txt\", \"/target/toFile.txt\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"toDir.txt\", \"/target/dir/toDir.txt\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithIncludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithIncludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithExcludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  private static FileEntry newEntry(\n+      Path testRoot,\n+      String src,\n+      String dest,\n+      String octalPermissions,\n+      int millis,\n+      String ownership) {\n+    return new FileEntry(\n+        testRoot.resolve(src),\n+        AbsoluteUnixPath.get(dest),\n+        FilePermissions.fromOctalString(octalPermissions),\n+        Instant.ofEpochMilli(millis),\n+        ownership);\n+  }\n+\n+  private static void checkLayer(\n+      FileEntriesLayer layer, String expectedName, Set<FileEntry> expectedLayerEntries) {\n+    Assert.assertEquals(expectedName, layer.getName());\n+\n+    try {\n+      Assert.assertEquals(expectedLayerEntries, ImmutableSet.copyOf(layer.getEntries()));\n+    } catch (AssertionError ae) {\n+      System.out.println(\"ACTUAL\");\n+      layer\n+          .getEntries()\n+          .forEach(\n+              entry -> {\n+                System.out.println(\"src: \" + entry.getSourceFile());\n+                System.out.println(\"dest: \" + entry.getExtractionPath());\n+                System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+                System.out.println(\"time: \" + entry.getModificationTime());\n+                System.out.println(\"ownership: \" + entry.getOwnership());\n+              });\n+      System.out.println(\"EXCPECTED\");\n+      expectedLayerEntries.forEach(\n+          entry -> {\n+            System.out.println(\"src: \" + entry.getSourceFile());\n+            System.out.println(\"dest: \" + entry.getExtractionPath());\n+            System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+            System.out.println(\"time: \" + entry.getModificationTime());\n+            System.out.println(\"ownership: \" + entry.getOwnership());\n+          });", "originalCommit": "f8b873ac5896a801ce8e457fae7c88760e69c23e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0MDAyMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474140023", "bodyText": "Yeah, that's a good point. Except that this object doest have a toString method. So instead it just prints something like FileEntry@577bcf5.\nWe could go add a toString method to it, but it's part of the build plan, and I'd rather not change it for a test at the moment. Although an argument can probably be made for doing it.", "author": "loosebazooka", "createdAt": "2020-08-20T17:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyNTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MTAzNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474151036", "bodyText": "Right. Yeah that's a valid point. It's worth adding (to avoid catching and throwing the same exception) but it can also be done in a different PR since this one is already pretty big:)", "author": "mpeddada1", "createdAt": "2020-08-20T17:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyNTY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2a7135e87529c7d682519d885b3cc052df7b5fda", "chunk": "diff --git a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\nindex bd25f15f6..c9baa70e8 100644\n--- a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n+++ b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n\n@@ -43,9 +43,9 @@ import org.junit.Test;\n /** Tests for {@link Layers}. */\n public class LayersTest {\n \n-  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+  private static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n \n-  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+  public static List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n       throws IOException {\n     Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n     List<LayerObject> layers =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474137443", "bodyText": "For my understanding, this method will be expanded to support other layers in addition to FileLayer in the future?", "author": "mpeddada1", "createdAt": "2020-08-20T16:56:50Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to convert between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {", "originalCommit": "f8b873ac5896a801ce8e457fae7c88760e69c23e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0MTEyMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474141121", "bodyText": "Correct, but I'm not sure what needs to be updated here?", "author": "loosebazooka", "createdAt": "2020-08-20T17:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwNjI5NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474206295", "bodyText": "Nice, might be worth adding a line to the PR summary or a TODO at beginning of the method that mentions that the change is for FileLayer.", "author": "mpeddada1", "createdAt": "2020-08-20T19:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2NzgwNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474367807", "bodyText": "Added to PR description", "author": "loosebazooka", "createdAt": "2020-08-21T02:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDY1OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150658", "bodyText": "private?", "author": "chanseokoh", "createdAt": "2020-08-20T17:21:13Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";", "originalCommit": "f8b873ac5896a801ce8e457fae7c88760e69c23e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a7135e87529c7d682519d885b3cc052df7b5fda", "chunk": "diff --git a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\nindex bd25f15f6..c9baa70e8 100644\n--- a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n+++ b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n\n@@ -43,9 +43,9 @@ import org.junit.Test;\n /** Tests for {@link Layers}. */\n public class LayersTest {\n \n-  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+  private static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n \n-  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+  public static List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n       throws IOException {\n     Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n     List<LayerObject> layers =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDczMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150730", "bodyText": "private static?", "author": "chanseokoh", "createdAt": "2020-08-20T17:21:21Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)", "originalCommit": "f8b873ac5896a801ce8e457fae7c88760e69c23e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a7135e87529c7d682519d885b3cc052df7b5fda", "chunk": "diff --git a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\nindex bd25f15f6..c9baa70e8 100644\n--- a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n+++ b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n\n@@ -43,9 +43,9 @@ import org.junit.Test;\n /** Tests for {@link Layers}. */\n public class LayersTest {\n \n-  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+  private static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n \n-  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+  public static List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n       throws IOException {\n     Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n     List<LayerObject> layers =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDc4Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150782", "bodyText": "static?", "author": "chanseokoh", "createdAt": "2020-08-20T17:21:26Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {", "originalCommit": "f8b873ac5896a801ce8e457fae7c88760e69c23e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a7135e87529c7d682519d885b3cc052df7b5fda", "chunk": "diff --git a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\nindex bd25f15f6..c9baa70e8 100644\n--- a/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n+++ b/jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java\n\n@@ -43,9 +43,9 @@ import org.junit.Test;\n /** Tests for {@link Layers}. */\n public class LayersTest {\n \n-  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+  private static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n \n-  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+  public static List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n       throws IOException {\n     Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n     List<LayerObject> layers =\n"}}, {"oid": "2a7135e87529c7d682519d885b3cc052df7b5fda", "url": "https://github.com/GoogleContainerTools/jib/commit/2a7135e87529c7d682519d885b3cc052df7b5fda", "message": "qualifiers in tests", "committedDate": "2020-08-21T02:08:18Z", "type": "commit"}]}