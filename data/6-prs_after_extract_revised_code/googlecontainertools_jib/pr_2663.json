{"pr_number": 2663, "pr_title": "Adding ability check the registry for manifests and push `builtImages` concurrently to the server", "pr_createdAt": "2020-08-05T20:21:14Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2663", "timeline": [{"oid": "5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "url": "https://github.com/GoogleContainerTools/jib/commit/5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "message": "Adding functionality to push up image manifests to the registry", "committedDate": "2020-08-06T17:10:26Z", "type": "commit"}, {"oid": "5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "url": "https://github.com/GoogleContainerTools/jib/commit/5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "message": "Adding functionality to push up image manifests to the registry", "committedDate": "2020-08-06T17:10:26Z", "type": "forcePushed"}, {"oid": "78cd01de020acbaa61bbbcd9f41760880fd5dc48", "url": "https://github.com/GoogleContainerTools/jib/commit/78cd01de020acbaa61bbbcd9f41760880fd5dc48", "message": "Style Fixes", "committedDate": "2020-08-06T19:38:14Z", "type": "commit"}, {"oid": "0bbc64253adf78befa8bb0cac7e5a97401c72c77", "url": "https://github.com/GoogleContainerTools/jib/commit/0bbc64253adf78befa8bb0cac7e5a97401c72c77", "message": "Removing commented out lines", "committedDate": "2020-08-06T19:41:02Z", "type": "commit"}, {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668", "url": "https://github.com/GoogleContainerTools/jib/commit/4fae9f105d0c4f4c3796607f047a06f54b546668", "message": "Fixing the Null Away Error", "committedDate": "2020-08-06T20:11:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466696191", "bodyText": "I don't think this is correct. As the original code, it should depend on baseImagesAndLayers. Depending on builtImages... means that this code will block until you complete building Images.", "author": "chanseokoh", "createdAt": "2020-08-06T21:28:26Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +333,22 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.builtImagesAndLayerPushResults =\n         executorService.submit(\n             () -> {\n-              List<List<Future<BlobDescriptor>>> pushResults = new ArrayList<>();\n-              for (List<Future<PreparedLayer>> baseImageLayers :\n-                  results.baseImagesAndLayers.get().values()) {\n+              Map<Future<Image>, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n+\n+              for (Map.Entry<Future<Image>, List<Future<PreparedLayer>>> entry :\n+                  results.builtImagesAndLayers.get().entrySet()) {", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4NDQ3OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467084478", "bodyText": "The logic here is to be able to keep track of builtimage -> baseImageLayerPushResults so that we can be able to use realizeFutures on the correct baseImageLayerPushResults in the pushImages step.\nThe reason why I am depending on builtImages here is because inorder to be able to match builtImage -> baseImageLayerPushResults you need to have the builtImage -> baseImageLayer mapping first which I create in the buildimage function.\nOn the brighter side ,all of these extra mapping can be avoided if we decided to for go realizeFutures(baseImageLayerPushResults) in the pushImage step", "author": "louismurerwa", "createdAt": "2020-08-07T14:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwMzYxNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467103614", "bodyText": "I can understand why it ended up like this, but I think this is not correct for a few reasons. I will just mention one reason that can alone make this not acceptable:\nresults.builtImagesAndLayers is the result coming from scheduling a thread in buildImages(). And calling results.builtImagesAndLayers.get() here means you will wait until the thread scheduled in buildImages() runs to completion. Conceptually, it means you'll wait until \"images\" are built. The code will now speak that \"in order to be able to push base image layers, I need to build images first.\" OTOH, previously, this pushBaseImageLayers() didn't have any dependency on buildImages(). Pushing base image layers can start as soon as we have base image layers. But with this change, you can start pushing only after the thread from buildImages() completed. This is a significant departure from the current async dependencies behaviors. Whenever we change the original intention, there should be a clear reason; just to allow making some other parts technically easy to make it work with minimal changes can't be a reason.", "author": "chanseokoh", "createdAt": "2020-08-07T15:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExMDY4OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467110689", "bodyText": "That makes sense - this implementation does slow down things.I'l revert this to the previous implementation and we can make changes starting from there.", "author": "louismurerwa", "createdAt": "2020-08-07T15:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -333,22 +331,20 @@ public class StepsRunner {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.builtImagesAndLayerPushResults =\n+    results.baseImageLayerPushResults =\n         executorService.submit(\n             () -> {\n-              Map<Future<Image>, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n-\n-              for (Map.Entry<Future<Image>, List<Future<PreparedLayer>>> entry :\n-                  results.builtImagesAndLayers.get().entrySet()) {\n-\n+              List<List<Future<BlobDescriptor>>> pushResults = new ArrayList<>();\n+              for (List<Future<PreparedLayer>> baseImageLayers :\n+                  results.baseImagesAndLayers.get().values()) {\n                 List<Future<BlobDescriptor>> baseImageLayerPushResult =\n                     scheduleCallables(\n                         PushLayerStep.makeList(\n                             buildContext,\n                             childProgressDispatcherFactory,\n                             results.targetRegistryClient.get(),\n-                            Verify.verifyNotNull(entry.getValue())));\n-                pushResults.put(entry.getKey(), baseImageLayerPushResult);\n+                            Verify.verifyNotNull(baseImageLayers)));\n+                pushResults.add(baseImageLayerPushResult);\n               }\n               return pushResults;\n             });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjQ1OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466696458", "bodyText": "builtImagesAndBaseImageLayerPushResults", "author": "chanseokoh", "createdAt": "2020-08-06T21:29:04Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +333,22 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.builtImagesAndLayerPushResults =", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -333,22 +331,20 @@ public class StepsRunner {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.builtImagesAndLayerPushResults =\n+    results.baseImageLayerPushResults =\n         executorService.submit(\n             () -> {\n-              Map<Future<Image>, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n-\n-              for (Map.Entry<Future<Image>, List<Future<PreparedLayer>>> entry :\n-                  results.builtImagesAndLayers.get().entrySet()) {\n-\n+              List<List<Future<BlobDescriptor>>> pushResults = new ArrayList<>();\n+              for (List<Future<PreparedLayer>> baseImageLayers :\n+                  results.baseImagesAndLayers.get().values()) {\n                 List<Future<BlobDescriptor>> baseImageLayerPushResult =\n                     scheduleCallables(\n                         PushLayerStep.makeList(\n                             buildContext,\n                             childProgressDispatcherFactory,\n                             results.targetRegistryClient.get(),\n-                            Verify.verifyNotNull(entry.getValue())));\n-                pushResults.put(entry.getKey(), baseImageLayerPushResult);\n+                            Verify.verifyNotNull(baseImageLayers)));\n+                pushResults.add(baseImageLayerPushResult);\n               }\n               return pushResults;\n             });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NzA0NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466697045", "bodyText": "Since we won't use builtImagesAndLayers in pushBaseImageLayers() (see my other comment), perhaps we don't need to change buildImages() code?", "author": "chanseokoh", "createdAt": "2020-08-06T21:30:27Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -379,9 +384,9 @@ private void buildImages() {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImages.add(builtImage);\n+                builtImagesAndLayers.put(builtImage, entry.getValue());", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -384,9 +379,9 @@ public class StepsRunner {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImagesAndLayers.put(builtImage, entry.getValue());\n+                builtImages.add(builtImage);\n               }\n-              return builtImagesAndLayers;\n+              return builtImages;\n             });\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODQ5NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466698494", "bodyText": "I think we should keep using builtImages. I think using builtImagesAndContainerConfigurationPushResults to get an Image causes confusion and feels like abusing.", "author": "chanseokoh", "createdAt": "2020-08-06T21:33:54Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -444,18 +439,9 @@ public class StepsRunner {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .values()\n-                                    .iterator()\n-                                    .next())\n+                                    .get(results.builtImages.get().get(0)))\n                             .get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .keySet()\n-                                    .iterator()\n-                                    .next())\n-                            .get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5OTQ1Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466699456", "bodyText": "Do we really need this change? I was aware that we can always use .iterator().next() to retrieve a value from a single-entry map, but you've been so far consistently calling Map.get(). Mixing patterns makes it harder to understand code.", "author": "chanseokoh", "createdAt": "2020-08-06T21:36:04Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -444,18 +439,9 @@ public class StepsRunner {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .values()\n-                                    .iterator()\n-                                    .next())\n+                                    .get(results.builtImages.get().get(0)))\n                             .get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .keySet()\n-                                    .iterator()\n-                                    .next())\n-                            .get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDY4Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466700682", "bodyText": "It takes some seconds to get what entry.getKey() means. I suggest declaring a local variable Future<Image> builtImage = entry.getKey() before this realizeFutures(). The same goes for entry.getValue().", "author": "chanseokoh", "createdAt": "2020-08-06T21:39:13Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5NTE5NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467095195", "bodyText": "@chanseokoh This is the line that has caused all the changes in the structure of the code .Do we really need to realizeFutures(baseImageLayerPushResults)  here ?\nIs there any way we could for-go realizing these futures here?\nOnce we have answered this question ,I can easily refactor the code.", "author": "louismurerwa", "createdAt": "2020-08-07T14:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExNDI4OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467114289", "bodyText": "Every line of code is there for a reason. We have realizeFutures() in the original code, so I assume there must be a reason. If you can't or don't know if what the existing code does or why it is there, you should assume it's necessary. Even when you think some code is unnecessary, you need to think through and really spend a lot of time before taking out some code.\nIn this case, I think it's definitely necessary. You can push a manifest only after you confirmed that you've done pushing layers. Otherwise, a registry will return \"bad manifest push; layers described in the manifest don't exist.\" And I can see the only place where we confirm the base image push results is here.", "author": "chanseokoh", "createdAt": "2020-08-07T15:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -444,18 +439,9 @@ public class StepsRunner {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .values()\n-                                    .iterator()\n-                                    .next())\n+                                    .get(results.builtImages.get().get(0)))\n                             .get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .keySet()\n-                                    .iterator()\n-                                    .next())\n-                            .get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMTA4OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466701089", "bodyText": "ditto about the .iterator().next() practice.", "author": "chanseokoh", "createdAt": "2020-08-06T21:40:07Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(entry.getValue()).get(),\n+                                      entry.getKey().get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(entry.getValue()).get().getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()\n+                                      .next()", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -444,18 +439,9 @@ public class StepsRunner {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .values()\n-                                    .iterator()\n-                                    .next())\n+                                    .get(results.builtImages.get().get(0)))\n                             .get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .keySet()\n-                                    .iterator()\n-                                    .next())\n-                            .get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMTEyOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466701128", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-08-06T21:40:12Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(entry.getValue()).get(),\n+                                      entry.getKey().get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(entry.getValue()).get().getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()\n+                                      .next()\n+                                      .get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new WriteTarFileStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  outputPath,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "55054594749e03da22349101ae6cc3bf8032941a", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 5078fa43..c2ced1ad 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -444,18 +439,9 @@ public class StepsRunner {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .values()\n-                                    .iterator()\n-                                    .next())\n+                                    .get(results.builtImages.get().get(0)))\n                             .get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .keySet()\n-                                    .iterator()\n-                                    .next())\n-                            .get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n"}}, {"oid": "55054594749e03da22349101ae6cc3bf8032941a", "url": "https://github.com/GoogleContainerTools/jib/commit/55054594749e03da22349101ae6cc3bf8032941a", "message": "Style Fixes", "committedDate": "2020-08-07T15:43:52Z", "type": "commit"}, {"oid": "ae90ce7407aecb5bcd45d88811a5461ec3afdbf8", "url": "https://github.com/GoogleContainerTools/jib/commit/ae90ce7407aecb5bcd45d88811a5461ec3afdbf8", "message": "Updating the code structure and adding functionality to match baseimage -> builtimage", "committedDate": "2020-08-07T19:23:29Z", "type": "commit"}, {"oid": "b88b7bc4f8c8d3105f924dd4a4bea41b5336caf1", "url": "https://github.com/GoogleContainerTools/jib/commit/b88b7bc4f8c8d3105f924dd4a4bea41b5336caf1", "message": "Style Fixes", "committedDate": "2020-08-07T19:56:42Z", "type": "commit"}, {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "url": "https://github.com/GoogleContainerTools/jib/commit/e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "message": "Style Fixes", "committedDate": "2020-08-07T20:02:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4MjMyMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467282320", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                results.baseImagesAndbaseImageLayerPushResults =\n          \n          \n            \n                results.baseImagesAndBaseImageLayerPushResults =\n          \n      \n    \n    \n  \n\nbut because this time it's all about base images, I think we can go with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                results.baseImagesAndbaseImageLayerPushResults =\n          \n          \n            \n                results.baseImagesAndLayerPushResults =", "author": "chanseokoh", "createdAt": "2020-08-07T21:32:44Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +332,23 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.baseImagesAndbaseImageLayerPushResults =", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex a427c130..27af8491 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -332,12 +332,13 @@ public class StepsRunner {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImagesAndbaseImageLayerPushResults =\n+    results.baseImagesAndLayerPushResults =\n         executorService.submit(\n             () -> {\n               Map<Image, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n               for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n                   results.baseImagesAndLayers.get().entrySet()) {\n+\n                 Image baseImage = entry.getKey();\n                 List<Future<PreparedLayer>> baseImageLayers = entry.getValue();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NTAyMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467285020", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            builtImagesAndBaseImages.put(builtImage, entry.getKey());\n          \n          \n            \n                            builtImagesAndBaseImages.put(builtImage, entry.getKey() /* base Image */);", "author": "chanseokoh", "createdAt": "2020-08-07T21:36:19Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -379,21 +383,21 @@ private void buildImages() {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImages.add(builtImage);\n+                builtImagesAndBaseImages.put(builtImage, entry.getKey());", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex a427c130..27af8491 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -383,7 +384,7 @@ public class StepsRunner {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImagesAndBaseImages.put(builtImage, entry.getKey());\n+                builtImagesAndBaseImages.put(builtImage, entry.getKey() /* base Image */);\n               }\n               return builtImagesAndBaseImages;\n             });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NzY3OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467287679", "bodyText": "You only need the key, so no need for entrySet(). And let's add a check; I'm certain the check will become useful going forward.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "author": "chanseokoh", "createdAt": "2020-08-07T21:39:54Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex a427c130..27af8491 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -435,9 +436,9 @@ public class StepsRunner {\n     results.manifestCheckResult =\n         executorService.submit(\n             () -> {\n-              Map.Entry<Future<Image>, Image> entry =\n-                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n-              Future<Image> builtImage = entry.getKey();\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n               return new CheckImageStep(\n                       buildContext,\n                       childProgressDispatcherFactory,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTU4NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467295585", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1, \"multi-platform image building not supported when pushing to Docker engine\");\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "author": "chanseokoh", "createdAt": "2020-08-07T21:50:09Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex a427c130..27af8491 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -435,9 +436,9 @@ public class StepsRunner {\n     results.manifestCheckResult =\n         executorService.submit(\n             () -> {\n-              Map.Entry<Future<Image>, Image> entry =\n-                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n-              Future<Image> builtImage = entry.getKey();\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n               return new CheckImageStep(\n                       buildContext,\n                       childProgressDispatcherFactory,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjU1NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467296554", "bodyText": "Can be simplified by return Collections.singletonList(executorService.submit(...)).", "author": "chanseokoh", "createdAt": "2020-08-07T21:51:23Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex a427c130..27af8491 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -435,9 +436,9 @@ public class StepsRunner {\n     results.manifestCheckResult =\n         executorService.submit(\n             () -> {\n-              Map.Entry<Future<Image>, Image> entry =\n-                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n-              Future<Image> builtImage = entry.getKey();\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n               return new CheckImageStep(\n                       buildContext,\n                       childProgressDispatcherFactory,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzQ1Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467297456", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Map.Entry<Future<Image>, Image> entry =\n          \n          \n            \n                              results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n          \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1, \"multi-platform image building not supported when building a local tar image\");\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "author": "chanseokoh", "createdAt": "2020-08-07T21:52:33Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex a427c130..27af8491 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -435,9 +436,9 @@ public class StepsRunner {\n     results.manifestCheckResult =\n         executorService.submit(\n             () -> {\n-              Map.Entry<Future<Image>, Image> entry =\n-                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n-              Future<Image> builtImage = entry.getKey();\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n               return new CheckImageStep(\n                       buildContext,\n                       childProgressDispatcherFactory,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODAyNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467298026", "bodyText": "Ditto. No need to create an array.", "author": "chanseokoh", "createdAt": "2020-08-07T21:53:17Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex a427c130..27af8491 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -435,9 +436,9 @@ public class StepsRunner {\n     results.manifestCheckResult =\n         executorService.submit(\n             () -> {\n-              Map.Entry<Future<Image>, Image> entry =\n-                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n-              Future<Image> builtImage = entry.getKey();\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n               return new CheckImageStep(\n                       buildContext,\n                       childProgressDispatcherFactory,\n"}}, {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "url": "https://github.com/GoogleContainerTools/jib/commit/00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "message": "Style Fixes", "committedDate": "2020-08-10T14:34:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4MTU4NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468081584", "bodyText": "I think we can block until we get the built Image?\n              Image builtImage =\n                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\nNext, I think we should avoid scheduling another thread. We can use Futures.immediateFuture (a utility method to directly instantiate a Future from a concrete value) that just wraps a value instead of actually scheduling a thread.\n              Image builtImage =\n                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\n\n              return Collections.singletonList(\n                  Futures.immediateFuture(\n                      new LoadDockerStep(\n                              buildContext,\n                              childProgressDispatcherFactory,\n                              dockerClient,\n                              builtImage)\n                          .call()));", "author": "chanseokoh", "createdAt": "2020-08-10T18:00:03Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when pushing to Docker engine\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call()));\n+            });", "originalCommit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODExMDE3MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468110170", "bodyText": "And I think this is more readable:\n              BuildResult buildResult =\n                  new LoadDockerStep(\n                          buildContext, childProgressDispatcherFactory, dockerClient, builtImage)\n                      .call();\n              return Collections.singletonList(Futures.immediateFuture(buildResult));", "author": "chanseokoh", "createdAt": "2020-08-10T18:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4MTU4NA=="}], "type": "inlineReview", "revised_code": {"commit": "8a92200f852c12e1925e2e08dc0c88817ed3009b", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 27af8491..a8b9a13d 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -478,18 +477,21 @@ public class StepsRunner {\n                               Verify.verifyNotNull(\n                                   results.baseImagesAndLayerPushResults.get().get(baseImage)));\n \n+                          BlobDescriptor containerConfigPushResult =\n+                              Verify.verifyNotNull(\n+                                      results\n+                                          .builtImagesAndContainerConfigurationPushResults\n+                                          .get()\n+                                          .get(builtImage))\n+                                  .get();\n+\n                           List<Future<BuildResult>> manifestPushResults =\n                               scheduleCallables(\n                                   PushImageStep.makeList(\n                                       buildContext,\n                                       childProgressDispatcherFactory,\n                                       results.targetRegistryClient.get(),\n-                                      Verify.verifyNotNull(\n-                                              results\n-                                                  .builtImagesAndContainerConfigurationPushResults\n-                                                  .get()\n-                                                  .get(builtImage))\n-                                          .get(),\n+                                      containerConfigPushResult,\n                                       builtImage.get(),\n                                       results.manifestCheckResult.get().isPresent()));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODQ2MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468098460", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-08-10T18:31:37Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when pushing to Docker engine\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call()));\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when building a local tar image\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(", "originalCommit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a92200f852c12e1925e2e08dc0c88817ed3009b", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 27af8491..a8b9a13d 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -478,18 +477,21 @@ public class StepsRunner {\n                               Verify.verifyNotNull(\n                                   results.baseImagesAndLayerPushResults.get().get(baseImage)));\n \n+                          BlobDescriptor containerConfigPushResult =\n+                              Verify.verifyNotNull(\n+                                      results\n+                                          .builtImagesAndContainerConfigurationPushResults\n+                                          .get()\n+                                          .get(builtImage))\n+                                  .get();\n+\n                           List<Future<BuildResult>> manifestPushResults =\n                               scheduleCallables(\n                                   PushImageStep.makeList(\n                                       buildContext,\n                                       childProgressDispatcherFactory,\n                                       results.targetRegistryClient.get(),\n-                                      Verify.verifyNotNull(\n-                                              results\n-                                                  .builtImagesAndContainerConfigurationPushResults\n-                                                  .get()\n-                                                  .get(builtImage))\n-                                          .get(),\n+                                      containerConfigPushResult,\n                                       builtImage.get(),\n                                       results.manifestCheckResult.get().isPresent()));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMjU0Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468132543", "bodyText": "This is also used on line 500, so I suggest refactor out into a local variable. I think it will considerable improve readability.", "author": "chanseokoh", "createdAt": "2020-08-10T19:29:05Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))", "originalCommit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a92200f852c12e1925e2e08dc0c88817ed3009b", "chunk": "diff --git a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\nindex 27af8491..a8b9a13d 100644\n--- a/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n+++ b/jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java\n\n@@ -478,18 +477,21 @@ public class StepsRunner {\n                               Verify.verifyNotNull(\n                                   results.baseImagesAndLayerPushResults.get().get(baseImage)));\n \n+                          BlobDescriptor containerConfigPushResult =\n+                              Verify.verifyNotNull(\n+                                      results\n+                                          .builtImagesAndContainerConfigurationPushResults\n+                                          .get()\n+                                          .get(builtImage))\n+                                  .get();\n+\n                           List<Future<BuildResult>> manifestPushResults =\n                               scheduleCallables(\n                                   PushImageStep.makeList(\n                                       buildContext,\n                                       childProgressDispatcherFactory,\n                                       results.targetRegistryClient.get(),\n-                                      Verify.verifyNotNull(\n-                                              results\n-                                                  .builtImagesAndContainerConfigurationPushResults\n-                                                  .get()\n-                                                  .get(builtImage))\n-                                          .get(),\n+                                      containerConfigPushResult,\n                                       builtImage.get(),\n                                       results.manifestCheckResult.get().isPresent()));\n \n"}}, {"oid": "8a92200f852c12e1925e2e08dc0c88817ed3009b", "url": "https://github.com/GoogleContainerTools/jib/commit/8a92200f852c12e1925e2e08dc0c88817ed3009b", "message": "Style Fixes", "committedDate": "2020-08-11T15:31:09Z", "type": "commit"}, {"oid": "97dfb42924055a67eb73b3a63b50bf0704fd0f17", "url": "https://github.com/GoogleContainerTools/jib/commit/97dfb42924055a67eb73b3a63b50bf0704fd0f17", "message": "Refactor code; no behavior change", "committedDate": "2020-08-11T16:16:45Z", "type": "commit"}, {"oid": "718c32c8dd92987a3d7c1cdfb6e735426593eb62", "url": "https://github.com/GoogleContainerTools/jib/commit/718c32c8dd92987a3d7c1cdfb6e735426593eb62", "message": "Merge remote-tracking branch 'origin/master' into pushImages", "committedDate": "2020-08-11T16:17:05Z", "type": "commit"}, {"oid": "d3c7019d986039014fa140888af5eac73ecd447c", "url": "https://github.com/GoogleContainerTools/jib/commit/d3c7019d986039014fa140888af5eac73ecd447c", "message": "Update comment", "committedDate": "2020-08-11T16:19:20Z", "type": "commit"}]}