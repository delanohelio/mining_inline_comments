{"pr_number": 5363, "pr_title": "a custom datetime shard algorithm used to shard tables by days/weeks/months/QUARTER_OF_YEAR", "pr_createdAt": "2020-04-28T07:06:36Z", "pr_url": "https://github.com/apache/shardingsphere/pull/5363", "timeline": [{"oid": "8240b8e910f8af2c036335ae8de291a47377043c", "url": "https://github.com/apache/shardingsphere/commit/8240b8e910f8af2c036335ae8de291a47377043c", "message": "datetime shard algorithm used to shard tables by days/weeks/months/QUARTER_OF_YEAR", "committedDate": "2020-04-28T06:40:15Z", "type": "commit"}, {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905", "url": "https://github.com/apache/shardingsphere/commit/152cb6d960cc23164b9044f1d4f9320ab2923905", "message": "add half range sharding tests", "committedDate": "2020-04-28T07:03:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyNTI3Nw==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416425277", "bodyText": "I like this detailed java doc.", "author": "tristaZero", "createdAt": "2020-04-28T08:23:56Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n+ *\n+ * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n+ *\n+ * <p>datetime.lower and datetime.upper: if app query with only half bound, lower and upper helps to build other half bound,\n+ * datetime.lower must be specified and datetime.upper has a default value to {@link LocalDateTime#now}\n+ * (default value of datetime.upper could only be used when query sql needn't get result that time larger than query time).\n+ *\n+ * <p>datetime.step.unit and datetime.step.amount used for calculate tables for range shard, datetime.step.unit is name of\n+ * {@link ChronoUnit}, default unit is Days and amount is 1, amount + unit should not be larger than but close to your shard range.\n+ *", "originalCommit": "152cb6d960cc23164b9044f1d4f9320ab2923905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3MzU4MA==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416473580", "bodyText": "Me too", "author": "kimmking", "createdAt": "2020-04-28T09:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyNTI3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "chunk": "diff --git a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\nindex 6bf7994db7..9285bdf9dd 100644\n--- a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n+++ b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n\n@@ -47,6 +47,7 @@ import java.util.Set;\n  * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n  * examples:\n  * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMM means shard by {@link ChronoUnit#MONTHS};\n  * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n  *\n  * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyODMxMQ==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416428311", "bodyText": "A redundant blank line is recommended to remove.", "author": "tristaZero", "createdAt": "2020-04-28T08:28:29Z", "path": "sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;\n+import org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy;\n+import org.apache.shardingsphere.core.strategy.route.value.ListRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RangeRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RouteValue;\n+import org.apache.shardingsphere.underlying.common.config.properties.ConfigurationProperties;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * datetime sharding algorithm test.\n+ */\n+public class CustomDateTimeShardingAlgorithmTest {\n+\n+    private final List<String> availableTables = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategy;\n+\n+    @Before\n+    public void setup() {\n+        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.format\", \"yyyy-MM-dd HH:mm:ss\");\n+        shardingAlgorithm.getProperties().setProperty(\"table.suffix.format\", \"yyyyQQ\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.lower\", \"2016-01-01 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.upper\", \"2021-12-31 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.unit\", \"Months\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.amount\", \"3\");\n+        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"create_time\", shardingAlgorithm);\n+        this.shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n+", "originalCommit": "152cb6d960cc23164b9044f1d4f9320ab2923905", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "chunk": "diff --git a/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java b/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\nindex 14d3f47888..8514d1348c 100644\n--- a/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\n+++ b/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\n\n@@ -45,52 +45,61 @@ import static org.junit.Assert.assertTrue;\n  */\n public class CustomDateTimeShardingAlgorithmTest {\n \n-    private final List<String> availableTables = new ArrayList<>();\n+    private final List<String> availableTablesForMonthStrategy = new ArrayList<>();\n \n-    private StandardShardingStrategy shardingStrategy;\n+    private final List<String> availableTablesForQuarterStrategy = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategyByMonth;\n+\n+    private StandardShardingStrategy shardingStrategyByQuarter;\n \n     @Before\n     public void setup() {\n-        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.format\", \"yyyy-MM-dd HH:mm:ss\");\n-        shardingAlgorithm.getProperties().setProperty(\"table.suffix.format\", \"yyyyQQ\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.lower\", \"2016-01-01 00:00:00.000\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.upper\", \"2021-12-31 00:00:00.000\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.step.unit\", \"Months\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.step.amount\", \"3\");\n-        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"create_time\", shardingAlgorithm);\n-        this.shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n-\n-        for (int i = 2016; i <= 2020; i++) {\n-            for (int j = 1; j <= 4; j++) {\n-                availableTables.add(String.format(\"t_order_%04d%02d\", i, j));\n-            }\n-        }\n+        initShardStrategyByMonth();\n+        initShardStrategyByQuarter();\n     }\n \n     @Test\n-    public void assertPreciseDoSharding() {\n+    public void assertPreciseDoShardingByQuarter() {\n         List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n                 Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(2));\n         assertTrue(actual.contains(\"t_order_202001\"));\n         assertTrue(actual.contains(\"t_order_202002\"));\n     }\n \n     @Test\n-    public void assertRangeDoSharding() {\n+    public void assertRangeDoShardingByQuarter() {\n         Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n         List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(3));\n     }\n \n+    @Test\n+    public void assertPreciseDoShardingByMonth() {\n+        List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n+                Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n+        Collection<String> actual = shardingStrategyByMonth.doSharding(availableTablesForMonthStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(2));\n+        assertTrue(actual.contains(\"t_order_202001\"));\n+        assertTrue(actual.contains(\"t_order_202004\"));\n+    }\n+\n+    @Test\n+    public void assertRangeDoShardingByMonth() {\n+        Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategyByMonth.doSharding(availableTablesForMonthStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(7));\n+    }\n+\n     @Test\n     public void assertLowerHalfRangeDoSharding() {\n         Range<String> rangeValue = Range.atLeast(\"2018-10-15 10:59:08\");\n         List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(9));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyOTExNA==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416429114", "bodyText": "Considering the consistent function names, assertFormat is better.", "author": "tristaZero", "createdAt": "2020-04-28T08:29:38Z", "path": "sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;\n+import org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy;\n+import org.apache.shardingsphere.core.strategy.route.value.ListRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RangeRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RouteValue;\n+import org.apache.shardingsphere.underlying.common.config.properties.ConfigurationProperties;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * datetime sharding algorithm test.\n+ */\n+public class CustomDateTimeShardingAlgorithmTest {\n+\n+    private final List<String> availableTables = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategy;\n+\n+    @Before\n+    public void setup() {\n+        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.format\", \"yyyy-MM-dd HH:mm:ss\");\n+        shardingAlgorithm.getProperties().setProperty(\"table.suffix.format\", \"yyyyQQ\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.lower\", \"2016-01-01 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.upper\", \"2021-12-31 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.unit\", \"Months\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.amount\", \"3\");\n+        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"create_time\", shardingAlgorithm);\n+        this.shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n+\n+        for (int i = 2016; i <= 2020; i++) {\n+            for (int j = 1; j <= 4; j++) {\n+                availableTables.add(String.format(\"t_order_%04d%02d\", i, j));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void assertPreciseDoSharding() {\n+        List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n+                Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(2));\n+        assertTrue(actual.contains(\"t_order_202001\"));\n+        assertTrue(actual.contains(\"t_order_202002\"));\n+    }\n+\n+    @Test\n+    public void assertRangeDoSharding() {\n+        Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(3));\n+    }\n+\n+    @Test\n+    public void assertLowerHalfRangeDoSharding() {\n+        Range<String> rangeValue = Range.atLeast(\"2018-10-15 10:59:08\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(9));\n+    }\n+\n+    @Test\n+    public void assertUpperHalfRangeDoSharding() {\n+        Range<String> rangeValue = Range.atMost(\"2019-09-01 00:00:00\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(15));\n+    }\n+\n+    @Test\n+    public void testFormat() {", "originalCommit": "152cb6d960cc23164b9044f1d4f9320ab2923905", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "chunk": "diff --git a/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java b/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\nindex 14d3f47888..8514d1348c 100644\n--- a/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\n+++ b/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\n\n@@ -45,52 +45,61 @@ import static org.junit.Assert.assertTrue;\n  */\n public class CustomDateTimeShardingAlgorithmTest {\n \n-    private final List<String> availableTables = new ArrayList<>();\n+    private final List<String> availableTablesForMonthStrategy = new ArrayList<>();\n \n-    private StandardShardingStrategy shardingStrategy;\n+    private final List<String> availableTablesForQuarterStrategy = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategyByMonth;\n+\n+    private StandardShardingStrategy shardingStrategyByQuarter;\n \n     @Before\n     public void setup() {\n-        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.format\", \"yyyy-MM-dd HH:mm:ss\");\n-        shardingAlgorithm.getProperties().setProperty(\"table.suffix.format\", \"yyyyQQ\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.lower\", \"2016-01-01 00:00:00.000\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.upper\", \"2021-12-31 00:00:00.000\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.step.unit\", \"Months\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.step.amount\", \"3\");\n-        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"create_time\", shardingAlgorithm);\n-        this.shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n-\n-        for (int i = 2016; i <= 2020; i++) {\n-            for (int j = 1; j <= 4; j++) {\n-                availableTables.add(String.format(\"t_order_%04d%02d\", i, j));\n-            }\n-        }\n+        initShardStrategyByMonth();\n+        initShardStrategyByQuarter();\n     }\n \n     @Test\n-    public void assertPreciseDoSharding() {\n+    public void assertPreciseDoShardingByQuarter() {\n         List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n                 Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(2));\n         assertTrue(actual.contains(\"t_order_202001\"));\n         assertTrue(actual.contains(\"t_order_202002\"));\n     }\n \n     @Test\n-    public void assertRangeDoSharding() {\n+    public void assertRangeDoShardingByQuarter() {\n         Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n         List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(3));\n     }\n \n+    @Test\n+    public void assertPreciseDoShardingByMonth() {\n+        List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n+                Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n+        Collection<String> actual = shardingStrategyByMonth.doSharding(availableTablesForMonthStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(2));\n+        assertTrue(actual.contains(\"t_order_202001\"));\n+        assertTrue(actual.contains(\"t_order_202004\"));\n+    }\n+\n+    @Test\n+    public void assertRangeDoShardingByMonth() {\n+        Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategyByMonth.doSharding(availableTablesForMonthStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(7));\n+    }\n+\n     @Test\n     public void assertLowerHalfRangeDoSharding() {\n         Range<String> rangeValue = Range.atLeast(\"2018-10-15 10:59:08\");\n         List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(9));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ0MDYzOA==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416440638", "bodyText": "This is a great practice t shard by quarter. Besides, could you provide another test case like sharding by month or day to present its flexibility to our users?\nYou know, a cool algorithm needs more examples to express its features.", "author": "tristaZero", "createdAt": "2020-04-28T08:47:14Z", "path": "sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;\n+import org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy;\n+import org.apache.shardingsphere.core.strategy.route.value.ListRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RangeRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RouteValue;\n+import org.apache.shardingsphere.underlying.common.config.properties.ConfigurationProperties;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * datetime sharding algorithm test.\n+ */\n+public class CustomDateTimeShardingAlgorithmTest {\n+\n+    private final List<String> availableTables = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategy;\n+\n+    @Before\n+    public void setup() {\n+        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();", "originalCommit": "152cb6d960cc23164b9044f1d4f9320ab2923905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1MDkzMA==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416650930", "bodyText": "I have just add test case for sharding by month, looking forward to further suggestions", "author": "SanmuWangZJU", "createdAt": "2020-04-28T14:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ0MDYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "chunk": "diff --git a/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java b/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\nindex 14d3f47888..8514d1348c 100644\n--- a/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\n+++ b/sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java\n\n@@ -45,52 +45,61 @@ import static org.junit.Assert.assertTrue;\n  */\n public class CustomDateTimeShardingAlgorithmTest {\n \n-    private final List<String> availableTables = new ArrayList<>();\n+    private final List<String> availableTablesForMonthStrategy = new ArrayList<>();\n \n-    private StandardShardingStrategy shardingStrategy;\n+    private final List<String> availableTablesForQuarterStrategy = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategyByMonth;\n+\n+    private StandardShardingStrategy shardingStrategyByQuarter;\n \n     @Before\n     public void setup() {\n-        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.format\", \"yyyy-MM-dd HH:mm:ss\");\n-        shardingAlgorithm.getProperties().setProperty(\"table.suffix.format\", \"yyyyQQ\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.lower\", \"2016-01-01 00:00:00.000\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.upper\", \"2021-12-31 00:00:00.000\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.step.unit\", \"Months\");\n-        shardingAlgorithm.getProperties().setProperty(\"datetime.step.amount\", \"3\");\n-        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"create_time\", shardingAlgorithm);\n-        this.shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n-\n-        for (int i = 2016; i <= 2020; i++) {\n-            for (int j = 1; j <= 4; j++) {\n-                availableTables.add(String.format(\"t_order_%04d%02d\", i, j));\n-            }\n-        }\n+        initShardStrategyByMonth();\n+        initShardStrategyByQuarter();\n     }\n \n     @Test\n-    public void assertPreciseDoSharding() {\n+    public void assertPreciseDoShardingByQuarter() {\n         List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n                 Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(2));\n         assertTrue(actual.contains(\"t_order_202001\"));\n         assertTrue(actual.contains(\"t_order_202002\"));\n     }\n \n     @Test\n-    public void assertRangeDoSharding() {\n+    public void assertRangeDoShardingByQuarter() {\n         Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n         List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(3));\n     }\n \n+    @Test\n+    public void assertPreciseDoShardingByMonth() {\n+        List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n+                Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n+        Collection<String> actual = shardingStrategyByMonth.doSharding(availableTablesForMonthStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(2));\n+        assertTrue(actual.contains(\"t_order_202001\"));\n+        assertTrue(actual.contains(\"t_order_202004\"));\n+    }\n+\n+    @Test\n+    public void assertRangeDoShardingByMonth() {\n+        Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategyByMonth.doSharding(availableTablesForMonthStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(7));\n+    }\n+\n     @Test\n     public void assertLowerHalfRangeDoSharding() {\n         Range<String> rangeValue = Range.atLeast(\"2018-10-15 10:59:08\");\n         List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n-        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        Collection<String> actual = shardingStrategyByQuarter.doSharding(availableTablesForQuarterStrategy, shardingValues, new ConfigurationProperties(new Properties()));\n         assertThat(actual.size(), is(9));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3NjE4Nw==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416476187", "bodyText": "remove tepUnit =", "author": "kimmking", "createdAt": "2020-04-28T09:42:04Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n+ *\n+ * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n+ *\n+ * <p>datetime.lower and datetime.upper: if app query with only half bound, lower and upper helps to build other half bound,\n+ * datetime.lower must be specified and datetime.upper has a default value to {@link LocalDateTime#now}\n+ * (default value of datetime.upper could only be used when query sql needn't get result that time larger than query time).\n+ *\n+ * <p>datetime.step.unit and datetime.step.amount used for calculate tables for range shard, datetime.step.unit is name of\n+ * {@link ChronoUnit}, default unit is Days and amount is 1, amount + unit should not be larger than but close to your shard range.\n+ *\n+ * <p>examples: when shard by {@link IsoFields#QUARTER_OF_YEAR}, datetime.step.unit = Months and datetime.step.amount = 3 is a better choice.\n+ */\n+public class CustomDateTimeShardingAlgorithm implements StandardShardingAlgorithm<Comparable<?>> {\n+\n+    private static final String DATE_TIME_FORMAT = \"datetime.format\";\n+\n+    private static final String TABLE_SUFFIX_FORMAT = \"table.suffix.format\";\n+\n+    private static final String DEFAULT_LOWER = \"datetime.lower\";\n+\n+    private static final String DEFAULT_UPPER = \"datetime.upper\";\n+\n+    private static final String STEP_UNIT = \"datetime.step.unit\";\n+\n+    private static final String STEP_AMOUNT = \"datetime.step.amount\";\n+\n+    private DateTimeFormatter datetimeFormatter;\n+\n+    private ChronoUnit stepUnit;\n+\n+    private int stepAmount;\n+\n+    private volatile boolean init;\n+\n+    @Getter\n+    @Setter\n+    private Properties properties = new Properties();\n+\n+    @Override\n+    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        return availableTargetNames.stream()\n+                .filter(tableName -> tableName.endsWith(formatForDateTime(parseDateTimeForValue(shardingValue.getValue().toString()))))\n+                .findFirst().orElseThrow(() -> new UnsupportedOperationException(\n+                        String.format(\"failed to shard value %s, and availableTables %s\", shardingValue, availableTargetNames)));\n+    }\n+\n+    @Override\n+    public Collection<String> doSharding(final Collection<String> availableTargetNames, final RangeShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        boolean hasStart = shardingValue.getValueRange().hasLowerBound();\n+        boolean hasEnd = shardingValue.getValueRange().hasUpperBound();\n+        Set<String> tables = new HashSet<>();\n+        if (!hasStart && !hasEnd) {\n+            return availableTargetNames;\n+        }\n+        LocalDateTime start = hasStart\n+                ? parseDateTimeForValue(shardingValue.getValueRange().lowerEndpoint().toString())\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_LOWER));\n+        LocalDateTime end = hasEnd\n+                ? parseDateTimeForValue(shardingValue.getValueRange().upperEndpoint().toString())\n+                : properties.getProperty(DEFAULT_UPPER) == null\n+                ? LocalDateTime.now()\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_UPPER));\n+        LocalDateTime tmp = start;\n+        while (!tmp.isAfter(end)) {\n+            mergeTableIfMatch(tmp, tables, availableTargetNames);\n+            tmp = tmp.plus(stepAmount, stepUnit);\n+        }\n+        mergeTableIfMatch(end, tables, availableTargetNames);\n+        return tables;\n+    }\n+\n+    private LocalDateTime parseDateTimeForValue(final String value) {\n+        return LocalDateTime.parse(value.substring(0, properties.getProperty(DATE_TIME_FORMAT).length()), datetimeFormatter);\n+    }\n+\n+    private String formatForDateTime(final LocalDateTime localDateTime) {\n+        return localDateTime.format(DateTimeFormatter.ofPattern(properties.get(TABLE_SUFFIX_FORMAT).toString()));\n+    }\n+\n+    private void mergeTableIfMatch(final LocalDateTime dateTime, final Collection<String> tables, final Collection<String> availableTargetNames) {\n+        String suffix = formatForDateTime(dateTime);\n+        availableTargetNames.parallelStream().filter(tableName -> tableName.endsWith(suffix)).findAny().map(tables::add);\n+    }\n+\n+    private void checkInit() {\n+        if (!init) {\n+            synchronized (this) {\n+                if (!init) {\n+                    verifyProperties();\n+                    init = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void verifyProperties() {\n+        Preconditions.checkNotNull(properties.getProperty(DATE_TIME_FORMAT));\n+        Preconditions.checkNotNull(properties.getProperty(TABLE_SUFFIX_FORMAT));\n+        Preconditions.checkNotNull(properties.getProperty(DEFAULT_LOWER));\n+        stepUnit = properties.getProperty(STEP_UNIT) == null\n+                ? stepUnit = ChronoUnit.DAYS", "originalCommit": "152cb6d960cc23164b9044f1d4f9320ab2923905", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "chunk": "diff --git a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\nindex 6bf7994db7..9285bdf9dd 100644\n--- a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n+++ b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n\n@@ -47,6 +47,7 @@ import java.util.Set;\n  * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n  * examples:\n  * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMM means shard by {@link ChronoUnit#MONTHS};\n  * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n  *\n  * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MTA5NA==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416481094", "bodyText": "why add sync block here\uff1f", "author": "kimmking", "createdAt": "2020-04-28T09:49:56Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n+ *\n+ * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n+ *\n+ * <p>datetime.lower and datetime.upper: if app query with only half bound, lower and upper helps to build other half bound,\n+ * datetime.lower must be specified and datetime.upper has a default value to {@link LocalDateTime#now}\n+ * (default value of datetime.upper could only be used when query sql needn't get result that time larger than query time).\n+ *\n+ * <p>datetime.step.unit and datetime.step.amount used for calculate tables for range shard, datetime.step.unit is name of\n+ * {@link ChronoUnit}, default unit is Days and amount is 1, amount + unit should not be larger than but close to your shard range.\n+ *\n+ * <p>examples: when shard by {@link IsoFields#QUARTER_OF_YEAR}, datetime.step.unit = Months and datetime.step.amount = 3 is a better choice.\n+ */\n+public class CustomDateTimeShardingAlgorithm implements StandardShardingAlgorithm<Comparable<?>> {\n+\n+    private static final String DATE_TIME_FORMAT = \"datetime.format\";\n+\n+    private static final String TABLE_SUFFIX_FORMAT = \"table.suffix.format\";\n+\n+    private static final String DEFAULT_LOWER = \"datetime.lower\";\n+\n+    private static final String DEFAULT_UPPER = \"datetime.upper\";\n+\n+    private static final String STEP_UNIT = \"datetime.step.unit\";\n+\n+    private static final String STEP_AMOUNT = \"datetime.step.amount\";\n+\n+    private DateTimeFormatter datetimeFormatter;\n+\n+    private ChronoUnit stepUnit;\n+\n+    private int stepAmount;\n+\n+    private volatile boolean init;\n+\n+    @Getter\n+    @Setter\n+    private Properties properties = new Properties();\n+\n+    @Override\n+    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        return availableTargetNames.stream()\n+                .filter(tableName -> tableName.endsWith(formatForDateTime(parseDateTimeForValue(shardingValue.getValue().toString()))))\n+                .findFirst().orElseThrow(() -> new UnsupportedOperationException(\n+                        String.format(\"failed to shard value %s, and availableTables %s\", shardingValue, availableTargetNames)));\n+    }\n+\n+    @Override\n+    public Collection<String> doSharding(final Collection<String> availableTargetNames, final RangeShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        boolean hasStart = shardingValue.getValueRange().hasLowerBound();\n+        boolean hasEnd = shardingValue.getValueRange().hasUpperBound();\n+        Set<String> tables = new HashSet<>();\n+        if (!hasStart && !hasEnd) {\n+            return availableTargetNames;\n+        }\n+        LocalDateTime start = hasStart\n+                ? parseDateTimeForValue(shardingValue.getValueRange().lowerEndpoint().toString())\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_LOWER));\n+        LocalDateTime end = hasEnd\n+                ? parseDateTimeForValue(shardingValue.getValueRange().upperEndpoint().toString())\n+                : properties.getProperty(DEFAULT_UPPER) == null\n+                ? LocalDateTime.now()\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_UPPER));\n+        LocalDateTime tmp = start;\n+        while (!tmp.isAfter(end)) {\n+            mergeTableIfMatch(tmp, tables, availableTargetNames);\n+            tmp = tmp.plus(stepAmount, stepUnit);\n+        }\n+        mergeTableIfMatch(end, tables, availableTargetNames);\n+        return tables;\n+    }\n+\n+    private LocalDateTime parseDateTimeForValue(final String value) {\n+        return LocalDateTime.parse(value.substring(0, properties.getProperty(DATE_TIME_FORMAT).length()), datetimeFormatter);\n+    }\n+\n+    private String formatForDateTime(final LocalDateTime localDateTime) {\n+        return localDateTime.format(DateTimeFormatter.ofPattern(properties.get(TABLE_SUFFIX_FORMAT).toString()));\n+    }\n+\n+    private void mergeTableIfMatch(final LocalDateTime dateTime, final Collection<String> tables, final Collection<String> availableTargetNames) {\n+        String suffix = formatForDateTime(dateTime);\n+        availableTargetNames.parallelStream().filter(tableName -> tableName.endsWith(suffix)).findAny().map(tables::add);\n+    }\n+\n+    private void checkInit() {", "originalCommit": "152cb6d960cc23164b9044f1d4f9320ab2923905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzNzQzNA==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416537434", "bodyText": "sync block here is used to ensure verifyProperties() method exactly execute once when multi-thread call doSharding(), inspired by Double-Checked Locking with Singleton", "author": "SanmuWangZJU", "createdAt": "2020-04-28T11:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MTA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "chunk": "diff --git a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\nindex 6bf7994db7..9285bdf9dd 100644\n--- a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n+++ b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n\n@@ -47,6 +47,7 @@ import java.util.Set;\n  * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n  * examples:\n  * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMM means shard by {@link ChronoUnit#MONTHS};\n  * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n  *\n  * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4NDcyMw==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416484723", "bodyText": "yyyyMM is also a common style.", "author": "kimmking", "createdAt": "2020-04-28T09:55:52Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.", "originalCommit": "152cb6d960cc23164b9044f1d4f9320ab2923905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUwNDA3MA==", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416504070", "bodyText": "yes, it support yyyyMM, I will add this example to java doc and provide corresponding test cases", "author": "SanmuWangZJU", "createdAt": "2020-04-28T10:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4NDcyMw=="}], "type": "inlineReview", "revised_code": {"commit": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "chunk": "diff --git a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\nindex 6bf7994db7..9285bdf9dd 100644\n--- a/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n+++ b/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java\n\n@@ -47,6 +47,7 @@ import java.util.Set;\n  * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n  * examples:\n  * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMM means shard by {@link ChronoUnit#MONTHS};\n  * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n  *\n  * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n"}}, {"oid": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "url": "https://github.com/apache/shardingsphere/commit/97e416ce28a0c706c1b6a7c06859dabea6a092f5", "message": "add test case for yyyyMM and fix format issue", "committedDate": "2020-04-28T11:46:25Z", "type": "commit"}]}