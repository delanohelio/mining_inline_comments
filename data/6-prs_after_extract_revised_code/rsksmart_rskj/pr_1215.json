{"pr_number": 1215, "pr_title": "Recursive contracts to test 400 recursive levels in VM, VM Refactor ", "pr_createdAt": "2020-04-16T19:21:21Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1215", "timeline": [{"oid": "aa0290c0a0855ff183ccb0cdcdb6628c7be73449", "url": "https://github.com/rsksmart/rskj/commit/aa0290c0a0855ff183ccb0cdcdb6628c7be73449", "message": "Refactor VM code to reduce complexity", "committedDate": "2020-04-17T16:04:22Z", "type": "forcePushed"}, {"oid": "9b53a42aa74b041a920b8d4f40f7f1c64da96635", "url": "https://github.com/rsksmart/rskj/commit/9b53a42aa74b041a920b8d4f40f7f1c64da96635", "message": "VM DSL Tests using recursive contracts", "committedDate": "2020-04-24T17:24:33Z", "type": "commit"}, {"oid": "66b451dab61dcb28da7dce644ab57353222102ba", "url": "https://github.com/rsksmart/rskj/commit/66b451dab61dcb28da7dce644ab57353222102ba", "message": "VM refactor to improve Java stack usage in recursive calls", "committedDate": "2020-04-24T17:24:33Z", "type": "commit"}, {"oid": "6c2261259676f383e6133b3a1777ce6242604028", "url": "https://github.com/rsksmart/rskj/commit/6c2261259676f383e6133b3a1777ce6242604028", "message": "Adding RecursiveInterface.sol source code to DSL files comments", "committedDate": "2020-04-24T17:24:33Z", "type": "commit"}, {"oid": "0a4928e838780a7c90c96eb2163feb9eaa9cf46a", "url": "https://github.com/rsksmart/rskj/commit/0a4928e838780a7c90c96eb2163feb9eaa9cf46a", "message": "Checking counter value in recursive contracts tests", "committedDate": "2020-04-24T17:24:33Z", "type": "commit"}, {"oid": "200689b59df5ca2626b3c0485271e840b07741ca", "url": "https://github.com/rsksmart/rskj/commit/200689b59df5ca2626b3c0485271e840b07741ca", "message": "Refactor VM code to reduce complexity", "committedDate": "2020-04-24T17:24:33Z", "type": "commit"}, {"oid": "200689b59df5ca2626b3c0485271e840b07741ca", "url": "https://github.com/rsksmart/rskj/commit/200689b59df5ca2626b3c0485271e840b07741ca", "message": "Refactor VM code to reduce complexity", "committedDate": "2020-04-24T17:24:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk0ODk2MA==", "url": "https://github.com/rsksmart/rskj/pull/1215#discussion_r415948960", "bodyText": "I would call this something different from calculate. calculate makes me think this is a transparently referential function, but because this can do a program.stackPop(), it's actually imperative. In fact, it almost always does a stackPop, it seems, except in two exceptional op codes. So it makes sense to me to call it something like popCallValue(), or even maybePopCallValue().", "author": "nicops", "createdAt": "2020-04-27T16:10:53Z", "path": "rskj-core/src/main/java/org/ethereum/vm/VM.java", "diffHunk": "@@ -1553,25 +1549,38 @@ protected void doCALL(){\n \n         program.memoryExpand(outDataOffs, outDataSize);\n \n-        MessageCall msg = new MessageCall(\n+        return new MessageCall(\n                 MsgType.fromOpcode(op),\n                 DataWord.valueOf(calleeGas), codeAddress, value, inDataOffs, inDataSize,\n                 outDataOffs, outDataSize);\n+    }\n \n-        callToAddress(codeAddress, msg);\n-\n-        program.step();\n+    private DataWord calculateCallValue(ActivationConfig.ForBlock activations) {", "originalCommit": "200689b59df5ca2626b3c0485271e840b07741ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk1MTc1Ng==", "url": "https://github.com/rsksmart/rskj/pull/1215#discussion_r415951756", "bodyText": "This function is not cohesive and the naming is unclear. It's doing two things, and one of them is validating and maybe throwing an exception. At the very least is should be called calculateAndValidateMinimumTransferGas", "author": "nicops", "createdAt": "2020-04-27T16:14:25Z", "path": "rskj-core/src/main/java/org/ethereum/vm/VM.java", "diffHunk": "@@ -1553,25 +1549,38 @@ protected void doCALL(){\n \n         program.memoryExpand(outDataOffs, outDataSize);\n \n-        MessageCall msg = new MessageCall(\n+        return new MessageCall(\n                 MsgType.fromOpcode(op),\n                 DataWord.valueOf(calleeGas), codeAddress, value, inDataOffs, inDataSize,\n                 outDataOffs, outDataSize);\n+    }\n \n-        callToAddress(codeAddress, msg);\n-\n-        program.step();\n+    private DataWord calculateCallValue(ActivationConfig.ForBlock activations) {\n+        DataWord value;\n+        if (activations.isActive(RSKIP103)) {\n+            // value is always zero in a DELEGATECALL or STATICCALL operation\n+            value = op == OpCode.DELEGATECALL || op == OpCode.STATICCALL ? DataWord.ZERO : program.stackPop();\n+        } else {\n+            // value is always zero in a DELEGATECALL operation\n+            value = op == OpCode.DELEGATECALL ? DataWord.ZERO : program.stackPop();\n+        }\n+        return value;\n     }\n \n-    private void callToAddress(DataWord codeAddress, MessageCall msg) {\n-        ActivationConfig.ForBlock activations = program.getActivations();\n-        PrecompiledContracts.PrecompiledContract contract = precompiledContracts.getContractForAddress(activations, codeAddress);\n+    private long calculateGetMinimumTransferGas(DataWord value, long remainingGas) {", "originalCommit": "200689b59df5ca2626b3c0485271e840b07741ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}