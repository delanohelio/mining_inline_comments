{"pr_number": 1201, "pr_title": "Added verification of node consolidated config property names", "pr_createdAt": "2020-03-30T12:51:24Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1201", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MTQzMQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400361431", "bodyText": "I would suggest doing like : \"Enum.VALUE.equals(value)\",\ngood practice", "author": "patogalla", "createdAt": "2020-03-30T17:19:56Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+\n+        switch (actualValue.valueType()) {\n+            case OBJECT:\n+                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1OTA4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406059087", "bodyText": "well.. there're pros and cons.. people from sonarsource suggest using == - https://rules.sonarsource.com/java/RSPEC-4551.", "author": "Vovchyk", "createdAt": "2020-04-09T08:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MTQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex ed0e78a8c..6aa7be00d 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -151,25 +157,38 @@ public class ConfigLoader {\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n \n-    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+    private static void verify(String keyPath, @Nullable ConfigValue expectedValue, ConfigValue actualValue, List<String> problems) {\n+        Objects.requireNonNull(keyPath);\n+        Objects.requireNonNull(actualValue);\n+        ConfigValueType actualValueType = Objects.requireNonNull(actualValue.valueType());\n+\n         if (expectedValue == null) {\n-            throw unexpectedKeyException(key, actualValue);\n+            problems.add(unexpectedKeyProblem(keyPath, actualValue));\n+            return;\n         }\n \n-        switch (actualValue.valueType()) {\n+        ConfigValueType expectedValueType = Objects.requireNonNull(expectedValue.valueType());\n+\n+        if (!isCollectionType(expectedValueType) && !isCollectionType(actualValueType)) {\n+            return; // We don't verify non-collection types\n+        }\n+\n+        if (expectedValueType != actualValueType) {\n+            problems.add(typeMismatchProblem(keyPath, expectedValue, actualValue));\n+            return;\n+        }\n+\n+        switch (actualValueType) {\n             case OBJECT:\n-                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n-                for (Map.Entry<String, ConfigValue> actualEntry : ((ConfigObject) actualValue).entrySet()) {\n-                    ConfigValue expectedEntryValue = ((ConfigObject) expectedValue).get(actualEntry.getKey());\n-                    verify((key.isEmpty() ? \"\" : key + \".\") + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue());\n+                ConfigObject actualObject = (ConfigObject) actualValue;\n+                ConfigObject expectedObject = (ConfigObject) expectedValue;\n+                String prefix = keyPath.isEmpty() ? \"\" : keyPath + \".\";\n+                for (Map.Entry<String, ConfigValue> actualEntry : actualObject.entrySet()) {\n+                    ConfigValue expectedEntryValue = expectedObject.get(actualEntry.getKey());\n+                    verify(prefix + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue(), problems);\n                 }\n                 break;\n             case LIST:\n-                if (!expectedValue.valueType().equals(ConfigValueType.LIST)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n                 ConfigList actualList = (ConfigList) actualValue;\n                 ConfigList expectedList = (ConfigList) expectedValue;\n                 if (!actualList.isEmpty() && !expectedList.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2Mjk2NA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400362964", "bodyText": "Isnt a way to compare types before going to the switch, it seems redundant to me, asking in each switch statement for the equal type. Whats the logic there?", "author": "patogalla", "createdAt": "2020-03-30T17:22:27Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODg0Ng==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401448846", "bodyText": "I've updated the code a bit.", "author": "Vovchyk", "createdAt": "2020-04-01T08:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2Mjk2NA=="}], "type": "inlineReview", "revised_code": {"commit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex ed0e78a8c..6aa7be00d 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -151,25 +157,38 @@ public class ConfigLoader {\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n \n-    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+    private static void verify(String keyPath, @Nullable ConfigValue expectedValue, ConfigValue actualValue, List<String> problems) {\n+        Objects.requireNonNull(keyPath);\n+        Objects.requireNonNull(actualValue);\n+        ConfigValueType actualValueType = Objects.requireNonNull(actualValue.valueType());\n+\n         if (expectedValue == null) {\n-            throw unexpectedKeyException(key, actualValue);\n+            problems.add(unexpectedKeyProblem(keyPath, actualValue));\n+            return;\n         }\n \n-        switch (actualValue.valueType()) {\n+        ConfigValueType expectedValueType = Objects.requireNonNull(expectedValue.valueType());\n+\n+        if (!isCollectionType(expectedValueType) && !isCollectionType(actualValueType)) {\n+            return; // We don't verify non-collection types\n+        }\n+\n+        if (expectedValueType != actualValueType) {\n+            problems.add(typeMismatchProblem(keyPath, expectedValue, actualValue));\n+            return;\n+        }\n+\n+        switch (actualValueType) {\n             case OBJECT:\n-                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n-                for (Map.Entry<String, ConfigValue> actualEntry : ((ConfigObject) actualValue).entrySet()) {\n-                    ConfigValue expectedEntryValue = ((ConfigObject) expectedValue).get(actualEntry.getKey());\n-                    verify((key.isEmpty() ? \"\" : key + \".\") + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue());\n+                ConfigObject actualObject = (ConfigObject) actualValue;\n+                ConfigObject expectedObject = (ConfigObject) expectedValue;\n+                String prefix = keyPath.isEmpty() ? \"\" : keyPath + \".\";\n+                for (Map.Entry<String, ConfigValue> actualEntry : actualObject.entrySet()) {\n+                    ConfigValue expectedEntryValue = expectedObject.get(actualEntry.getKey());\n+                    verify(prefix + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue(), problems);\n                 }\n                 break;\n             case LIST:\n-                if (!expectedValue.valueType().equals(ConfigValueType.LIST)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n                 ConfigList actualList = (ConfigList) actualValue;\n                 ConfigList expectedList = (ConfigList) expectedValue;\n                 if (!actualList.isEmpty() && !expectedList.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2OTAzNQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400369035", "bodyText": "\"(key.isEmpty() ? \"\" : key + \".\")\" logic should be outside \"for\", no need to ask in each iteration.", "author": "patogalla", "createdAt": "2020-03-30T17:31:44Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+\n+        switch (actualValue.valueType()) {\n+            case OBJECT:\n+                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n+                    throw typeMismatchException(key, expectedValue, actualValue);\n+                }\n+                for (Map.Entry<String, ConfigValue> actualEntry : ((ConfigObject) actualValue).entrySet()) {\n+                    ConfigValue expectedEntryValue = ((ConfigObject) expectedValue).get(actualEntry.getKey());\n+                    verify((key.isEmpty() ? \"\" : key + \".\") + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue());", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1OTE1NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406059155", "bodyText": "done", "author": "Vovchyk", "createdAt": "2020-04-09T08:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2OTAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex ed0e78a8c..6aa7be00d 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -151,25 +157,38 @@ public class ConfigLoader {\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n \n-    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+    private static void verify(String keyPath, @Nullable ConfigValue expectedValue, ConfigValue actualValue, List<String> problems) {\n+        Objects.requireNonNull(keyPath);\n+        Objects.requireNonNull(actualValue);\n+        ConfigValueType actualValueType = Objects.requireNonNull(actualValue.valueType());\n+\n         if (expectedValue == null) {\n-            throw unexpectedKeyException(key, actualValue);\n+            problems.add(unexpectedKeyProblem(keyPath, actualValue));\n+            return;\n         }\n \n-        switch (actualValue.valueType()) {\n+        ConfigValueType expectedValueType = Objects.requireNonNull(expectedValue.valueType());\n+\n+        if (!isCollectionType(expectedValueType) && !isCollectionType(actualValueType)) {\n+            return; // We don't verify non-collection types\n+        }\n+\n+        if (expectedValueType != actualValueType) {\n+            problems.add(typeMismatchProblem(keyPath, expectedValue, actualValue));\n+            return;\n+        }\n+\n+        switch (actualValueType) {\n             case OBJECT:\n-                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n-                for (Map.Entry<String, ConfigValue> actualEntry : ((ConfigObject) actualValue).entrySet()) {\n-                    ConfigValue expectedEntryValue = ((ConfigObject) expectedValue).get(actualEntry.getKey());\n-                    verify((key.isEmpty() ? \"\" : key + \".\") + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue());\n+                ConfigObject actualObject = (ConfigObject) actualValue;\n+                ConfigObject expectedObject = (ConfigObject) expectedValue;\n+                String prefix = keyPath.isEmpty() ? \"\" : keyPath + \".\";\n+                for (Map.Entry<String, ConfigValue> actualEntry : actualObject.entrySet()) {\n+                    ConfigValue expectedEntryValue = expectedObject.get(actualEntry.getKey());\n+                    verify(prefix + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue(), problems);\n                 }\n                 break;\n             case LIST:\n-                if (!expectedValue.valueType().equals(ConfigValueType.LIST)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n                 ConfigList actualList = (ConfigList) actualValue;\n                 ConfigList expectedList = (ConfigList) expectedValue;\n                 if (!actualList.isEmpty() && !expectedList.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MDMyNw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400370327", "bodyText": "instead of throwing, it would be nice to collect them, and throw/log them all at once.", "author": "patogalla", "createdAt": "2020-03-30T17:33:37Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+\n+        switch (actualValue.valueType()) {\n+            case OBJECT:\n+                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n+                    throw typeMismatchException(key, expectedValue, actualValue);", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1OTI1MQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406059251", "bodyText": "done", "author": "Vovchyk", "createdAt": "2020-04-09T08:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MDMyNw=="}], "type": "inlineReview", "revised_code": {"commit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex ed0e78a8c..6aa7be00d 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -151,25 +157,38 @@ public class ConfigLoader {\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n \n-    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+    private static void verify(String keyPath, @Nullable ConfigValue expectedValue, ConfigValue actualValue, List<String> problems) {\n+        Objects.requireNonNull(keyPath);\n+        Objects.requireNonNull(actualValue);\n+        ConfigValueType actualValueType = Objects.requireNonNull(actualValue.valueType());\n+\n         if (expectedValue == null) {\n-            throw unexpectedKeyException(key, actualValue);\n+            problems.add(unexpectedKeyProblem(keyPath, actualValue));\n+            return;\n         }\n \n-        switch (actualValue.valueType()) {\n+        ConfigValueType expectedValueType = Objects.requireNonNull(expectedValue.valueType());\n+\n+        if (!isCollectionType(expectedValueType) && !isCollectionType(actualValueType)) {\n+            return; // We don't verify non-collection types\n+        }\n+\n+        if (expectedValueType != actualValueType) {\n+            problems.add(typeMismatchProblem(keyPath, expectedValue, actualValue));\n+            return;\n+        }\n+\n+        switch (actualValueType) {\n             case OBJECT:\n-                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n-                for (Map.Entry<String, ConfigValue> actualEntry : ((ConfigObject) actualValue).entrySet()) {\n-                    ConfigValue expectedEntryValue = ((ConfigObject) expectedValue).get(actualEntry.getKey());\n-                    verify((key.isEmpty() ? \"\" : key + \".\") + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue());\n+                ConfigObject actualObject = (ConfigObject) actualValue;\n+                ConfigObject expectedObject = (ConfigObject) expectedValue;\n+                String prefix = keyPath.isEmpty() ? \"\" : keyPath + \".\";\n+                for (Map.Entry<String, ConfigValue> actualEntry : actualObject.entrySet()) {\n+                    ConfigValue expectedEntryValue = expectedObject.get(actualEntry.getKey());\n+                    verify(prefix + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue(), problems);\n                 }\n                 break;\n             case LIST:\n-                if (!expectedValue.valueType().equals(ConfigValueType.LIST)) {\n-                    throw typeMismatchException(key, expectedValue, actualValue);\n-                }\n                 ConfigList actualList = (ConfigList) actualValue;\n                 ConfigList expectedList = (ConfigList) expectedValue;\n                 if (!actualList.isEmpty() && !expectedList.isEmpty()) {\n"}}, {"oid": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "url": "https://github.com/rsksmart/rskj/commit/6a1da5be6f455f3323d6b829cb3764a504f48cd2", "message": "Added verification of node consolidated config property names", "committedDate": "2020-04-01T08:35:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MTEyMA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401451120", "bodyText": "Config without systemPropsConfig and systemEnvConfig which are out of our interest", "author": "Vovchyk", "createdAt": "2020-04-01T08:44:46Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -56,13 +59,38 @@ public ConfigLoader(CliArgs<NodeCliOptions, NodeCliFlags> cliArgs) {\n     }\n \n     public Config getConfig() {\n-        Config userConfig = getConfigFromCliArgs()\n-                .withFallback(ConfigFactory.systemProperties())\n-                .withFallback(ConfigFactory.systemEnvironment())\n-                .withFallback(getUserCustomConfig())\n-                .withFallback(getInstallerConfig());\n+        Config cliConfig = getConfigFromCliArgs();\n+        Config systemPropsConfig = ConfigFactory.systemProperties();\n+        Config systemEnvConfig = ConfigFactory.systemEnvironment();\n+        Config userCustomConfig = getUserCustomConfig();\n+        Config installerConfig = getInstallerConfig();\n+\n+        Config userConfig = ConfigFactory.empty()\n+                .withFallback(cliConfig)\n+                .withFallback(systemPropsConfig)\n+                .withFallback(systemEnvConfig)\n+                .withFallback(userCustomConfig)\n+                .withFallback(installerConfig);\n         Config networkBaseConfig = getNetworkDefaultConfig(userConfig);\n-        return userConfig.withFallback(networkBaseConfig);\n+        Config unifiedConfig = userConfig.withFallback(networkBaseConfig);\n+\n+        if (unifiedConfig.getBoolean(SystemProperties.PROPERTY_BC_VERIFY)) {\n+            Config expectedConfig = ConfigFactory.load(EXPECTED_RESOURCE_PATH);\n+            Config actualConfig = ConfigFactory.empty()", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyMzQ3OA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401623478", "bodyText": "can you add this as a comment on the code directly?", "author": "nicops", "createdAt": "2020-04-01T13:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MTEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "a3429f938f36f89216300c8563644aa9dacb412e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex 6aa7be00d..b1540ad5d 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -58,6 +51,29 @@ public class ConfigLoader {\n         this.cliArgs = Objects.requireNonNull(cliArgs);\n     }\n \n+    /**\n+     * Loads configurations from different sources with the following precedence:\n+     * 1. Command line arguments\n+     * 2. Environment variables\n+     * 3. System properties\n+     * 4. User configuration file\n+     * 5. Installer configuration file\n+     * 6. Default settings per network in resources/[network].conf\n+     * 7. Default settings for all networks in resources/reference.conf\n+     *\n+     * <p>\n+     * If the <b><blockchain.config.verify/b> setting is {@code true} (either set in a .conf file or via <b>--verify-config</b> command line flag),\n+     * then the loaded config wll be tested against the setting names defined in the expected.conf config file.\n+     *\n+     * Note:\n+     *  1. The <b><blockchain.config.verify/b> setting is {@code false} by default.\n+     *  2. Config verification process of matching actual and expected configs is recursive and takes into account appropriate setting names\n+     *      and values which are collections of other settings (LIST's and OBJECT's).\n+     *\n+     * @throws RskConfigurationException on configuration errors\n+     *\n+     * @see ConfigProblems\n+     */\n     public Config getConfig() {\n         Config cliConfig = getConfigFromCliArgs();\n         Config systemPropsConfig = ConfigFactory.systemProperties();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401626980", "bodyText": "This is the original case? When a misspelled property will be warned... am i right?", "author": "patogalla", "createdAt": "2020-04-01T13:45:39Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +156,66 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String keyPath, @Nullable ConfigValue expectedValue, ConfigValue actualValue, List<String> problems) {\n+        Objects.requireNonNull(keyPath);\n+        Objects.requireNonNull(actualValue);\n+        ConfigValueType actualValueType = Objects.requireNonNull(actualValue.valueType());\n+\n+        if (expectedValue == null) {", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NjU1MA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405486550", "bodyText": "This seems to be my original case presented in #1192. Maybe a comment explaining how we got here can help.", "author": "lucasvuotto", "createdAt": "2020-04-08T12:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMjkzMA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405522930", "bodyText": "agree, I would add a comment here.", "author": "nicops", "createdAt": "2020-04-08T13:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzE5NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406053195", "bodyText": "Yes, the verify method is recursive one and expectedValue could be null during recursive iterations when an appropriate matching key path is to found.", "author": "Vovchyk", "createdAt": "2020-04-09T08:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "a3429f938f36f89216300c8563644aa9dacb412e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex 6aa7be00d..b1540ad5d 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -163,7 +176,7 @@ public class ConfigLoader {\n         ConfigValueType actualValueType = Objects.requireNonNull(actualValue.valueType());\n \n         if (expectedValue == null) {\n-            problems.add(unexpectedKeyProblem(keyPath, actualValue));\n+            problems.add(ConfigProblems.unexpectedKeyProblem(keyPath, actualValue));\n             return;\n         }\n \n"}}, {"oid": "a3429f938f36f89216300c8563644aa9dacb412e", "url": "https://github.com/rsksmart/rskj/commit/a3429f938f36f89216300c8563644aa9dacb412e", "message": "Added verification of node consolidated config property names", "committedDate": "2020-04-06T08:21:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDQ3NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405484475", "bodyText": "I can see this getting overly verbose and quite difficult to read and search for problems, should multiple configuration problems be present. I suggest making verify return a boolean instead, signaling if the verification was successful, and logging each of the misconfigurations instead of pushing them into problems.", "author": "lucasvuotto", "createdAt": "2020-04-08T12:26:03Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -55,14 +51,59 @@ public ConfigLoader(CliArgs<NodeCliOptions, NodeCliFlags> cliArgs) {\n         this.cliArgs = Objects.requireNonNull(cliArgs);\n     }\n \n+    /**\n+     * Loads configurations from different sources with the following precedence:\n+     * 1. Command line arguments\n+     * 2. Environment variables\n+     * 3. System properties\n+     * 4. User configuration file\n+     * 5. Installer configuration file\n+     * 6. Default settings per network in resources/[network].conf\n+     * 7. Default settings for all networks in resources/reference.conf\n+     *\n+     * <p>\n+     * If the <b><blockchain.config.verify/b> setting is {@code true} (either set in a .conf file or via <b>--verify-config</b> command line flag),\n+     * then the loaded config wll be tested against the setting names defined in the expected.conf config file.\n+     *\n+     * Note:\n+     *  1. The <b><blockchain.config.verify/b> setting is {@code false} by default.\n+     *  2. Config verification process of matching actual and expected configs is recursive and takes into account appropriate setting names\n+     *      and values which are collections of other settings (LIST's and OBJECT's).\n+     *\n+     * @throws RskConfigurationException on configuration errors\n+     *\n+     * @see ConfigProblems\n+     */\n     public Config getConfig() {\n-        Config userConfig = getConfigFromCliArgs()\n-                .withFallback(ConfigFactory.systemProperties())\n-                .withFallback(ConfigFactory.systemEnvironment())\n-                .withFallback(getUserCustomConfig())\n-                .withFallback(getInstallerConfig());\n+        Config cliConfig = getConfigFromCliArgs();\n+        Config systemPropsConfig = ConfigFactory.systemProperties();\n+        Config systemEnvConfig = ConfigFactory.systemEnvironment();\n+        Config userCustomConfig = getUserCustomConfig();\n+        Config installerConfig = getInstallerConfig();\n+\n+        Config userConfig = ConfigFactory.empty()\n+                .withFallback(cliConfig)\n+                .withFallback(systemPropsConfig)\n+                .withFallback(systemEnvConfig)\n+                .withFallback(userCustomConfig)\n+                .withFallback(installerConfig);\n         Config networkBaseConfig = getNetworkDefaultConfig(userConfig);\n-        return userConfig.withFallback(networkBaseConfig);\n+        Config unifiedConfig = userConfig.withFallback(networkBaseConfig);\n+\n+        if (unifiedConfig.getBoolean(SystemProperties.PROPERTY_BC_VERIFY)) {\n+            Config expectedConfig = ConfigFactory.parseResourcesAnySyntax(EXPECTED_RESOURCE_PATH)\n+                    .withFallback(systemPropsConfig)\n+                    .withFallback(systemEnvConfig);\n+\n+            ArrayList<String> problems = new ArrayList<>();\n+            verify(\"\", expectedConfig.root(), unifiedConfig.root(), problems);\n+            if (!problems.isEmpty()) {\n+                throw new RskConfigurationException(\"Verification of node configs has failed. The following problems were found: \"\n+                        + String.join(\"; \", problems));", "originalCommit": "a3429f938f36f89216300c8563644aa9dacb412e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwNTI5Mw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405605293", "bodyText": "I agree and disagree.\nAgree: I would iterate over problems and log each of them as a separate line.\nDisagree: I think the method works fine as it is, right now we don't unit test it directly, but it could be directly unit tested, and it's a richer interface to have it return a problems array instead of a boolean. What I would add is an overload:\n private static List<String> verify(ConfigValue expectedRoot, ConfigValue actualRoot) {\n    ArrayList<String> problems = new ArrayList<>();\n    verify(\"\", expectedConfig.root(), unifiedConfig.root(), problems);\n    return problems;\n}\n\nIMHO it's nice to add an overload in such cases to make the calling code more oblivious to the internal details of the recursive method.", "author": "nicops", "createdAt": "2020-04-08T15:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MDg3Mw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406050873", "bodyText": "I just don't want to overarchitect this solution. Good point about doing verification all the time and only throwing an exception if the flag is present.", "author": "Vovchyk", "createdAt": "2020-04-09T08:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDQ3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex b1540ad5d..70a2a872a 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -62,17 +60,21 @@ public class ConfigLoader {\n      * 7. Default settings for all networks in resources/reference.conf\n      *\n      * <p>\n+     * During the verification process the unified configuration is being tested against the setting names\n+     * defined in the expected.conf config file. The process is silent by default which means that in a case of any problems\n+     * with the config settings only error logs will be generated and the node will continue its running.\n+     *\n+     * <p>\n      * If the <b><blockchain.config.verify/b> setting is {@code true} (either set in a .conf file or via <b>--verify-config</b> command line flag),\n-     * then the loaded config wll be tested against the setting names defined in the expected.conf config file.\n+     * then in a case of any problems an exception will be thrown.\n      *\n      * Note:\n      *  1. The <b><blockchain.config.verify/b> setting is {@code false} by default.\n-     *  2. Config verification process of matching actual and expected configs is recursive and takes into account appropriate setting names\n-     *      and values which are collections of other settings (LIST's and OBJECT's).\n+     *  2. Config verification process of matching actual and expected config settings is a recursive process and takes into\n+     *  account appropriate setting names. Scalar values are not tested for matching, e.g. if we have settingKey=\"some value\"\n+     *  in the expected.conf file and settingKey=100 in a user config file, then it will pass the verification process.\n      *\n      * @throws RskConfigurationException on configuration errors\n-     *\n-     * @see ConfigProblems\n      */\n     public Config getConfig() {\n         Config cliConfig = getConfigFromCliArgs();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405485123", "bodyText": "Can't we run the config verification always and just abort execution only when this flag is set?", "author": "lucasvuotto", "createdAt": "2020-04-08T12:27:11Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -55,14 +51,59 @@ public ConfigLoader(CliArgs<NodeCliOptions, NodeCliFlags> cliArgs) {\n         this.cliArgs = Objects.requireNonNull(cliArgs);\n     }\n \n+    /**\n+     * Loads configurations from different sources with the following precedence:\n+     * 1. Command line arguments\n+     * 2. Environment variables\n+     * 3. System properties\n+     * 4. User configuration file\n+     * 5. Installer configuration file\n+     * 6. Default settings per network in resources/[network].conf\n+     * 7. Default settings for all networks in resources/reference.conf\n+     *\n+     * <p>\n+     * If the <b><blockchain.config.verify/b> setting is {@code true} (either set in a .conf file or via <b>--verify-config</b> command line flag),\n+     * then the loaded config wll be tested against the setting names defined in the expected.conf config file.\n+     *\n+     * Note:\n+     *  1. The <b><blockchain.config.verify/b> setting is {@code false} by default.\n+     *  2. Config verification process of matching actual and expected configs is recursive and takes into account appropriate setting names\n+     *      and values which are collections of other settings (LIST's and OBJECT's).\n+     *\n+     * @throws RskConfigurationException on configuration errors\n+     *\n+     * @see ConfigProblems\n+     */\n     public Config getConfig() {\n-        Config userConfig = getConfigFromCliArgs()\n-                .withFallback(ConfigFactory.systemProperties())\n-                .withFallback(ConfigFactory.systemEnvironment())\n-                .withFallback(getUserCustomConfig())\n-                .withFallback(getInstallerConfig());\n+        Config cliConfig = getConfigFromCliArgs();\n+        Config systemPropsConfig = ConfigFactory.systemProperties();\n+        Config systemEnvConfig = ConfigFactory.systemEnvironment();\n+        Config userCustomConfig = getUserCustomConfig();\n+        Config installerConfig = getInstallerConfig();\n+\n+        Config userConfig = ConfigFactory.empty()\n+                .withFallback(cliConfig)\n+                .withFallback(systemPropsConfig)\n+                .withFallback(systemEnvConfig)\n+                .withFallback(userCustomConfig)\n+                .withFallback(installerConfig);\n         Config networkBaseConfig = getNetworkDefaultConfig(userConfig);\n-        return userConfig.withFallback(networkBaseConfig);\n+        Config unifiedConfig = userConfig.withFallback(networkBaseConfig);\n+\n+        if (unifiedConfig.getBoolean(SystemProperties.PROPERTY_BC_VERIFY)) {", "originalCommit": "a3429f938f36f89216300c8563644aa9dacb412e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMjE4Mw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405522183", "bodyText": "that would be interesting. In which case we catch the exception and only log it?", "author": "nicops", "createdAt": "2020-04-08T13:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyOTY1Ng==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405529656", "bodyText": "About what exception are we talking? I only see verify throwing an exception if there is a malformed entry in expected.conf.", "author": "lucasvuotto", "createdAt": "2020-04-08T13:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMDAwNg==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405600006", "bodyText": "sorry, I did not read the code carefully between all the changes. Right now this method throws the exception, it could skip throwing the exception if the flag is not set.", "author": "nicops", "createdAt": "2020-04-08T15:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\nindex b1540ad5d..70a2a872a 100644\n--- a/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n+++ b/rskj-core/src/main/java/co/rsk/config/ConfigLoader.java\n\n@@ -62,17 +60,21 @@ public class ConfigLoader {\n      * 7. Default settings for all networks in resources/reference.conf\n      *\n      * <p>\n+     * During the verification process the unified configuration is being tested against the setting names\n+     * defined in the expected.conf config file. The process is silent by default which means that in a case of any problems\n+     * with the config settings only error logs will be generated and the node will continue its running.\n+     *\n+     * <p>\n      * If the <b><blockchain.config.verify/b> setting is {@code true} (either set in a .conf file or via <b>--verify-config</b> command line flag),\n-     * then the loaded config wll be tested against the setting names defined in the expected.conf config file.\n+     * then in a case of any problems an exception will be thrown.\n      *\n      * Note:\n      *  1. The <b><blockchain.config.verify/b> setting is {@code false} by default.\n-     *  2. Config verification process of matching actual and expected configs is recursive and takes into account appropriate setting names\n-     *      and values which are collections of other settings (LIST's and OBJECT's).\n+     *  2. Config verification process of matching actual and expected config settings is a recursive process and takes into\n+     *  account appropriate setting names. Scalar values are not tested for matching, e.g. if we have settingKey=\"some value\"\n+     *  in the expected.conf file and settingKey=100 in a user config file, then it will pass the verification process.\n      *\n      * @throws RskConfigurationException on configuration errors\n-     *\n-     * @see ConfigProblems\n      */\n     public Config getConfig() {\n         Config cliConfig = getConfigFromCliArgs();\n"}}, {"oid": "0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "url": "https://github.com/rsksmart/rskj/commit/0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-11T12:53:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU0NzcwMw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r407547703", "bodyText": "with the latest change, this test and the one above it is not making any assertion", "author": "nicops", "createdAt": "2020-04-13T15:45:47Z", "path": "rskj-core/src/test/java/co/rsk/config/ConfigLoaderTest.java", "diffHunk": "@@ -181,13 +168,7 @@ public void detectExpectedScalarValueProblemInList() {\n \n         mockConfigFactory(defaultConfig, expectedConfig);\n \n-        try {\n-            loader.getConfig();\n-        } catch (RskConfigurationException e) {\n-            assertThat(e.getMessage(), containsString(ConfigProblems.expectedScalarValueProblem(\"expectedKey[0]\", EMPTY_LIST_VALUE)));\n-\n-            throw e;\n-        }\n+        loader.getConfig();", "originalCommit": "0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "653879c305926c0596a0511ad2421bdaaad3bba7", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/config/ConfigLoaderTest.java b/rskj-core/src/test/java/co/rsk/config/ConfigLoaderTest.java\nindex 32aa5152e..9626da5b1 100644\n--- a/rskj-core/src/test/java/co/rsk/config/ConfigLoaderTest.java\n+++ b/rskj-core/src/test/java/co/rsk/config/ConfigLoaderTest.java\n\n@@ -168,7 +181,13 @@ public class ConfigLoaderTest {\n \n         mockConfigFactory(defaultConfig, expectedConfig);\n \n-        loader.getConfig();\n+        try {\n+            loader.getConfig();\n+        } catch (RskConfigurationException e) {\n+            assertThat(e.getMessage(), containsString(ConfigProblems.expectedScalarValueProblem(\"expectedKey[0]\", EMPTY_LIST_VALUE)));\n+\n+            throw e;\n+        }\n     }\n \n     @Test\n"}}, {"oid": "63a829a8d92f966575d8c81475ff4cb04efc2dfd", "url": "https://github.com/rsksmart/rskj/commit/63a829a8d92f966575d8c81475ff4cb04efc2dfd", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-25T09:32:47Z", "type": "forcePushed"}, {"oid": "653879c305926c0596a0511ad2421bdaaad3bba7", "url": "https://github.com/rsksmart/rskj/commit/653879c305926c0596a0511ad2421bdaaad3bba7", "message": "Added verification of node consolidated config property names", "committedDate": "2020-04-28T13:48:14Z", "type": "commit"}, {"oid": "c973bf23ce80e83208d5c3e192920c261bce526d", "url": "https://github.com/rsksmart/rskj/commit/c973bf23ce80e83208d5c3e192920c261bce526d", "message": "Added extra keys to expected.conf", "committedDate": "2020-04-28T13:48:14Z", "type": "commit"}, {"oid": "1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "url": "https://github.com/rsksmart/rskj/commit/1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-28T13:48:14Z", "type": "commit"}, {"oid": "1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "url": "https://github.com/rsksmart/rskj/commit/1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-28T13:48:14Z", "type": "forcePushed"}]}