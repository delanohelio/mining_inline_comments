{"pr_number": 1350, "pr_title": "Create pre-validations for the RegisterBtcTransfer function", "pr_createdAt": "2020-10-29T18:32:42Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1350", "timeline": [{"oid": "965855cc39d1dd237891b58262f24eebb3b47fb1", "url": "https://github.com/rsksmart/rskj/commit/965855cc39d1dd237891b58262f24eebb3b47fb1", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself.", "committedDate": "2020-10-29T21:05:53Z", "type": "forcePushed"}, {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "url": "https://github.com/rsksmart/rskj/commit/a963d710cc14b9a01dbd69124f5fd9122baa06b0", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself.", "committedDate": "2020-10-30T13:12:07Z", "type": "commit"}, {"oid": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "url": "https://github.com/rsksmart/rskj/commit/a963d710cc14b9a01dbd69124f5fd9122baa06b0", "message": "Create pre-validations for the RegisterBtcTransfer function\n\nThis commit is only based on creating the previous validations for this function. It does not include the logic of the functionality itself.", "committedDate": "2020-10-30T13:12:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4OTcxMA==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515089710", "bodyText": "Variable should be errorMessage", "author": "guidohernan93", "createdAt": "2020-10-30T13:19:04Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4OTk3Mg==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515089972", "bodyText": "Line is too long, add new line", "author": "guidohernan93", "createdAt": "2020-10-30T13:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4OTcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 7f0f374b3..8663f9247 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2072,58 +2068,181 @@ public class BridgeSupport {\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n+            Address lpBtcAddress,\n             boolean shouldTransferToContract\n-    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n         if (!BridgeUtils.isContractTx(rskTx)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n         }\n \n-        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n-        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n-\n+        Context.propagate(btcContext);\n         Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n \n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n         if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n         }\n \n-        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!shouldTransferToContract){\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!verifyLockDoesNotSurpassLockingCap(\n-                btcTx,\n-                this.getSenderBtcAddress(btcTx),\n-                totalAmount\n-        )) {\n-            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n             return -2;\n         }\n \n         return 1;  //TODO: Includes logic\n     }\n \n-    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n-        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n-        if (!btcLockSenderOptional.isPresent() ||\n-                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n-            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());\n-            throw new GetSenderBtcAddressSenderNotPresentException(String.format(\"[registerBtcTransfer] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash()));\n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n         }\n-        return btcLockSenderOptional.get().getBTCAddress();\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n     }\n \n     protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5Mjk0OA==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515092948", "bodyText": "Same typo, variable should beerrorMessage, and should add new line", "author": "guidohernan93", "createdAt": "2020-10-30T13:23:38Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 7f0f374b3..8663f9247 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2072,58 +2068,181 @@ public class BridgeSupport {\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n+            Address lpBtcAddress,\n             boolean shouldTransferToContract\n-    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n         if (!BridgeUtils.isContractTx(rskTx)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n         }\n \n-        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n-        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n-\n+        Context.propagate(btcContext);\n         Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n \n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n         if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n         }\n \n-        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!shouldTransferToContract){\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!verifyLockDoesNotSurpassLockingCap(\n-                btcTx,\n-                this.getSenderBtcAddress(btcTx),\n-                totalAmount\n-        )) {\n-            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n             return -2;\n         }\n \n         return 1;  //TODO: Includes logic\n     }\n \n-    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n-        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n-        if (!btcLockSenderOptional.isPresent() ||\n-                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n-            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());\n-            throw new GetSenderBtcAddressSenderNotPresentException(String.format(\"[registerBtcTransfer] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash()));\n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n         }\n-        return btcLockSenderOptional.get().getBTCAddress();\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n     }\n \n     protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5NDAwNg==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515094006", "bodyText": "Condition here should be true, we are checking if derivation arguments hash was already used", "author": "guidohernan93", "createdAt": "2020-10-30T13:25:17Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 7f0f374b3..8663f9247 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2072,58 +2068,181 @@ public class BridgeSupport {\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n+            Address lpBtcAddress,\n             boolean shouldTransferToContract\n-    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n         if (!BridgeUtils.isContractTx(rskTx)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n         }\n \n-        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n-        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n-\n+        Context.propagate(btcContext);\n         Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n \n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n         if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n         }\n \n-        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!shouldTransferToContract){\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!verifyLockDoesNotSurpassLockingCap(\n-                btcTx,\n-                this.getSenderBtcAddress(btcTx),\n-                totalAmount\n-        )) {\n-            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n             return -2;\n         }\n \n         return 1;  //TODO: Includes logic\n     }\n \n-    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n-        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n-        if (!btcLockSenderOptional.isPresent() ||\n-                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n-            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());\n-            throw new GetSenderBtcAddressSenderNotPresentException(String.format(\"[registerBtcTransfer] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash()));\n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n         }\n-        return btcLockSenderOptional.get().getBTCAddress();\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n     }\n \n     protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTM3Ng==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515099376", "bodyText": "getSenderBtcAddress & getAmountToActiveFederation are duplicating existing code on processPegin. That method should be invoked from processPegin.", "author": "guidohernan93", "createdAt": "2020-10-30T13:33:33Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract){\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(\n+                btcTx,\n+                this.getSenderBtcAddress(btcTx),\n+                totalAmount\n+        )) {\n+            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTM5Mw==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515109393", "bodyText": "I think getSenderBtcAddress should be protected too, and both methods should be tested", "author": "guidohernan93", "createdAt": "2020-10-30T13:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTM3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 7f0f374b3..8663f9247 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2072,58 +2068,181 @@ public class BridgeSupport {\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n+            Address lpBtcAddress,\n             boolean shouldTransferToContract\n-    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n         if (!BridgeUtils.isContractTx(rskTx)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n         }\n \n-        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n-        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n-\n+        Context.propagate(btcContext);\n         Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n \n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n         if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n         }\n \n-        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!shouldTransferToContract){\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!verifyLockDoesNotSurpassLockingCap(\n-                btcTx,\n-                this.getSenderBtcAddress(btcTx),\n-                totalAmount\n-        )) {\n-            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n             return -2;\n         }\n \n         return 1;  //TODO: Includes logic\n     }\n \n-    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n-        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n-        if (!btcLockSenderOptional.isPresent() ||\n-                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n-            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());\n-            throw new GetSenderBtcAddressSenderNotPresentException(String.format(\"[registerBtcTransfer] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash()));\n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n         }\n-        return btcLockSenderOptional.get().getBTCAddress();\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n     }\n \n     protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTY4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515099687", "bodyText": "Missing new line.", "author": "guidohernan93", "createdAt": "2020-10-30T13:34:02Z", "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTransferException{\n+    public GetSenderBtcAddressSenderNotPresentException(String message) {\n+        super(message);\n+    }\n+}", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java b/rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java\nindex 689955aeb..2829b0524 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java\n\n@@ -4,4 +4,4 @@ public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTra\n     public GetSenderBtcAddressSenderNotPresentException(String message) {\n         super(message);\n     }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjg5NA==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515102894", "bodyText": "Missing new line.", "author": "guidohernan93", "createdAt": "2020-10-30T13:38:10Z", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferContractValidationException extends RegisterBtcTransferException {\n+    public RegisterBtcTransferContractValidationException(String message) {\n+        super(message);\n+    }\n+}", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java b/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java\nindex 353d38f48..86b511e26 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferContractValidationException.java\n\n@@ -4,4 +4,4 @@ public class RegisterBtcTransferContractValidationException extends RegisterBtcT\n     public RegisterBtcTransferContractValidationException(String message) {\n         super(message);\n     }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjk0NQ==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515102945", "bodyText": "Missing new line.", "author": "guidohernan93", "createdAt": "2020-10-30T13:38:18Z", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferException extends Exception {\n+    public RegisterBtcTransferException(String message) {\n+        super(message);\n+    }\n+}", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java b/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java\nindex 62acf91e0..dbd44614a 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferException.java\n\n@@ -4,4 +4,4 @@ public class RegisterBtcTransferException extends Exception {\n     public RegisterBtcTransferException(String message) {\n         super(message);\n     }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMzAzNQ==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515103035", "bodyText": "Missing new line.", "author": "guidohernan93", "createdAt": "2020-10-30T13:38:27Z", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferRegisterBtcTransValidationException extends RegisterBtcTransferException{\n+    public RegisterBtcTransferRegisterBtcTransValidationException(String message) {\n+        super(message);\n+    }\n+}", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java b/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java\nindex 032f58b82..f11261775 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java\n\n@@ -4,4 +4,4 @@ public class RegisterBtcTransferRegisterBtcTransValidationException extends Regi\n     public RegisterBtcTransferRegisterBtcTransValidationException(String message) {\n         super(message);\n     }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNDMxOQ==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515104319", "bodyText": "log and exception should use the same string for error, and leave it on a variable", "author": "guidohernan93", "createdAt": "2020-10-30T13:40:18Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2073,11 +2073,69 @@ public int registerBtcTransfer(\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n             Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            boolean shouldTransferToContract\n+    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n+\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n+            logger.warn(errorMesage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+        }\n+\n+        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract){\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(\n+                btcTx,\n+                this.getSenderBtcAddress(btcTx),\n+                totalAmount\n+        )) {\n+            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n+        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n+        if (!btcLockSenderOptional.isPresent() ||\n+                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n+            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 7f0f374b3..8663f9247 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2072,58 +2068,181 @@ public class BridgeSupport {\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n+            Address lpBtcAddress,\n             boolean shouldTransferToContract\n-    ) throws BlockStoreException, RegisterBtcTransferException, IOException {\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n         if (!BridgeUtils.isContractTx(rskTx)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\", ByteUtil.toHexString(rskTx.getHash().getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferContractValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n         }\n \n-        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n-        Coin totalAmount = this.getAmountToActiveFederation(btcTx);\n-\n+        Context.propagate(btcContext);\n         Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n \n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n         if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n-            String errorMesage = String.format(\"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\", ByteUtil.toHexString(btcTxHash.getBytes()));\n-            logger.warn(errorMesage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMesage);\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n         }\n \n-        if (!provider.isFastBridgeFederationDerivationHashUsed(derivationArgumentsHash)) {\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already saved in BridgeStorageProvider \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!shouldTransferToContract){\n-            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False \", btcTxHash);\n-            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, true);\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n             return -1;\n         }\n \n-        if (!verifyLockDoesNotSurpassLockingCap(\n-                btcTx,\n-                this.getSenderBtcAddress(btcTx),\n-                totalAmount\n-        )) {\n-            generateRejectionRelease(btcTx, lpbtcAddress, rskTx, totalAmount, true);\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n             return -2;\n         }\n \n         return 1;  //TODO: Includes logic\n     }\n \n-    private Address getSenderBtcAddress(BtcTransaction btcTx) throws GetSenderBtcAddressSenderNotPresentException {\n-        Optional<BtcLockSender> btcLockSenderOptional = btcLockSenderProvider.tryGetBtcLockSender(btcTx);\n-        if (!btcLockSenderOptional.isPresent() ||\n-                !BridgeUtils.txIsProcessable(btcLockSenderOptional.get().getType(), activations)) {\n-            logger.warn(\"[getSenderBtcAddress] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash());\n-            throw new GetSenderBtcAddressSenderNotPresentException(String.format(\"[registerBtcTransfer] [btcTx:{}] Could not get BtcLockSender from Btc tx\", btcTx.getHash()));\n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n         }\n-        return btcLockSenderOptional.get().getBTCAddress();\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n     }\n \n     protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTgzNw==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515105837", "bodyText": "Before RSKIP 176 this method should not be allowed to be called.", "author": "guidohernan93", "createdAt": "2020-10-30T13:42:34Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\nindex b579b44ea..7b718ebb4 100644\n--- a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n+++ b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n\n@@ -4984,9 +4985,9 @@ public class BridgeSupportTest {\n                 ConsensusRule.RSKIP134);\n     }\n \n-\n     @Test(expected = RegisterBtcTransferContractValidationException.class)\n-    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n         BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n         Transaction rskTxMock = mock(Transaction.class);\n         Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjUwMg==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515106502", "bodyText": "Unused variable hash", "author": "guidohernan93", "createdAt": "2020-10-30T13:43:44Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\nindex b579b44ea..7b718ebb4 100644\n--- a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n+++ b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n\n@@ -4984,9 +4985,9 @@ public class BridgeSupportTest {\n                 ConsensusRule.RSKIP134);\n     }\n \n-\n     @Test(expected = RegisterBtcTransferContractValidationException.class)\n-    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n         BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n         Transaction rskTxMock = mock(Transaction.class);\n         Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzYwMA==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515107600", "bodyText": "Line too long", "author": "guidohernan93", "createdAt": "2020-10-30T13:45:19Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.valueOf(1)).when(bridgeSupport).getAmountToActiveFederation(any());\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContractFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\nindex b579b44ea..7b718ebb4 100644\n--- a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n+++ b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n\n@@ -4984,9 +4985,9 @@ public class BridgeSupportTest {\n                 ConsensusRule.RSKIP134);\n     }\n \n-\n     @Test(expected = RegisterBtcTransferContractValidationException.class)\n-    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n         BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n         Transaction rskTxMock = mock(Transaction.class);\n         Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODQ4Mg==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r515108482", "bodyText": "I think we should avoid using raw transactions", "author": "guidohernan93", "createdAt": "2020-10-30T13:46:39Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4984,275 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+\n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransactionReturnFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        );\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_providerFastBridgeFederationScriptHashReturnNotPresent() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+        byte[]  btcTxSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +\n+                \"ffff0502cc000101ffffffff029c070395000000002321036d6b5bc8c0e902f296b5bdf3dfd4b6f095d8d0987818a557e1766\" +\n+                \"ea25c664524ac0000000000000000266a24aa21a9edfeb3b9170ae765cc6586edd67229eaa8bc19f9674d64cb10ee8a205f4c\" +\n+                \"cf0bc60120000000000000000000000000000000000000000000000000000000000000000000000000\");\n+\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.valueOf(1)).when(bridgeSupport).getAmountToActiveFederation(any());\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                pmtSerialized,\n+                height,\n+                btcTxSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContractFalse() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+        int height = 111;\n+        byte[]  pmtSerialized = Hex.decode(\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffff\" +", "originalCommit": "a963d710cc14b9a01dbd69124f5fd9122baa06b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\nindex b579b44ea..7b718ebb4 100644\n--- a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n+++ b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n\n@@ -4984,9 +4985,9 @@ public class BridgeSupportTest {\n                 ConsensusRule.RSKIP134);\n     }\n \n-\n     @Test(expected = RegisterBtcTransferContractValidationException.class)\n-    public void registerBtcTransfer_isNotcontract() throws RegisterBtcTransferException, IOException, BlockStoreException {\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n         BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n         Transaction rskTxMock = mock(Transaction.class);\n         Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n"}}, {"oid": "f2875daea8888eccb681f837dc68ed932caf4315", "url": "https://github.com/rsksmart/rskj/commit/f2875daea8888eccb681f837dc68ed932caf4315", "message": "Update registerBtcTransfer signature\n\n- Update BridgeMethods and Bridge classes to cast BTC addresses as bytes\n- Update tests", "committedDate": "2020-11-04T19:06:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5OTI1MQ==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517599251", "bodyText": "Mark with Ok in the function name if the test is a successful one", "author": "pamgonzalez", "createdAt": "2020-11-04T20:03:25Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4985,467 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransaction_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            provider,\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            mock(Address.class),\n+            mock(RskAddress.class),\n+            mock(Address.class),\n+            true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_derivation_arguments_hash_already_used()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        when(provider.isFastBridgeFederationDerivationHashUsed(any(Sha256Hash.class))).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                provider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                btcContext,\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                tx.bitcoinSerialize(),\n+                100,\n+                pmtSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                btcAddress,\n+                lbcAddress,\n+                btcAddress,\n+                true\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContract_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            false\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_verifyLockDoesNotSurpassLockingCap_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+        when(activations.isActive(ConsensusRule.RSKIP134)).thenReturn(true);\n+\n+        BtcLockSender btcLockSender = mock(BtcLockSender.class);\n+        BtcLockSenderProvider btcLockSenderProvider = mock(BtcLockSenderProvider.class);\n+        when(btcLockSenderProvider.tryGetBtcLockSender(any())).thenReturn(Optional.of(btcLockSender));\n+\n+        Repository repository = mock(Repository.class);\n+        when(repository.getBalance(any())).thenReturn(co.rsk.core.Coin.valueOf(1));\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            btcLockSenderProvider,\n+            repository,\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.COIN).when(bridgeSupport).getLockingCap();\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(-2, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_OK()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(1, result);\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        List<UTXO> utxoList = new ArrayList<>();\n+        UTXO utxo = new UTXO(tx.getHash(), 0, Coin.COIN, 0, false, fastBridgeP2SH);\n+        utxoList.add(utxo);\n+\n+        Assert.assertEquals(utxoList, bridgeSupport.getUTXOsForAddress(tx, fastBridgeFedAddress));\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress_no_utxos_for_address() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        Assert.assertEquals(Collections.emptyList(), bridgeSupport.getUTXOsForAddress(tx, btcAddress));\n+    }\n+\n+    @Test\n+    public void getFastBridgeWallet() {", "originalCommit": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\nindex 927eb7eef..7b718ebb4 100644\n--- a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n+++ b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n\n@@ -5340,7 +5340,7 @@ public class BridgeSupportTest {\n     }\n \n     @Test\n-    public void getUTXOsForAddress() {\n+    public void getUTXOsForAddress_OK() {\n         ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n         when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwMDk0OQ==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517600949", "bodyText": "Mark with Ok in the function name if the test is a successful one", "author": "pamgonzalez", "createdAt": "2020-11-04T20:06:42Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4983,6 +4985,467 @@ public void processPegIn_tx_no_lockable_by_surpassing_locking_cap() throws IOExc\n                 ConsensusRule.RSKIP134);\n     }\n \n+    @Test(expected = RegisterBtcTransferContractValidationException.class)\n+    public void registerBtcTransfer_is_not_contract()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+        Transaction rskTxMock = mock(Transaction.class);\n+        Keccak256 hash = new Keccak256(HashUtil.keccak256(new byte[]{}));\n+        when(rskTxMock.getHash()).thenReturn(hash);\n+\n+        bridgeSupport.registerBtcTransfer(\n+                rskTxMock,\n+                new byte[]{},\n+                0,\n+                new byte[]{},\n+                Sha256Hash.ZERO_HASH,\n+                mock(Address.class),\n+                mock(RskAddress.class),\n+                mock(Address.class),\n+                true);\n+    }\n+\n+    @Test(expected = RegisterBtcTransferRegisterBtcTransValidationException.class)\n+    public void registerBtcTransfer_validationsForRegisterBtcTransaction_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            provider,\n+            mock(Repository.class),\n+            mock(BridgeEventLogger.class),\n+            null,\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        );\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            mock(Address.class),\n+            mock(RskAddress.class),\n+            mock(Address.class),\n+            true);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_derivation_arguments_hash_already_used()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        when(provider.isFastBridgeFederationDerivationHashUsed(any(Sha256Hash.class))).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+                bridgeConstants,\n+                provider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                btcContext,\n+                mock(FederationSupport.class),\n+                mock(BtcBlockStoreWithCache.Factory.class),\n+                activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+                rskTx,\n+                tx.bitcoinSerialize(),\n+                100,\n+                pmtSerialized,\n+                Sha256Hash.ZERO_HASH,\n+                btcAddress,\n+                lbcAddress,\n+                btcAddress,\n+                true\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_shouldTransferToContract_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            false\n+        );\n+\n+        Assert.assertEquals(-1, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_verifyLockDoesNotSurpassLockingCap_returns_false()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+        when(activations.isActive(ConsensusRule.RSKIP134)).thenReturn(true);\n+\n+        BtcLockSender btcLockSender = mock(BtcLockSender.class);\n+        BtcLockSenderProvider btcLockSenderProvider = mock(BtcLockSenderProvider.class);\n+        when(btcLockSenderProvider.tryGetBtcLockSender(any())).thenReturn(Optional.of(btcLockSender));\n+\n+        Repository repository = mock(Repository.class);\n+        when(repository.getBalance(any())).thenReturn(co.rsk.core.Coin.valueOf(1));\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            btcLockSenderProvider,\n+            repository,\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Coin.COIN).when(bridgeSupport).getLockingCap();\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(-2, result);\n+    }\n+\n+    @Test\n+    public void registerBtcTransfer_OK()\n+        throws RegisterBtcTransferException, IOException, BlockStoreException, RegisterBtcTransactionException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n+\n+        Context btcContext = mock(Context.class);\n+        when(btcContext.getParams()).thenReturn(bridgeConstants.getBtcParams());\n+\n+        BridgeSupport bridgeSupport = spy(new BridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            btcContext,\n+            mock(FederationSupport.class),\n+            mock(BtcBlockStoreWithCache.Factory.class),\n+            activations\n+        ));\n+\n+        doReturn(bridgeConstants.getGenesisFederation()).when(bridgeSupport).getActiveFederation();\n+        doReturn(true).when(bridgeSupport).validationsForRegisterBtcTransaction(any(), anyInt(), any(), any());\n+        doReturn(Sha256Hash.of(new byte [1])).when(bridgeSupport).getFastBridgeDerivationHash(\n+            any(Sha256Hash.class),\n+            any(Address.class),\n+            any(Address.class),\n+            any(RskAddress.class)\n+        );\n+\n+        Address btcAddress = Address.fromBase58(\n+            btcParams,\n+            \"n3PLxDiwWqa5uH7fSbHCxS6VAjD9Y7Rwkj\"\n+        );\n+\n+        ECKey key = ECKey.fromPublicOnly(new BtcECKey().getPubKey());\n+        RskAddress lbcAddress = new RskAddress(key.getAddress());\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            bridgeConstants.getGenesisFederation().getRedeemScript(),\n+            Sha256Hash.of(new byte[1])\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(Coin.COIN, fastBridgeFedAddress);\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        byte[] pmtSerialized = Hex.decode(\"ab\");\n+        InternalTransaction rskTx = new InternalTransaction(null, 0, 0, null, null, null, null, null, null, null, null);\n+\n+        int result = bridgeSupport.registerBtcTransfer(\n+            rskTx,\n+            tx.bitcoinSerialize(),\n+            100,\n+            pmtSerialized,\n+            Sha256Hash.ZERO_HASH,\n+            btcAddress,\n+            lbcAddress,\n+            btcAddress,\n+            true\n+        );\n+\n+        Assert.assertEquals(1, result);\n+    }\n+\n+    @Test\n+    public void getUTXOsForAddress() {", "originalCommit": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\nindex 927eb7eef..7b718ebb4 100644\n--- a/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n+++ b/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java\n\n@@ -5340,7 +5340,7 @@ public class BridgeSupportTest {\n     }\n \n     @Test\n-    public void getUTXOsForAddress() {\n+    public void getUTXOsForAddress_OK() {\n         ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n         when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDg0MA==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517604840", "bodyText": "why this function is protected?", "author": "pamgonzalez", "createdAt": "2020-11-04T20:14:19Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2081,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    protected WalletProvider createWallet() {", "originalCommit": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwOTg1Mw==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517609853", "bodyText": "Could be private agree", "author": "guidohernan93", "createdAt": "2020-11-04T20:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDg0MA=="}], "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 3a75039ac..8663f9247 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2166,7 +2153,7 @@ public class BridgeSupport {\n         return 1;  //TODO: Includes logic\n     }\n \n-    protected WalletProvider createWallet() {\n+    private WalletProvider createWallet() {\n         return (BtcTransaction a, Address b) -> {\n             List<UTXO> utxosList = getUTXOsForAddress(a, b);\n             return getFastBridgeWallet(btcContext, utxosList);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwODI5MQ==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517608291", "bodyText": "I think it does not meet the code standards", "author": "pamgonzalez", "createdAt": "2020-11-04T20:21:00Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2222,8 +2462,8 @@ private boolean verifyLockDoesNotSurpassLockingCap(BtcTransaction btcTx, Address\n         return false;\n     }\n \n-    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(BtcTransaction btcTx, Address senderBtcAddress, boolean isFastBridgeCompatible) throws IOException {\n-\n+    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(\n+        BtcTransaction btcTx, Address refundingBtcAddress, boolean isFastBridgeCompatible) throws IOException {", "originalCommit": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwOTk0Ng==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r517609946", "bodyText": "This method is no longer nedeed", "author": "guidohernan93", "createdAt": "2020-11-04T20:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwODI5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 3a75039ac..8663f9247 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2462,32 +2449,6 @@ public class BridgeSupport {\n         return false;\n     }\n \n-    private Optional<ReleaseTransactionBuilder.BuildResult> getRefundingTransaction(\n-        BtcTransaction btcTx, Address refundingBtcAddress, boolean isFastBridgeCompatible) throws IOException {\n-        // Build the list of UTXOs in the BTC transaction sent to either the active\n-        // or retiring federation\n-        List<UTXO> utxosToUs = btcTx.getWalletOutputs(getNoSpendWalletForLiveFederations(isFastBridgeCompatible)).stream()\n-                .map(output ->\n-                        new UTXO(\n-                                btcTx.getHash(),\n-                                output.getIndex(),\n-                                output.getValue(),\n-                                0,\n-                                btcTx.isCoinBase(),\n-                                output.getScriptPubKey()\n-                        )\n-                ).collect(Collectors.toList());\n-        // Use the list of UTXOs to build a transaction builder\n-        // for the return btc transaction generation\n-        ReleaseTransactionBuilder txBuilder = new ReleaseTransactionBuilder(\n-                btcContext.getParams(),\n-                getUTXOBasedWalletForLiveFederations(utxosToUs, isFastBridgeCompatible),\n-                refundingBtcAddress,\n-                getFeePerKb()\n-        );\n-        return txBuilder.buildEmptyWalletTo(refundingBtcAddress);\n-    }\n-\n     private Coin getBtcLockedInFederation() {\n         Coin maxRbtc = this.bridgeConstants.getMaxRbtc();\n         Coin currentBridgeBalance = rskRepository.getBalance(PrecompiledContracts.BRIDGE_ADDR).toBitcoin();\n"}}, {"oid": "e7c52562dc083831ee9b8827ad79706b27034c2e", "url": "https://github.com/rsksmart/rskj/commit/e7c52562dc083831ee9b8827ad79706b27034c2e", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests", "committedDate": "2020-11-05T12:45:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyMjg2NA==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518022864", "bodyText": "Bridge should not throw any of these errors. They should be catched and rethrow as RunTime (at most)...", "author": "josedahlquist", "createdAt": "2020-11-05T12:44:41Z", "path": "rskj-core/src/main/java/co/rsk/peg/Bridge.java", "diffHunk": "@@ -1095,17 +1095,17 @@ public boolean hasBtcBlockCoinbaseTransactionInformation(Object[] args) {\n     }\n \n     public int registerBtcTransfer(Object[] args)\n-    {\n+        throws RegisterBtcTransferException, BlockStoreException, IOException, RegisterBtcTransactionException {", "originalCommit": "849cf6ad55a1e8ab1d1dd516a6cd06a27b88d29f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "922e1987c8211b9196f02eb17955c0fb97e58170", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/Bridge.java b/rskj-core/src/main/java/co/rsk/peg/Bridge.java\nindex 6e70585a3..b1711d1bd 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/Bridge.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/Bridge.java\n\n@@ -1094,8 +1094,7 @@ public class Bridge extends PrecompiledContracts.PrecompiledContract {\n         return bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(blockHash);\n     }\n \n-    public int registerBtcTransfer(Object[] args)\n-        throws RegisterBtcTransferException, BlockStoreException, IOException, RegisterBtcTransactionException {\n+    public int registerBtcTransfer(Object[] args) {\n         logger.trace(\"registerBtcTransfer\");\n \n         byte[] btcTxSerialized = (byte[]) args[0];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyNzgxNA==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518027814", "bodyText": "The return code shouldn't be the same, we should probably review the usage of return codes in the RSKIP", "author": "josedahlquist", "createdAt": "2020-11-05T12:53:24Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;", "originalCommit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1MDgxNw==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518050817", "bodyText": "Will be discussed on https://rsklabs.atlassian.net/browse/RFS-891", "author": "guidohernan93", "createdAt": "2020-11-05T13:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyNzgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "922e1987c8211b9196f02eb17955c0fb97e58170", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 8663f9247..22d204b50 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2095,7 +2095,7 @@ public class BridgeSupport {\n                 ByteUtil.toHexString(btcTxHash.getBytes())\n             );\n             logger.warn(errorMessage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+            throw new RegisterBtcTransferValidationException(errorMessage);\n         }\n \n         BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyODIzNw==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518028237", "bodyText": "The method doesn't return a Wallet but a WalletProvider, and it creates a fast bridge wallet, please rename the method", "author": "josedahlquist", "createdAt": "2020-11-05T12:54:10Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private WalletProvider createWallet() {", "originalCommit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "922e1987c8211b9196f02eb17955c0fb97e58170", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 8663f9247..22d204b50 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2095,7 +2095,7 @@ public class BridgeSupport {\n                 ByteUtil.toHexString(btcTxHash.getBytes())\n             );\n             logger.warn(errorMessage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+            throw new RegisterBtcTransferValidationException(errorMessage);\n         }\n \n         BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAyOTkwMg==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518029902", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{\n          \n          \n            \n                protected Coin getAmountToLiveFederations(BtcTransaction btcTx) throws IOException{", "author": "josedahlquist", "createdAt": "2020-11-05T12:56:42Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -2072,12 +2068,203 @@ public int registerBtcTransfer(\n             Sha256Hash derivationArgumentsHash,\n             Address userRefundAddress,\n             RskAddress lbcAddress,\n-            Address lpbtcAddress,\n-            boolean executionStatus\n-    ) {\n+            Address lpBtcAddress,\n+            boolean shouldTransferToContract\n+    )\n+        throws BlockStoreException, RegisterBtcTransferException, IOException, RegisterBtcTransactionException {\n+        if (!BridgeUtils.isContractTx(rskTx)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] Transaction not a contract\",\n+                ByteUtil.toHexString(rskTx.getHash().getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferContractValidationException(errorMessage);\n+        }\n+\n+        Context.propagate(btcContext);\n+        Sha256Hash btcTxHash = BtcTransactionFormatUtils.calculateBtcTxHash(btcTxSerialized);\n+\n+        // Check the tx was not already processed\n+        if (isAlreadyBtcTxHashProcessed(btcTxHash)) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        if (!validationsForRegisterBtcTransaction(btcTxHash, height, pmtSerialized, btcTxSerialized)) {\n+            String errorMessage = String.format(\n+                \"[registerBtcTransfer] [rskTx:%s] error during validationsForRegisterBtcTransaction\",\n+                ByteUtil.toHexString(btcTxHash.getBytes())\n+            );\n+            logger.warn(errorMessage);\n+            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+        }\n+\n+        BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n+        btcTx.verify();\n+\n+        // Check again that the tx was not already processed but making sure to use the txid (no witness)\n+        if (isAlreadyBtcTxHashProcessed(btcTx.getHash(false))) {\n+            throw new RegisterBtcTransactionException(\"Transaction already processed\");\n+        }\n+\n+        Sha256Hash fastBridgeDerivationHash = getFastBridgeDerivationHash(\n+            derivationArgumentsHash,\n+            userRefundAddress,\n+            lpBtcAddress,\n+            lbcAddress\n+        );\n+\n+        Script fastBridgeRedeemScript = RedeemScriptParser.createMultiSigFastBridgeRedeemScript(\n+            getActiveFederation().getRedeemScript(),\n+            fastBridgeDerivationHash\n+        );\n+\n+        Script fastBridgeP2SH = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+\n+        Address fastBridgeFedAddress =\n+            Address.fromP2SHScript(bridgeConstants.getBtcParams(), fastBridgeP2SH);\n+\n+        Coin totalAmount = getAmountSentToAddress(btcTx, fastBridgeFedAddress);\n+\n+        if (provider.isFastBridgeFederationDerivationHashUsed(fastBridgeDerivationHash)) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] derivationArgumentsHash is already \"\n+                + \"saved in BridgeStorageProvider\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!shouldTransferToContract) {\n+            logger.warn(\"[registerBtcTransfer] [btcTxHash:{}] shouldTransferToContract is set as False\",\n+                btcTxHash\n+            );\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, userRefundAddress, rskTx, totalAmount, walletProvider);\n+            return -1;\n+        }\n+\n+        if (!verifyLockDoesNotSurpassLockingCap(btcTx, null, totalAmount)) {\n+            WalletProvider walletProvider = createWallet();\n+            generateRejectionRelease(btcTx, lpBtcAddress, rskTx, totalAmount, walletProvider);\n+            return -2;\n+        }\n+\n         return 1;  //TODO: Includes logic\n     }\n \n+    private WalletProvider createWallet() {\n+        return (BtcTransaction a, Address b) -> {\n+            List<UTXO> utxosList = getUTXOsForAddress(a, b);\n+            return getFastBridgeWallet(btcContext, utxosList);\n+        };\n+    }\n+\n+    protected List<UTXO> getUTXOsForAddress(BtcTransaction btcTx, Address btcAddress) {\n+        List<UTXO> utxosList = new ArrayList<>();\n+        for (TransactionOutput o : btcTx.getOutputs()) {\n+            if (o.getScriptPubKey().getToAddress(bridgeConstants.getBtcParams()).equals(btcAddress)) {\n+                utxosList.add(\n+                    new UTXO(\n+                        btcTx.getHash(),\n+                        o.getIndex(),\n+                        o.getValue(),\n+                        0,\n+                        btcTx.isCoinBase(),\n+                        o.getScriptPubKey()\n+                    )\n+                );\n+            }\n+        }\n+\n+        return utxosList;\n+    }\n+\n+    protected Wallet getFastBridgeWallet(Context btcContext, List<UTXO> utxos) {\n+        Wallet wallet = new Wallet(btcContext);\n+        RskUTXOProvider utxoProvider = new RskUTXOProvider(btcContext.getParams(), utxos);\n+        wallet.setUTXOProvider(utxoProvider);\n+        wallet.setCoinSelector(new RskAllowUnconfirmedCoinSelector());\n+        return wallet;\n+    }\n+\n+    protected Sha256Hash getFastBridgeDerivationHash(\n+        Sha256Hash derivationArgumentsHash,\n+        Address userRefundAddress,\n+        Address lpBtcAddress,\n+        RskAddress lbcAddress\n+    ) {\n+        byte[] fastBridgeDerivationHashData = derivationArgumentsHash.getBytes();\n+        byte[] userRefundAddressBytes = userRefundAddress.getHash160();\n+        byte[] lbcAddressBytes = lbcAddress.getBytes();\n+        byte[] lpBtcAddressBytes = lpBtcAddress.getHash160();\n+\n+        byte[] result = new byte[fastBridgeDerivationHashData.length +\n+            userRefundAddressBytes.length + lpBtcAddressBytes.length + lbcAddressBytes.length];\n+\n+        int dstPosition = 0;\n+\n+        System.arraycopy(\n+            fastBridgeDerivationHashData,\n+            0,\n+            result,\n+            dstPosition,\n+            fastBridgeDerivationHashData.length\n+        );\n+\n+        dstPosition += fastBridgeDerivationHashData.length;\n+\n+        System.arraycopy(\n+            userRefundAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            userRefundAddressBytes.length\n+        );\n+\n+        dstPosition += userRefundAddressBytes.length;\n+\n+        System.arraycopy(\n+            lbcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lbcAddressBytes.length\n+        );\n+\n+        dstPosition += lbcAddressBytes.length;\n+\n+        System.arraycopy(\n+            lpBtcAddressBytes,\n+            0,\n+            result,\n+            dstPosition,\n+            lpBtcAddressBytes.length\n+        );\n+\n+        return Sha256Hash.of(result);\n+    }\n+\n+    protected Coin getAmountToActiveFederation(BtcTransaction btcTx) throws IOException{", "originalCommit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "922e1987c8211b9196f02eb17955c0fb97e58170", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\nindex 8663f9247..22d204b50 100644\n--- a/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n+++ b/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java\n\n@@ -2095,7 +2095,7 @@ public class BridgeSupport {\n                 ByteUtil.toHexString(btcTxHash.getBytes())\n             );\n             logger.warn(errorMessage);\n-            throw new RegisterBtcTransferRegisterBtcTransValidationException(errorMessage);\n+            throw new RegisterBtcTransferValidationException(errorMessage);\n         }\n \n         BtcTransaction btcTx = new BtcTransaction(bridgeConstants.getBtcParams(), btcTxSerialized);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMDE4OQ==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518030189", "bodyText": "not used?", "author": "josedahlquist", "createdAt": "2020-11-05T12:57:12Z", "path": "rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTransferException{", "originalCommit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "922e1987c8211b9196f02eb17955c0fb97e58170", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java b/rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java\ndeleted file mode 100644\nindex 2829b0524..000000000\n--- a/rskj-core/src/main/java/co/rsk/peg/GetSenderBtcAddressSenderNotPresentException.java\n+++ /dev/null\n\n@@ -1,7 +0,0 @@\n-package co.rsk.peg;\n-\n-public class GetSenderBtcAddressSenderNotPresentException extends RegisterBtcTransferException{\n-    public GetSenderBtcAddressSenderNotPresentException(String message) {\n-        super(message);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMDc4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1350#discussion_r518030787", "bodyText": "the name of the exception is kind of confusing", "author": "josedahlquist", "createdAt": "2020-11-05T12:58:12Z", "path": "rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;\n+\n+public class RegisterBtcTransferRegisterBtcTransValidationException extends RegisterBtcTransferException{", "originalCommit": "e7c52562dc083831ee9b8827ad79706b27034c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "922e1987c8211b9196f02eb17955c0fb97e58170", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java b/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java\ndeleted file mode 100644\nindex f11261775..000000000\n--- a/rskj-core/src/main/java/co/rsk/peg/RegisterBtcTransferRegisterBtcTransValidationException.java\n+++ /dev/null\n\n@@ -1,7 +0,0 @@\n-package co.rsk.peg;\n-\n-public class RegisterBtcTransferRegisterBtcTransValidationException extends RegisterBtcTransferException{\n-    public RegisterBtcTransferRegisterBtcTransValidationException(String message) {\n-        super(message);\n-    }\n-}\n"}}, {"oid": "922e1987c8211b9196f02eb17955c0fb97e58170", "url": "https://github.com/rsksmart/rskj/commit/922e1987c8211b9196f02eb17955c0fb97e58170", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests", "committedDate": "2020-11-05T13:30:46Z", "type": "forcePushed"}, {"oid": "3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "url": "https://github.com/rsksmart/rskj/commit/3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests", "committedDate": "2020-11-05T15:39:20Z", "type": "commit"}, {"oid": "3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "url": "https://github.com/rsksmart/rskj/commit/3ba9d46dbd0afb3cbaa59d249cdc0755610d54a3", "message": "Fixes on method registerBtcTransfer\n\n- Refactor generateRejectionRelease to receive a lambda function for creating Wallet\n- Add method to create fast bridge wallet\n- Add method to get list of utxos for a given BTC address\n- Update unit tests", "committedDate": "2020-11-05T15:39:20Z", "type": "forcePushed"}]}