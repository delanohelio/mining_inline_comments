{"pr_number": 1184, "pr_title": "Light client capabilities", "pr_createdAt": "2020-03-05T15:16:09Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1184", "timeline": [{"oid": "bd2278383b2685427ec1bbb74dd5d14a2994ec27", "url": "https://github.com/rsksmart/rskj/commit/bd2278383b2685427ec1bbb74dd5d14a2994ec27", "message": "light client added as part of the handshake, test has been modified too", "committedDate": "2020-03-05T15:23:49Z", "type": "forcePushed"}, {"oid": "c21a0e614e0a738ae87c037b809784828b85f4a0", "url": "https://github.com/rsksmart/rskj/commit/c21a0e614e0a738ae87c037b809784828b85f4a0", "message": "light client added as part of the handshake, test has been modified too", "committedDate": "2020-03-05T16:22:53Z", "type": "forcePushed"}, {"oid": "c4f8a5397bf7c9e3d821d21668ae161db5649c4e", "url": "https://github.com/rsksmart/rskj/commit/c4f8a5397bf7c9e3d821d21668ae161db5649c4e", "message": "LightClientMessage added", "committedDate": "2020-03-09T17:12:18Z", "type": "forcePushed"}, {"oid": "6a5524e48d8dc5edea4e8c89e1ac3aeee56e215c", "url": "https://github.com/rsksmart/rskj/commit/6a5524e48d8dc5edea4e8c89e1ac3aeee56e215c", "message": "lightprocessor added", "committedDate": "2020-03-11T15:10:48Z", "type": "forcePushed"}, {"oid": "011db74fa192c8bda0cefb244fd69fa3883c58b5", "url": "https://github.com/rsksmart/rskj/commit/011db74fa192c8bda0cefb244fd69fa3883c58b5", "message": "changes in order activateLC ops", "committedDate": "2020-03-11T15:35:28Z", "type": "forcePushed"}, {"oid": "2380eba07828e7c998d3cc2bf7ce1d876c1dde7d", "url": "https://github.com/rsksmart/rskj/commit/2380eba07828e7c998d3cc2bf7ce1d876c1dde7d", "message": "light processor deleted from rsk messages", "committedDate": "2020-03-11T18:35:08Z", "type": "forcePushed"}, {"oid": "33f663912268da3c0031d9216bf6c00bc5150fe6", "url": "https://github.com/rsksmart/rskj/commit/33f663912268da3c0031d9216bf6c00bc5150fe6", "message": "light processor deleted from rsk messages", "committedDate": "2020-03-11T18:45:56Z", "type": "forcePushed"}, {"oid": "c445bcf15544ad047c9e1cedefde93936650e0a7", "url": "https://github.com/rsksmart/rskj/commit/c445bcf15544ad047c9e1cedefde93936650e0a7", "message": "light processor deleted from rsk messages", "committedDate": "2020-03-16T16:07:17Z", "type": "forcePushed"}, {"oid": "b158b61ef9e7966268501e1d416aa039f3864d1b", "url": "https://github.com/rsksmart/rskj/commit/b158b61ef9e7966268501e1d416aa039f3864d1b", "message": "light processor deleted from rsk messages", "committedDate": "2020-03-16T17:51:03Z", "type": "forcePushed"}, {"oid": "032c313bb33a874840089edc1e7afe5187e9af61", "url": "https://github.com/rsksmart/rskj/commit/032c313bb33a874840089edc1e7afe5187e9af61", "message": "Status message (#1200)\n\n* change test message for status message adding the latest\r\n\r\n* create and test StatusMessage, also addd it to lightProcessor and lightClientHandler, processStatusMessage is not implemented\r\n\r\n* added LightSyncProcessoras manager for sync messaged, tested processStatus\r\n\r\n* lightPeer added as channel wrapper\r\n\r\n* Create Status as class\r\n\r\n* processing blockheader after status. Also tested", "committedDate": "2020-04-15T15:17:59Z", "type": "forcePushed"}, {"oid": "f4f5af422779035adf2c354c2f263a651438bf9f", "url": "https://github.com/rsksmart/rskj/commit/f4f5af422779035adf2c354c2f263a651438bf9f", "message": "Fix and enhance testing (#1220)\n\n* tests cases in which RLP desencode as null, it's when message fields are in zero\r\n\r\n* pipeline run", "committedDate": "2020-04-20T14:13:54Z", "type": "forcePushed"}, {"oid": "5bb5e528312e5675a3168403ec4188f3598d8432", "url": "https://github.com/rsksmart/rskj/commit/5bb5e528312e5675a3168403ec4188f3598d8432", "message": "deleted unused logger in LightClientHandler", "committedDate": "2020-04-21T18:08:16Z", "type": "forcePushed"}, {"oid": "4a9efe993112373870eb2ed68d19cc0595a8850a", "url": "https://github.com/rsksmart/rskj/commit/4a9efe993112373870eb2ed68d19cc0595a8850a", "message": "TxRelay added as option in Status message handshake (#1224)\n\n* added txrelay as option in StatusMessage\r\n\r\n* txRelay added as lightpeer data", "committedDate": "2020-04-24T15:02:19Z", "type": "forcePushed"}, {"oid": "e8fdf0a655582af76d996ffeae908880d11abdb7", "url": "https://github.com/rsksmart/rskj/commit/e8fdf0a655582af76d996ffeae908880d11abdb7", "message": "TxRelay added as option in Status message handshake (#1224)\n\n* added txrelay as option in StatusMessage\r\n\r\n* txRelay added as lightpeer data", "committedDate": "2020-04-28T12:49:50Z", "type": "forcePushed"}, {"oid": "ebf7915690e101cb123b308b0b5ccc13a89a1584", "url": "https://github.com/rsksmart/rskj/commit/ebf7915690e101cb123b308b0b5ccc13a89a1584", "message": "TxRelay added as option in Status message handshake (#1224)\n\n* added txrelay as option in StatusMessage\r\n\r\n* txRelay added as lightpeer data", "committedDate": "2020-04-28T12:51:03Z", "type": "forcePushed"}, {"oid": "8c375b4d2c8062301cf466baf83bbb67e8e89dbf", "url": "https://github.com/rsksmart/rskj/commit/8c375b4d2c8062301cf466baf83bbb67e8e89dbf", "message": "TxRelay added as option in Status message handshake (#1224)\n\n* added txrelay as option in StatusMessage\r\n\r\n* txRelay added as lightpeer data", "committedDate": "2020-04-28T12:58:55Z", "type": "forcePushed"}, {"oid": "88fa936b791a819a2a6a9aedb3e4d7ec4d966b71", "url": "https://github.com/rsksmart/rskj/commit/88fa936b791a819a2a6a9aedb3e4d7ec4d966b71", "message": "TxRelay added as option in Status message handshake (#1224)\n\n* added txrelay as option in StatusMessage\r\n\r\n* txRelay added as lightpeer data", "committedDate": "2020-04-29T13:42:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNDY4Ng==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431304686", "bodyText": "This seems to be for testing only, since the getBlocks() method is only called from test code, maybe it merits a comment or a TODO.", "author": "nicops", "createdAt": "2020-05-27T17:07:01Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightPeer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.net.MessageQueue;\n+import org.ethereum.net.message.Message;\n+import org.ethereum.net.message.ReasonCode;\n+import org.ethereum.net.server.Channel;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class LightPeer {\n+\n+    private final LinkedList<BlockHeader> blockHeaders;\n+    private Channel channel;\n+    private MessageQueue msgQueue;\n+\n+    public LightPeer(Channel channel, MessageQueue msgQueue) {\n+        this.channel = channel;\n+        this.msgQueue = msgQueue;\n+        this.blockHeaders = new LinkedList<>();\n+    }\n+\n+    public String getPeerIdShort() {\n+        return channel.getPeerIdShort();\n+    }\n+\n+    public void sendMessage(Message message) {\n+        msgQueue.sendMessage(message);\n+    }\n+\n+    public void disconnect(ReasonCode reasonCode) {\n+        msgQueue.disconnect(reasonCode);\n+    }\n+\n+    public void receivedBlock(BlockHeader blockHeader) {\n+        blockHeaders.add(blockHeader);", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MDY3Mw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431390673", "bodyText": "Received block headers will be stored in a header chain. These methods together with the block header list in each Light peer will disappear.", "author": "julianlen", "createdAt": "2020-05-27T19:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNDY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightPeer.java b/rskj-core/src/main/java/co/rsk/net/light/LightPeer.java\ndeleted file mode 100644\nindex 676e623d2..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightPeer.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light;\n-\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.net.MessageQueue;\n-import org.ethereum.net.message.Message;\n-import org.ethereum.net.message.ReasonCode;\n-import org.ethereum.net.server.Channel;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-public class LightPeer {\n-\n-    private final LinkedList<BlockHeader> blockHeaders;\n-    private Channel channel;\n-    private MessageQueue msgQueue;\n-\n-    public LightPeer(Channel channel, MessageQueue msgQueue) {\n-        this.channel = channel;\n-        this.msgQueue = msgQueue;\n-        this.blockHeaders = new LinkedList<>();\n-    }\n-\n-    public String getPeerIdShort() {\n-        return channel.getPeerIdShort();\n-    }\n-\n-    public void sendMessage(Message message) {\n-        msgQueue.sendMessage(message);\n-    }\n-\n-    public void disconnect(ReasonCode reasonCode) {\n-        msgQueue.disconnect(reasonCode);\n-    }\n-\n-    public void receivedBlock(BlockHeader blockHeader) {\n-        blockHeaders.add(blockHeader);\n-    }\n-\n-    public List<BlockHeader> getBlocks() {\n-        return new LinkedList<>(blockHeaders);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNDg4OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431304889", "bodyText": "Since there is another MessageVisitor, even if it is on a different namespace, I'm tempted to change the name, (MessageVisitor isn't on itself very meaningful either), maybe to something like LightClientMessageVisitor?", "author": "nicops", "createdAt": "2020-05-27T17:07:21Z", "path": "rskj-core/src/main/java/co/rsk/net/light/MessageVisitor.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2019 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.*;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/04/20.\n+ */\n+public class MessageVisitor {", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/MessageVisitor.java b/rskj-core/src/main/java/co/rsk/net/light/MessageVisitor.java\ndeleted file mode 100644\nindex 3a394fcb8..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/MessageVisitor.java\n+++ /dev/null\n\n@@ -1,125 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2019 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light;\n-\n-import co.rsk.net.eth.LightClientHandler;\n-import co.rsk.net.light.message.*;\n-import io.netty.channel.ChannelHandlerContext;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 21/04/20.\n- */\n-public class MessageVisitor {\n-    private static final Logger logger = LoggerFactory.getLogger(\"lightnet\");\n-    private final LightPeer lightPeer;\n-    private final LightSyncProcessor lightSyncProcessor;\n-    private final LightProcessor lightProcessor;\n-    private final LightClientHandler handler;\n-    private final ChannelHandlerContext ctx;\n-\n-    public MessageVisitor(LightPeer lightPeer, LightProcessor lightProcessor, LightSyncProcessor lightSyncProcessor,\n-                          ChannelHandlerContext ctx, LightClientHandler handler) {\n-        this.lightProcessor = lightProcessor;\n-        this.lightSyncProcessor = lightSyncProcessor;\n-        this.lightPeer = lightPeer;\n-        this.handler = handler;\n-        this.ctx = ctx;\n-    }\n-\n-    public void apply(StatusMessage msg) {\n-        logger.debug(\"Read message: {} STATUS\", msg);\n-        lightSyncProcessor.processStatusMessage(msg, lightPeer, ctx, handler);\n-    }\n-\n-    public void apply(GetBlockReceiptsMessage msg) {\n-        logger.debug(\"Read message: {} GET_BLOCK_RECEIPTS\", msg);\n-        lightProcessor.processGetBlockReceiptsMessage(msg.getId(), msg.getBlockHash(), lightPeer);\n-    }\n-\n-    public void apply(BlockReceiptsMessage msg) {\n-        logger.debug(\"Read message: {} BLOCK_RECEIPTS\", msg);\n-        lightProcessor.processBlockReceiptsMessage(msg.getId(), msg.getBlockReceipts(), lightPeer);\n-    }\n-\n-    public void apply(GetTransactionIndexMessage msg){\n-        logger.debug(\"Read message: {} GET_TRANSACTION_INDEX\", msg);\n-        lightProcessor.processGetTransactionIndex(msg.getId(), msg.getTxHash(), lightPeer);\n-    }\n-\n-    public void apply(TransactionIndexMessage msg){\n-        logger.debug(\"Read message: {} TRANSACTION_INDEX\", msg);\n-        lightProcessor.processTransactionIndexMessage(msg.getId(), msg.getBlockNumber(),\n-                msg.getBlockHash(), msg.getTransactionIndex(), lightPeer);\n-    }\n-\n-    public void apply(GetCodeMessage msg){\n-        logger.debug(\"Read message: {} GET_CODE\", msg);\n-        lightProcessor.processGetCodeMessage(msg.getId(), msg.getBlockHash(), msg.getAddress(), lightPeer);\n-    }\n-\n-    public void apply(CodeMessage msg){\n-        logger.debug(\"Read message: {} CODE\", msg);\n-        lightProcessor.processCodeMessage(msg.getId(), msg.getCodeHash(), lightPeer);\n-    }\n-\n-    public void apply(GetAccountsMessage msg){\n-        logger.debug(\"Read message: {} GET_ACCOUNTS\", msg);\n-        lightProcessor.processGetAccountsMessage(msg.getId(), msg.getBlockHash(), msg.getAddressHash(), lightPeer);\n-    }\n-\n-    public void apply(AccountsMessage msg){\n-        logger.debug(\"Read message: {} ACCOUNTS\", msg);\n-        lightProcessor.processAccountsMessage(msg.getId(), msg.getMerkleInclusionProof(),\n-                msg.getNonce(), msg.getBalance(), msg.getCodeHash(), msg.getStorageRoot(), lightPeer);\n-    }\n-\n-    public void apply(GetBlockHeaderMessage msg) {\n-        logger.debug(\"Read message: {} GET_BLOCK_HEADER\", msg);\n-        lightProcessor.processGetBlockHeaderMessage(msg.getId(), msg.getBlockHash(), lightPeer);\n-    }\n-\n-    public void apply(BlockHeaderMessage msg) {\n-        logger.debug(\"Read message: {} BLOCK_HEADER\", msg);\n-        lightSyncProcessor.processBlockHeaderMessage(msg.getId(), msg.getBlockHeader(), lightPeer);\n-    }\n-\n-    public void apply(GetBlockBodyMessage msg) {\n-        logger.debug(\"Read message: {} GET_BLOCK_BODY\", msg);\n-        lightProcessor.processGetBlockBodyMessage(msg.getId(), msg.getBlockHash(), lightPeer);\n-    }\n-\n-    public void apply(BlockBodyMessage msg) {\n-        logger.debug(\"Read message: {} BLOCK_BODY\", msg);\n-        lightProcessor.processBlockBodyMessage(msg.getId(), msg.getUncles(), msg.getTransactions(), lightPeer);\n-    }\n-\n-    public void apply(GetStorageMessage msg) {\n-        logger.debug(\"Read message: {} GET_STORAGE\", msg);\n-        lightProcessor.processGetStorageMessage(msg.getId(), msg.getBlockHash(), msg.getAddressHash(),\n-                msg.getStorageKeyHash(), lightPeer);\n-    }\n-\n-    public void apply(StorageMessage msg) {\n-        logger.debug(\"Read message: {} STORAGE\", msg);\n-        lightProcessor.processStorageMessage(msg.getId(), msg.getMerkleInclusionProof(), msg.getStorageValue(), lightPeer);\n-    }\n-}\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTIxMg==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305212", "bodyText": "Since the calling code that uses this method says \"this works only for testing purposes\", should this method have a similar comment? Or will it make sense later?", "author": "nicops", "createdAt": "2020-05-27T17:07:53Z", "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java", "diffHunk": "@@ -50,4 +51,8 @@ public BlockDifficulty getTotalDifficulty() {\n     public boolean hasLowerTotalDifficultyThan(Status status) {\n         return this.totalDifficulty.compareTo(status.getTotalDifficulty()) < 0;\n     }\n+\n+    public boolean hasLowerDifficultyThan(LightStatus status) {", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5Mzc4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431393787", "bodyText": "That comment points to the \"hasTotalDifficulty\" variable. Not the whole method.", "author": "julianlen", "createdAt": "2020-05-27T19:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTIxMg=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java b/rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java\nindex 752cffc9f..ebb68e724 100644\n--- a/rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java\n+++ b/rskj-core/src/main/java/co/rsk/core/bc/BlockChainStatus.java\n\n@@ -51,8 +50,4 @@ public class BlockChainStatus {\n     public boolean hasLowerTotalDifficultyThan(Status status) {\n         return this.totalDifficulty.compareTo(status.getTotalDifficulty()) < 0;\n     }\n-\n-    public boolean hasLowerDifficultyThan(LightStatus status) {\n-        return this.totalDifficulty.compareTo(status.getTotalDifficulty()) < 0;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTY2NQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305665", "bodyText": "This comment seems off. That's not what the BlockStore does, or is it?", "author": "nicops", "createdAt": "2020-05-27T17:08:40Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwMjg1OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431802859", "bodyText": "You're right, this seems to be an old comment, we should remove it, it makes no sense there", "author": "smcsicardi", "createdAt": "2020-05-28T12:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\nindex 796119eeb..e442ee40a 100644\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n\n@@ -1,222 +1,4 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package co.rsk.net.light;\n \n-import co.rsk.core.RskAddress;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.db.RepositorySnapshot;\n-import co.rsk.db.RepositoryLocator;\n-import co.rsk.net.light.message.*;\n-import org.ethereum.core.*;\n-import org.ethereum.net.message.Message;\n-import org.bouncycastle.util.encoders.Hex;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.db.TransactionInfo;\n-import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nonnull;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n- */\n public class LightProcessor {\n-    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n-    // keep tabs on which nodes know which blocks.\n-    private final BlockStore blockStore;\n-    private final RepositoryLocator repositoryLocator;\n-    private final Blockchain blockchain;\n-\n-    public LightProcessor(@Nonnull final Blockchain blockchain,\n-                          @Nonnull final BlockStore blockStore,\n-                          @Nonnull final RepositoryLocator repositoryLocator) {\n-        this.blockchain = blockchain;\n-        this.blockStore = blockStore;\n-        this.repositoryLocator = repositoryLocator;\n-    }\n-    /**\n-     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n-     * @param requestId the id of the request\n-     * @param blockHash   the requested block hash.\n-     * @param lightPeer\n-     */\n-    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-\n-        for (Transaction tx :  block.getTransactionsList()) {\n-            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n-            receipts.add(txInfo.getReceipt());\n-        }\n-\n-        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n-        lightPeer.sendMessage(responseMessage);\n-    }\n-\n-    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n-    }\n-\n-    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n-        logger.debug(\"Get Transaction Index Message Received\");\n-\n-        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n-\n-        if (txinfo == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        byte[] blockHash = txinfo.getBlockHash();\n-        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n-        long txIndex = txinfo.getIndex();\n-\n-        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n-    }\n-\n-    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        String addressLog = Hex.toHexString(address);\n-        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress addr = new RskAddress(address);\n-        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n-\n-        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Code processing\");\n-    }\n-\n-    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n-        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        AccountState state = repositorySnapshot.getAccountState(address);\n-\n-        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),\n-                state.getBalance().asBigInteger().longValue(), repositorySnapshot.getCodeHash(address).getBytes(),\n-                repositorySnapshot.getRoot());\n-\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processAccountsMessage(long id, byte[] merkleInclusionProof, long nonce, long balance,\n-                                       byte[] codeHash, byte[] storageRoot, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported AccountsMessage processing\");\n-    }\n-\n-    public void processGetBlockHeaderMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, blockHashLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockHeaderMessage response = new BlockHeaderMessage(id, block.getHeader());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processGetBlockBodyMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, logBlockHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockBodyMessage response = new BlockBodyMessage(id, block.getTransactionsList(), block.getUncleList());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processBlockBodyMessage(long id, List<BlockHeader> uncles, List<Transaction> transactions, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockBody processing\");\n-    }\n-\n-    public void processGetStorageMessage(long id, byte[] blockHash, byte[] addressHash, byte[] storageKeyHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        String logAddressHash = Hex.toHexString(addressHash);\n-        String logStrorageKey = Hex.toHexString(storageKeyHash);\n-        logger.trace(\"Processing storage request {} block {} address {} storage key {}\", id,\n-                logBlockHash, logAddressHash, logStrorageKey);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        byte[] storageValue = repositorySnapshot.getStorageBytes(address, DataWord.valueOf(storageKeyHash));\n-\n-        if (storageValue == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        StorageMessage response = new StorageMessage(id, new byte[] {0x00}, storageValue);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processStorageMessage(long id, byte[] merkleInclusionProof, byte[] storageValue, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Storage processing\");\n-    }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTgwNw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305807", "bodyText": "For this and all other methods, will this be the long term solution, to respond nothing? In https://openethereum.github.io/wiki/The-Parity-Light-Protocol-%28PIP%29 there is a mention of exclusion proofs, would that apply here? Alternatively, should we account for spam in some way?", "author": "nicops", "createdAt": "2020-05-27T17:08:54Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5NjQ5Ng==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431396496", "bodyText": "In the long term, a light client will have available an amount of \"credits\". Once these credits are finished, the light peer cannot request anything to the full node.", "author": "julianlen", "createdAt": "2020-05-27T19:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\nindex 796119eeb..e442ee40a 100644\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n\n@@ -1,222 +1,4 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package co.rsk.net.light;\n \n-import co.rsk.core.RskAddress;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.db.RepositorySnapshot;\n-import co.rsk.db.RepositoryLocator;\n-import co.rsk.net.light.message.*;\n-import org.ethereum.core.*;\n-import org.ethereum.net.message.Message;\n-import org.bouncycastle.util.encoders.Hex;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.db.TransactionInfo;\n-import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nonnull;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n- */\n public class LightProcessor {\n-    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n-    // keep tabs on which nodes know which blocks.\n-    private final BlockStore blockStore;\n-    private final RepositoryLocator repositoryLocator;\n-    private final Blockchain blockchain;\n-\n-    public LightProcessor(@Nonnull final Blockchain blockchain,\n-                          @Nonnull final BlockStore blockStore,\n-                          @Nonnull final RepositoryLocator repositoryLocator) {\n-        this.blockchain = blockchain;\n-        this.blockStore = blockStore;\n-        this.repositoryLocator = repositoryLocator;\n-    }\n-    /**\n-     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n-     * @param requestId the id of the request\n-     * @param blockHash   the requested block hash.\n-     * @param lightPeer\n-     */\n-    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-\n-        for (Transaction tx :  block.getTransactionsList()) {\n-            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n-            receipts.add(txInfo.getReceipt());\n-        }\n-\n-        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n-        lightPeer.sendMessage(responseMessage);\n-    }\n-\n-    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n-    }\n-\n-    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n-        logger.debug(\"Get Transaction Index Message Received\");\n-\n-        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n-\n-        if (txinfo == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        byte[] blockHash = txinfo.getBlockHash();\n-        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n-        long txIndex = txinfo.getIndex();\n-\n-        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n-    }\n-\n-    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        String addressLog = Hex.toHexString(address);\n-        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress addr = new RskAddress(address);\n-        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n-\n-        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Code processing\");\n-    }\n-\n-    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n-        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        AccountState state = repositorySnapshot.getAccountState(address);\n-\n-        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),\n-                state.getBalance().asBigInteger().longValue(), repositorySnapshot.getCodeHash(address).getBytes(),\n-                repositorySnapshot.getRoot());\n-\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processAccountsMessage(long id, byte[] merkleInclusionProof, long nonce, long balance,\n-                                       byte[] codeHash, byte[] storageRoot, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported AccountsMessage processing\");\n-    }\n-\n-    public void processGetBlockHeaderMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, blockHashLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockHeaderMessage response = new BlockHeaderMessage(id, block.getHeader());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processGetBlockBodyMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, logBlockHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockBodyMessage response = new BlockBodyMessage(id, block.getTransactionsList(), block.getUncleList());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processBlockBodyMessage(long id, List<BlockHeader> uncles, List<Transaction> transactions, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockBody processing\");\n-    }\n-\n-    public void processGetStorageMessage(long id, byte[] blockHash, byte[] addressHash, byte[] storageKeyHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        String logAddressHash = Hex.toHexString(addressHash);\n-        String logStrorageKey = Hex.toHexString(storageKeyHash);\n-        logger.trace(\"Processing storage request {} block {} address {} storage key {}\", id,\n-                logBlockHash, logAddressHash, logStrorageKey);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        byte[] storageValue = repositorySnapshot.getStorageBytes(address, DataWord.valueOf(storageKeyHash));\n-\n-        if (storageValue == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        StorageMessage response = new StorageMessage(id, new byte[] {0x00}, storageValue);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processStorageMessage(long id, byte[] merkleInclusionProof, byte[] storageValue, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Storage processing\");\n-    }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTk1OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431305959", "bodyText": "Could this possibly return null?", "author": "nicops", "createdAt": "2020-05-27T17:09:08Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxMTM2OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431411369", "bodyText": "This is weird, all transactions return a receipt, it doesn't matter if the transaction was successful or not.", "author": "julianlen", "createdAt": "2020-05-27T20:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNTk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\nindex 796119eeb..e442ee40a 100644\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n\n@@ -1,222 +1,4 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package co.rsk.net.light;\n \n-import co.rsk.core.RskAddress;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.db.RepositorySnapshot;\n-import co.rsk.db.RepositoryLocator;\n-import co.rsk.net.light.message.*;\n-import org.ethereum.core.*;\n-import org.ethereum.net.message.Message;\n-import org.bouncycastle.util.encoders.Hex;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.db.TransactionInfo;\n-import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nonnull;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n- */\n public class LightProcessor {\n-    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n-    // keep tabs on which nodes know which blocks.\n-    private final BlockStore blockStore;\n-    private final RepositoryLocator repositoryLocator;\n-    private final Blockchain blockchain;\n-\n-    public LightProcessor(@Nonnull final Blockchain blockchain,\n-                          @Nonnull final BlockStore blockStore,\n-                          @Nonnull final RepositoryLocator repositoryLocator) {\n-        this.blockchain = blockchain;\n-        this.blockStore = blockStore;\n-        this.repositoryLocator = repositoryLocator;\n-    }\n-    /**\n-     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n-     * @param requestId the id of the request\n-     * @param blockHash   the requested block hash.\n-     * @param lightPeer\n-     */\n-    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-\n-        for (Transaction tx :  block.getTransactionsList()) {\n-            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n-            receipts.add(txInfo.getReceipt());\n-        }\n-\n-        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n-        lightPeer.sendMessage(responseMessage);\n-    }\n-\n-    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n-    }\n-\n-    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n-        logger.debug(\"Get Transaction Index Message Received\");\n-\n-        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n-\n-        if (txinfo == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        byte[] blockHash = txinfo.getBlockHash();\n-        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n-        long txIndex = txinfo.getIndex();\n-\n-        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n-    }\n-\n-    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        String addressLog = Hex.toHexString(address);\n-        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress addr = new RskAddress(address);\n-        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n-\n-        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Code processing\");\n-    }\n-\n-    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n-        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        AccountState state = repositorySnapshot.getAccountState(address);\n-\n-        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),\n-                state.getBalance().asBigInteger().longValue(), repositorySnapshot.getCodeHash(address).getBytes(),\n-                repositorySnapshot.getRoot());\n-\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processAccountsMessage(long id, byte[] merkleInclusionProof, long nonce, long balance,\n-                                       byte[] codeHash, byte[] storageRoot, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported AccountsMessage processing\");\n-    }\n-\n-    public void processGetBlockHeaderMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, blockHashLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockHeaderMessage response = new BlockHeaderMessage(id, block.getHeader());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processGetBlockBodyMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, logBlockHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockBodyMessage response = new BlockBodyMessage(id, block.getTransactionsList(), block.getUncleList());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processBlockBodyMessage(long id, List<BlockHeader> uncles, List<Transaction> transactions, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockBody processing\");\n-    }\n-\n-    public void processGetStorageMessage(long id, byte[] blockHash, byte[] addressHash, byte[] storageKeyHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        String logAddressHash = Hex.toHexString(addressHash);\n-        String logStrorageKey = Hex.toHexString(storageKeyHash);\n-        logger.trace(\"Processing storage request {} block {} address {} storage key {}\", id,\n-                logBlockHash, logAddressHash, logStrorageKey);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        byte[] storageValue = repositorySnapshot.getStorageBytes(address, DataWord.valueOf(storageKeyHash));\n-\n-        if (storageValue == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        StorageMessage response = new StorageMessage(id, new byte[] {0x00}, storageValue);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processStorageMessage(long id, byte[] merkleInclusionProof, byte[] storageValue, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Storage processing\");\n-    }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjAyMg==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306022", "bodyText": "I would delete this and all the other methods that aren't supported. They don't belong together at all: One thing is to reply to LC queries as a full node, something very different is to consume replies to those queries as a light node. I would also rename the class to reflect this, maybe something like LightClientQueriesResolver (I didn't think this through).", "author": "nicops", "createdAt": "2020-05-27T17:09:15Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\nindex 796119eeb..e442ee40a 100644\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n\n@@ -1,222 +1,4 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package co.rsk.net.light;\n \n-import co.rsk.core.RskAddress;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.db.RepositorySnapshot;\n-import co.rsk.db.RepositoryLocator;\n-import co.rsk.net.light.message.*;\n-import org.ethereum.core.*;\n-import org.ethereum.net.message.Message;\n-import org.bouncycastle.util.encoders.Hex;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.db.TransactionInfo;\n-import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nonnull;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n- */\n public class LightProcessor {\n-    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n-    // keep tabs on which nodes know which blocks.\n-    private final BlockStore blockStore;\n-    private final RepositoryLocator repositoryLocator;\n-    private final Blockchain blockchain;\n-\n-    public LightProcessor(@Nonnull final Blockchain blockchain,\n-                          @Nonnull final BlockStore blockStore,\n-                          @Nonnull final RepositoryLocator repositoryLocator) {\n-        this.blockchain = blockchain;\n-        this.blockStore = blockStore;\n-        this.repositoryLocator = repositoryLocator;\n-    }\n-    /**\n-     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n-     * @param requestId the id of the request\n-     * @param blockHash   the requested block hash.\n-     * @param lightPeer\n-     */\n-    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-\n-        for (Transaction tx :  block.getTransactionsList()) {\n-            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n-            receipts.add(txInfo.getReceipt());\n-        }\n-\n-        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n-        lightPeer.sendMessage(responseMessage);\n-    }\n-\n-    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n-    }\n-\n-    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n-        logger.debug(\"Get Transaction Index Message Received\");\n-\n-        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n-\n-        if (txinfo == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        byte[] blockHash = txinfo.getBlockHash();\n-        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n-        long txIndex = txinfo.getIndex();\n-\n-        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n-    }\n-\n-    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        String addressLog = Hex.toHexString(address);\n-        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress addr = new RskAddress(address);\n-        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n-\n-        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Code processing\");\n-    }\n-\n-    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n-        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        AccountState state = repositorySnapshot.getAccountState(address);\n-\n-        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),\n-                state.getBalance().asBigInteger().longValue(), repositorySnapshot.getCodeHash(address).getBytes(),\n-                repositorySnapshot.getRoot());\n-\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processAccountsMessage(long id, byte[] merkleInclusionProof, long nonce, long balance,\n-                                       byte[] codeHash, byte[] storageRoot, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported AccountsMessage processing\");\n-    }\n-\n-    public void processGetBlockHeaderMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, blockHashLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockHeaderMessage response = new BlockHeaderMessage(id, block.getHeader());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processGetBlockBodyMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, logBlockHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockBodyMessage response = new BlockBodyMessage(id, block.getTransactionsList(), block.getUncleList());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processBlockBodyMessage(long id, List<BlockHeader> uncles, List<Transaction> transactions, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockBody processing\");\n-    }\n-\n-    public void processGetStorageMessage(long id, byte[] blockHash, byte[] addressHash, byte[] storageKeyHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        String logAddressHash = Hex.toHexString(addressHash);\n-        String logStrorageKey = Hex.toHexString(storageKeyHash);\n-        logger.trace(\"Processing storage request {} block {} address {} storage key {}\", id,\n-                logBlockHash, logAddressHash, logStrorageKey);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        byte[] storageValue = repositorySnapshot.getStorageBytes(address, DataWord.valueOf(storageKeyHash));\n-\n-        if (storageValue == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        StorageMessage response = new StorageMessage(id, new byte[] {0x00}, storageValue);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processStorageMessage(long id, byte[] merkleInclusionProof, byte[] storageValue, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Storage processing\");\n-    }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjE4OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306189", "bodyText": "If this is modelled after https://openethereum.github.io/wiki/The-Parity-Light-Protocol-%28PIP%29 then shouldn't this be the bytecode rather than the code hash?", "author": "nicops", "createdAt": "2020-05-27T17:09:33Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n+    }\n+\n+    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n+        logger.debug(\"Get Transaction Index Message Received\");\n+\n+        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n+\n+        if (txinfo == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        byte[] blockHash = txinfo.getBlockHash();\n+        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n+        long txIndex = txinfo.getIndex();\n+\n+        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n+    }\n+\n+    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        String addressLog = Hex.toHexString(address);\n+        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress addr = new RskAddress(address);\n+        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n+\n+        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDk4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431414987", "bodyText": "@smcsicardi", "author": "julianlen", "createdAt": "2020-05-27T20:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwMzcyMw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431803723", "bodyText": "Totally right! Clear mistake on my part, will change it now.", "author": "smcsicardi", "createdAt": "2020-05-28T12:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjE4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\nindex 796119eeb..e442ee40a 100644\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n\n@@ -1,222 +1,4 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package co.rsk.net.light;\n \n-import co.rsk.core.RskAddress;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.db.RepositorySnapshot;\n-import co.rsk.db.RepositoryLocator;\n-import co.rsk.net.light.message.*;\n-import org.ethereum.core.*;\n-import org.ethereum.net.message.Message;\n-import org.bouncycastle.util.encoders.Hex;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.db.TransactionInfo;\n-import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nonnull;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n- */\n public class LightProcessor {\n-    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n-    // keep tabs on which nodes know which blocks.\n-    private final BlockStore blockStore;\n-    private final RepositoryLocator repositoryLocator;\n-    private final Blockchain blockchain;\n-\n-    public LightProcessor(@Nonnull final Blockchain blockchain,\n-                          @Nonnull final BlockStore blockStore,\n-                          @Nonnull final RepositoryLocator repositoryLocator) {\n-        this.blockchain = blockchain;\n-        this.blockStore = blockStore;\n-        this.repositoryLocator = repositoryLocator;\n-    }\n-    /**\n-     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n-     * @param requestId the id of the request\n-     * @param blockHash   the requested block hash.\n-     * @param lightPeer\n-     */\n-    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-\n-        for (Transaction tx :  block.getTransactionsList()) {\n-            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n-            receipts.add(txInfo.getReceipt());\n-        }\n-\n-        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n-        lightPeer.sendMessage(responseMessage);\n-    }\n-\n-    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n-    }\n-\n-    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n-        logger.debug(\"Get Transaction Index Message Received\");\n-\n-        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n-\n-        if (txinfo == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        byte[] blockHash = txinfo.getBlockHash();\n-        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n-        long txIndex = txinfo.getIndex();\n-\n-        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n-    }\n-\n-    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        String addressLog = Hex.toHexString(address);\n-        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress addr = new RskAddress(address);\n-        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n-\n-        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Code processing\");\n-    }\n-\n-    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n-        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        AccountState state = repositorySnapshot.getAccountState(address);\n-\n-        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),\n-                state.getBalance().asBigInteger().longValue(), repositorySnapshot.getCodeHash(address).getBytes(),\n-                repositorySnapshot.getRoot());\n-\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processAccountsMessage(long id, byte[] merkleInclusionProof, long nonce, long balance,\n-                                       byte[] codeHash, byte[] storageRoot, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported AccountsMessage processing\");\n-    }\n-\n-    public void processGetBlockHeaderMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, blockHashLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockHeaderMessage response = new BlockHeaderMessage(id, block.getHeader());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processGetBlockBodyMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, logBlockHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockBodyMessage response = new BlockBodyMessage(id, block.getTransactionsList(), block.getUncleList());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processBlockBodyMessage(long id, List<BlockHeader> uncles, List<Transaction> transactions, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockBody processing\");\n-    }\n-\n-    public void processGetStorageMessage(long id, byte[] blockHash, byte[] addressHash, byte[] storageKeyHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        String logAddressHash = Hex.toHexString(addressHash);\n-        String logStrorageKey = Hex.toHexString(storageKeyHash);\n-        logger.trace(\"Processing storage request {} block {} address {} storage key {}\", id,\n-                logBlockHash, logAddressHash, logStrorageKey);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        byte[] storageValue = repositorySnapshot.getStorageBytes(address, DataWord.valueOf(storageKeyHash));\n-\n-        if (storageValue == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        StorageMessage response = new StorageMessage(id, new byte[] {0x00}, storageValue);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processStorageMessage(long id, byte[] merkleInclusionProof, byte[] storageValue, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Storage processing\");\n-    }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjM1NQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306355", "bodyText": "I would add a TODO comment to mark that the merkle proof is yet to be implemented, and the same below", "author": "nicops", "createdAt": "2020-05-27T17:09:50Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.net.light.message.*;\n+import org.ethereum.core.*;\n+import org.ethereum.net.message.Message;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n+ */\n+public class LightProcessor {\n+    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n+    // keep tabs on which nodes know which blocks.\n+    private final BlockStore blockStore;\n+    private final RepositoryLocator repositoryLocator;\n+    private final Blockchain blockchain;\n+\n+    public LightProcessor(@Nonnull final Blockchain blockchain,\n+                          @Nonnull final BlockStore blockStore,\n+                          @Nonnull final RepositoryLocator repositoryLocator) {\n+        this.blockchain = blockchain;\n+        this.blockStore = blockStore;\n+        this.repositoryLocator = repositoryLocator;\n+    }\n+    /**\n+     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n+     * @param requestId the id of the request\n+     * @param blockHash   the requested block hash.\n+     * @param lightPeer\n+     */\n+    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+\n+        for (Transaction tx :  block.getTransactionsList()) {\n+            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n+            receipts.add(txInfo.getReceipt());\n+        }\n+\n+        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n+        lightPeer.sendMessage(responseMessage);\n+    }\n+\n+    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n+    }\n+\n+    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n+        logger.debug(\"Get Transaction Index Message Received\");\n+\n+        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n+\n+        if (txinfo == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        byte[] blockHash = txinfo.getBlockHash();\n+        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n+        long txIndex = txinfo.getIndex();\n+\n+        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n+    }\n+\n+    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n+        String blockHashLog = Hex.toHexString(blockHash);\n+        String addressLog = Hex.toHexString(address);\n+        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress addr = new RskAddress(address);\n+        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n+\n+        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n+        lightPeer.sendMessage(response);\n+    }\n+\n+    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n+        throw new UnsupportedOperationException(\"Not supported Code processing\");\n+    }\n+\n+    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n+        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n+\n+        final Block block = blockStore.getBlockByHash(blockHash);\n+\n+        if (block == null) {\n+            // Don't waste time sending an empty response.\n+            return;\n+        }\n+\n+        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n+        RskAddress address = new RskAddress(addressHash);\n+        AccountState state = repositorySnapshot.getAccountState(address);\n+\n+        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\nindex 796119eeb..e442ee40a 100644\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/net/light/LightProcessor.java\n\n@@ -1,222 +1,4 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package co.rsk.net.light;\n \n-import co.rsk.core.RskAddress;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.db.RepositorySnapshot;\n-import co.rsk.db.RepositoryLocator;\n-import co.rsk.net.light.message.*;\n-import org.ethereum.core.*;\n-import org.ethereum.net.message.Message;\n-import org.bouncycastle.util.encoders.Hex;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.db.TransactionInfo;\n-import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nonnull;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 21/10/19.\n- */\n public class LightProcessor {\n-    private static final Logger logger = LoggerFactory.getLogger(\"lightprocessor\");\n-    // keep tabs on which nodes know which blocks.\n-    private final BlockStore blockStore;\n-    private final RepositoryLocator repositoryLocator;\n-    private final Blockchain blockchain;\n-\n-    public LightProcessor(@Nonnull final Blockchain blockchain,\n-                          @Nonnull final BlockStore blockStore,\n-                          @Nonnull final RepositoryLocator repositoryLocator) {\n-        this.blockchain = blockchain;\n-        this.blockStore = blockStore;\n-        this.repositoryLocator = repositoryLocator;\n-    }\n-    /**\n-     * processBlockReceiptsRequest sends the requested block receipts if it is available.\n-     * @param requestId the id of the request\n-     * @param blockHash   the requested block hash.\n-     * @param lightPeer\n-     */\n-    public void processGetBlockReceiptsMessage(long requestId, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block receipts request {} block {}\", requestId, blockHashLog);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-\n-        for (Transaction tx :  block.getTransactionsList()) {\n-            TransactionInfo txInfo = blockchain.getTransactionInfo(tx.getHash().getBytes());\n-            receipts.add(txInfo.getReceipt());\n-        }\n-\n-        Message responseMessage = new BlockReceiptsMessage(requestId, receipts);\n-        lightPeer.sendMessage(responseMessage);\n-    }\n-\n-    public void processBlockReceiptsMessage(long id, List<TransactionReceipt> blockReceipts, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockReceipt processing\");\n-    }\n-\n-    public void processGetTransactionIndex(long id, byte[] hash, LightPeer lightPeer) {\n-        logger.debug(\"Get Transaction Index Message Received\");\n-\n-        TransactionInfo txinfo = blockchain.getTransactionInfo(hash);\n-\n-        if (txinfo == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        byte[] blockHash = txinfo.getBlockHash();\n-        long blockNumber = blockchain.getBlockByHash(blockHash).getNumber();\n-        long txIndex = txinfo.getIndex();\n-\n-        TransactionIndexMessage response = new TransactionIndexMessage(id, blockNumber, blockHash, txIndex);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processTransactionIndexMessage(long id, long blockNumber, byte[] blockHash, long txIndex, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported TransactionIndexMessage processing\");\n-    }\n-\n-    public void processGetCodeMessage(long requestId, byte[] blockHash, byte[] address, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        String addressLog = Hex.toHexString(address);\n-        logger.trace(\"Processing code request {} block {} code {}\", requestId, blockHashLog, addressLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress addr = new RskAddress(address);\n-        Keccak256 codeHash = repositorySnapshot.getCodeHash(addr);\n-\n-        CodeMessage response = new CodeMessage(requestId, codeHash.getBytes());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processCodeMessage(long id, byte[] codeHash, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Code processing\");\n-    }\n-\n-    public void processGetAccountsMessage(long id, byte[] blockHash, byte[] addressHash, LightPeer lightPeer) {\n-        logger.debug(\"Get Accounts Message Received: id {}, blockhash: {}, addressHash {}\", id, blockHash, addressHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        AccountState state = repositorySnapshot.getAccountState(address);\n-\n-        AccountsMessage response = new AccountsMessage(id, new byte[] {0x00}, state.getNonce().longValue(),\n-                state.getBalance().asBigInteger().longValue(), repositorySnapshot.getCodeHash(address).getBytes(),\n-                repositorySnapshot.getRoot());\n-\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processAccountsMessage(long id, byte[] merkleInclusionProof, long nonce, long balance,\n-                                       byte[] codeHash, byte[] storageRoot, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported AccountsMessage processing\");\n-    }\n-\n-    public void processGetBlockHeaderMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String blockHashLog = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, blockHashLog);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockHeaderMessage response = new BlockHeaderMessage(id, block.getHeader());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processGetBlockBodyMessage(long id, byte[] blockHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        logger.trace(\"Processing block header request {} block {}\", id, logBlockHash);\n-\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        BlockBodyMessage response = new BlockBodyMessage(id, block.getTransactionsList(), block.getUncleList());\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processBlockBodyMessage(long id, List<BlockHeader> uncles, List<Transaction> transactions, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported BlockBody processing\");\n-    }\n-\n-    public void processGetStorageMessage(long id, byte[] blockHash, byte[] addressHash, byte[] storageKeyHash, LightPeer lightPeer) {\n-        String logBlockHash = Hex.toHexString(blockHash);\n-        String logAddressHash = Hex.toHexString(addressHash);\n-        String logStrorageKey = Hex.toHexString(storageKeyHash);\n-        logger.trace(\"Processing storage request {} block {} address {} storage key {}\", id,\n-                logBlockHash, logAddressHash, logStrorageKey);\n-        final Block block = blockStore.getBlockByHash(blockHash);\n-\n-        if (block == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-        RepositorySnapshot repositorySnapshot = repositoryLocator.snapshotAt(block.getHeader());\n-        RskAddress address = new RskAddress(addressHash);\n-        byte[] storageValue = repositorySnapshot.getStorageBytes(address, DataWord.valueOf(storageKeyHash));\n-\n-        if (storageValue == null) {\n-            // Don't waste time sending an empty response.\n-            return;\n-        }\n-\n-        StorageMessage response = new StorageMessage(id, new byte[] {0x00}, storageValue);\n-        lightPeer.sendMessage(response);\n-    }\n-\n-    public void processStorageMessage(long id, byte[] merkleInclusionProof, byte[] storageValue, LightPeer lightPeer) {\n-        throw new UnsupportedOperationException(\"Not supported Storage processing\");\n-    }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjY2Nw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306667", "bodyText": "This method encodes only the signature, which doesn't seem correct.", "author": "nicops", "createdAt": "2020-05-27T17:10:18Z", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n+\n+        this.id = id;\n+        this.transactions = new LinkedList<>(transactionList);\n+        this.uncles = new LinkedList<>(uncleList);\n+\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    @Override\n+    public byte[] getEncoded() {\n+        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n+\n+        byte[][] rlpTransactions = getTransactions().stream()\n+                .map(Transaction::getEncoded)", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwNzMwOA==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431807308", "bodyText": "Actually the method uses another method which, given the signature, encodes the whole transaction\nLine it calls encoding method: \n  \n    \n      rskj/rskj-core/src/main/java/org/ethereum/core/Transaction.java\n    \n    \n         Line 482\n      in\n      9feb5a0\n    \n    \n    \n    \n\n        \n          \n           this.rlpEncoding = encode(v, r, s); \n        \n    \n  \n\n\nMethod itself: \n  \n    \n      rskj/rskj-core/src/main/java/org/ethereum/core/Transaction.java\n    \n    \n         Line 488\n      in\n      9feb5a0\n    \n    \n    \n    \n\n        \n          \n           private byte[] encode(byte[] v, byte[] r, byte[] s) {", "author": "smcsicardi", "createdAt": "2020-05-28T12:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg3MDIxNA==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431870214", "bodyText": "you're right!", "author": "nicops", "createdAt": "2020-05-28T14:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java b/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\ndeleted file mode 100644\nindex 2fd67a109..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\n+++ /dev/null\n\n@@ -1,120 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light.message;\n-\n-import co.rsk.net.light.MessageVisitor;\n-import org.bouncycastle.util.BigIntegers;\n-import org.ethereum.core.BlockFactory;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.ImmutableTransaction;\n-import org.ethereum.core.Transaction;\n-import org.ethereum.util.RLPList;\n-\n-import java.math.BigInteger;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n-import static org.ethereum.util.RLP.*;\n-\n-public class BlockBodyMessage extends LightClientMessage {\n-\n-    private final long id;\n-    private final List<Transaction> transactions;\n-    private final List<BlockHeader> uncles;\n-\n-    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n-        RLPList list = (RLPList) decode2(encoded).get(0);\n-        byte[] rlpId = list.get(0).getRLPData();\n-        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n-\n-        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n-\n-        List<Transaction> transactionList = new LinkedList<>();\n-        for (int k = 0; k < rlpTransactions.size(); k++) {\n-            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n-            Transaction tx = new ImmutableTransaction(rlpData);\n-            transactionList.add(tx);\n-        }\n-\n-        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n-\n-        List<BlockHeader> uncleList = new LinkedList<>();\n-        for (int k = 0; k < rlpUncles.size(); k++) {\n-            byte[] rlpData = rlpUncles.get(k).getRLPData();\n-            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n-            uncleList.add(uncle);\n-        }\n-\n-        this.transactions = transactionList;\n-        this.uncles = uncleList;\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n-\n-        this.id = id;\n-        this.transactions = new LinkedList<>(transactionList);\n-        this.uncles = new LinkedList<>(uncleList);\n-\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    @Override\n-    public byte[] getEncoded() {\n-        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n-\n-        byte[][] rlpTransactions = getTransactions().stream()\n-                .map(Transaction::getEncoded)\n-                .toArray(byte[][]::new);\n-\n-        byte[][] rlpUncles = getUncles().stream()\n-                .map(BlockHeader::getFullEncoded)\n-                .toArray(byte[][]::new);\n-\n-        return encodeList(rlpId, encodeList(rlpTransactions), encodeList(rlpUncles));\n-    }\n-\n-    @Override\n-    public Class<?> getAnswerMessage() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"\";\n-    }\n-\n-    public long getId() {\n-        return id;\n-    }\n-\n-    public List<Transaction> getTransactions() {\n-        return new LinkedList<>(transactions);\n-    }\n-\n-    public List<BlockHeader> getUncles() {\n-        return new LinkedList<>(uncles);\n-    }\n-\n-    @Override\n-    public void accept(MessageVisitor v) {\n-        v.apply(this);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjc2NQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306765", "bodyText": "Why empty toString on this and the other messages?", "author": "nicops", "createdAt": "2020-05-27T17:10:27Z", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n+\n+        this.id = id;\n+        this.transactions = new LinkedList<>(transactionList);\n+        this.uncles = new LinkedList<>(uncleList);\n+\n+        this.code = BLOCK_BODY.asByte();\n+    }\n+\n+    @Override\n+    public byte[] getEncoded() {\n+        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n+\n+        byte[][] rlpTransactions = getTransactions().stream()\n+                .map(Transaction::getEncoded)\n+                .toArray(byte[][]::new);\n+\n+        byte[][] rlpUncles = getUncles().stream()\n+                .map(BlockHeader::getFullEncoded)\n+                .toArray(byte[][]::new);\n+\n+        return encodeList(rlpId, encodeList(rlpTransactions), encodeList(rlpUncles));\n+    }\n+\n+    @Override\n+    public Class<?> getAnswerMessage() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\";", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1Nzc3NQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431957775", "bodyText": "Ready", "author": "julianlen", "createdAt": "2020-05-28T16:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjc2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java b/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\ndeleted file mode 100644\nindex 2fd67a109..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\n+++ /dev/null\n\n@@ -1,120 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light.message;\n-\n-import co.rsk.net.light.MessageVisitor;\n-import org.bouncycastle.util.BigIntegers;\n-import org.ethereum.core.BlockFactory;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.ImmutableTransaction;\n-import org.ethereum.core.Transaction;\n-import org.ethereum.util.RLPList;\n-\n-import java.math.BigInteger;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n-import static org.ethereum.util.RLP.*;\n-\n-public class BlockBodyMessage extends LightClientMessage {\n-\n-    private final long id;\n-    private final List<Transaction> transactions;\n-    private final List<BlockHeader> uncles;\n-\n-    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n-        RLPList list = (RLPList) decode2(encoded).get(0);\n-        byte[] rlpId = list.get(0).getRLPData();\n-        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n-\n-        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n-\n-        List<Transaction> transactionList = new LinkedList<>();\n-        for (int k = 0; k < rlpTransactions.size(); k++) {\n-            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n-            Transaction tx = new ImmutableTransaction(rlpData);\n-            transactionList.add(tx);\n-        }\n-\n-        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n-\n-        List<BlockHeader> uncleList = new LinkedList<>();\n-        for (int k = 0; k < rlpUncles.size(); k++) {\n-            byte[] rlpData = rlpUncles.get(k).getRLPData();\n-            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n-            uncleList.add(uncle);\n-        }\n-\n-        this.transactions = transactionList;\n-        this.uncles = uncleList;\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n-\n-        this.id = id;\n-        this.transactions = new LinkedList<>(transactionList);\n-        this.uncles = new LinkedList<>(uncleList);\n-\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    @Override\n-    public byte[] getEncoded() {\n-        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n-\n-        byte[][] rlpTransactions = getTransactions().stream()\n-                .map(Transaction::getEncoded)\n-                .toArray(byte[][]::new);\n-\n-        byte[][] rlpUncles = getUncles().stream()\n-                .map(BlockHeader::getFullEncoded)\n-                .toArray(byte[][]::new);\n-\n-        return encodeList(rlpId, encodeList(rlpTransactions), encodeList(rlpUncles));\n-    }\n-\n-    @Override\n-    public Class<?> getAnswerMessage() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"\";\n-    }\n-\n-    public long getId() {\n-        return id;\n-    }\n-\n-    public List<Transaction> getTransactions() {\n-        return new LinkedList<>(transactions);\n-    }\n-\n-    public List<BlockHeader> getUncles() {\n-        return new LinkedList<>(uncles);\n-    }\n-\n-    @Override\n-    public void accept(MessageVisitor v) {\n-        v.apply(this);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNjg3Nw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431306877", "bodyText": "In this and other places, the usage of import static for enum can be a little hard to read. It is of course, a matter of personal preference.", "author": "nicops", "createdAt": "2020-05-27T17:10:39Z", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();\n+        for (int k = 0; k < rlpTransactions.size(); k++) {\n+            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n+            Transaction tx = new ImmutableTransaction(rlpData);\n+            transactionList.add(tx);\n+        }\n+\n+        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n+\n+        List<BlockHeader> uncleList = new LinkedList<>();\n+        for (int k = 0; k < rlpUncles.size(); k++) {\n+            byte[] rlpData = rlpUncles.get(k).getRLPData();\n+            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n+            uncleList.add(uncle);\n+        }\n+\n+        this.transactions = transactionList;\n+        this.uncles = uncleList;\n+        this.code = BLOCK_BODY.asByte();", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java b/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\ndeleted file mode 100644\nindex 2fd67a109..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\n+++ /dev/null\n\n@@ -1,120 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light.message;\n-\n-import co.rsk.net.light.MessageVisitor;\n-import org.bouncycastle.util.BigIntegers;\n-import org.ethereum.core.BlockFactory;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.ImmutableTransaction;\n-import org.ethereum.core.Transaction;\n-import org.ethereum.util.RLPList;\n-\n-import java.math.BigInteger;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n-import static org.ethereum.util.RLP.*;\n-\n-public class BlockBodyMessage extends LightClientMessage {\n-\n-    private final long id;\n-    private final List<Transaction> transactions;\n-    private final List<BlockHeader> uncles;\n-\n-    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n-        RLPList list = (RLPList) decode2(encoded).get(0);\n-        byte[] rlpId = list.get(0).getRLPData();\n-        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n-\n-        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n-\n-        List<Transaction> transactionList = new LinkedList<>();\n-        for (int k = 0; k < rlpTransactions.size(); k++) {\n-            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n-            Transaction tx = new ImmutableTransaction(rlpData);\n-            transactionList.add(tx);\n-        }\n-\n-        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n-\n-        List<BlockHeader> uncleList = new LinkedList<>();\n-        for (int k = 0; k < rlpUncles.size(); k++) {\n-            byte[] rlpData = rlpUncles.get(k).getRLPData();\n-            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n-            uncleList.add(uncle);\n-        }\n-\n-        this.transactions = transactionList;\n-        this.uncles = uncleList;\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n-\n-        this.id = id;\n-        this.transactions = new LinkedList<>(transactionList);\n-        this.uncles = new LinkedList<>(uncleList);\n-\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    @Override\n-    public byte[] getEncoded() {\n-        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n-\n-        byte[][] rlpTransactions = getTransactions().stream()\n-                .map(Transaction::getEncoded)\n-                .toArray(byte[][]::new);\n-\n-        byte[][] rlpUncles = getUncles().stream()\n-                .map(BlockHeader::getFullEncoded)\n-                .toArray(byte[][]::new);\n-\n-        return encodeList(rlpId, encodeList(rlpTransactions), encodeList(rlpUncles));\n-    }\n-\n-    @Override\n-    public Class<?> getAnswerMessage() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"\";\n-    }\n-\n-    public long getId() {\n-        return id;\n-    }\n-\n-    public List<Transaction> getTransactions() {\n-        return new LinkedList<>(transactions);\n-    }\n-\n-    public List<BlockHeader> getUncles() {\n-        return new LinkedList<>(uncles);\n-    }\n-\n-    @Override\n-    public void accept(MessageVisitor v) {\n-        v.apply(this);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzMyNg==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307326", "bodyText": "In this and other places, there is a repeated usage of an structure that could be abstracted away in a lambda, maybe as a static method on a utils package. Something like this:\npublic static <T> List<T> mapListRLP(RLPList inputList, Function<byte[], T> lambda) {\n    List<T> output = new LinkedList<>();\n    for (int k = 0; k < inputList.size(); k++) {\n        byte[] rlpData = inputList.get(k).getRLPData();\n        T outputElement = lambda.apply(rlpData);\n        output.add(outputElement);\n    }\n    return output;\n}\n\nAnd then you can replace this with simply\nList<Transaction> transactionList = mapListRLP(rlpTransactions, rlpData -> new ImmutableTransaction(rlpData));", "author": "nicops", "createdAt": "2020-05-27T17:11:26Z", "path": "rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light.message;\n+\n+import co.rsk.net.light.MessageVisitor;\n+import org.bouncycastle.util.BigIntegers;\n+import org.ethereum.core.BlockFactory;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.ImmutableTransaction;\n+import org.ethereum.core.Transaction;\n+import org.ethereum.util.RLPList;\n+\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n+import static org.ethereum.util.RLP.*;\n+\n+public class BlockBodyMessage extends LightClientMessage {\n+\n+    private final long id;\n+    private final List<Transaction> transactions;\n+    private final List<BlockHeader> uncles;\n+\n+    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n+        RLPList list = (RLPList) decode2(encoded).get(0);\n+        byte[] rlpId = list.get(0).getRLPData();\n+        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n+\n+        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n+\n+        List<Transaction> transactionList = new LinkedList<>();", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwOTM3OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431809379", "bodyText": "I really like it, the RLP encoding is always cumbersome, we just didn't took the time to refactor it. We will organize with @julianlen for this and the other fixes.", "author": "smcsicardi", "createdAt": "2020-05-28T12:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODY5MA==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432048690", "bodyText": "Nice", "author": "julianlen", "createdAt": "2020-05-28T18:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java b/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\ndeleted file mode 100644\nindex 2fd67a109..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/message/BlockBodyMessage.java\n+++ /dev/null\n\n@@ -1,120 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light.message;\n-\n-import co.rsk.net.light.MessageVisitor;\n-import org.bouncycastle.util.BigIntegers;\n-import org.ethereum.core.BlockFactory;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.ImmutableTransaction;\n-import org.ethereum.core.Transaction;\n-import org.ethereum.util.RLPList;\n-\n-import java.math.BigInteger;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.BLOCK_BODY;\n-import static org.ethereum.util.RLP.*;\n-\n-public class BlockBodyMessage extends LightClientMessage {\n-\n-    private final long id;\n-    private final List<Transaction> transactions;\n-    private final List<BlockHeader> uncles;\n-\n-    public BlockBodyMessage(byte[] encoded, BlockFactory blockFactory) {\n-        RLPList list = (RLPList) decode2(encoded).get(0);\n-        byte[] rlpId = list.get(0).getRLPData();\n-        this.id = rlpId == null ? 0 : BigIntegers.fromUnsignedByteArray(rlpId).longValue();\n-\n-        RLPList rlpTransactions = (RLPList) decode2(list.get(1).getRLPData()).get(0);\n-\n-        List<Transaction> transactionList = new LinkedList<>();\n-        for (int k = 0; k < rlpTransactions.size(); k++) {\n-            byte[] rlpData = rlpTransactions.get(k).getRLPData();\n-            Transaction tx = new ImmutableTransaction(rlpData);\n-            transactionList.add(tx);\n-        }\n-\n-        RLPList rlpUncles = (RLPList) decode2(list.get(2).getRLPData()).get(0);\n-\n-        List<BlockHeader> uncleList = new LinkedList<>();\n-        for (int k = 0; k < rlpUncles.size(); k++) {\n-            byte[] rlpData = rlpUncles.get(k).getRLPData();\n-            BlockHeader uncle = blockFactory.decodeHeader(rlpData);\n-            uncleList.add(uncle);\n-        }\n-\n-        this.transactions = transactionList;\n-        this.uncles = uncleList;\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    public BlockBodyMessage(long id, List<Transaction> transactionList, List<BlockHeader> uncleList) {\n-\n-        this.id = id;\n-        this.transactions = new LinkedList<>(transactionList);\n-        this.uncles = new LinkedList<>(uncleList);\n-\n-        this.code = BLOCK_BODY.asByte();\n-    }\n-\n-    @Override\n-    public byte[] getEncoded() {\n-        byte[] rlpId = encodeBigInteger(BigInteger.valueOf(getId()));\n-\n-        byte[][] rlpTransactions = getTransactions().stream()\n-                .map(Transaction::getEncoded)\n-                .toArray(byte[][]::new);\n-\n-        byte[][] rlpUncles = getUncles().stream()\n-                .map(BlockHeader::getFullEncoded)\n-                .toArray(byte[][]::new);\n-\n-        return encodeList(rlpId, encodeList(rlpTransactions), encodeList(rlpUncles));\n-    }\n-\n-    @Override\n-    public Class<?> getAnswerMessage() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"\";\n-    }\n-\n-    public long getId() {\n-        return id;\n-    }\n-\n-    public List<Transaction> getTransactions() {\n-        return new LinkedList<>(transactions);\n-    }\n-\n-    public List<BlockHeader> getUncles() {\n-        return new LinkedList<>(uncles);\n-    }\n-\n-    @Override\n-    public void accept(MessageVisitor v) {\n-        v.apply(this);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzcwMg==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307702", "bodyText": "This repeated code makes me think that you should have an auxiliary method that returns a disconnection code or null, and then you disconnect with that code.", "author": "nicops", "createdAt": "2020-05-27T17:12:06Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\ndeleted file mode 100644\nindex 8aea307c9..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\n+++ /dev/null\n\n@@ -1,190 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light;\n-\n-import co.rsk.core.BlockDifficulty;\n-import co.rsk.core.bc.BlockChainStatus;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.net.eth.LightClientHandler;\n-import co.rsk.net.light.message.GetBlockHeaderMessage;\n-import co.rsk.net.light.message.StatusMessage;\n-import io.netty.channel.ChannelHandlerContext;\n-import org.ethereum.config.SystemProperties;\n-import org.ethereum.core.Block;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.Blockchain;\n-import org.ethereum.core.Genesis;\n-import org.ethereum.crypto.HashUtil;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.net.message.ReasonCode;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.*;\n-\n-\n-public class LightSyncProcessor {\n-\n-    private static final int MAX_PENDING_MESSAGES = 1;\n-    private static final int MAX_PEER_CONNECTIONS = 1;\n-    private SystemProperties config;\n-    private final Genesis genesis;\n-    private final BlockStore blockStore;\n-    private Blockchain blockchain;\n-    private final byte version;\n-    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n-    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n-    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n-    private long lastRequestedId;\n-    private final Map<Long, LightClientMessageCodes> pendingMessages;\n-\n-\n-    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n-        this.config = config;\n-        this.genesis = genesis;\n-        this.blockStore = blockStore;\n-        this.blockchain = blockchain;\n-        this.version = (byte) 0;\n-        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n-            @Override\n-            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n-                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n-                if (shouldDiscard) {\n-                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n-                }\n-                return shouldDiscard;\n-            }\n-        };\n-    }\n-\n-    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n-        LightStatus status = msg.getStatus();\n-        try {\n-            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n-            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n-\n-            byte protocolVersion = status.getProtocolVersion();\n-            if (protocolVersion != version) {\n-                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n-                        version,\n-                        protocolVersion);\n-                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n-                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n-                return;\n-            }\n-\n-            int networkId = config.networkId();\n-            int msgNetworkId = status.getNetworkId();\n-            if (msgNetworkId != networkId) {\n-                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n-                        networkId, msgNetworkId);\n-                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-\n-            Keccak256 genesisHash = genesis.getHash();\n-            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n-            if (!msgGenesisHash.equals(genesisHash)) {\n-                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n-                        genesisHash, msgGenesisHash);\n-                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-        } catch (NoSuchElementException e) {\n-            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n-        }\n-\n-        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n-            return;\n-        }\n-\n-        if (!hasLowerDifficulty(status)) {\n-            return;\n-        }\n-\n-        peerStatuses.put(lightPeer, status);\n-\n-        if (msg.isTxRelay()) {\n-            txRelay.put(lightPeer, true);\n-        }\n-\n-        byte[] bestBlockHash = status.getBestHash();\n-        GetBlockHeaderMessage blockHeaderMessage = new GetBlockHeaderMessage(++lastRequestedId, bestBlockHash);\n-        pendingMessages.put(lastRequestedId, BLOCK_HEADER);\n-        lightPeer.sendMessage(blockHeaderMessage);\n-    }\n-\n-    public void sendStatusMessage(LightPeer lightPeer) {\n-        Block block = blockStore.getBestBlock();\n-        LightStatus status = getCurrentStatus(block);\n-        StatusMessage statusMessage = new StatusMessage(0L, status, false);\n-\n-        lightPeer.sendMessage(statusMessage);\n-\n-        loggerNet.trace(\"Sending status best block {} to {}\",\n-                block.getNumber(), lightPeer.getPeerIdShort());\n-    }\n-\n-    public void processBlockHeaderMessage(long id, BlockHeader blockHeader, LightPeer lightPeer) {\n-        if (!isPending(id, BLOCK_HEADER)) {\n-            return;\n-        }\n-\n-        pendingMessages.remove(id, BLOCK_HEADER);\n-        lightPeer.receivedBlock(blockHeader);\n-    }\n-\n-    public boolean hasTxRelay(LightPeer peer) {\n-        if (!txRelay.containsKey(peer)) {\n-            return false;\n-        }\n-\n-        return txRelay.get(peer);\n-    }\n-\n-    private boolean isPending(long id, LightClientMessageCodes code) {\n-        return pendingMessages.containsKey(id) && pendingMessages.get(id).asByte() == code.asByte();\n-    }\n-\n-    private boolean hasLowerDifficulty(LightStatus status) {\n-        boolean hasTotalDifficulty = status.getTotalDifficulty() != null;\n-        BlockChainStatus nodeStatus = blockchain.getStatus();\n-\n-        // this works only for testing purposes, real status without difficulty don't reach this far\n-        return  (hasTotalDifficulty && nodeStatus.hasLowerDifficultyThan(status)) ||\n-                (!hasTotalDifficulty && nodeStatus.getBestBlockNumber() < status.getBestNumber());\n-    }\n-\n-    private LightStatus getCurrentStatus(Block block) {\n-        byte[] bestHash = block.getHash().getBytes();\n-        long bestNumber = block.getNumber();\n-        BlockDifficulty totalDifficulty = blockStore.getTotalDifficultyForHash(bestHash);\n-        return new LightStatus((byte) 0, config.networkId(), totalDifficulty, bestHash, bestNumber, genesis.getHash().getBytes());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzc3Ng==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307776", "bodyText": "I don't understand this line nor the usage of the Map. Why use a Map for what essentially could be an int? why you don't disconnect in this case? Shouldn't there be a mechanism to account for disconnections?", "author": "nicops", "createdAt": "2020-05-27T17:12:16Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NjY1Nw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432046657", "bodyText": "This is another case of \"dummy things\". The map is the basic approach to handle peers. For now, there is no something like \"PeerHandlers\". In the sync stage, peerStatuses is used to get the best peer, I mean, the peer with high total difficult and with the best block.\nThen, each node accepts a max quantity of peers.", "author": "julianlen", "createdAt": "2020-05-28T18:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\ndeleted file mode 100644\nindex 8aea307c9..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\n+++ /dev/null\n\n@@ -1,190 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light;\n-\n-import co.rsk.core.BlockDifficulty;\n-import co.rsk.core.bc.BlockChainStatus;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.net.eth.LightClientHandler;\n-import co.rsk.net.light.message.GetBlockHeaderMessage;\n-import co.rsk.net.light.message.StatusMessage;\n-import io.netty.channel.ChannelHandlerContext;\n-import org.ethereum.config.SystemProperties;\n-import org.ethereum.core.Block;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.Blockchain;\n-import org.ethereum.core.Genesis;\n-import org.ethereum.crypto.HashUtil;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.net.message.ReasonCode;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.*;\n-\n-\n-public class LightSyncProcessor {\n-\n-    private static final int MAX_PENDING_MESSAGES = 1;\n-    private static final int MAX_PEER_CONNECTIONS = 1;\n-    private SystemProperties config;\n-    private final Genesis genesis;\n-    private final BlockStore blockStore;\n-    private Blockchain blockchain;\n-    private final byte version;\n-    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n-    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n-    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n-    private long lastRequestedId;\n-    private final Map<Long, LightClientMessageCodes> pendingMessages;\n-\n-\n-    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n-        this.config = config;\n-        this.genesis = genesis;\n-        this.blockStore = blockStore;\n-        this.blockchain = blockchain;\n-        this.version = (byte) 0;\n-        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n-            @Override\n-            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n-                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n-                if (shouldDiscard) {\n-                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n-                }\n-                return shouldDiscard;\n-            }\n-        };\n-    }\n-\n-    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n-        LightStatus status = msg.getStatus();\n-        try {\n-            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n-            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n-\n-            byte protocolVersion = status.getProtocolVersion();\n-            if (protocolVersion != version) {\n-                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n-                        version,\n-                        protocolVersion);\n-                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n-                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n-                return;\n-            }\n-\n-            int networkId = config.networkId();\n-            int msgNetworkId = status.getNetworkId();\n-            if (msgNetworkId != networkId) {\n-                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n-                        networkId, msgNetworkId);\n-                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-\n-            Keccak256 genesisHash = genesis.getHash();\n-            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n-            if (!msgGenesisHash.equals(genesisHash)) {\n-                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n-                        genesisHash, msgGenesisHash);\n-                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-        } catch (NoSuchElementException e) {\n-            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n-        }\n-\n-        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n-            return;\n-        }\n-\n-        if (!hasLowerDifficulty(status)) {\n-            return;\n-        }\n-\n-        peerStatuses.put(lightPeer, status);\n-\n-        if (msg.isTxRelay()) {\n-            txRelay.put(lightPeer, true);\n-        }\n-\n-        byte[] bestBlockHash = status.getBestHash();\n-        GetBlockHeaderMessage blockHeaderMessage = new GetBlockHeaderMessage(++lastRequestedId, bestBlockHash);\n-        pendingMessages.put(lastRequestedId, BLOCK_HEADER);\n-        lightPeer.sendMessage(blockHeaderMessage);\n-    }\n-\n-    public void sendStatusMessage(LightPeer lightPeer) {\n-        Block block = blockStore.getBestBlock();\n-        LightStatus status = getCurrentStatus(block);\n-        StatusMessage statusMessage = new StatusMessage(0L, status, false);\n-\n-        lightPeer.sendMessage(statusMessage);\n-\n-        loggerNet.trace(\"Sending status best block {} to {}\",\n-                block.getNumber(), lightPeer.getPeerIdShort());\n-    }\n-\n-    public void processBlockHeaderMessage(long id, BlockHeader blockHeader, LightPeer lightPeer) {\n-        if (!isPending(id, BLOCK_HEADER)) {\n-            return;\n-        }\n-\n-        pendingMessages.remove(id, BLOCK_HEADER);\n-        lightPeer.receivedBlock(blockHeader);\n-    }\n-\n-    public boolean hasTxRelay(LightPeer peer) {\n-        if (!txRelay.containsKey(peer)) {\n-            return false;\n-        }\n-\n-        return txRelay.get(peer);\n-    }\n-\n-    private boolean isPending(long id, LightClientMessageCodes code) {\n-        return pendingMessages.containsKey(id) && pendingMessages.get(id).asByte() == code.asByte();\n-    }\n-\n-    private boolean hasLowerDifficulty(LightStatus status) {\n-        boolean hasTotalDifficulty = status.getTotalDifficulty() != null;\n-        BlockChainStatus nodeStatus = blockchain.getStatus();\n-\n-        // this works only for testing purposes, real status without difficulty don't reach this far\n-        return  (hasTotalDifficulty && nodeStatus.hasLowerDifficultyThan(status)) ||\n-                (!hasTotalDifficulty && nodeStatus.getBestBlockNumber() < status.getBestNumber());\n-    }\n-\n-    private LightStatus getCurrentStatus(Block block) {\n-        byte[] bestHash = block.getHash().getBytes();\n-        long bestNumber = block.getNumber();\n-        BlockDifficulty totalDifficulty = blockStore.getTotalDifficultyForHash(bestHash);\n-        return new LightStatus((byte) 0, config.networkId(), totalDifficulty, bestHash, bestNumber, genesis.getHash().getBytes());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzg4Mw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431307883", "bodyText": "This is always false, except on the unit tests. Right?", "author": "nicops", "createdAt": "2020-05-27T17:12:27Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n+            return;\n+        }\n+\n+        if (!hasLowerDifficulty(status)) {\n+            return;\n+        }\n+\n+        peerStatuses.put(lightPeer, status);\n+\n+        if (msg.isTxRelay()) {", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MTU2OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432061569", "bodyText": "It's false by default", "author": "julianlen", "createdAt": "2020-05-28T19:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwNzg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\ndeleted file mode 100644\nindex 8aea307c9..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\n+++ /dev/null\n\n@@ -1,190 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light;\n-\n-import co.rsk.core.BlockDifficulty;\n-import co.rsk.core.bc.BlockChainStatus;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.net.eth.LightClientHandler;\n-import co.rsk.net.light.message.GetBlockHeaderMessage;\n-import co.rsk.net.light.message.StatusMessage;\n-import io.netty.channel.ChannelHandlerContext;\n-import org.ethereum.config.SystemProperties;\n-import org.ethereum.core.Block;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.Blockchain;\n-import org.ethereum.core.Genesis;\n-import org.ethereum.crypto.HashUtil;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.net.message.ReasonCode;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.*;\n-\n-\n-public class LightSyncProcessor {\n-\n-    private static final int MAX_PENDING_MESSAGES = 1;\n-    private static final int MAX_PEER_CONNECTIONS = 1;\n-    private SystemProperties config;\n-    private final Genesis genesis;\n-    private final BlockStore blockStore;\n-    private Blockchain blockchain;\n-    private final byte version;\n-    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n-    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n-    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n-    private long lastRequestedId;\n-    private final Map<Long, LightClientMessageCodes> pendingMessages;\n-\n-\n-    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n-        this.config = config;\n-        this.genesis = genesis;\n-        this.blockStore = blockStore;\n-        this.blockchain = blockchain;\n-        this.version = (byte) 0;\n-        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n-            @Override\n-            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n-                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n-                if (shouldDiscard) {\n-                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n-                }\n-                return shouldDiscard;\n-            }\n-        };\n-    }\n-\n-    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n-        LightStatus status = msg.getStatus();\n-        try {\n-            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n-            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n-\n-            byte protocolVersion = status.getProtocolVersion();\n-            if (protocolVersion != version) {\n-                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n-                        version,\n-                        protocolVersion);\n-                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n-                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n-                return;\n-            }\n-\n-            int networkId = config.networkId();\n-            int msgNetworkId = status.getNetworkId();\n-            if (msgNetworkId != networkId) {\n-                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n-                        networkId, msgNetworkId);\n-                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-\n-            Keccak256 genesisHash = genesis.getHash();\n-            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n-            if (!msgGenesisHash.equals(genesisHash)) {\n-                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n-                        genesisHash, msgGenesisHash);\n-                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-        } catch (NoSuchElementException e) {\n-            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n-        }\n-\n-        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n-            return;\n-        }\n-\n-        if (!hasLowerDifficulty(status)) {\n-            return;\n-        }\n-\n-        peerStatuses.put(lightPeer, status);\n-\n-        if (msg.isTxRelay()) {\n-            txRelay.put(lightPeer, true);\n-        }\n-\n-        byte[] bestBlockHash = status.getBestHash();\n-        GetBlockHeaderMessage blockHeaderMessage = new GetBlockHeaderMessage(++lastRequestedId, bestBlockHash);\n-        pendingMessages.put(lastRequestedId, BLOCK_HEADER);\n-        lightPeer.sendMessage(blockHeaderMessage);\n-    }\n-\n-    public void sendStatusMessage(LightPeer lightPeer) {\n-        Block block = blockStore.getBestBlock();\n-        LightStatus status = getCurrentStatus(block);\n-        StatusMessage statusMessage = new StatusMessage(0L, status, false);\n-\n-        lightPeer.sendMessage(statusMessage);\n-\n-        loggerNet.trace(\"Sending status best block {} to {}\",\n-                block.getNumber(), lightPeer.getPeerIdShort());\n-    }\n-\n-    public void processBlockHeaderMessage(long id, BlockHeader blockHeader, LightPeer lightPeer) {\n-        if (!isPending(id, BLOCK_HEADER)) {\n-            return;\n-        }\n-\n-        pendingMessages.remove(id, BLOCK_HEADER);\n-        lightPeer.receivedBlock(blockHeader);\n-    }\n-\n-    public boolean hasTxRelay(LightPeer peer) {\n-        if (!txRelay.containsKey(peer)) {\n-            return false;\n-        }\n-\n-        return txRelay.get(peer);\n-    }\n-\n-    private boolean isPending(long id, LightClientMessageCodes code) {\n-        return pendingMessages.containsKey(id) && pendingMessages.get(id).asByte() == code.asByte();\n-    }\n-\n-    private boolean hasLowerDifficulty(LightStatus status) {\n-        boolean hasTotalDifficulty = status.getTotalDifficulty() != null;\n-        BlockChainStatus nodeStatus = blockchain.getStatus();\n-\n-        // this works only for testing purposes, real status without difficulty don't reach this far\n-        return  (hasTotalDifficulty && nodeStatus.hasLowerDifficultyThan(status)) ||\n-                (!hasTotalDifficulty && nodeStatus.getBestBlockNumber() < status.getBestNumber());\n-    }\n-\n-    private LightStatus getCurrentStatus(Block block) {\n-        byte[] bestHash = block.getHash().getBytes();\n-        long bestNumber = block.getNumber();\n-        BlockDifficulty totalDifficulty = blockStore.getTotalDifficultyForHash(bestHash);\n-        return new LightStatus((byte) 0, config.networkId(), totalDifficulty, bestHash, bestNumber, genesis.getHash().getBytes());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODE2NQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431308165", "bodyText": "hasTxRelay should have a @VisibleForTesting annotation, or similar. Because it is a method ONLY for testing", "author": "nicops", "createdAt": "2020-05-27T17:12:51Z", "path": "rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net.light;\n+\n+import co.rsk.core.BlockDifficulty;\n+import co.rsk.core.bc.BlockChainStatus;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.eth.LightClientHandler;\n+import co.rsk.net.light.message.GetBlockHeaderMessage;\n+import co.rsk.net.light.message.StatusMessage;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.ethereum.config.SystemProperties;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.Genesis;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.net.message.ReasonCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static co.rsk.net.light.LightClientMessageCodes.*;\n+\n+\n+public class LightSyncProcessor {\n+\n+    private static final int MAX_PENDING_MESSAGES = 1;\n+    private static final int MAX_PEER_CONNECTIONS = 1;\n+    private SystemProperties config;\n+    private final Genesis genesis;\n+    private final BlockStore blockStore;\n+    private Blockchain blockchain;\n+    private final byte version;\n+    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n+    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n+    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n+    private long lastRequestedId;\n+    private final Map<Long, LightClientMessageCodes> pendingMessages;\n+\n+\n+    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n+        this.config = config;\n+        this.genesis = genesis;\n+        this.blockStore = blockStore;\n+        this.blockchain = blockchain;\n+        this.version = (byte) 0;\n+        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n+                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n+                if (shouldDiscard) {\n+                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n+                }\n+                return shouldDiscard;\n+            }\n+        };\n+    }\n+\n+    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n+        LightStatus status = msg.getStatus();\n+        try {\n+            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n+            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n+\n+            byte protocolVersion = status.getProtocolVersion();\n+            if (protocolVersion != version) {\n+                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n+                        version,\n+                        protocolVersion);\n+                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n+                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n+                return;\n+            }\n+\n+            int networkId = config.networkId();\n+            int msgNetworkId = status.getNetworkId();\n+            if (msgNetworkId != networkId) {\n+                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n+                        networkId, msgNetworkId);\n+                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+\n+            Keccak256 genesisHash = genesis.getHash();\n+            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n+            if (!msgGenesisHash.equals(genesisHash)) {\n+                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n+                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n+                        genesisHash, msgGenesisHash);\n+                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n+                ctx.pipeline().remove(lightClientHandler);\n+                return;\n+            }\n+        } catch (NoSuchElementException e) {\n+            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n+        }\n+\n+        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n+            return;\n+        }\n+\n+        if (!hasLowerDifficulty(status)) {\n+            return;\n+        }\n+\n+        peerStatuses.put(lightPeer, status);\n+\n+        if (msg.isTxRelay()) {\n+            txRelay.put(lightPeer, true);\n+        }\n+\n+        byte[] bestBlockHash = status.getBestHash();\n+        GetBlockHeaderMessage blockHeaderMessage = new GetBlockHeaderMessage(++lastRequestedId, bestBlockHash);\n+        pendingMessages.put(lastRequestedId, BLOCK_HEADER);\n+        lightPeer.sendMessage(blockHeaderMessage);\n+    }\n+\n+    public void sendStatusMessage(LightPeer lightPeer) {\n+        Block block = blockStore.getBestBlock();\n+        LightStatus status = getCurrentStatus(block);\n+        StatusMessage statusMessage = new StatusMessage(0L, status, false);\n+\n+        lightPeer.sendMessage(statusMessage);\n+\n+        loggerNet.trace(\"Sending status best block {} to {}\",\n+                block.getNumber(), lightPeer.getPeerIdShort());\n+    }\n+\n+    public void processBlockHeaderMessage(long id, BlockHeader blockHeader, LightPeer lightPeer) {\n+        if (!isPending(id, BLOCK_HEADER)) {\n+            return;\n+        }\n+\n+        pendingMessages.remove(id, BLOCK_HEADER);\n+        lightPeer.receivedBlock(blockHeader);\n+    }\n+\n+    public boolean hasTxRelay(LightPeer peer) {", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MTc1Mw==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r432061753", "bodyText": "At this moment, it should be visible for testing, right.", "author": "julianlen", "createdAt": "2020-05-28T19:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODE2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java b/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\ndeleted file mode 100644\nindex 8aea307c9..000000000\n--- a/rskj-core/src/main/java/co/rsk/net/light/LightSyncProcessor.java\n+++ /dev/null\n\n@@ -1,190 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net.light;\n-\n-import co.rsk.core.BlockDifficulty;\n-import co.rsk.core.bc.BlockChainStatus;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.net.eth.LightClientHandler;\n-import co.rsk.net.light.message.GetBlockHeaderMessage;\n-import co.rsk.net.light.message.StatusMessage;\n-import io.netty.channel.ChannelHandlerContext;\n-import org.ethereum.config.SystemProperties;\n-import org.ethereum.core.Block;\n-import org.ethereum.core.BlockHeader;\n-import org.ethereum.core.Blockchain;\n-import org.ethereum.core.Genesis;\n-import org.ethereum.crypto.HashUtil;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.net.message.ReasonCode;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-\n-import static co.rsk.net.light.LightClientMessageCodes.*;\n-\n-\n-public class LightSyncProcessor {\n-\n-    private static final int MAX_PENDING_MESSAGES = 1;\n-    private static final int MAX_PEER_CONNECTIONS = 1;\n-    private SystemProperties config;\n-    private final Genesis genesis;\n-    private final BlockStore blockStore;\n-    private Blockchain blockchain;\n-    private final byte version;\n-    private static final Logger loggerNet = LoggerFactory.getLogger(\"lightnet\");\n-    private Map<LightPeer, LightStatus> peerStatuses = new HashMap<>();\n-    private Map<LightPeer, Boolean> txRelay = new HashMap<>();\n-    private long lastRequestedId;\n-    private final Map<Long, LightClientMessageCodes> pendingMessages;\n-\n-\n-    public LightSyncProcessor(SystemProperties config, Genesis genesis, BlockStore blockStore, Blockchain blockchain) {\n-        this.config = config;\n-        this.genesis = genesis;\n-        this.blockStore = blockStore;\n-        this.blockchain = blockchain;\n-        this.version = (byte) 0;\n-        this.pendingMessages = new LinkedHashMap<Long, LightClientMessageCodes>() {\n-            @Override\n-            protected boolean removeEldestEntry(Map.Entry<Long, LightClientMessageCodes> eldest) {\n-                boolean shouldDiscard = size() > MAX_PENDING_MESSAGES;\n-                if (shouldDiscard) {\n-                    loggerNet.trace(\"Pending {}@{} DISCARDED\", eldest.getValue(), eldest.getKey());\n-                }\n-                return shouldDiscard;\n-            }\n-        };\n-    }\n-\n-    public void processStatusMessage(StatusMessage msg, LightPeer lightPeer, ChannelHandlerContext ctx, LightClientHandler lightClientHandler) {\n-        LightStatus status = msg.getStatus();\n-        try {\n-            String bestHashLog = HashUtil.shortHash(status.getBestHash());\n-            loggerNet.debug(\"Receiving Status - block {} {}\", status.getBestNumber(), bestHashLog);\n-\n-            byte protocolVersion = status.getProtocolVersion();\n-            if (protocolVersion != version) {\n-                loggerNet.info(\"Removing LCHandler for {} due to protocol incompatibility\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Protocol version {} - message protocol version {}\",\n-                        version,\n-                        protocolVersion);\n-                lightPeer.disconnect(ReasonCode.INCOMPATIBLE_PROTOCOL);\n-                ctx.pipeline().remove(lightClientHandler); // Peer is not compatible for the 'lc' sub-protocol\n-                return;\n-            }\n-\n-            int networkId = config.networkId();\n-            int msgNetworkId = status.getNetworkId();\n-            if (msgNetworkId != networkId) {\n-                loggerNet.info(\"Removing LCHandler for {} due to invalid network\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Different network received: config network ID {} - message network ID {}\",\n-                        networkId, msgNetworkId);\n-                lightPeer.disconnect(ReasonCode.NULL_IDENTITY);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-\n-            Keccak256 genesisHash = genesis.getHash();\n-            Keccak256 msgGenesisHash = new Keccak256(status.getGenesisHash());\n-            if (!msgGenesisHash.equals(genesisHash)) {\n-                loggerNet.info(\"Removing LCHandler for {} due to unexpected genesis\", ctx.channel().remoteAddress());\n-                loggerNet.info(\"Config genesis hash {} - message genesis hash {}\",\n-                        genesisHash, msgGenesisHash);\n-                lightPeer.disconnect(ReasonCode.UNEXPECTED_GENESIS);\n-                ctx.pipeline().remove(lightClientHandler);\n-                return;\n-            }\n-        } catch (NoSuchElementException e) {\n-            loggerNet.debug(\"LCHandler already removed - exception: {}\", e.getMessage());\n-        }\n-\n-        if (peerStatuses.size() >= MAX_PEER_CONNECTIONS) {\n-            return;\n-        }\n-\n-        if (!hasLowerDifficulty(status)) {\n-            return;\n-        }\n-\n-        peerStatuses.put(lightPeer, status);\n-\n-        if (msg.isTxRelay()) {\n-            txRelay.put(lightPeer, true);\n-        }\n-\n-        byte[] bestBlockHash = status.getBestHash();\n-        GetBlockHeaderMessage blockHeaderMessage = new GetBlockHeaderMessage(++lastRequestedId, bestBlockHash);\n-        pendingMessages.put(lastRequestedId, BLOCK_HEADER);\n-        lightPeer.sendMessage(blockHeaderMessage);\n-    }\n-\n-    public void sendStatusMessage(LightPeer lightPeer) {\n-        Block block = blockStore.getBestBlock();\n-        LightStatus status = getCurrentStatus(block);\n-        StatusMessage statusMessage = new StatusMessage(0L, status, false);\n-\n-        lightPeer.sendMessage(statusMessage);\n-\n-        loggerNet.trace(\"Sending status best block {} to {}\",\n-                block.getNumber(), lightPeer.getPeerIdShort());\n-    }\n-\n-    public void processBlockHeaderMessage(long id, BlockHeader blockHeader, LightPeer lightPeer) {\n-        if (!isPending(id, BLOCK_HEADER)) {\n-            return;\n-        }\n-\n-        pendingMessages.remove(id, BLOCK_HEADER);\n-        lightPeer.receivedBlock(blockHeader);\n-    }\n-\n-    public boolean hasTxRelay(LightPeer peer) {\n-        if (!txRelay.containsKey(peer)) {\n-            return false;\n-        }\n-\n-        return txRelay.get(peer);\n-    }\n-\n-    private boolean isPending(long id, LightClientMessageCodes code) {\n-        return pendingMessages.containsKey(id) && pendingMessages.get(id).asByte() == code.asByte();\n-    }\n-\n-    private boolean hasLowerDifficulty(LightStatus status) {\n-        boolean hasTotalDifficulty = status.getTotalDifficulty() != null;\n-        BlockChainStatus nodeStatus = blockchain.getStatus();\n-\n-        // this works only for testing purposes, real status without difficulty don't reach this far\n-        return  (hasTotalDifficulty && nodeStatus.hasLowerDifficultyThan(status)) ||\n-                (!hasTotalDifficulty && nodeStatus.getBestBlockNumber() < status.getBestNumber());\n-    }\n-\n-    private LightStatus getCurrentStatus(Block block) {\n-        byte[] bestHash = block.getHash().getBytes();\n-        long bestNumber = block.getNumber();\n-        BlockDifficulty totalDifficulty = blockStore.getTotalDifficultyForHash(bestHash);\n-        return new LightStatus((byte) 0, config.networkId(), totalDifficulty, bestHash, bestNumber, genesis.getHash().getBytes());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODU1OQ==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431308559", "bodyText": "To ask for the presence is a pattern that reoccurs through the code, but it is bad pattern: this should be set in reference.conf, that assures that the value can never be null. Besides that, lc should not be a default", "author": "nicops", "createdAt": "2020-05-27T17:13:33Z", "path": "rskj-core/src/main/java/org/ethereum/config/SystemProperties.java", "diffHunk": "@@ -318,7 +318,7 @@ public String helloPhrase() {\n     }\n \n     public List<String> peerCapabilities() {\n-        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\"));\n+        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\",\"lc\"));", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxMzg0NA==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431813844", "bodyText": "We will check that (the pattern).\nOn the other hand, the Light Client capability should be a default. By default any full node should serve Light Clients, removing it will cause that no Full Node will serve them.\nI think the root of this problem is the bad way that defaults and config settings are handled in general in the code.", "author": "smcsicardi", "createdAt": "2020-05-28T12:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwODU1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/main/java/org/ethereum/config/SystemProperties.java b/rskj-core/src/main/java/org/ethereum/config/SystemProperties.java\nindex 05e2e2776..1e58d27d5 100644\n--- a/rskj-core/src/main/java/org/ethereum/config/SystemProperties.java\n+++ b/rskj-core/src/main/java/org/ethereum/config/SystemProperties.java\n\n@@ -318,7 +318,7 @@ public abstract class SystemProperties {\n     }\n \n     public List<String> peerCapabilities() {\n-        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\",\"lc\"));\n+        return configFromFiles.hasPath(\"peer.capabilities\") ?  configFromFiles.getStringList(\"peer.capabilities\") : new ArrayList<>(Arrays.asList(\"rsk\"));\n     }\n \n     public boolean vmTrace() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMwOTM2NA==", "url": "https://github.com/rsksmart/rskj/pull/1184#discussion_r431309364", "bodyText": "Like ajl says on his blog https://blogs.msmvps.com/lopez/2012/08/09/tdd-unit-tests-and-mocks/ it's undesirable to mock so much when testing. Ideally, we should have factories to build these objects for us, it is a strong smell to resort to mock all these classes, especially domain classes like Block and Transaction, since it's not exactly the external, unpredictable world the one we're mocking.\nThere is a BlockBuilder class for this, it might be a bit unwieldy for the purposes of this test, but I think it merits trying to make efforts in order to make non mocking tests easy to code.", "author": "nicops", "createdAt": "2020-05-27T17:14:59Z", "path": "rskj-core/src/test/java/co/rsk/net/LightProcessorTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2020 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.core.Coin;\n+import co.rsk.core.RskAddress;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.db.RepositoryLocator;\n+import co.rsk.db.RepositorySnapshot;\n+import co.rsk.net.light.LightPeer;\n+import co.rsk.net.light.LightProcessor;\n+import co.rsk.net.light.message.*;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.ethereum.core.*;\n+import org.ethereum.crypto.HashUtil;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.db.TransactionInfo;\n+import org.ethereum.net.MessageQueue;\n+import org.ethereum.net.server.Channel;\n+import org.ethereum.vm.DataWord;\n+import org.ethereum.vm.LogInfo;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.ethereum.TestUtils.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Created by Julian Len and Sebastian Sicardi on 20/10/19.\n+ */\n+public class LightProcessorTest {\n+\n+    private static final byte[] HASH_1 = HashUtil.sha256(new byte[]{1});\n+\n+    private Blockchain blockchain;\n+    private BlockStore blockStore;\n+    private LightProcessor lightProcessor;\n+    private MessageQueue msgQueue;\n+    private Keccak256 blockHash;\n+    private RepositoryLocator repositoryLocator;\n+    private LightPeer lightPeer;\n+\n+    @Before\n+    public void setup(){\n+        blockchain = mock(Blockchain.class);\n+        blockStore = mock(BlockStore.class);\n+        repositoryLocator = mock(RepositoryLocator.class);\n+        lightProcessor = new LightProcessor(blockchain, blockStore, repositoryLocator);\n+        msgQueue = spy(MessageQueue.class);\n+        blockHash = new Keccak256(HASH_1);\n+        lightPeer = new LightPeer(mock(Channel.class), msgQueue);\n+    }\n+\n+    @Test\n+    public void processGetBlockReceiptMessageAndShouldReturnsReceiptsCorrectly() {\n+        List<Transaction> txs = new LinkedList<>();\n+        long requestId = 0;\n+        List<TransactionReceipt> receipts = new LinkedList<>();\n+        TransactionReceipt receipt = createReceipt();\n+        receipts.add(receipt);\n+        final Block block = mock(Block.class);", "originalCommit": "0ad9527f250d51cca20e951ef97762b428c2886d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af5a0c686bccb510f213a61766678928f9807259", "chunk": "diff --git a/rskj-core/src/test/java/co/rsk/net/LightProcessorTest.java b/rskj-core/src/test/java/co/rsk/net/LightProcessorTest.java\ndeleted file mode 100644\nindex 022936f91..000000000\n--- a/rskj-core/src/test/java/co/rsk/net/LightProcessorTest.java\n+++ /dev/null\n\n@@ -1,412 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2020 RSK Labs Ltd.\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.net;\n-\n-import co.rsk.core.Coin;\n-import co.rsk.core.RskAddress;\n-import co.rsk.crypto.Keccak256;\n-import co.rsk.db.RepositoryLocator;\n-import co.rsk.db.RepositorySnapshot;\n-import co.rsk.net.light.LightPeer;\n-import co.rsk.net.light.LightProcessor;\n-import co.rsk.net.light.message.*;\n-import org.bouncycastle.util.encoders.Hex;\n-import org.ethereum.core.*;\n-import org.ethereum.crypto.HashUtil;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.db.TransactionInfo;\n-import org.ethereum.net.MessageQueue;\n-import org.ethereum.net.server.Channel;\n-import org.ethereum.vm.DataWord;\n-import org.ethereum.vm.LogInfo;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.ArgumentCaptor;\n-\n-import java.math.BigInteger;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import static org.ethereum.TestUtils.*;\n-import static org.junit.Assert.assertArrayEquals;\n-import static org.mockito.ArgumentCaptor.forClass;\n-import static org.mockito.Mockito.*;\n-\n-/**\n- * Created by Julian Len and Sebastian Sicardi on 20/10/19.\n- */\n-public class LightProcessorTest {\n-\n-    private static final byte[] HASH_1 = HashUtil.sha256(new byte[]{1});\n-\n-    private Blockchain blockchain;\n-    private BlockStore blockStore;\n-    private LightProcessor lightProcessor;\n-    private MessageQueue msgQueue;\n-    private Keccak256 blockHash;\n-    private RepositoryLocator repositoryLocator;\n-    private LightPeer lightPeer;\n-\n-    @Before\n-    public void setup(){\n-        blockchain = mock(Blockchain.class);\n-        blockStore = mock(BlockStore.class);\n-        repositoryLocator = mock(RepositoryLocator.class);\n-        lightProcessor = new LightProcessor(blockchain, blockStore, repositoryLocator);\n-        msgQueue = spy(MessageQueue.class);\n-        blockHash = new Keccak256(HASH_1);\n-        lightPeer = new LightPeer(mock(Channel.class), msgQueue);\n-    }\n-\n-    @Test\n-    public void processGetBlockReceiptMessageAndShouldReturnsReceiptsCorrectly() {\n-        List<Transaction> txs = new LinkedList<>();\n-        long requestId = 0;\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-        TransactionReceipt receipt = createReceipt();\n-        receipts.add(receipt);\n-        final Block block = mock(Block.class);\n-        Transaction tx = mock(Transaction.class);\n-        txs.add(tx);\n-        TransactionInfo transactionInfo = mock(TransactionInfo.class);\n-\n-        when(block.getHash()).thenReturn(blockHash);\n-        when(block.getTransactionsList()).thenReturn(txs);\n-        when(tx.getHash()).thenReturn(new Keccak256(randomBytes(32)));\n-        when(blockchain.getTransactionInfo(tx.getHash().getBytes())).thenReturn(transactionInfo);\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(transactionInfo.getReceipt()).thenReturn(receipt);\n-\n-        BlockReceiptsMessage expectedMessage = new BlockReceiptsMessage(0, receipts);\n-\n-        ArgumentCaptor<BlockReceiptsMessage> argument = forClass(BlockReceiptsMessage.class);\n-        lightProcessor.processGetBlockReceiptsMessage(requestId, block.getHash().getBytes(), lightPeer);\n-        verify(msgQueue).sendMessage(argument.capture());\n-        assertArrayEquals(expectedMessage.getEncoded(), argument.getValue().getEncoded());\n-    }\n-\n-    @Test\n-    public void processGetBlockReceiptMessageWithInvalidBlockHash() {\n-        lightProcessor.processGetBlockReceiptsMessage(0, blockHash.getBytes(), lightPeer);\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test(expected = UnsupportedOperationException.class)\n-    public void processBlockReceiptMessageAndShouldThrowAnException() {\n-        long requestId = 0;\n-        List<TransactionReceipt> receipts = new LinkedList<>();\n-        lightProcessor.processBlockReceiptsMessage(requestId, receipts, lightPeer);\n-    }\n-    \n-    @Test\n-    public void processGetTransactionIndexMessageAndReturnsTransactionIndexCorrectly() {\n-        final Block block = mock(Block.class);\n-        Transaction tx = mock(Transaction.class);\n-        TransactionInfo transactionInfo = mock(TransactionInfo.class);\n-\n-        Keccak256 txHash = new Keccak256(randomBytes(32));\n-\n-        long id = 100;\n-        long blockNumber = 101;\n-        int txIndex = 42069;\n-        Keccak256 blockHash = new Keccak256(HASH_1);\n-\n-        when(block.getHash()).thenReturn(blockHash);\n-        when(tx.getHash()).thenReturn(txHash);\n-        when(blockchain.getTransactionInfo(tx.getHash().getBytes())).thenReturn(transactionInfo);\n-\n-        when(transactionInfo.getBlockHash()).thenReturn(blockHash.getBytes());\n-        when(blockchain.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(block.getNumber()).thenReturn(blockNumber);\n-        when(transactionInfo.getIndex()).thenReturn(txIndex);\n-\n-        TransactionIndexMessage expectedMessage = new TransactionIndexMessage(id, blockNumber, block.getHash().getBytes(), txIndex);\n-\n-        ArgumentCaptor<TransactionIndexMessage> argument = forClass(TransactionIndexMessage.class);\n-        lightProcessor.processGetTransactionIndex(id, txHash.getBytes(), lightPeer);\n-        verify(msgQueue).sendMessage(argument.capture());\n-        assertArrayEquals(expectedMessage.getEncoded(), argument.getValue().getEncoded());\n-    }\n-\n-    @Test\n-    public void processGetTransactionIndexMessageWithIncorrectBlockHash() {\n-        lightProcessor.processGetTransactionIndex(100, blockHash.getBytes(), lightPeer);\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test(expected = UnsupportedOperationException.class)\n-    public void processTransactionIndexMessageAndShouldThrowAnException() {\n-        lightProcessor.processTransactionIndexMessage(0, 0, null, 0, lightPeer);\n-    }\n-\n-    @Test\n-    public void processGetCodeMessageAndShouldReturnsCodeHashCorrectly() {\n-        final Block block = mock(Block.class);\n-        final RepositorySnapshot repositorySnapshot = mock(RepositorySnapshot.class);\n-\n-        byte[] codeHash = randomBytes(32);\n-        RskAddress address = randomAddress();\n-        long id = 0;\n-\n-        when(block.getHash()).thenReturn(blockHash);\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(repositoryLocator.snapshotAt(block.getHeader())).thenReturn(repositorySnapshot);\n-        when(repositorySnapshot.getCodeHash(address)).thenReturn(new Keccak256(codeHash));\n-\n-        CodeMessage expectedMessage = new CodeMessage(id, codeHash);\n-\n-        ArgumentCaptor<CodeMessage> argument = forClass(CodeMessage.class);\n-        lightProcessor.processGetCodeMessage(id, blockHash.getBytes(), address.getBytes(), lightPeer);\n-        verify(msgQueue).sendMessage(argument.capture());\n-\n-        assertArrayEquals(expectedMessage.getEncoded(), argument.getValue().getEncoded());\n-    }\n-\n-    @Test\n-    public void processGetCodeMessageWithInvalidBlockHash() {\n-        long id = 100;\n-        RskAddress address = randomAddress();\n-\n-        lightProcessor.processGetCodeMessage(id, blockHash.getBytes(), address.getBytes(), lightPeer);\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test(expected = UnsupportedOperationException.class)\n-    public void processCodeMessageAndShouldThrowAnException() {\n-        long requestId = 0;\n-        byte[] codeHash = randomBytes(32);\n-\n-        lightProcessor.processCodeMessage(requestId, codeHash, lightPeer);\n-    }\n-\n-    @Test\n-    public void processGetAccountsMessageAndShouldReturnsAccountsCorrectly() {\n-        long id = 101;\n-        Coin balance = Coin.valueOf(1010);\n-        long nonce = 100;\n-        RskAddress address = randomAddress();\n-        final Block block = mock(Block.class);\n-        final RepositorySnapshot repositorySnapshot = mock(RepositorySnapshot.class);\n-        Keccak256 codeHash = randomHash();\n-        byte[] storageRoot = randomHash().getBytes();\n-        AccountState accountState = mock(AccountState.class);\n-\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(block.getHash()).thenReturn(blockHash);\n-        when(repositoryLocator.snapshotAt(block.getHeader())).thenReturn(repositorySnapshot);\n-        when(repositorySnapshot.getAccountState(address)).thenReturn(accountState);\n-\n-        when(accountState.getNonce()).thenReturn(BigInteger.valueOf(nonce));\n-        when(accountState.getBalance()).thenReturn(balance);\n-        when(repositorySnapshot.getCodeHash(address)).thenReturn(codeHash);\n-        when(repositorySnapshot.getRoot()).thenReturn(storageRoot);\n-\n-        AccountsMessage expectedMessage = new AccountsMessage(id, new byte[] {0x00}, nonce,\n-                balance.asBigInteger().longValue(), codeHash.getBytes(), storageRoot);\n-\n-        ArgumentCaptor<AccountsMessage> argument = forClass(AccountsMessage.class);\n-        lightProcessor.processGetAccountsMessage(id, blockHash.getBytes(), address.getBytes(), lightPeer);\n-        verify(msgQueue).sendMessage(argument.capture());\n-\n-        assertArrayEquals(expectedMessage.getEncoded(), argument.getValue().getEncoded());\n-    }\n-\n-    @Test\n-    public void processGetAccountsMessageWithInvalidBlockHash() {\n-        long requestId = 100;\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(null);\n-        byte[] addressHash = HashUtil.randomHash();\n-\n-        lightProcessor.processGetAccountsMessage(requestId, blockHash.getBytes(), addressHash, lightPeer);\n-\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test(expected = UnsupportedOperationException.class)\n-    public void processAccountsMessageAndShouldThrowAnException() {\n-        long id = 1;\n-        byte [] merkleInclusionProof = new byte[] {0x01};\n-        long nonce = 123;\n-        long balance = 100;\n-        byte[] codeHash = HashUtil.randomHash();\n-        byte[] storageRoot = HashUtil.randomHash();\n-\n-        lightProcessor.processAccountsMessage(id, merkleInclusionProof, nonce, balance, codeHash, storageRoot, lightPeer);\n-    }\n-\n-    @Test\n-    public void processGetBlockHeaderMessageAndShouldReturnsBlockHeaderCorrectly() {\n-        final Block block = mock(Block.class);\n-        long requestId = 100;\n-        BlockHeader blockHeader = mock(BlockHeader.class);\n-        byte[] blockHeaderHash = randomHash().getBytes();\n-\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(block.getHeader()).thenReturn(blockHeader);\n-        when(blockHeader.getFullEncoded()).thenReturn(blockHeaderHash);\n-\n-        BlockHeaderMessage expectedMessage = new BlockHeaderMessage(requestId, blockHeader);\n-\n-        ArgumentCaptor<BlockHeaderMessage> argument = forClass(BlockHeaderMessage.class);\n-        lightProcessor.processGetBlockHeaderMessage(requestId, blockHash.getBytes(), lightPeer);\n-        verify(msgQueue).sendMessage(argument.capture());\n-\n-        assertArrayEquals(expectedMessage.getEncoded(), argument.getValue().getEncoded());\n-    }\n-\n-    @Test\n-    public void processGetBlockHeaderMessageWithInvalidBlockHash() {\n-        long requestId = 100;\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(null);\n-\n-        lightProcessor.processGetBlockHeaderMessage(requestId, blockHash.getBytes(), lightPeer);\n-\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test\n-    public void processGetBlocBodyMessageAndShouldReturnsBlockBodyCorrectly() {\n-        final Block block = mock(Block.class);\n-        Transaction transaction = mock(Transaction.class);\n-        BlockHeader blockHeader = mock(BlockHeader.class);\n-        byte[] blockHeaderHash = randomHash().getBytes();\n-        byte[] transactionHash = randomHash().getBytes();\n-        long requestId = 100;\n-\n-        LinkedList<BlockHeader> uncleList = new LinkedList<>();\n-        uncleList.add(blockHeader);\n-\n-        LinkedList<Transaction> transactionList = new LinkedList<>();\n-        transactionList.add(transaction);\n-\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(block.getUncleList()).thenReturn(uncleList);\n-        when(block.getTransactionsList()).thenReturn(transactionList);\n-        when(blockHeader.getFullEncoded()).thenReturn(blockHeaderHash);\n-        when(blockHeader.getEncoded()).thenReturn(blockHeaderHash);\n-        when(transaction.getEncoded()).thenReturn(transactionHash);\n-\n-        BlockBodyMessage expectedMessage = new BlockBodyMessage(requestId, transactionList, uncleList);\n-\n-        ArgumentCaptor<BlockBodyMessage> argument = forClass(BlockBodyMessage.class);\n-        lightProcessor.processGetBlockBodyMessage(requestId, blockHash.getBytes(), lightPeer);\n-        verify(msgQueue).sendMessage(argument.capture());\n-\n-        assertArrayEquals(expectedMessage.getEncoded(), argument.getValue().getEncoded());\n-    }\n-\n-    @Test\n-    public void processGetBlockBodyMessageWithInvalidBlockHash() {\n-        long requestId = 100;\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(null);\n-\n-        lightProcessor.processGetBlockBodyMessage(requestId, blockHash.getBytes(), lightPeer);\n-\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test(expected = UnsupportedOperationException.class)\n-    public void processBlockBodyMessageAndShouldThrowAnException() {\n-        LinkedList<Transaction> transactionList = new LinkedList<>();\n-        LinkedList<BlockHeader> uncleList = new LinkedList<>();\n-\n-        lightProcessor.processBlockBodyMessage(0, uncleList, transactionList,  lightPeer);\n-    }\n-\n-    @Test\n-    public void processGetStorageMessageAndShouldReturnsBlockBodyCorrectly() {\n-        long id = 0;\n-        final Block block = mock(Block.class);\n-        RskAddress address = randomAddress();\n-        DataWord storageKey = DataWord.valueOf(HashUtil.randomHash());\n-        final RepositorySnapshot repositorySnapshot = mock(RepositorySnapshot.class);\n-        byte[] storageValue = HashUtil.randomHash();\n-\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(block.getHash()).thenReturn(blockHash);\n-        when(repositoryLocator.snapshotAt(block.getHeader())).thenReturn(repositorySnapshot);\n-        when(repositorySnapshot.getStorageBytes(address, storageKey)).thenReturn(storageValue);\n-\n-        StorageMessage expectedMessage = new StorageMessage(id, new byte[] {0x00}, storageValue);\n-\n-        ArgumentCaptor<StorageMessage> argument = forClass(StorageMessage.class);\n-        lightProcessor.processGetStorageMessage(id, blockHash.getBytes(), address.getBytes(),\n-                storageKey.getData(), lightPeer);\n-        verify(msgQueue).sendMessage(argument.capture());\n-\n-        assertArrayEquals(expectedMessage.getEncoded(), argument.getValue().getEncoded());\n-    }\n-\n-    @Test\n-    public void processGetStorageMessageWithInvalidBlockHash() {\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(null);\n-\n-        lightProcessor.processGetStorageMessage(100, blockHash.getBytes(), randomAddress().getBytes(),\n-                new byte[] {0x00}, lightPeer);\n-\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test\n-    public void processGetStorageMessageWithNullStorage() {\n-        final Block block = mock(Block.class);\n-        RskAddress address = randomAddress();\n-        DataWord storageKey = DataWord.valueOf(HashUtil.randomHash());\n-        final RepositorySnapshot repositorySnapshot = mock(RepositorySnapshot.class);\n-\n-        when(blockStore.getBlockByHash(blockHash.getBytes())).thenReturn(block);\n-        when(block.getHash()).thenReturn(blockHash);\n-        when(repositoryLocator.snapshotAt(block.getHeader())).thenReturn(repositorySnapshot);\n-        when(repositorySnapshot.getStorageBytes(address, storageKey)).thenReturn(null);\n-\n-        lightProcessor.processGetStorageMessage(100, blockHash.getBytes(), randomAddress().getBytes(),\n-                new byte[] {0x00}, lightPeer);\n-\n-        verify(msgQueue, times(0)).sendMessage(any());\n-    }\n-\n-    @Test(expected = UnsupportedOperationException.class)\n-    public void processStorageMessageAndShouldThrowAnException() {\n-        lightProcessor.processStorageMessage(0, new byte[] {0x00}, new byte[] {0x00}, lightPeer);\n-    }\n-\n-    // from TransactionTest\n-    private static TransactionReceipt createReceipt() {\n-        byte[] stateRoot = Hex.decode(\"f5ff3fbd159773816a7c707a9b8cb6bb778b934a8f6466c7830ed970498f4b68\");\n-        byte[] gasUsed = Hex.decode(\"01E848\");\n-        Bloom bloom = new Bloom(Hex.decode(\"0000000000000000800000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"));\n-\n-        LogInfo logInfo1 = new LogInfo(\n-                Hex.decode(\"cd2a3d9f938e13cd947ec05abc7fe734df8dd826\"),\n-                null,\n-                Hex.decode(\"a1a1a1\")\n-        );\n-\n-        List<LogInfo> logs = new ArrayList<>();\n-        logs.add(logInfo1);\n-\n-        // TODO calculate cumulative gas\n-        TransactionReceipt receipt = new TransactionReceipt(stateRoot, gasUsed, gasUsed, bloom, logs, new byte[]{0x01});\n-\n-        receipt.setTransaction(new Transaction(null, null, null, null, null, null));\n-\n-        return receipt;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"oid": "af5a0c686bccb510f213a61766678928f9807259", "url": "https://github.com/rsksmart/rskj/commit/af5a0c686bccb510f213a61766678928f9807259", "message": "lightprocessor added", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "da7681997a189b7887101e63a2f64ddd6fb92ad2", "url": "https://github.com/rsksmart/rskj/commit/da7681997a189b7887101e63a2f64ddd6fb92ad2", "message": "BlockReceipts added to LightProcessor", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "57f1d344e6983f004657457177cb7fa49c0fbfa2", "url": "https://github.com/rsksmart/rskj/commit/57f1d344e6983f004657457177cb7fa49c0fbfa2", "message": "implemented TransactionIndex messages (Request and Response)", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "ce3b66f57ee37d56f7e073cc57dd0dc01b6c29ed", "url": "https://github.com/rsksmart/rskj/commit/ce3b66f57ee37d56f7e073cc57dd0dc01b6c29ed", "message": "blockstore and locatorRepository added in lightprocessor", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "8e2bffdd96166e2ae4ec55edb941e5e8d587d288", "url": "https://github.com/rsksmart/rskj/commit/8e2bffdd96166e2ae4ec55edb941e5e8d587d288", "message": "CodeRequestMessage added", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "db9281b8fb7742334f8d14b92dda3e3e1aa6a23d", "url": "https://github.com/rsksmart/rskj/commit/db9281b8fb7742334f8d14b92dda3e3e1aa6a23d", "message": "lightClient added as capability in Capability class", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "ff197eedc0624019d74bc328f2db6b99b216f0d6", "url": "https://github.com/rsksmart/rskj/commit/ff197eedc0624019d74bc328f2db6b99b216f0d6", "message": "init lightclienthandler\n\n\u00b7added LinkedList<>", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "6c158230d6933ee8856ff13de0f60235e7b7eace", "url": "https://github.com/rsksmart/rskj/commit/6c158230d6933ee8856ff13de0f60235e7b7eace", "message": "lc as default capability", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "cb4f5e52f781b53049cc95038c473d8ae01fd54f", "url": "https://github.com/rsksmart/rskj/commit/cb4f5e52f781b53049cc95038c473d8ae01fd54f", "message": "LightClientMessage added", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "03970a5d2357616cdae13b81fd4af9bfed9b3ea6", "url": "https://github.com/rsksmart/rskj/commit/03970a5d2357616cdae13b81fd4af9bfed9b3ea6", "message": "lightprocessor added", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "0a694b0cb034fa39f7abbafde6581a759f19d01f", "url": "https://github.com/rsksmart/rskj/commit/0a694b0cb034fa39f7abbafde6581a759f19d01f", "message": "LightClient Receipts messages (#1194)\n\n* GetBlockReceipts and BlockReceipts messages added and tested\r\n\r\n* delete blockreceipts(response/request) unused classes\r\n\r\n* messages added in both lightClientHandler and lightProcessor\r\n\r\n* initialize code instance variables in BlockReceipt y GetBlockReceipts", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "c05b4a9aba442f75e7530b0f0de3d0aab95c26ba", "url": "https://github.com/rsksmart/rskj/commit/c05b4a9aba442f75e7530b0f0de3d0aab95c26ba", "message": "Code and GetCode messages (#1197)\n\n* GetCode and Code messages added\r\n\r\n* Code(request/response) message deleted from unused classes\r\n\r\n* CodeMessage and GetCodeMessage added in LightClientHandler and LightProcessor, also in its tests", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "777f76a480d9b711efa648dc96f2899fe8afca48", "url": "https://github.com/rsksmart/rskj/commit/777f76a480d9b711efa648dc96f2899fe8afca48", "message": "GetTransactionIndex and TransactionIndex Messages (#1198)\n\n* init transaction index\r\n\r\n* WIP transactions\r\n\r\n* finished messages\r\n\r\n* added txidx to handler\r\n\r\n* fixed answer message return\r\n\r\n* hooked up to lightprocessor\r\n\r\n* len's changes\r\n\r\n* deleted old messages\r\n\r\n* rename classes\r\n\r\n* init tests\r\n\r\n* added tests for txindex\r\n\r\n* finish tests txindex\r\n\r\n* finish tests\r\n\r\n* fix sonarcould issues\r\n\r\n* code review", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "b4a00b0b67476653671e24325ab0762dbe2a3136", "url": "https://github.com/rsksmart/rskj/commit/b4a00b0b67476653671e24325ab0762dbe2a3136", "message": "Add break in lightclienthandler for BLOCK_RECEIPTS msg", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "02fa3379463bab8def9651a87e8b16a825475a6b", "url": "https://github.com/rsksmart/rskj/commit/02fa3379463bab8def9651a87e8b16a825475a6b", "message": "GetBlockHeader and BlockHeader messages (#1204)\n\n* BlockHeader and GetBlockHeader messages added\r\n\r\n* Added getBlockHeader and blockHeader in lightProcessor and lightClientHandler, everything tested", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "1f74623ff1ff81f47c33e23bf878a1793394e258", "url": "https://github.com/rsksmart/rskj/commit/1f74623ff1ff81f47c33e23bf878a1793394e258", "message": "Light client GetAccounts and Accounts Messages (#1206)\n\n* added accounts response funcionality\r\n\r\n* accounts message tests\r\n\r\n* added headers\r\n\r\n* more headers hehe\r\n\r\n* changed last message code in inRange method\r\n\r\n* Fixed some typos and better error handling on tests", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "b98515c22fde0a498b8d2c49ba71cd3856f5b473", "url": "https://github.com/rsksmart/rskj/commit/b98515c22fde0a498b8d2c49ba71cd3856f5b473", "message": "Status message (#1200)\n\n* change test message for status message adding the latest\r\n\r\n* create and test StatusMessage, also addd it to lightProcessor and lightClientHandler, processStatusMessage is not implemented\r\n\r\n* added LightSyncProcessoras manager for sync messaged, tested processStatus\r\n\r\n* lightPeer added as channel wrapper\r\n\r\n* Create Status as class\r\n\r\n* processing blockheader after status. Also tested", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "d9300c154762e1bd07c4935815c977ade2eca268", "url": "https://github.com/rsksmart/rskj/commit/d9300c154762e1bd07c4935815c977ade2eca268", "message": "Light client block body message (#1214)\n\n* BlockBody and GetBlockBody messages created and tested\r\n\r\n* GetBlockBody and BlockBody added in lightprocessor and in light handler, both were tested", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "a6def0b75d20bc039a9ed8aaa430eea630b2c70f", "url": "https://github.com/rsksmart/rskj/commit/a6def0b75d20bc039a9ed8aaa430eea630b2c70f", "message": "changed logs in light processor (#1219)", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "7a81fb50381fb6f21c054db5504919681a5fc1ad", "url": "https://github.com/rsksmart/rskj/commit/7a81fb50381fb6f21c054db5504919681a5fc1ad", "message": "GetStorage and Storage Messages (#1217)\n\n* init storage messages\r\n\r\n* get storage functionality\r\n\r\n* tests!\r\n\r\n* headers\r\n\r\n* forgotten break\r\n\r\n* changes! (from juli's review)\r\n\r\n* fix sonar cloud issues", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "4fad593f53687015a95f954a383b413648c71cc8", "url": "https://github.com/rsksmart/rskj/commit/4fad593f53687015a95f954a383b413648c71cc8", "message": "Fix and enhance testing (#1220)\n\n* tests cases in which RLP desencode as null, it's when message fields are in zero\n\n* pipeline run", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "9762917580f032f5b67b2861e21f1bb423599302", "url": "https://github.com/rsksmart/rskj/commit/9762917580f032f5b67b2861e21f1bb423599302", "message": "processStatusMessage fixed", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "4cb14b04f5f809764243c17e41c019584f72e725", "url": "https://github.com/rsksmart/rskj/commit/4cb14b04f5f809764243c17e41c019584f72e725", "message": "Message Visitor for the light client handler (#1223)\n\n* added visitor\r\n* header", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "404fe48d700d76c70626e82a58217679fc89b5ee", "url": "https://github.com/rsksmart/rskj/commit/404fe48d700d76c70626e82a58217679fc89b5ee", "message": "deleted unused logger in LightClientHandler", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "359a4ca464be6d95f4d29f8d3e64228b98bb9a35", "url": "https://github.com/rsksmart/rskj/commit/359a4ca464be6d95f4d29f8d3e64228b98bb9a35", "message": "TxRelay added as option in Status message handshake (#1224)\n\n* added txrelay as option in StatusMessage\r\n\r\n* txRelay added as lightpeer data", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "d2e57aabd09a7b16a828ccd697e8e7f6e8a7bee0", "url": "https://github.com/rsksmart/rskj/commit/d2e57aabd09a7b16a828ccd697e8e7f6e8a7bee0", "message": "txRelay settled", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "ea41c50326d17ea8d93211e25ce555c9286b51eb", "url": "https://github.com/rsksmart/rskj/commit/ea41c50326d17ea8d93211e25ce555c9286b51eb", "message": "toString methods in light client messages (#1244)", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "7d447a74568d3218784e12fb411a1d7b77d1e55e", "url": "https://github.com/rsksmart/rskj/commit/7d447a74568d3218784e12fb411a1d7b77d1e55e", "message": "Added todo comment and light client message visitor renaming (#1246)", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "3014011ae33e08dfaea7e714dada7fc0f4b6beaf", "url": "https://github.com/rsksmart/rskj/commit/3014011ae33e08dfaea7e714dada7fc0f4b6beaf", "message": "Light processor fixes (#1247)\n\n* deleted an old comment\r\n\r\n* unified the variable name request id to id", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "1824d74abe4efcce2e2d6f53123a5006529aef07", "url": "https://github.com/rsksmart/rskj/commit/1824d74abe4efcce2e2d6f53123a5006529aef07", "message": "added VisibleForTesting tag to getBlock method in LightPeer (#1245)", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "dff1a0127c5b8f41cdcca48d055c430f10bac35d", "url": "https://github.com/rsksmart/rskj/commit/dff1a0127c5b8f41cdcca48d055c430f10bac35d", "message": "add RLP utils to decode some messages, also modified getEncoded() in some message too (#1250)", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "7d36975d56495d15370d29c18ceca636fd3fc3d4", "url": "https://github.com/rsksmart/rskj/commit/7d36975d56495d15370d29c18ceca636fd3fc3d4", "message": "Fix get code usage to follow protocol correctly (#1248)\n\n* fix get code usage to follow the protocol correctly\r\n\r\n* added null check\r\n\r\n* test", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "1f076a57a1d3500ac253af322f29a3839b27e07a", "url": "https://github.com/rsksmart/rskj/commit/1f076a57a1d3500ac253af322f29a3839b27e07a", "message": "Lc lightsync refactor (#1249)\n\n* posible refactior\r\n\r\n* better refactor\r\n\r\n* added visiblefortesting tag", "committedDate": "2020-06-01T14:32:22Z", "type": "commit"}, {"oid": "1f076a57a1d3500ac253af322f29a3839b27e07a", "url": "https://github.com/rsksmart/rskj/commit/1f076a57a1d3500ac253af322f29a3839b27e07a", "message": "Lc lightsync refactor (#1249)\n\n* posible refactior\r\n\r\n* better refactor\r\n\r\n* added visiblefortesting tag", "committedDate": "2020-06-01T14:32:22Z", "type": "forcePushed"}]}