{"pr_number": 1584, "pr_title": "Support resolving stacktrace to uri", "pr_createdAt": "2020-10-27T03:02:12Z", "pr_url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1584", "timeline": [{"oid": "e29b2ef4108eac1c8af877b11ada288b5129279a", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/e29b2ef4108eac1c8af877b11ada288b5129279a", "message": "Support resolving stacktrace to uri\n\nSigned-off-by: Sheng Chen <sheche@microsoft.com>", "committedDate": "2020-10-27T02:58:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM3NzM3Nw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1584#discussion_r515377377", "bodyText": "I think there may be an issue here when JavaSourceLookupUtil#translate(..) creates a PackageFragmentRootSourceContainer(..) for the archive entries. The PackageFragmentRootSourceContainer class doesn't seem to use the source attachment to figure the source location. It ends up just returning a reference in the classfile.\nUpdate : Come to think of it, I could be wrong here. I mean if the stacktrace reference is meant to just resolve to the artifact that ran that code then I think this is fine.", "author": "rgrunber", "createdAt": "2020-10-30T20:51:40Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/handlers/JdtSourceLookUpProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Microsoft Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     Microsoft Corporation - initial API and implementation\n+*******************************************************************************/\n+\n+package org.eclipse.jdt.ls.core.internal.handlers;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.debug.core.sourcelookup.ISourceContainer;\n+import org.eclipse.jdt.core.IClassFile;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.launching.IRuntimeClasspathEntry;\n+import org.eclipse.jdt.launching.JavaRuntime;\n+import org.eclipse.jdt.launching.sourcelookup.containers.JavaProjectSourceContainer;\n+import org.eclipse.jdt.ls.core.internal.JDTUtils;\n+import org.eclipse.jdt.ls.core.internal.JavaLanguageServerPlugin;\n+import org.eclipse.jdt.ls.core.internal.ProjectUtils;\n+\n+public class JdtSourceLookUpProvider {\n+\n+    /**\n+     * Resolve the uri of the source file or class file by the class fully qualified name, the source path\n+     * and the interested projects.\n+     * \n+     * @param fullyQualifiedName\n+     *              the fully qualified name of the class.\n+     * @param sourcePath\n+     *              the source path of the class.\n+     * @param projectNames\n+     *              A list of the project names that needs to search in. If the given list is empty,\n+     *              All the projects in the workspace will be searched.\n+     * \n+     * @return the uri of the associated source file or class file.\n+     */\n+    public String getSourceFileURI(String fullyQualifiedName, String sourcePath, List<String> projectNames) {\n+        if (sourcePath == null) {\n+            return null;\n+        }\n+\n+        Object sourceElement = findSourceElement(sourcePath, getSourceContainers(projectNames));\n+        if (sourceElement instanceof IResource) {\n+            return JDTUtils.getFileURI((IResource) sourceElement);\n+        } else if (sourceElement instanceof IClassFile) {\n+            return JDTUtils.toUri((IClassFile) sourceElement);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given a source name info, search the associated source file or class file from the source container list.\n+     *\n+     * @param sourcePath\n+     *                  the target source name (e.g. org\\eclipse\\jdt\\ls\\xxx.java).\n+     * @param containers\n+     *                  the source container list.\n+     * @return the associated source file or class file.\n+     */\n+    private Object findSourceElement(String sourcePath, ISourceContainer[] containers) {\n+        if (containers == null) {\n+            return null;\n+        }\n+        for (ISourceContainer container : containers) {\n+            try {\n+                Object[] objects = container.findSourceElements(sourcePath);\n+                if (objects.length > 0 && (objects[0] instanceof IResource || objects[0] instanceof IClassFile)) {\n+                    return objects[0];\n+                }\n+            } catch (CoreException e) {\n+                JavaLanguageServerPlugin.logException(\"Failed to find the source elements\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private ISourceContainer[] getSourceContainers(List<String> projectNames) {\n+        List<IProject> projects = new ArrayList<>();\n+        if (projectNames == null || projectNames.size() == 0) {\n+            projects.addAll(Arrays.asList(ProjectUtils.getAllProjects()));\n+        } else {\n+            for (String projectName : projectNames) {\n+                projects.add(ProjectUtils.getProject(projectName));\n+            }\n+        }\n+\n+        Set<ISourceContainer> containers = new LinkedHashSet<>();\n+        Set<IRuntimeClasspathEntry> calculated = new LinkedHashSet<>();\n+        projects.stream().map(project -> ProjectUtils.getJavaProject(project))\n+            .filter(javaProject -> javaProject != null && javaProject.exists())\n+            .forEach(javaProject -> {\n+                // Add source containers associated with the project's runtime classpath entries.\n+                containers.addAll(Arrays.asList(getSourceContainers(javaProject, calculated)));\n+                // Add source containers associated with the project's source folders.\n+                containers.add(new JavaProjectSourceContainer(javaProject));\n+            });\n+\n+        return containers.toArray(new ISourceContainer[0]);\n+    }\n+\n+    private ISourceContainer[] getSourceContainers(IJavaProject project, Set<IRuntimeClasspathEntry> calculated) {\n+        if (project == null || !project.exists()) {\n+            return new ISourceContainer[0];\n+        }\n+\n+        try {\n+            IRuntimeClasspathEntry[] unresolved = JavaRuntime.computeUnresolvedRuntimeClasspath(project);\n+            List<IRuntimeClasspathEntry> resolved = new ArrayList<>();\n+            for (IRuntimeClasspathEntry entry : unresolved) {\n+                for (IRuntimeClasspathEntry resolvedEntry : JavaRuntime.resolveRuntimeClasspathEntry(entry, project)) {\n+                    if (!calculated.contains(resolvedEntry)) {\n+                        calculated.add(resolvedEntry);\n+                        resolved.add(resolvedEntry);\n+                    }\n+                }\n+            }\n+            Set<ISourceContainer> containers = new LinkedHashSet<>();\n+            containers.addAll(Arrays.asList(\n+                    JavaRuntime.getSourceContainers(resolved.toArray(new IRuntimeClasspathEntry[0]))));", "originalCommit": "e29b2ef4108eac1c8af877b11ada288b5129279a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwNzc2Nw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1584#discussion_r515707767", "bodyText": "Yes, here we mean to resolve a uri for a given stack trace line, and the uri comes from the classfile's reference.\nTo resolve the content(source code) of the uri, we have a content provider to do this: https://github.com/eclipse/eclipse.jdt.ls/blob/master/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/DisassemblerContentProvider.java#L52", "author": "jdneo", "createdAt": "2020-11-02T02:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM3NzM3Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5NjMyMA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1584#discussion_r515796320", "bodyText": "Can you make the second argument to be optional?", "author": "testforstephen", "createdAt": "2020-11-02T08:06:36Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java", "diffHunk": "@@ -79,6 +80,8 @@ public Object executeCommand(String commandId, List<Object> arguments, IProgress\n \t\t\t\tcase \"java.project.import\":\r\n \t\t\t\t\tProjectCommand.importProject(monitor);\r\n \t\t\t\t\treturn null;\r\n+\t\t\t\tcase \"java.project.resolveSourceUri\":\r\n+\t\t\t\t\treturn ResolveSourceMappingHandler.resolveSourceUri((String) arguments.get(0), (ArrayList<String>) arguments.get(1));\r", "originalCommit": "e29b2ef4108eac1c8af877b11ada288b5129279a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "278e1bd82fb39a6e9c0c18b2df21af3ed5a79d3c", "chunk": "diff --git a/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java b/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java\nindex 1d3382b8..bb2268a9 100644\n--- a/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java\n+++ b/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java\n\n@@ -81,7 +81,11 @@ public class JDTDelegateCommandHandler implements IDelegateCommandHandler {\n \t\t\t\t\tProjectCommand.importProject(monitor);\n \t\t\t\t\treturn null;\n \t\t\t\tcase \"java.project.resolveSourceUri\":\n-\t\t\t\t\treturn ResolveSourceMappingHandler.resolveSourceUri((String) arguments.get(0), (ArrayList<String>) arguments.get(1));\n+\t\t\t\t\tList<String> projectNames = null;\n+\t\t\t\t\tif (arguments.size() > 1) {\n+\t\t\t\t\t\tprojectNames = (ArrayList<String>) arguments.get(1);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn ResolveSourceMappingHandler.resolveSourceUri((String) arguments.get(0), projectNames);\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n"}}, {"oid": "278e1bd82fb39a6e9c0c18b2df21af3ed5a79d3c", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/278e1bd82fb39a6e9c0c18b2df21af3ed5a79d3c", "message": "Make projectNames optional\n\nSigned-off-by: Sheng Chen <sheche@microsoft.com>", "committedDate": "2020-11-02T08:23:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxMDkxNQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1584#discussion_r515910915", "bodyText": "Since the input is the stacktrace text, the command name such as java.project.resolveStackTraceLocation is more descriptive.", "author": "testforstephen", "createdAt": "2020-11-02T11:31:45Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java", "diffHunk": "@@ -79,6 +80,12 @@ public Object executeCommand(String commandId, List<Object> arguments, IProgress\n \t\t\t\tcase \"java.project.import\":\r\n \t\t\t\t\tProjectCommand.importProject(monitor);\r\n \t\t\t\t\treturn null;\r\n+\t\t\t\tcase \"java.project.resolveSourceUri\":\r", "originalCommit": "278e1bd82fb39a6e9c0c18b2df21af3ed5a79d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a55f4f4f3a2a4ef5584dfb8b781f07506606c0b", "chunk": "diff --git a/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java b/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java\nindex bb2268a9..291cd0d6 100644\n--- a/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java\n+++ b/org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTDelegateCommandHandler.java\n\n@@ -80,12 +80,12 @@ public class JDTDelegateCommandHandler implements IDelegateCommandHandler {\n \t\t\t\tcase \"java.project.import\":\n \t\t\t\t\tProjectCommand.importProject(monitor);\n \t\t\t\t\treturn null;\n-\t\t\t\tcase \"java.project.resolveSourceUri\":\n+\t\t\t\tcase \"java.project.resolveStackTraceLocation\":\n \t\t\t\t\tList<String> projectNames = null;\n \t\t\t\t\tif (arguments.size() > 1) {\n \t\t\t\t\t\tprojectNames = (ArrayList<String>) arguments.get(1);\n \t\t\t\t\t}\n-\t\t\t\t\treturn ResolveSourceMappingHandler.resolveSourceUri((String) arguments.get(0), projectNames);\n+\t\t\t\t\treturn ResolveSourceMappingHandler.resolveStackTraceLocation((String) arguments.get(0), projectNames);\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n"}}, {"oid": "8a55f4f4f3a2a4ef5584dfb8b781f07506606c0b", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/8a55f4f4f3a2a4ef5584dfb8b781f07506606c0b", "message": "Rename to 'java.project.resolveStackTraceLocation'\n\nSigned-off-by: Sheng Chen <sheche@microsoft.com>", "committedDate": "2020-11-03T01:36:35Z", "type": "commit"}]}