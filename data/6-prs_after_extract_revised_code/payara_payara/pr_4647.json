{"pr_number": 4647, "pr_title": "APPSERV-157 preInvoke/postInvoke ComponentInvocation logging", "pr_createdAt": "2020-05-01T14:33:59Z", "pr_url": "https://github.com/payara/Payara/pull/4647", "timeline": [{"oid": "cee27d23e05884eeb987071ca1b71bd2b485c9d8", "url": "https://github.com/payara/Payara/commit/cee27d23e05884eeb987071ca1b71bd2b485c9d8", "message": "APPSERV-157 relaxed expectation of pre and post ComponentInvcation being equal instead of identical; improved log message format and added stack trace to it", "committedDate": "2020-05-01T14:23:24Z", "type": "commit"}, {"oid": "dca22e8bd2202939a9fe5fa0b84cb5bcbe7fc192", "url": "https://github.com/payara/Payara/commit/dca22e8bd2202939a9fe5fa0b84cb5bcbe7fc192", "message": "APPSERV-157 also override hashCode for consistency", "committedDate": "2020-05-01T14:33:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0MjYxNQ==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419142615", "bodyText": "How about using Objects.hash(container, instance)?", "author": "svendiedrichsen", "createdAt": "2020-05-03T18:41:36Z", "path": "appserver/web/web-glue/src/main/java/com/sun/enterprise/web/WebComponentInvocation.java", "diffHunk": "@@ -160,4 +160,18 @@ public boolean equals(Object obj) {\n             return eq;\n         }\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        return instance == null ? container.hashCode() : container.hashCode() ^ instance.hashCode();", "originalCommit": "dca22e8bd2202939a9fe5fa0b84cb5bcbe7fc192", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2ODg3NQ==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419268875", "bodyText": "If there are other changes requested I use it for better readability. Just this alone I feel is to small to go through a new round.", "author": "jbee", "createdAt": "2020-05-04T08:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0MjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2OTgyNg==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419269826", "bodyText": "So I am back here (see comments down there) ...\nWe have two implementations of this class\n\nWebComponentInvocation - now you say two invocations are equal if they are done in same container and same instance. Are you sure it is alright?\nEjbInvocation - this uses Object.equals, so two invocations are equals if they are same one invocation\n\nThese all and even more are events ...", "author": "dmatej", "createdAt": "2020-05-04T08:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0MjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MjQxMg==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419282412", "bodyText": "There are even more implementations. That is part of the reason for the chosen solution.\nGenerally it seems reasonable for an invocation to only assume two instances being equal when a == b as they basically represent a call stack element. However, callers themselves only reacting to events have trouble to pass the very same instance of the invocation to both pre- and post as those originate from different execution stacks. The point where those are within one method is either too far up or does not even exist when originating from scheduled executions of working events.\nGiven this the question becomes: how do we know the pre/post invocation instance represent the same stack element? If == is no option equals is the next reasonable choice. WebComponentInvocation are always constructed from a WebModule and possibly an instance. Being more strict here is better since behaviour before was ==.", "author": "jbee", "createdAt": "2020-05-04T08:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0MjYxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "844fbd00498a8792ca935de5bdbcb965c31efc66", "chunk": "diff --git a/appserver/web/web-glue/src/main/java/com/sun/enterprise/web/WebComponentInvocation.java b/appserver/web/web-glue/src/main/java/com/sun/enterprise/web/WebComponentInvocation.java\nindex a32cb631ae..7c52a947b9 100644\n--- a/appserver/web/web-glue/src/main/java/com/sun/enterprise/web/WebComponentInvocation.java\n+++ b/appserver/web/web-glue/src/main/java/com/sun/enterprise/web/WebComponentInvocation.java\n\n@@ -163,7 +164,7 @@ public class WebComponentInvocation extends ComponentInvocation {\n \n     @Override\n     public int hashCode() {\n-        return instance == null ? container.hashCode() : container.hashCode() ^ instance.hashCode();\n+        return Objects.hash(container, instance);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2Mjg3Mg==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419262872", "bodyText": "I don't like mixing OR and AND operators. AND has higher priority than OR, but then the a.equals(b) will be executed ONLY IF a.getClass() == b.getClass() is true and object a is not b. But then it all can be simplified to\na.equals(b)\nBut then it smells ... so I am going back to equals of those ComponentInvocation implementations....", "author": "dmatej", "createdAt": "2020-05-04T07:48:38Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -206,6 +206,10 @@ public void setThreadInheritableInvocation(List<? extends ComponentInvocation> p\n         }\n     }\n \n+    private static boolean isEqual(ComponentInvocation a, ComponentInvocation b) {\n+        return a == b || a.getClass() == b.getClass() && a.equals(b);", "originalCommit": "dca22e8bd2202939a9fe5fa0b84cb5bcbe7fc192", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3MzY5Ng==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419273696", "bodyText": "Checking the class is not equal to only doing a.equals(b). Implementations could consider sub types as equal while I do not want that to happen.", "author": "jbee", "createdAt": "2020-05-04T08:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2Mjg3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b359a67565c5262fdebefc8eeb84c7242b55d26c", "chunk": "diff --git a/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java b/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java\nindex e3bca9f39d..feaf9320cf 100644\n--- a/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java\n+++ b/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java\n\n@@ -188,26 +191,32 @@ public class InvocationManagerImpl implements InvocationManager {\n         ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n             if (allTypesHandler != null) {\n-                allTypesHandler.beforePostInvoke(type, prev, invocation);\n+                allTypesHandler.beforePostInvoke(type, prev, current);\n             }\n             if (typeHandler != null) {\n-                typeHandler.beforePostInvoke(type, prev, invocation);\n+                typeHandler.beforePostInvoke(type, prev, current);\n             }\n         } finally {\n             // pop the stack\n             frames.removeLast();\n \n             if (allTypesHandler != null) {\n-                allTypesHandler.afterPostInvoke(type, prev, invocation);\n+                allTypesHandler.afterPostInvoke(type, prev, current);\n             }\n             if (typeHandler != null) {\n-                typeHandler.afterPostInvoke(type, prev, invocation);\n+                typeHandler.afterPostInvoke(type, prev, current);\n             }\n         }\n     }\n \n-    private static boolean isEqual(ComponentInvocation a, ComponentInvocation b) {\n-        return a == b || a.getClass() == b.getClass() && a.equals(b);\n+    private static boolean isInconsistentUse(ComponentInvocation a, ComponentInvocation b) {\n+        if (a == null || b == null) {\n+            return a != b;\n+        }\n+        if (a.getClass() != b.getClass()) {\n+            return true;\n+        }\n+        return a != b && !a.getClass().getSimpleName().equals(\"WebComponentInvocation\"); // Effectively we ignore WebComponentInvocations for now\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2NDE3Mw==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419264173", "bodyText": "Maybe instead of printing unlimited stacktrace to a single line I would rather do two logs:\nLOGGER.log(WARNING, ... message with two arguments)\nLOGGER.log(FINE, \"Stacktrace\", new IllegalStateException(\"This exception is not thrown, it is only to trace the invocation\"));", "author": "dmatej", "createdAt": "2020-05-04T07:51:23Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -178,9 +178,9 @@ public void setThreadInheritableInvocation(List<? extends ComponentInvocation> p\n         }\n \n         ComponentInvocation current = iter.next(); // the last is the current is \"invocation\"\n-        if (invocation != current) {\n-            LOGGER.log(WARNING, \"postInvoke not called with top of the invocation stack. Expected {0} but was: {1}\",\n-                    new Object[] { current, invocation });\n+        if (!isEqual(invocation, current)) {\n+            LOGGER.log(WARNING, \"postInvoke not called with top of the invocation stack. Expected:\\n{0}\\nbut was:\\n{1}\\nfor caller:\\n{2}\",\n+                    new Object[] { current, invocation, Arrays.toString(Thread.currentThread().getStackTrace()) });", "originalCommit": "dca22e8bd2202939a9fe5fa0b84cb5bcbe7fc192", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2NDgyNQ==", "url": "https://github.com/payara/Payara/pull/4647#discussion_r419264825", "bodyText": "Also that Arrays.toString will be executed even if you would set logger's level to sever or off.", "author": "dmatej", "createdAt": "2020-05-04T07:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2NDE3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "844fbd00498a8792ca935de5bdbcb965c31efc66", "chunk": "diff --git a/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java b/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java\nindex e3bca9f39d..da5aceaeac 100644\n--- a/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java\n+++ b/nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java\n\n@@ -179,8 +180,10 @@ public class InvocationManagerImpl implements InvocationManager {\n \n         ComponentInvocation current = iter.next(); // the last is the current is \"invocation\"\n         if (!isEqual(invocation, current)) {\n-            LOGGER.log(WARNING, \"postInvoke not called with top of the invocation stack. Expected:\\n{0}\\nbut was:\\n{1}\\nfor caller:\\n{2}\",\n-                    new Object[] { current, invocation, Arrays.toString(Thread.currentThread().getStackTrace()) });\n+            LOGGER.log(WARNING, \"postInvoke not called with top of the invocation stack. Expected:\\n{0}\\nbut was:\\n{1}\",\n+                    new Object[] { current, invocation });\n+            LOGGER.log(Level.FINE, \"Stacktrace: \",\n+                    new IllegalStateException(\"This exception is not thrown, it is only to trace the invocation\"));\n         }\n         ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n"}}, {"oid": "844fbd00498a8792ca935de5bdbcb965c31efc66", "url": "https://github.com/payara/Payara/commit/844fbd00498a8792ca935de5bdbcb965c31efc66", "message": "APPSERV-157 addresses review comments", "committedDate": "2020-05-04T08:38:11Z", "type": "commit"}, {"oid": "b359a67565c5262fdebefc8eeb84c7242b55d26c", "url": "https://github.com/payara/Payara/commit/b359a67565c5262fdebefc8eeb84c7242b55d26c", "message": "APPSERV-157 exlude WebComponentInvocation, otherwise expect ==", "committedDate": "2020-05-04T10:37:21Z", "type": "commit"}]}