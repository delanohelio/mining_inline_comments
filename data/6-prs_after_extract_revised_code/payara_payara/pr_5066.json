{"pr_number": 5066, "pr_title": "FISH-659: Fault Tolerance 3.0 full pass", "pr_createdAt": "2020-12-21T18:51:50Z", "pr_url": "https://github.com/payara/Payara/pull/5066", "timeline": [{"oid": "f60bcef7a619eaf20a211cc438b68ef50afb7b73", "url": "https://github.com/payara/Payara/commit/f60bcef7a619eaf20a211cc438b68ef50afb7b73", "message": "FISH-659: Clear all application-related cache on undeployment", "committedDate": "2020-12-18T16:08:44Z", "type": "commit"}, {"oid": "60c62493a079614ca49f2afd3c7917ff6617d452", "url": "https://github.com/payara/Payara/commit/60c62493a079614ca49f2afd3c7917ff6617d452", "message": "FISH-659: Revert to using managed executors for fault tolerance\n\nManaged executor retain invocation context upon submission, fixing the problem\nof interceptor getting fresh state because invocation manager returned wrong\napplication name", "committedDate": "2020-12-18T16:19:47Z", "type": "commit"}, {"oid": "624e3e42d10012f212b3b885580b59473b57e171", "url": "https://github.com/payara/Payara/commit/624e3e42d10012f212b3b885580b59473b57e171", "message": "FISH-659: Remove arbitrary limit on bulkhead CAS operation\n\nResulted in \"No free work or queue space\" when CAS would fail just 5 times.\nFix NPE in FaultToleranceInvocation.toString.", "committedDate": "2020-12-21T17:21:27Z", "type": "commit"}, {"oid": "6e1359f3c85eed347c4849e7c3a233ff8d06412c", "url": "https://github.com/payara/Payara/commit/6e1359f3c85eed347c4849e7c3a233ff8d06412c", "message": "FISH-659: Optimize initialization of FaultToleranceInterceptor", "committedDate": "2020-12-21T18:13:28Z", "type": "commit"}, {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3", "url": "https://github.com/payara/Payara/commit/b6f5638129116272d7e23bc0e51298995513b0e3", "message": "FISH-659: Use compound method key for FT data\n\nDetermining app name and composing String methodId unnecessarily slows down.\n\nApp name is determined once per method context now.\n\nFT data are now deleted upon undeployment by matching classes' classloaders\nagainst undeployed app's classloader.\n\nExpiration of the cache was removed, removing need for target object and expiration checks.\n\nFaultToleranceServiceStub introduces StubContext as encapsulation of MethodKey which would\notherwise need to be public.", "committedDate": "2020-12-21T18:20:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2NzcxNQ==", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547167715", "bodyText": "Nice idea.", "author": "jbee", "createdAt": "2020-12-22T09:31:06Z", "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -119,87 +115,28 @@\n     @Inject\n     private MetricsService metricsService;\n \n-    private final ConcurrentMap<String, ConcurrentMap<String, FaultToleranceMethodContextImpl>> contextByAppNameAndMethodId = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<MethodKey, FaultToleranceMethodContextImpl> contextByMethod = new ConcurrentHashMap<>();\n     private final ConcurrentMap<String, BindableFaultToleranceConfig> configByAppName = new ConcurrentHashMap<>();\n-    private ThreadPoolExecutor asyncExecutorService;\n+    private ExecutorService asyncExecutorService;\n     private ScheduledExecutorService delayExecutorService;\n \n     @PostConstruct\n-    public void postConstruct() {\n+    public void postConstruct() throws NamingException {\n         events.register(this);\n         invocationManager = serviceLocator.getService(InvocationManager.class);\n         requestTracingService = serviceLocator.getService(RequestTracingService.class);\n         config = serviceLocator.getService(FaultToleranceServiceConfiguration.class);\n-        delayExecutorService = Executors.newScheduledThreadPool(getMaxDelayPoolSize());\n-        asyncExecutorService = new ThreadPoolExecutor(0, getMaxAsyncPoolSize(), getAsyncPoolKeepAliveInSeconds(),\n-                TimeUnit.SECONDS, new SynchronousQueue<Runnable>(true)); // a fair queue => FIFO\n-        int interval = getCleanupIntervalInMinutes();\n-        delayExecutorService.scheduleAtFixedRate(this::cleanMethodContexts, interval, interval, TimeUnit.MINUTES);\n-        if (config != null) {\n-            if (!\"concurrent/__defaultManagedExecutorService\".equals(config.getManagedExecutorService())) {\n-                logger.log(Level.WARNING,\n-                        \"Fault tolerance executor service was configured to managed executor service {0}. This option has been replaced by 'async-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n-                        config.getManagedExecutorService());\n-            }\n-            if (!\"concurrent/__defaultManagedScheduledExecutorService\".equals(config.getManagedScheduledExecutorService())) {\n-                logger.log(Level.WARNING,\n-                        \"Fault tolerance scheduled executor service was configured to managed scheduled executor service {0}. This option has been replaced by 'delay-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n-                        config.getManagedScheduledExecutorService());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Since {@link Map#compute(Object, java.util.function.BiFunction)} locks the key entry for\n-     * {@link ConcurrentHashMap} it is safe to remove the entry in case\n-     * {@link FaultToleranceMethodContextImpl#isExpired(long)} as concurrent call to\n-     * {@link Map#computeIfAbsent(Object, java.util.function.Function)} are going to wait for the completion of\n-     * {@link Map#compute(Object, java.util.function.BiFunction)}.\n-     */\n-    private void cleanMethodContexts() {\n-        final long ttl = TimeUnit.MINUTES.toMillis(1);\n-        int cleaned = 0;\n-        for (Map<String, FaultToleranceMethodContextImpl> appEntry : contextByAppNameAndMethodId.values()) {\n-            for (String key : new HashSet<>(appEntry.keySet())) {\n-                try {\n-                    Object newValue = appEntry.compute(key,\n-                            (k, methodContext) -> methodContext.isExpired(ttl) ? null : methodContext);\n-                    if (newValue == null) {\n-                        cleaned++;\n-                    }\n-                } catch (Exception e) {\n-                    logger.log(Level.WARNING, \"Failed to clean FT method context for \" + key, e);\n-                }\n-            }\n-        }\n-        if (cleaned > 0) {\n-            String allClean = contextByAppNameAndMethodId.isEmpty() ? \".All clean.\" : \".\";\n-            logger.log(Level.INFO, \"Cleaned {0} expired FT method contexts\" + allClean, cleaned);\n-        }\n-    }\n-\n-    private int getMaxDelayPoolSize() {\n-        return config == null ? 20 : parseInt(config.getDelayMaxPoolSize());\n-    }\n-\n-    private int getMaxAsyncPoolSize() {\n-        return config == null ? 2000 : parseInt(config.getAsyncMaxPoolSize());\n-    }\n-\n-    private int getAsyncPoolKeepAliveInSeconds() {\n-        return config == null ? 60 : parseInt(config.getAsyncPoolKeepAliveInSeconds());\n-    }\n-\n-    private int getCleanupIntervalInMinutes() {\n-        return config == null ? 1 : parseInt(config.getCleanupIntervalInMinutes());\n+        InitialContext context = new InitialContext();\n+        asyncExecutorService = (ManagedExecutorService) context.lookup(config.getManagedExecutorService());\n+        delayExecutorService = (ManagedScheduledExecutorService) context.lookup(config.getManagedScheduledExecutorService());\n     }\n \n     @Override\n     public void event(Event<?> event) {\n         if (event.is(Deployment.APPLICATION_UNLOADED)) {\n             ApplicationInfo info = (ApplicationInfo) event.hook();\n-            deregisterApplication(info.getName());\n-            FaultTolerancePolicy.clean();\n+            deregisterApplication(info);\n+            FaultTolerancePolicy.clean(info.getAppClassLoader());", "originalCommit": "b6f5638129116272d7e23bc0e51298995513b0e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2OTkxMQ==", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547169911", "bodyText": "I assume you are happy to have this run in parallel threads in worst case as the result will be the same.", "author": "jbee", "createdAt": "2020-12-22T09:35:25Z", "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/MethodKey.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package fish.payara.microprofile.faulttolerance.service;\n+\n+import javax.interceptor.InvocationContext;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+/**\n+ * Identifier of method-related data in Fault Tolerance.\n+ * It is essential that the computed signature is referring to the {@link Method} as defined by the target\n+ * {@link Object} class not its declaring {@link Class} as this could be different when called via an abstract\n+ * {@link Method} implemented or overridden by the target {@link Class}.\n+ *\n+ * Since MP FT 3.0 all instances of a class share same state object for the same method. Or in other words the FT\n+ * context is not specific to an instance but to the annotated class and method.\n+ */\n+final class MethodKey {\n+    final Class<?> targetClass;\n+    final Method method;\n+    private String methodId;\n+\n+    MethodKey(InvocationContext ctx) {\n+        this.targetClass = ctx.getTarget().getClass();\n+        this.method = ctx.getMethod();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        MethodKey methodKey = (MethodKey) o;\n+        return targetClass.equals(methodKey.targetClass) && method.equals(methodKey.method);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(targetClass, method);\n+    }\n+\n+    String getMethodId() {\n+        if (methodId != null) {\n+            return methodId;\n+        }\n+        StringBuilder idBuilder = new StringBuilder();\n+        idBuilder.append(targetClass.getName()).append('.').append(method.getName());\n+        if (method.getParameterCount() > 0) {\n+            idBuilder.append('(');\n+            for (Class<?> param : method.getParameterTypes()) {\n+                idBuilder.append(param.getName()).append(' ');\n+            }\n+            idBuilder.append(')');\n+        }\n+        methodId = idBuilder.toString();", "originalCommit": "b6f5638129116272d7e23bc0e51298995513b0e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwMDQ0OA==", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547200448", "bodyText": "Yes, that was my thoughts.", "author": "pdudits", "createdAt": "2020-12-22T10:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2OTkxMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "12d9c21cdfbf86838f6d8d6f34847007ffe74e76", "url": "https://github.com/payara/Payara/commit/12d9c21cdfbf86838f6d8d6f34847007ffe74e76", "message": "FISH-659: Lookup managed concurrency objects via their logical name\n\nLooking them up via logical name triggers the activator which\nwould create them in domain config if they are not materialized in domain.xml\nyet", "committedDate": "2020-12-22T15:40:37Z", "type": "commit"}]}