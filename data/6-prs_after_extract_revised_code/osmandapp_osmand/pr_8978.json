{"pr_number": 8978, "pr_title": "Route merge", "pr_createdAt": "2020-05-15T12:40:38Z", "pr_url": "https://github.com/osmandapp/OsmAnd/pull/8978", "timeline": [{"oid": "87a7b42f66e4d14ade81b68a677ffa494ad96c2e", "url": "https://github.com/osmandapp/OsmAnd/commit/87a7b42f66e4d14ade81b68a677ffa494ad96c2e", "message": "work in project, crude merge working", "committedDate": "2020-05-08T13:40:58Z", "type": "commit"}, {"oid": "2c8824341ad1c4f5df1e87da8de4c9ca9d19b014", "url": "https://github.com/osmandapp/OsmAnd/commit/2c8824341ad1c4f5df1e87da8de4c9ca9d19b014", "message": "work in progress", "committedDate": "2020-05-12T09:42:12Z", "type": "commit"}, {"oid": "8e56faabd1bb9610826327c94ea7e93f5250de2b", "url": "https://github.com/osmandapp/OsmAnd/commit/8e56faabd1bb9610826327c94ea7e93f5250de2b", "message": "Merge branch 'master' into route_merge", "committedDate": "2020-05-12T09:45:18Z", "type": "commit"}, {"oid": "7699e2061c75bcf13697145f79f1522c5f40ec79", "url": "https://github.com/osmandapp/OsmAnd/commit/7699e2061c75bcf13697145f79f1522c5f40ec79", "message": "add reading of incomplete routes. Add cache - work in progress", "committedDate": "2020-05-13T12:09:30Z", "type": "commit"}, {"oid": "3aafda798b60692a7eaaf7cd73865735c878e731", "url": "https://github.com/osmandapp/OsmAnd/commit/3aafda798b60692a7eaaf7cd73865735c878e731", "message": "Merge branch 'master' into route_merge", "committedDate": "2020-05-13T12:12:45Z", "type": "commit"}, {"oid": "d3d55cec4b3c419c1bc2b5c6a8e52abf06c786d4", "url": "https://github.com/osmandapp/OsmAnd/commit/d3d55cec4b3c419c1bc2b5c6a8e52abf06c786d4", "message": "combine routes WIP", "committedDate": "2020-05-14T07:18:21Z", "type": "commit"}, {"oid": "3ec03040ea68f3412145d4d92f8b26cce45fcbc8", "url": "https://github.com/osmandapp/OsmAnd/commit/3ec03040ea68f3412145d4d92f8b26cce45fcbc8", "message": "merge route parts implementation", "committedDate": "2020-05-15T11:36:31Z", "type": "commit"}, {"oid": "3c655c4f986f192fe49d08332ba8d19d48b55b54", "url": "https://github.com/osmandapp/OsmAnd/commit/3c655c4f986f192fe49d08332ba8d19d48b55b54", "message": "fixes", "committedDate": "2020-05-15T11:39:42Z", "type": "commit"}, {"oid": "9fe736957dbd13abb7234c454934ceb310bf935e", "url": "https://github.com/osmandapp/OsmAnd/commit/9fe736957dbd13abb7234c454934ceb310bf935e", "message": "clear garbage", "committedDate": "2020-05-15T11:57:06Z", "type": "commit"}, {"oid": "87f49ed3d9845e806dbd8c20b2cd19cf8d4b4e88", "url": "https://github.com/osmandapp/OsmAnd/commit/87f49ed3d9845e806dbd8c20b2cd19cf8d4b4e88", "message": "Transport route", "committedDate": "2020-05-15T15:27:59Z", "type": "commit"}, {"oid": "99503fdec5b1a6139bde6af4707d776779a33c78", "url": "https://github.com/osmandapp/OsmAnd/commit/99503fdec5b1a6139bde6af4707d776779a33c78", "message": "Update transport rotues", "committedDate": "2020-05-16T14:03:54Z", "type": "commit"}, {"oid": "b456c41b341e7f1bd6c60c08abc4b0ab816770e6", "url": "https://github.com/osmandapp/OsmAnd/commit/b456c41b341e7f1bd6c60c08abc4b0ab816770e6", "message": "Update transport rotues", "committedDate": "2020-05-16T14:33:59Z", "type": "commit"}, {"oid": "52fec9c7cc46f8455b9e13a1c36ef5e04d813b66", "url": "https://github.com/osmandapp/OsmAnd/commit/52fec9c7cc46f8455b9e13a1c36ef5e04d813b66", "message": "Update transport rotues", "committedDate": "2020-05-16T14:48:01Z", "type": "commit"}, {"oid": "e5bd6cb065ab46cdbf177773f7a90f8a8df2c67b", "url": "https://github.com/osmandapp/OsmAnd/commit/e5bd6cb065ab46cdbf177773f7a90f8a8df2c67b", "message": "Update transport rotues", "committedDate": "2020-05-16T14:49:17Z", "type": "commit"}, {"oid": "4873ab04a95af48214f5db6bcfe6d9accc12425b", "url": "https://github.com/osmandapp/OsmAnd/commit/4873ab04a95af48214f5db6bcfe6d9accc12425b", "message": "Update transport rotues", "committedDate": "2020-05-16T14:51:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MTgyNg==", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426161826", "bodyText": "This is not part of cachedosmandindexes so it won't work correctly with cache", "author": "vshcherb", "createdAt": "2020-05-16T15:08:57Z", "path": "OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapTransportReaderAdapter.java", "diffHunk": "@@ -43,6 +44,8 @@ private int readInt() throws IOException {\n \n \t\tint stopsFileOffset = 0;\n \t\tint stopsFileLength = 0;\n+\t\tint incompleteRoutesOffset = 0;", "originalCommit": "4873ab04a95af48214f5db6bcfe6d9accc12425b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "7319a235c0c778c089c9b6b935d7e27f1ea2ffb8", "url": "https://github.com/osmandapp/OsmAnd/commit/7319a235c0c778c089c9b6b935d7e27f1ea2ffb8", "message": "Lazy loading reading", "committedDate": "2020-05-16T15:12:34Z", "type": "commit"}, {"oid": "a52767bdb3a819d2eaad2255151f02311354889e", "url": "https://github.com/osmandapp/OsmAnd/commit/a52767bdb3a819d2eaad2255151f02311354889e", "message": "clean up", "committedDate": "2020-05-16T15:17:04Z", "type": "commit"}, {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29", "url": "https://github.com/osmandapp/OsmAnd/commit/a00011693acdfa4aac0f04fd8557719a07256e29", "message": "clean up", "committedDate": "2020-05-16T15:18:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Mjc5OQ==", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426162799", "bodyText": "???", "author": "vshcherb", "createdAt": "2020-05-16T15:19:58Z", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -378,7 +382,7 @@ public QuadRect getSegmentRect() {\n \n \t\tpublic List<Way> getGeometry() {\n \t\t\tList<Way> list = new ArrayList<>();\n-\t\t\troute.mergeForwardWays();\n+\t\t\troute.mergeForwardWays(); //TODO merge ways of all Route parts", "originalCommit": "a00011693acdfa4aac0f04fd8557719a07256e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a01a4ad63e24e96f37d125b22803513989cf9832", "chunk": "diff --git a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\nindex 9ca8d2a609..84e257323b 100644\n--- a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n+++ b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n\n@@ -381,8 +382,7 @@ public class TransportRoutePlanner {\n \t\t}\n \n \t\tpublic List<Way> getGeometry() {\n-\t\t\tList<Way> list = new ArrayList<>();\n-\t\t\troute.mergeForwardWays(); //TODO merge ways of all Route parts\n+\t\t\troute.mergeForwardWays();\n \t\t\tif (DISPLAY_FULL_SEGMENT_ROUTE) {\n \t\t\t\tSystem.out.println(\"TOTAL SEGMENTS: \" + route.getForwardWays().size());\n \t\t\t\tif (route.getForwardWays().size() > DISPLAY_SEGMENT_IND) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Mjk5Nw==", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426162997", "bodyText": "TODO", "author": "vshcherb", "createdAt": "2020-05-16T15:22:15Z", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -903,7 +923,229 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \n \t\t\treturn stops;\n \t\t}\n+\t\t\n+\t\tprivate TransportRoute getCombinedRoute(TransportRoute route) throws IOException {\n+\t\t\tif (!route.isIncomplete()) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\tTransportRoute c = combinedRoutesCache.get(route.getId());\n+\t\t\tif (c == null) {\n+\t\t\t\tc = combineRoute(route);\n+\t\t\t\tcombinedRoutesCache.put(route.getId(), c);\n+\t\t\t}\n+\t\t\treturn c;\n+\t\t} \n+\n+\t\tprivate TransportRoute combineRoute(TransportRoute route) throws IOException {\n+\t\t\t// 1. Get all available route parts;\n+\t\t\tList<TransportRoute> incompleteRoutes = findIncompleteRouteParts(route);\n+\t\t\tif (incompleteRoutes == null) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\t// here could be multiple overlays between same points\n+\t\t\t// It's better to remove them especially identical segments\n+\t\t\tList<Way> allWays = getAllWays(incompleteRoutes);\n+\t\t\t\n+\t\t\t\n+\t\t\t// 2. Get array of segments (each array size > 1):\n+\t\t\tLinkedList<List<TransportStop>> stopSegments = parseRoutePartsToSegments(incompleteRoutes);\n+\t\t\t\n+\t\t\t// 3. Merge segments and remove excess missingStops (when they are closer then MISSING_STOP_SEARCH_RADIUS):\n+\t\t\t//    + Check for missingStops. If they present in the middle/there more then one segment - we have a hole in the  map data\n+\t\t\tList<List<TransportStop>> mergedSegments = combineSegmentsOfSameRoute(stopSegments);\n+\t\t\t\n+\t\t\t// 4. Now we need to properly sort segments, proper sorting is minimizing distance between stops\n+\t\t\t// So it is salesman problem, we have this solution at TspAnt, but if we know last or first segment we can solve it straightforward\n+\t\t\tList<TransportStop> firstSegment = null;\n+\t\t\tList<TransportStop> lastSegment = null;\n+\t\t\tfor(List<TransportStop> l : mergedSegments) {\n+\t\t\t\tif(!l.get(0).isMissingStop()) {\n+\t\t\t\t\tfirstSegment = l;\n+\t\t\t\t} \n+\t\t\t\tif(!l.get(l.size() - 1).isMissingStop()) {\n+\t\t\t\t\tlastSegment = l;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tList<List<TransportStop>> sortedSegments = new ArrayList<List<TransportStop>>(); \n+\t\t\tif(firstSegment != null) {\n+\t\t\t\tsortedSegments.add(firstSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> last = sortedSegments.get(sortedSegments.size() - 1);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(last.get(last.size() - 1).getLocation(), mergedSegments, true);\n+\t\t\t\t\tsortedSegments.add(add);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t} else if(lastSegment != null) {\n+\t\t\t\tsortedSegments.add(lastSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> first = sortedSegments.get(0);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(first.get(0).getLocation(), mergedSegments, false);\n+\t\t\t\t\tsortedSegments.add(0, add);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tsortedSegments = mergedSegments;\n+\t\t\t}\n+\t\t\tList<TransportStop> finalList = new ArrayList<TransportStop>();\n+\t\t\tfor(List<TransportStop> s : sortedSegments) {\n+\t\t\t\tfinalList.addAll(s);\n+\t\t\t}\n+\t\t\t// 5. Create combined TransportRoute and return it\n+\t\t\treturn new TransportRoute(route, finalList, allWays);\n+\t\t}\n+\n+\t\tprivate List<TransportStop> findAndDeleteMinDistance(LatLon location, List<List<TransportStop>> mergedSegments,\n+\t\t\t\tboolean attachToBegin) {\n+\t\t\tint ind = attachToBegin ? 0 : mergedSegments.get(0).size() - 1;\n+\t\t\tdouble minDist = MapUtils.getDistance(mergedSegments.get(0).get(ind).getLocation(), location);\n+\t\t\tint minInd = 0;\n+\t\t\tfor(int i = 1; i < mergedSegments.size(); i++) {\n+\t\t\t\tind = attachToBegin ? 0 : mergedSegments.get(i).size() - 1;\n+\t\t\t\tdouble dist = MapUtils.getDistance(mergedSegments.get(i).get(ind).getLocation(), location);\n+\t\t\t\tif(dist < minDist) {\n+\t\t\t\t\tminInd = i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mergedSegments.remove(minInd);\n+\t\t}\n \n+\t\tprivate List<Way> getAllWays(List<TransportRoute> parts) {\n+\t\t\tList<Way> w = new ArrayList<Way>();\n+\t\t\tfor (TransportRoute t : parts) {\n+\t\t\t\tw.addAll(t.getForwardWays());\n+\t\t\t}\n+\t\t\treturn w;\n+\t\t}\n+\t\t\n+\t\t\n+\t\t\n+\t\tprivate List<List<TransportStop>> combineSegmentsOfSameRoute(LinkedList<List<TransportStop>> segments) {\n+\t\t\tList<List<TransportStop>> resultSegments = new ArrayList<List<TransportStop>>();\n+\t\t\twhile (!segments.isEmpty()) {\n+\t\t\t\tList<TransportStop> firstSegment = segments.poll();\n+\t\t\t\tboolean merged = true;\n+\t\t\t\twhile (merged) {\n+\t\t\t\t\tmerged = false;\n+\t\t\t\t\tIterator<List<TransportStop>> it = segments.iterator();\n+\t\t\t\t\twhile (it.hasNext()) {\n+\t\t\t\t\t\tList<TransportStop> segmentToMerge = it.next();\n+\t\t\t\t\t\tmerged = tryToMerge(firstSegment, segmentToMerge);\n+\t\t\t\t\t\tif (merged) {\n+\t\t\t\t\t\t\tit.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tresultSegments.add(firstSegment);\n+\t\t\t}\n+\t\t\treturn resultSegments;\n+\t\t}\t\n+\t\t\n+\t\tprivate boolean tryToMerge(List<TransportStop> firstSegment, List<TransportStop> segmentToMerge) {\n+\t\t\tif(firstSegment.size() < 2 || segmentToMerge.size() < 2) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t// 1st we check that segments overlap by stop\n+\t\t\tint commonStopFirst = 0;\n+\t\t\tint commonStopSecond = 0;\n+\t\t\tfor(;commonStopFirst < firstSegment.size(); commonStopFirst++) {\n+\t\t\t\tfor(; commonStopSecond < segmentToMerge.size(); commonStopSecond++ ) {\n+\t\t\t\t\tlong lid1 = firstSegment.get(commonStopFirst).getId();\n+\t\t\t\t\tlong lid2 = segmentToMerge.get(commonStopSecond).getId();\n+\t\t\t\t\tif(lid1 > 0 && lid2 == lid1) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(commonStopFirst < firstSegment.size()) {\n+\t\t\t\t// we've found common stop so we can merge based on stops\n+\t\t\t\t// merge last part first\n+\t\t\t\tif(firstSegment.size() - commonStopFirst < segmentToMerge.size() - commonStopSecond) {\n+\t\t\t\t\twhile(firstSegment.size() > commonStopFirst) {\n+\t\t\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// merge first part\n+\t\t\t\tif(commonStopFirst < commonStopSecond) {\n+\t\t\t\t\tfor(int i = 0; i < commonStopFirst; i++) {\n+\t\t\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i >= 0; i--) {\n+\t\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t\t}\t\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t\t\n+\t\t\t}\n+\t\t\t// no common stops, so try to connect to the end or beginning\n+\t\t\t// beginning\n+\t\t\tboolean merged = false;\n+\t\t\tif (MapUtils.getDistance(firstSegment.get(0).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(segmentToMerge.size() - 1).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\tfor(int i = segmentToMerge.size() - 2; i >= 0; i--) {\n+\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t} else if(MapUtils.getDistance(firstSegment.get(firstSegment.size() - 1).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(0).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\tfor(int i = 1; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t}\n+\t\t\treturn merged;\n+\t\t}\n+\n+\t\t\n+\t\t\n+\t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n+\t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n+\t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n+\t\t\t// TODO check generation that are doubles\n+\t\t\tfor (TransportRoute part : routeParts) {\n+\t\t\t\tList<TransportStop> newSeg = new ArrayList<TransportStop>();\n+\t\t\t\tfor (TransportStop s : part.getForwardStops()) {\n+\t\t\t\t\tnewSeg.add(s);\n+\t\t\t\t\tif (s.isMissingStop()) {\n+\t\t\t\t\t\tif (newSeg.size() > 1) {\n+\t\t\t\t\t\t\tsegs.add(newSeg);\n+\t\t\t\t\t\t\tnewSeg = new ArrayList<TransportStop>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (newSeg.size() > 1) {\n+\t\t\t\t\tsegs.add(newSeg);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn segs;\n+\t\t}\n+\t\t\n+\t\tprivate List<TransportRoute> findIncompleteRouteParts(TransportRoute baseRoute) throws IOException {\n+\t\t\tList<TransportRoute> allRoutes = null;\n+\t\t\t// TODO completely irrelevant always reiteration over all maps (especially not in bbox of the route probabl)\n+\t\t\tfor (BinaryMapIndexReader bmir : routeMap.keySet()) {", "originalCommit": "a00011693acdfa4aac0f04fd8557719a07256e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d96394a0e19c13d589f988987944523814041c8", "chunk": "diff --git a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\nindex 9ca8d2a609..599c664203 100644\n--- a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n+++ b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n\n@@ -1105,7 +1104,7 @@ public class TransportRoutePlanner {\n \t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n \t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n \t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n-\t\t\t// TODO check generation that are doubles\n+\t\t\t// we don't add segments with 1 stop cause they are irrelevant further\n \t\t\tfor (TransportRoute part : routeParts) {\n \t\t\t\tList<TransportStop> newSeg = new ArrayList<TransportStop>();\n \t\t\t\tfor (TransportStop s : part.getForwardStops()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzAwNQ==", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426163005", "bodyText": "TODO", "author": "vshcherb", "createdAt": "2020-05-16T15:22:19Z", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -903,7 +923,229 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \n \t\t\treturn stops;\n \t\t}\n+\t\t\n+\t\tprivate TransportRoute getCombinedRoute(TransportRoute route) throws IOException {\n+\t\t\tif (!route.isIncomplete()) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\tTransportRoute c = combinedRoutesCache.get(route.getId());\n+\t\t\tif (c == null) {\n+\t\t\t\tc = combineRoute(route);\n+\t\t\t\tcombinedRoutesCache.put(route.getId(), c);\n+\t\t\t}\n+\t\t\treturn c;\n+\t\t} \n+\n+\t\tprivate TransportRoute combineRoute(TransportRoute route) throws IOException {\n+\t\t\t// 1. Get all available route parts;\n+\t\t\tList<TransportRoute> incompleteRoutes = findIncompleteRouteParts(route);\n+\t\t\tif (incompleteRoutes == null) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\t// here could be multiple overlays between same points\n+\t\t\t// It's better to remove them especially identical segments\n+\t\t\tList<Way> allWays = getAllWays(incompleteRoutes);\n+\t\t\t\n+\t\t\t\n+\t\t\t// 2. Get array of segments (each array size > 1):\n+\t\t\tLinkedList<List<TransportStop>> stopSegments = parseRoutePartsToSegments(incompleteRoutes);\n+\t\t\t\n+\t\t\t// 3. Merge segments and remove excess missingStops (when they are closer then MISSING_STOP_SEARCH_RADIUS):\n+\t\t\t//    + Check for missingStops. If they present in the middle/there more then one segment - we have a hole in the  map data\n+\t\t\tList<List<TransportStop>> mergedSegments = combineSegmentsOfSameRoute(stopSegments);\n+\t\t\t\n+\t\t\t// 4. Now we need to properly sort segments, proper sorting is minimizing distance between stops\n+\t\t\t// So it is salesman problem, we have this solution at TspAnt, but if we know last or first segment we can solve it straightforward\n+\t\t\tList<TransportStop> firstSegment = null;\n+\t\t\tList<TransportStop> lastSegment = null;\n+\t\t\tfor(List<TransportStop> l : mergedSegments) {\n+\t\t\t\tif(!l.get(0).isMissingStop()) {\n+\t\t\t\t\tfirstSegment = l;\n+\t\t\t\t} \n+\t\t\t\tif(!l.get(l.size() - 1).isMissingStop()) {\n+\t\t\t\t\tlastSegment = l;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tList<List<TransportStop>> sortedSegments = new ArrayList<List<TransportStop>>(); \n+\t\t\tif(firstSegment != null) {\n+\t\t\t\tsortedSegments.add(firstSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> last = sortedSegments.get(sortedSegments.size() - 1);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(last.get(last.size() - 1).getLocation(), mergedSegments, true);\n+\t\t\t\t\tsortedSegments.add(add);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t} else if(lastSegment != null) {\n+\t\t\t\tsortedSegments.add(lastSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> first = sortedSegments.get(0);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(first.get(0).getLocation(), mergedSegments, false);\n+\t\t\t\t\tsortedSegments.add(0, add);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tsortedSegments = mergedSegments;\n+\t\t\t}\n+\t\t\tList<TransportStop> finalList = new ArrayList<TransportStop>();\n+\t\t\tfor(List<TransportStop> s : sortedSegments) {\n+\t\t\t\tfinalList.addAll(s);\n+\t\t\t}\n+\t\t\t// 5. Create combined TransportRoute and return it\n+\t\t\treturn new TransportRoute(route, finalList, allWays);\n+\t\t}\n+\n+\t\tprivate List<TransportStop> findAndDeleteMinDistance(LatLon location, List<List<TransportStop>> mergedSegments,\n+\t\t\t\tboolean attachToBegin) {\n+\t\t\tint ind = attachToBegin ? 0 : mergedSegments.get(0).size() - 1;\n+\t\t\tdouble minDist = MapUtils.getDistance(mergedSegments.get(0).get(ind).getLocation(), location);\n+\t\t\tint minInd = 0;\n+\t\t\tfor(int i = 1; i < mergedSegments.size(); i++) {\n+\t\t\t\tind = attachToBegin ? 0 : mergedSegments.get(i).size() - 1;\n+\t\t\t\tdouble dist = MapUtils.getDistance(mergedSegments.get(i).get(ind).getLocation(), location);\n+\t\t\t\tif(dist < minDist) {\n+\t\t\t\t\tminInd = i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mergedSegments.remove(minInd);\n+\t\t}\n \n+\t\tprivate List<Way> getAllWays(List<TransportRoute> parts) {\n+\t\t\tList<Way> w = new ArrayList<Way>();\n+\t\t\tfor (TransportRoute t : parts) {\n+\t\t\t\tw.addAll(t.getForwardWays());\n+\t\t\t}\n+\t\t\treturn w;\n+\t\t}\n+\t\t\n+\t\t\n+\t\t\n+\t\tprivate List<List<TransportStop>> combineSegmentsOfSameRoute(LinkedList<List<TransportStop>> segments) {\n+\t\t\tList<List<TransportStop>> resultSegments = new ArrayList<List<TransportStop>>();\n+\t\t\twhile (!segments.isEmpty()) {\n+\t\t\t\tList<TransportStop> firstSegment = segments.poll();\n+\t\t\t\tboolean merged = true;\n+\t\t\t\twhile (merged) {\n+\t\t\t\t\tmerged = false;\n+\t\t\t\t\tIterator<List<TransportStop>> it = segments.iterator();\n+\t\t\t\t\twhile (it.hasNext()) {\n+\t\t\t\t\t\tList<TransportStop> segmentToMerge = it.next();\n+\t\t\t\t\t\tmerged = tryToMerge(firstSegment, segmentToMerge);\n+\t\t\t\t\t\tif (merged) {\n+\t\t\t\t\t\t\tit.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tresultSegments.add(firstSegment);\n+\t\t\t}\n+\t\t\treturn resultSegments;\n+\t\t}\t\n+\t\t\n+\t\tprivate boolean tryToMerge(List<TransportStop> firstSegment, List<TransportStop> segmentToMerge) {\n+\t\t\tif(firstSegment.size() < 2 || segmentToMerge.size() < 2) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t// 1st we check that segments overlap by stop\n+\t\t\tint commonStopFirst = 0;\n+\t\t\tint commonStopSecond = 0;\n+\t\t\tfor(;commonStopFirst < firstSegment.size(); commonStopFirst++) {\n+\t\t\t\tfor(; commonStopSecond < segmentToMerge.size(); commonStopSecond++ ) {\n+\t\t\t\t\tlong lid1 = firstSegment.get(commonStopFirst).getId();\n+\t\t\t\t\tlong lid2 = segmentToMerge.get(commonStopSecond).getId();\n+\t\t\t\t\tif(lid1 > 0 && lid2 == lid1) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(commonStopFirst < firstSegment.size()) {\n+\t\t\t\t// we've found common stop so we can merge based on stops\n+\t\t\t\t// merge last part first\n+\t\t\t\tif(firstSegment.size() - commonStopFirst < segmentToMerge.size() - commonStopSecond) {\n+\t\t\t\t\twhile(firstSegment.size() > commonStopFirst) {\n+\t\t\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// merge first part\n+\t\t\t\tif(commonStopFirst < commonStopSecond) {\n+\t\t\t\t\tfor(int i = 0; i < commonStopFirst; i++) {\n+\t\t\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i >= 0; i--) {\n+\t\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t\t}\t\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t\t\n+\t\t\t}\n+\t\t\t// no common stops, so try to connect to the end or beginning\n+\t\t\t// beginning\n+\t\t\tboolean merged = false;\n+\t\t\tif (MapUtils.getDistance(firstSegment.get(0).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(segmentToMerge.size() - 1).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\tfor(int i = segmentToMerge.size() - 2; i >= 0; i--) {\n+\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t} else if(MapUtils.getDistance(firstSegment.get(firstSegment.size() - 1).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(0).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\tfor(int i = 1; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t}\n+\t\t\treturn merged;\n+\t\t}\n+\n+\t\t\n+\t\t\n+\t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n+\t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n+\t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n+\t\t\t// TODO check generation that are doubles", "originalCommit": "a00011693acdfa4aac0f04fd8557719a07256e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d96394a0e19c13d589f988987944523814041c8", "chunk": "diff --git a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\nindex 9ca8d2a609..599c664203 100644\n--- a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n+++ b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n\n@@ -1105,7 +1104,7 @@ public class TransportRoutePlanner {\n \t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n \t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n \t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n-\t\t\t// TODO check generation that are doubles\n+\t\t\t// we don't add segments with 1 stop cause they are irrelevant further\n \t\t\tfor (TransportRoute part : routeParts) {\n \t\t\t\tList<TransportStop> newSeg = new ArrayList<TransportStop>();\n \t\t\t\tfor (TransportStop s : part.getForwardStops()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzA0Ng==", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426163046", "bodyText": "TODO why do we skip missing stop?", "author": "vshcherb", "createdAt": "2020-05-16T15:22:38Z", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -785,18 +794,23 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \t\t\t\n \t\t\t// could be global ?\n \t\t\tTLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();\n-\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>();\n+\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>(); //reference, route\n \t\t\tfor (BinaryMapIndexReader r : routeMap.keySet()) {\n \t\t\t\tsr.clearSearchResults();\n \t\t\t\tList<TransportStop> stops = r.searchTransportIndex(sr);\n \n \t\t\t\tlocalFileRoutes.clear();\n \t\t\t\tmergeTransportStops(r, loadedTransportStops, stops, localFileRoutes, routeMap.get(r));\n-\n+\t\t\t\t\t\n \t\t\t\tfor (TransportStop stop : stops) {\n+\t\t\t\t\t// skip missing stops\n+\t\t\t\t\tif (stop.isMissingStop()) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t\tlong stopId = stop.getId();\n \t\t\t\t\tTransportStop multifileStop = loadedTransportStops.get(stopId);\n \t\t\t\t\tint[] rrs = stop.getReferencesToRoutes();\n+\t\t\t\t\t// TODO what is this?", "originalCommit": "a00011693acdfa4aac0f04fd8557719a07256e29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE3NzY3MQ==", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426177671", "bodyText": "TODO why duplicate same code?", "author": "vshcherb", "createdAt": "2020-05-16T18:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzODQ0NA==", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426238444", "bodyText": "I thought that we need to skip missing stops so that they were not used during route calculation as valid start/finish/change stops. But I could be wrong with the exact place of such skip. Will look into this.", "author": "MadWasp79", "createdAt": "2020-05-17T09:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "684e2d3d366a48e9ae33eca87a68aae29a0bc6c9", "chunk": "diff --git a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\nindex 9ca8d2a609..8726a5a33f 100644\n--- a/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n+++ b/OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java\n\n@@ -810,14 +840,8 @@ public class TransportRoutePlanner {\n \t\t\t\t\tlong stopId = stop.getId();\n \t\t\t\t\tTransportStop multifileStop = loadedTransportStops.get(stopId);\n \t\t\t\t\tint[] rrs = stop.getReferencesToRoutes();\n-\t\t\t\t\t// TODO what is this?\n-\t\t\t\t\tif (multifileStop == stop) {\n-\t\t\t\t\t\t// clear up so it won't be used as it is multi file stop\n-\t\t\t\t\t\tstop.setReferencesToRoutes(null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// add other routes\n-\t\t\t\t\t\tstop.setReferencesToRoutes(null);\n-\t\t\t\t\t}\n+\t\t\t\t\t// clear up so it won't be used as it is multi file stop\n+\t\t\t\t\tstop.setReferencesToRoutes(null);\n \t\t\t\t\tif (rrs != null && !multifileStop.isDeleted()) {\n \t\t\t\t\t\tfor (int rr : rrs) {\n \t\t\t\t\t\t\tTransportRoute route = localFileRoutes.get(rr);\n"}}, {"oid": "15ce3fa998e7b65a3943ccef337e141a7fec0944", "url": "https://github.com/osmandapp/OsmAnd/commit/15ce3fa998e7b65a3943ccef337e141a7fec0944", "message": "Add incomplete stops to cached indexes", "committedDate": "2020-05-16T17:57:11Z", "type": "commit"}, {"oid": "0d96394a0e19c13d589f988987944523814041c8", "url": "https://github.com/osmandapp/OsmAnd/commit/0d96394a0e19c13d589f988987944523814041c8", "message": "Udpate planner", "committedDate": "2020-05-16T18:15:16Z", "type": "commit"}, {"oid": "a01a4ad63e24e96f37d125b22803513989cf9832", "url": "https://github.com/osmandapp/OsmAnd/commit/a01a4ad63e24e96f37d125b22803513989cf9832", "message": "Fix broken geometry", "committedDate": "2020-05-16T19:28:00Z", "type": "commit"}, {"oid": "f529dfad5d0989c7695ea18c0949832b83e7002b", "url": "https://github.com/osmandapp/OsmAnd/commit/f529dfad5d0989c7695ea18c0949832b83e7002b", "message": "Optimize drawing geometry", "committedDate": "2020-05-16T20:24:08Z", "type": "commit"}, {"oid": "ee1f8c683b544861d646053e5e75afd0d140a7ba", "url": "https://github.com/osmandapp/OsmAnd/commit/ee1f8c683b544861d646053e5e75afd0d140a7ba", "message": "Optimize drawing geometry", "committedDate": "2020-05-16T20:35:30Z", "type": "commit"}, {"oid": "30fe9c86983c46593d4610c9a90623e0cfecec7a", "url": "https://github.com/osmandapp/OsmAnd/commit/30fe9c86983c46593d4610c9a90623e0cfecec7a", "message": "Add more info", "committedDate": "2020-05-16T20:41:21Z", "type": "commit"}, {"oid": "7589610a278f86fe3eaeca86f02dcba21e0ed074", "url": "https://github.com/osmandapp/OsmAnd/commit/7589610a278f86fe3eaeca86f02dcba21e0ed074", "message": "Fix routing", "committedDate": "2020-05-16T20:55:40Z", "type": "commit"}, {"oid": "684e2d3d366a48e9ae33eca87a68aae29a0bc6c9", "url": "https://github.com/osmandapp/OsmAnd/commit/684e2d3d366a48e9ae33eca87a68aae29a0bc6c9", "message": "Fix routing", "committedDate": "2020-05-17T11:21:59Z", "type": "commit"}]}