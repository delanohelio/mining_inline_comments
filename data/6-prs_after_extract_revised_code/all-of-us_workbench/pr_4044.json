{"pr_number": 4044, "pr_title": "[RW-5404][risk=low] GetRuntime: support user override runtime semantics", "pr_createdAt": "2020-09-22T18:10:40Z", "pr_url": "https://github.com/all-of-us/workbench/pull/4044", "timeline": [{"oid": "b4759146fa427ff08de6ac70e7dadae2c0ec33cc", "url": "https://github.com/all-of-us/workbench/commit/b4759146fa427ff08de6ac70e7dadae2c0ec33cc", "message": "add tests", "committedDate": "2020-09-22T14:50:25Z", "type": "commit"}, {"oid": "7ad8e69cfef160b1c1d6c8f02ecfe51c61c52eea", "url": "https://github.com/all-of-us/workbench/commit/7ad8e69cfef160b1c1d6c8f02ecfe51c61c52eea", "message": "passing tests", "committedDate": "2020-09-22T17:40:09Z", "type": "commit"}, {"oid": "c48d9215df1bc171c4d9f9d67485a5eef4b7642c", "url": "https://github.com/all-of-us/workbench/commit/c48d9215df1bc171c4d9f9d67485a5eef4b7642c", "message": "spotless", "committedDate": "2020-09-22T17:40:39Z", "type": "commit"}, {"oid": "bfa5881d415b50aca4cfb86e8c428c54ec97dc12", "url": "https://github.com/all-of-us/workbench/commit/bfa5881d415b50aca4cfb86e8c428c54ec97dc12", "message": "move constants to interface", "committedDate": "2020-09-22T18:08:59Z", "type": "commit"}, {"oid": "7f76535037b039060f38087b0ff729433b93a7ad", "url": "https://github.com/all-of-us/workbench/commit/7f76535037b039060f38087b0ff729433b93a7ad", "message": "spotless", "committedDate": "2020-09-22T19:33:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNDg4OA==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r493904888", "bodyText": "Shouldn't this check be after the stream/filter?", "author": "calbach", "createdAt": "2020-09-23T21:26:17Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +175,51 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      List<LeonardoListRuntimeResponse> runtimes =\n+          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n+      if (runtimes.isEmpty()) {", "originalCommit": "7f76535037b039060f38087b0ff729433b93a7ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5OTI2MQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494499261", "bodyText": "I put it here since I'm not filtering anything but I suppose I can just check for the mostRecentRuntime optional and that should work.", "author": "ericsong", "createdAt": "2020-09-24T17:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNDg4OA=="}], "type": "inlineReview", "revised_code": {"commit": "228ab3c0974df85ffa5162abb62db0837ee56010", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 129c0d31f..34f33aee2 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -185,41 +186,59 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      List<LeonardoListRuntimeResponse> runtimes =\n-          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n-      if (runtimes.isEmpty()) {\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {\n         throw e;\n       }\n+    }\n+  }\n \n-      LeonardoListRuntimeResponse mostRecentRuntime =\n-          runtimes.stream()\n-              .sorted(\n-                  (a, b) ->\n-                      b.getAuditInfo()\n-                          .getCreatedDate()\n-                          .compareTo(a.getAuditInfo().getCreatedDate()))\n-              .findFirst()\n-              .get();\n-\n-      final String OVERRIDE_LABEL =\n-          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n-              RuntimeConfigurationType.USEROVERRIDE);\n-      Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n-      if (runtimeLabels != null\n-          && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n-        Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n-        if (!runtime.getStatus().equals(RuntimeStatus.DELETED)) {\n-          log.warning(\n-              \"Runtimes returned from ListRuntimes should be DELETED but found \"\n-                  + runtime.getStatus());\n-        }\n-\n-        return ResponseEntity.ok(\n-            leonardoMapper.toApiRuntime(mostRecentRuntime).status(RuntimeStatus.DELETED));\n-      } else {\n-        throw e;\n+  private Runtime getOverrideFromListRuntimes(String workspaceNamespace) {\n+    Optional<LeonardoListRuntimeResponse> mostRecentRuntimeMaybe =\n+        leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace, true).stream()\n+            .sorted(\n+                (a, b) -> {\n+                  String a_createdDate, b_createdDate;\n+                  if (a.getAuditInfo() == null || a.getAuditInfo().getCreatedDate() == null) {\n+                    a_createdDate = \"\";\n+                  } else {\n+                    a_createdDate = a.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  if (b.getAuditInfo() == null || b.getAuditInfo().getCreatedDate() == null) {\n+                    b_createdDate = \"\";\n+                  } else {\n+                    b_createdDate = b.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  return b_createdDate.compareTo(a_createdDate);\n+                })\n+            .findFirst();\n+\n+    if (!mostRecentRuntimeMaybe.isPresent()) {\n+      throw new NotFoundException();\n+    }\n+\n+    LeonardoListRuntimeResponse mostRecentRuntime = mostRecentRuntimeMaybe.get();\n+    final String OVERRIDE_LABEL =\n+        LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n+            RuntimeConfigurationType.USEROVERRIDE);\n+    Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n+\n+    if (runtimeLabels != null\n+        && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n+      Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n+      if (!RuntimeStatus.DELETED.equals(runtime.getStatus())) {\n+        log.warning(\n+            \"Runtimes returned from ListRuntimes should be DELETED but found \"\n+                + runtime.getStatus());\n       }\n+\n+      return runtime.status(RuntimeStatus.DELETED);\n     }\n+\n+    throw new NotFoundException();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNTY4Ng==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r493905686", "bodyText": "I would clarify that this includes deleted runtimes, e.g. listRuntimesByProjectWithDeleted(); or else plumb the boolean through. Distinction is otherwise unclear between these two methods", "author": "calbach", "createdAt": "2020-09-23T21:28:03Z", "path": "api/src/main/java/org/pmiops/workbench/notebooks/LeonardoNotebooksClient.java", "diffHunk": "@@ -16,6 +16,8 @@\n   /** lists all notebook runtimes as the appengine SA, to be used only for admin operations */\n   List<LeonardoListRuntimeResponse> listRuntimesByProjectAsService(String googleProject);\n \n+  List<LeonardoListRuntimeResponse> listRuntimesByProject(String googleProject);", "originalCommit": "7f76535037b039060f38087b0ff729433b93a7ad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "228ab3c0974df85ffa5162abb62db0837ee56010", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/notebooks/LeonardoNotebooksClient.java b/api/src/main/java/org/pmiops/workbench/notebooks/LeonardoNotebooksClient.java\nindex 02e5bb6be..e2c7d2669 100644\n--- a/api/src/main/java/org/pmiops/workbench/notebooks/LeonardoNotebooksClient.java\n+++ b/api/src/main/java/org/pmiops/workbench/notebooks/LeonardoNotebooksClient.java\n\n@@ -16,7 +16,8 @@ public interface LeonardoNotebooksClient {\n   /** lists all notebook runtimes as the appengine SA, to be used only for admin operations */\n   List<LeonardoListRuntimeResponse> listRuntimesByProjectAsService(String googleProject);\n \n-  List<LeonardoListRuntimeResponse> listRuntimesByProject(String googleProject);\n+  List<LeonardoListRuntimeResponse> listRuntimesByProject(\n+      String googleProject, boolean includeDeleted);\n \n   /**\n    * Creates a notebooks runtime owned by the current authenticated user.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNzMyMQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r493907321", "bodyText": "I don't know if there's an elegant way of doing this, but if we encounter an old and invalid runtime, it would be nice to bail here and just return a 404. I'm not sure if we can expect that manifest as an NPE out of the mapper, or perhaps as a malformed runtime.", "author": "calbach", "createdAt": "2020-09-23T21:31:33Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +175,51 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      List<LeonardoListRuntimeResponse> runtimes =\n+          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n+      if (runtimes.isEmpty()) {\n+        throw e;\n+      }\n+\n+      LeonardoListRuntimeResponse mostRecentRuntime =\n+          runtimes.stream()\n+              .sorted(\n+                  (a, b) ->\n+                      b.getAuditInfo()\n+                          .getCreatedDate()\n+                          .compareTo(a.getAuditInfo().getCreatedDate()))\n+              .findFirst()\n+              .get();\n+\n+      final String OVERRIDE_LABEL =\n+          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n+              RuntimeConfigurationType.USEROVERRIDE);\n+      Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n+      if (runtimeLabels != null\n+          && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n+        Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n+        if (!runtime.getStatus().equals(RuntimeStatus.DELETED)) {\n+          log.warning(\n+              \"Runtimes returned from ListRuntimes should be DELETED but found \"\n+                  + runtime.getStatus());\n+        }\n+\n+        return ResponseEntity.ok(\n+            leonardoMapper.toApiRuntime(mostRecentRuntime).status(RuntimeStatus.DELETED));", "originalCommit": "7f76535037b039060f38087b0ff729433b93a7ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzNTY0NA==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494535644", "bodyText": "I can just catch RuntimeExceptions for now? it will cover some cases like invalid configuration types. It should also continue to work as we add more validation checks.\nI'm not too worried about catching exceptions over eagerly either. I think anything that throws here is fine to 404.", "author": "ericsong", "createdAt": "2020-09-24T18:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNzMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "228ab3c0974df85ffa5162abb62db0837ee56010", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 129c0d31f..34f33aee2 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -185,41 +186,59 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      List<LeonardoListRuntimeResponse> runtimes =\n-          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n-      if (runtimes.isEmpty()) {\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {\n         throw e;\n       }\n+    }\n+  }\n \n-      LeonardoListRuntimeResponse mostRecentRuntime =\n-          runtimes.stream()\n-              .sorted(\n-                  (a, b) ->\n-                      b.getAuditInfo()\n-                          .getCreatedDate()\n-                          .compareTo(a.getAuditInfo().getCreatedDate()))\n-              .findFirst()\n-              .get();\n-\n-      final String OVERRIDE_LABEL =\n-          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n-              RuntimeConfigurationType.USEROVERRIDE);\n-      Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n-      if (runtimeLabels != null\n-          && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n-        Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n-        if (!runtime.getStatus().equals(RuntimeStatus.DELETED)) {\n-          log.warning(\n-              \"Runtimes returned from ListRuntimes should be DELETED but found \"\n-                  + runtime.getStatus());\n-        }\n-\n-        return ResponseEntity.ok(\n-            leonardoMapper.toApiRuntime(mostRecentRuntime).status(RuntimeStatus.DELETED));\n-      } else {\n-        throw e;\n+  private Runtime getOverrideFromListRuntimes(String workspaceNamespace) {\n+    Optional<LeonardoListRuntimeResponse> mostRecentRuntimeMaybe =\n+        leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace, true).stream()\n+            .sorted(\n+                (a, b) -> {\n+                  String a_createdDate, b_createdDate;\n+                  if (a.getAuditInfo() == null || a.getAuditInfo().getCreatedDate() == null) {\n+                    a_createdDate = \"\";\n+                  } else {\n+                    a_createdDate = a.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  if (b.getAuditInfo() == null || b.getAuditInfo().getCreatedDate() == null) {\n+                    b_createdDate = \"\";\n+                  } else {\n+                    b_createdDate = b.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  return b_createdDate.compareTo(a_createdDate);\n+                })\n+            .findFirst();\n+\n+    if (!mostRecentRuntimeMaybe.isPresent()) {\n+      throw new NotFoundException();\n+    }\n+\n+    LeonardoListRuntimeResponse mostRecentRuntime = mostRecentRuntimeMaybe.get();\n+    final String OVERRIDE_LABEL =\n+        LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n+            RuntimeConfigurationType.USEROVERRIDE);\n+    Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n+\n+    if (runtimeLabels != null\n+        && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n+      Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n+      if (!RuntimeStatus.DELETED.equals(runtime.getStatus())) {\n+        log.warning(\n+            \"Runtimes returned from ListRuntimes should be DELETED but found \"\n+                + runtime.getStatus());\n       }\n+\n+      return runtime.status(RuntimeStatus.DELETED);\n     }\n+\n+    throw new NotFoundException();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNzc5MQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r493907791", "bodyText": "opt_nit: should there just be mapper methods between the enum and storage string ? Feels like this could provide better isolation", "author": "calbach", "createdAt": "2020-09-23T21:32:42Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +175,51 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      List<LeonardoListRuntimeResponse> runtimes =\n+          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n+      if (runtimes.isEmpty()) {\n+        throw e;\n+      }\n+\n+      LeonardoListRuntimeResponse mostRecentRuntime =\n+          runtimes.stream()\n+              .sorted(\n+                  (a, b) ->\n+                      b.getAuditInfo()\n+                          .getCreatedDate()\n+                          .compareTo(a.getAuditInfo().getCreatedDate()))\n+              .findFirst()\n+              .get();\n+\n+      final String OVERRIDE_LABEL =\n+          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(", "originalCommit": "7f76535037b039060f38087b0ff729433b93a7ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyODA4OA==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494528088", "bodyText": "hmm, the main reason I didn't do a mapper method is b/c Mapstruct wouldn't be able to pick it up anyways. I think the way it is now is fine but we can refactor later if we need the isolation.", "author": "ericsong", "createdAt": "2020-09-24T18:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNzc5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "228ab3c0974df85ffa5162abb62db0837ee56010", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 129c0d31f..34f33aee2 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -185,41 +186,59 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      List<LeonardoListRuntimeResponse> runtimes =\n-          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n-      if (runtimes.isEmpty()) {\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {\n         throw e;\n       }\n+    }\n+  }\n \n-      LeonardoListRuntimeResponse mostRecentRuntime =\n-          runtimes.stream()\n-              .sorted(\n-                  (a, b) ->\n-                      b.getAuditInfo()\n-                          .getCreatedDate()\n-                          .compareTo(a.getAuditInfo().getCreatedDate()))\n-              .findFirst()\n-              .get();\n-\n-      final String OVERRIDE_LABEL =\n-          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n-              RuntimeConfigurationType.USEROVERRIDE);\n-      Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n-      if (runtimeLabels != null\n-          && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n-        Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n-        if (!runtime.getStatus().equals(RuntimeStatus.DELETED)) {\n-          log.warning(\n-              \"Runtimes returned from ListRuntimes should be DELETED but found \"\n-                  + runtime.getStatus());\n-        }\n-\n-        return ResponseEntity.ok(\n-            leonardoMapper.toApiRuntime(mostRecentRuntime).status(RuntimeStatus.DELETED));\n-      } else {\n-        throw e;\n+  private Runtime getOverrideFromListRuntimes(String workspaceNamespace) {\n+    Optional<LeonardoListRuntimeResponse> mostRecentRuntimeMaybe =\n+        leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace, true).stream()\n+            .sorted(\n+                (a, b) -> {\n+                  String a_createdDate, b_createdDate;\n+                  if (a.getAuditInfo() == null || a.getAuditInfo().getCreatedDate() == null) {\n+                    a_createdDate = \"\";\n+                  } else {\n+                    a_createdDate = a.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  if (b.getAuditInfo() == null || b.getAuditInfo().getCreatedDate() == null) {\n+                    b_createdDate = \"\";\n+                  } else {\n+                    b_createdDate = b.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  return b_createdDate.compareTo(a_createdDate);\n+                })\n+            .findFirst();\n+\n+    if (!mostRecentRuntimeMaybe.isPresent()) {\n+      throw new NotFoundException();\n+    }\n+\n+    LeonardoListRuntimeResponse mostRecentRuntime = mostRecentRuntimeMaybe.get();\n+    final String OVERRIDE_LABEL =\n+        LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n+            RuntimeConfigurationType.USEROVERRIDE);\n+    Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n+\n+    if (runtimeLabels != null\n+        && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n+      Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n+      if (!RuntimeStatus.DELETED.equals(runtime.getStatus())) {\n+        log.warning(\n+            \"Runtimes returned from ListRuntimes should be DELETED but found \"\n+                + runtime.getStatus());\n       }\n+\n+      return runtime.status(RuntimeStatus.DELETED);\n     }\n+\n+    throw new NotFoundException();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwODQzNQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r493908435", "bodyText": "nit: would put constant first", "author": "calbach", "createdAt": "2020-09-23T21:34:12Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +175,51 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      List<LeonardoListRuntimeResponse> runtimes =\n+          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n+      if (runtimes.isEmpty()) {\n+        throw e;\n+      }\n+\n+      LeonardoListRuntimeResponse mostRecentRuntime =\n+          runtimes.stream()\n+              .sorted(\n+                  (a, b) ->\n+                      b.getAuditInfo()\n+                          .getCreatedDate()\n+                          .compareTo(a.getAuditInfo().getCreatedDate()))\n+              .findFirst()\n+              .get();\n+\n+      final String OVERRIDE_LABEL =\n+          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n+              RuntimeConfigurationType.USEROVERRIDE);\n+      Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n+      if (runtimeLabels != null\n+          && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n+        Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n+        if (!runtime.getStatus().equals(RuntimeStatus.DELETED)) {", "originalCommit": "7f76535037b039060f38087b0ff729433b93a7ad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "228ab3c0974df85ffa5162abb62db0837ee56010", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 129c0d31f..34f33aee2 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -185,41 +186,59 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      List<LeonardoListRuntimeResponse> runtimes =\n-          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n-      if (runtimes.isEmpty()) {\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {\n         throw e;\n       }\n+    }\n+  }\n \n-      LeonardoListRuntimeResponse mostRecentRuntime =\n-          runtimes.stream()\n-              .sorted(\n-                  (a, b) ->\n-                      b.getAuditInfo()\n-                          .getCreatedDate()\n-                          .compareTo(a.getAuditInfo().getCreatedDate()))\n-              .findFirst()\n-              .get();\n-\n-      final String OVERRIDE_LABEL =\n-          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n-              RuntimeConfigurationType.USEROVERRIDE);\n-      Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n-      if (runtimeLabels != null\n-          && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n-        Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n-        if (!runtime.getStatus().equals(RuntimeStatus.DELETED)) {\n-          log.warning(\n-              \"Runtimes returned from ListRuntimes should be DELETED but found \"\n-                  + runtime.getStatus());\n-        }\n-\n-        return ResponseEntity.ok(\n-            leonardoMapper.toApiRuntime(mostRecentRuntime).status(RuntimeStatus.DELETED));\n-      } else {\n-        throw e;\n+  private Runtime getOverrideFromListRuntimes(String workspaceNamespace) {\n+    Optional<LeonardoListRuntimeResponse> mostRecentRuntimeMaybe =\n+        leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace, true).stream()\n+            .sorted(\n+                (a, b) -> {\n+                  String a_createdDate, b_createdDate;\n+                  if (a.getAuditInfo() == null || a.getAuditInfo().getCreatedDate() == null) {\n+                    a_createdDate = \"\";\n+                  } else {\n+                    a_createdDate = a.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  if (b.getAuditInfo() == null || b.getAuditInfo().getCreatedDate() == null) {\n+                    b_createdDate = \"\";\n+                  } else {\n+                    b_createdDate = b.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  return b_createdDate.compareTo(a_createdDate);\n+                })\n+            .findFirst();\n+\n+    if (!mostRecentRuntimeMaybe.isPresent()) {\n+      throw new NotFoundException();\n+    }\n+\n+    LeonardoListRuntimeResponse mostRecentRuntime = mostRecentRuntimeMaybe.get();\n+    final String OVERRIDE_LABEL =\n+        LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n+            RuntimeConfigurationType.USEROVERRIDE);\n+    Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n+\n+    if (runtimeLabels != null\n+        && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n+      Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n+      if (!RuntimeStatus.DELETED.equals(runtime.getStatus())) {\n+        log.warning(\n+            \"Runtimes returned from ListRuntimes should be DELETED but found \"\n+                + runtime.getStatus());\n       }\n+\n+      return runtime.status(RuntimeStatus.DELETED);\n     }\n+\n+    throw new NotFoundException();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwOTc1MQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r493909751", "bodyText": "It's possible there are some degenerate entries missing this  - I would make this sort method immune to null auditInfo and createdDate (treat these as older)", "author": "calbach", "createdAt": "2020-09-23T21:37:15Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +175,51 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      List<LeonardoListRuntimeResponse> runtimes =\n+          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n+      if (runtimes.isEmpty()) {\n+        throw e;\n+      }\n+\n+      LeonardoListRuntimeResponse mostRecentRuntime =\n+          runtimes.stream()\n+              .sorted(\n+                  (a, b) ->\n+                      b.getAuditInfo()", "originalCommit": "7f76535037b039060f38087b0ff729433b93a7ad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "228ab3c0974df85ffa5162abb62db0837ee56010", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 129c0d31f..34f33aee2 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -185,41 +186,59 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      List<LeonardoListRuntimeResponse> runtimes =\n-          leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace);\n-      if (runtimes.isEmpty()) {\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {\n         throw e;\n       }\n+    }\n+  }\n \n-      LeonardoListRuntimeResponse mostRecentRuntime =\n-          runtimes.stream()\n-              .sorted(\n-                  (a, b) ->\n-                      b.getAuditInfo()\n-                          .getCreatedDate()\n-                          .compareTo(a.getAuditInfo().getCreatedDate()))\n-              .findFirst()\n-              .get();\n-\n-      final String OVERRIDE_LABEL =\n-          LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n-              RuntimeConfigurationType.USEROVERRIDE);\n-      Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n-      if (runtimeLabels != null\n-          && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n-        Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n-        if (!runtime.getStatus().equals(RuntimeStatus.DELETED)) {\n-          log.warning(\n-              \"Runtimes returned from ListRuntimes should be DELETED but found \"\n-                  + runtime.getStatus());\n-        }\n-\n-        return ResponseEntity.ok(\n-            leonardoMapper.toApiRuntime(mostRecentRuntime).status(RuntimeStatus.DELETED));\n-      } else {\n-        throw e;\n+  private Runtime getOverrideFromListRuntimes(String workspaceNamespace) {\n+    Optional<LeonardoListRuntimeResponse> mostRecentRuntimeMaybe =\n+        leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace, true).stream()\n+            .sorted(\n+                (a, b) -> {\n+                  String a_createdDate, b_createdDate;\n+                  if (a.getAuditInfo() == null || a.getAuditInfo().getCreatedDate() == null) {\n+                    a_createdDate = \"\";\n+                  } else {\n+                    a_createdDate = a.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  if (b.getAuditInfo() == null || b.getAuditInfo().getCreatedDate() == null) {\n+                    b_createdDate = \"\";\n+                  } else {\n+                    b_createdDate = b.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  return b_createdDate.compareTo(a_createdDate);\n+                })\n+            .findFirst();\n+\n+    if (!mostRecentRuntimeMaybe.isPresent()) {\n+      throw new NotFoundException();\n+    }\n+\n+    LeonardoListRuntimeResponse mostRecentRuntime = mostRecentRuntimeMaybe.get();\n+    final String OVERRIDE_LABEL =\n+        LeonardoMapper.RUNTIME_CONFIGURATION_TYPE_ENUM_TO_STORAGE_MAP.get(\n+            RuntimeConfigurationType.USEROVERRIDE);\n+    Map<String, String> runtimeLabels = (Map<String, String>) mostRecentRuntime.getLabels();\n+\n+    if (runtimeLabels != null\n+        && OVERRIDE_LABEL.equals(runtimeLabels.get(LeonardoMapper.RUNTIME_LABEL_AOU_CONFIG))) {\n+      Runtime runtime = leonardoMapper.toApiRuntime(mostRecentRuntime);\n+      if (!RuntimeStatus.DELETED.equals(runtime.getStatus())) {\n+        log.warning(\n+            \"Runtimes returned from ListRuntimes should be DELETED but found \"\n+                + runtime.getStatus());\n       }\n+\n+      return runtime.status(RuntimeStatus.DELETED);\n     }\n+\n+    throw new NotFoundException();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxMDI5Ng==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r493910296", "bodyText": "What's the status on this? Is it intentionally omitted by Leo?", "author": "calbach", "createdAt": "2020-09-23T21:38:37Z", "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java", "diffHunk": "@@ -59,27 +72,55 @@ ListRuntimeResponse toApiListRuntimeResponse(\n   @Mapping(target = \"dataprocConfig\", ignore = true)\n   Runtime toApiRuntime(LeonardoGetRuntimeResponse runtime);\n \n+  @Mapping(target = \"createdDate\", source = \"auditInfo.createdDate\")\n+  @Mapping(target = \"autopauseThreshold\", ignore = true)\n+  @Mapping(target = \"toolDockerImage\", ignore = true)", "originalCommit": "7f76535037b039060f38087b0ff729433b93a7ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTEwMg==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494549102", "bodyText": "I verified that it is not actually sent through in the JSON response. Just shot off a message to the Leo team about it.", "author": "ericsong", "createdAt": "2020-09-24T19:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxMDI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e47266b4518e6973d57d67dfaf215051d2085da0", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java b/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java\nindex bd95086b0..2fb94a504 100644\n--- a/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java\n+++ b/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java\n\n@@ -96,6 +96,8 @@ public interface LeonardoMapper {\n \n   default void mapLabels(Runtime runtime, Map<String, String> runtimeLabels) {\n     if (runtimeLabels == null || runtimeLabels.get(RUNTIME_LABEL_AOU_CONFIG) == null) {\n+      // If there's no label, fall back onto the old behavior where every Runtime was created with a\n+      // default Dataproc config\n       runtime.setConfigurationType(RuntimeConfigurationType.DEFAULTDATAPROC);\n     } else {\n       runtime.setConfigurationType(\n"}}, {"oid": "228ab3c0974df85ffa5162abb62db0837ee56010", "url": "https://github.com/all-of-us/workbench/commit/228ab3c0974df85ffa5162abb62db0837ee56010", "message": "address code review; handle null cases in ListRuntimes response; throw 404s on error", "committedDate": "2020-09-24T19:08:03Z", "type": "commit"}, {"oid": "89facb2814c95dfa5edaac135e3b51274cfb3039", "url": "https://github.com/all-of-us/workbench/commit/89facb2814c95dfa5edaac135e3b51274cfb3039", "message": "forgot to commit tests", "committedDate": "2020-09-24T19:09:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU1OTI3NQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494559275", "bodyText": "This should at least be logged", "author": "calbach", "createdAt": "2020-09-24T19:26:19Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +176,69 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {", "originalCommit": "89facb2814c95dfa5edaac135e3b51274cfb3039", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e47266b4518e6973d57d67dfaf215051d2085da0", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 34f33aee2..3a13243f0 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -186,11 +186,7 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      try {\n-        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n-      } catch (RuntimeException e2) {\n-        throw e;\n-      }\n+      return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU1OTg0Ng==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494559846", "bodyText": "I would scope this as tightly as possible, i.e. directly around the mapper call - RuntimeException catch-alls are problematic in that they may mask programming errors.", "author": "calbach", "createdAt": "2020-09-24T19:27:25Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +176,69 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {", "originalCommit": "89facb2814c95dfa5edaac135e3b51274cfb3039", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e47266b4518e6973d57d67dfaf215051d2085da0", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 34f33aee2..3a13243f0 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -186,11 +186,7 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      try {\n-        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n-      } catch (RuntimeException e2) {\n-        throw e;\n-      }\n+      return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2MTQ4Mw==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494561483", "bodyText": "opt_nit: I would just exercise the LeonardoMapper here. If you're also trying to cover conversion testing here, probably I'd split that out into a LeonardoMapperTest", "author": "calbach", "createdAt": "2020-09-24T19:30:27Z", "path": "api/src/test/java/org/pmiops/workbench/api/RuntimeControllerTest.java", "diffHunk": "@@ -247,17 +255,25 @@ public void setUp() {\n \n     String createdDate = Date.fromYearMonthDay(1988, 12, 26).toString();\n \n-    DataprocConfig dataprocConfig =\n+    dataprocConfig =\n         new DataprocConfig()\n             .numberOfWorkers(0)\n             .masterMachineType(\"n1-standard-4\")\n             .masterDiskSize(50);\n \n-    LinkedTreeMap<String, Object> dataProcConfigObj = new LinkedTreeMap<>();\n-    dataProcConfigObj.put(\"cloudService\", \"DATAPROC\");\n-    dataProcConfigObj.put(\"numberOfWorkers\", 0);\n-    dataProcConfigObj.put(\"masterMachineType\", \"n1-standard-4\");\n-    dataProcConfigObj.put(\"masterDiskSize\", 50.0);\n+    dataprocConfigObj = new LinkedTreeMap<>();", "originalCommit": "89facb2814c95dfa5edaac135e3b51274cfb3039", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwNTQyNw==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r495005427", "bodyText": "wasn't sure if this is what you had in mind but I could only use LeonardoMapper to map dataprocConfigObj to dataprocConfig. Not as ideal as going the other direction but I also don't have that code implemented right now since we're not doing Runtime -> Leonardo mapping atm.", "author": "ericsong", "createdAt": "2020-09-25T13:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2MTQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e47266b4518e6973d57d67dfaf215051d2085da0", "chunk": "diff --git a/api/src/test/java/org/pmiops/workbench/api/RuntimeControllerTest.java b/api/src/test/java/org/pmiops/workbench/api/RuntimeControllerTest.java\nindex f631c233d..47842b313 100644\n--- a/api/src/test/java/org/pmiops/workbench/api/RuntimeControllerTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/api/RuntimeControllerTest.java\n\n@@ -255,11 +255,7 @@ public class RuntimeControllerTest {\n \n     String createdDate = Date.fromYearMonthDay(1988, 12, 26).toString();\n \n-    dataprocConfig =\n-        new DataprocConfig()\n-            .numberOfWorkers(0)\n-            .masterMachineType(\"n1-standard-4\")\n-            .masterDiskSize(50);\n+    Runtime tmpRuntime = new Runtime();\n \n     dataprocConfigObj = new LinkedTreeMap<>();\n     dataprocConfigObj.put(\"cloudService\", \"DATAPROC\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2MjQwMA==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494562400", "bodyText": "Please add a comment here. I believe this logic exists because older runtimes without the label can only be default dataproc configs.", "author": "calbach", "createdAt": "2020-09-24T19:32:05Z", "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java", "diffHunk": "@@ -59,27 +72,55 @@ ListRuntimeResponse toApiListRuntimeResponse(\n   @Mapping(target = \"dataprocConfig\", ignore = true)\n   Runtime toApiRuntime(LeonardoGetRuntimeResponse runtime);\n \n+  @Mapping(target = \"createdDate\", source = \"auditInfo.createdDate\")\n+  @Mapping(target = \"autopauseThreshold\", ignore = true)\n+  @Mapping(target = \"toolDockerImage\", ignore = true)\n+  @Mapping(target = \"configurationType\", ignore = true)\n+  @Mapping(target = \"gceConfig\", ignore = true)\n+  @Mapping(target = \"dataprocConfig\", ignore = true)\n+  Runtime toApiRuntime(LeonardoListRuntimeResponse runtime);\n+\n   @AfterMapping\n-  default void mapRuntimeConfig(\n+  default void getRuntimeAfterMapper(\n       @MappingTarget Runtime runtime, LeonardoGetRuntimeResponse leonardoGetRuntimeResponse) {\n+    mapLabels(runtime, (Map<String, String>) leonardoGetRuntimeResponse.getLabels());\n+    mapRuntimeConfig(runtime, leonardoGetRuntimeResponse.getRuntimeConfig());\n+  }\n+\n+  @AfterMapping\n+  default void listRuntimeAfterMapper(\n+      @MappingTarget Runtime runtime, LeonardoListRuntimeResponse leonardoListRuntimeResponse) {\n+    mapLabels(runtime, (Map<String, String>) leonardoListRuntimeResponse.getLabels());\n+    mapRuntimeConfig(runtime, leonardoListRuntimeResponse.getRuntimeConfig());\n+  }\n+\n+  default void mapLabels(Runtime runtime, Map<String, String> runtimeLabels) {\n+    if (runtimeLabels == null || runtimeLabels.get(RUNTIME_LABEL_AOU_CONFIG) == null) {\n+      runtime.setConfigurationType(RuntimeConfigurationType.DEFAULTDATAPROC);", "originalCommit": "89facb2814c95dfa5edaac135e3b51274cfb3039", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e47266b4518e6973d57d67dfaf215051d2085da0", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java b/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java\nindex bd95086b0..2fb94a504 100644\n--- a/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java\n+++ b/api/src/main/java/org/pmiops/workbench/utils/mappers/LeonardoMapper.java\n\n@@ -96,6 +96,8 @@ public interface LeonardoMapper {\n \n   default void mapLabels(Runtime runtime, Map<String, String> runtimeLabels) {\n     if (runtimeLabels == null || runtimeLabels.get(RUNTIME_LABEL_AOU_CONFIG) == null) {\n+      // If there's no label, fall back onto the old behavior where every Runtime was created with a\n+      // default Dataproc config\n       runtime.setConfigurationType(RuntimeConfigurationType.DEFAULTDATAPROC);\n     } else {\n       runtime.setConfigurationType(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMjY1NA==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494622654", "bodyText": "nit: generally java local vars should not have underscores in them", "author": "calbach", "createdAt": "2020-09-24T21:32:16Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +176,69 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  private Runtime getOverrideFromListRuntimes(String workspaceNamespace) {\n+    Optional<LeonardoListRuntimeResponse> mostRecentRuntimeMaybe =\n+        leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace, true).stream()\n+            .sorted(\n+                (a, b) -> {\n+                  String a_createdDate, b_createdDate;", "originalCommit": "89facb2814c95dfa5edaac135e3b51274cfb3039", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e47266b4518e6973d57d67dfaf215051d2085da0", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 34f33aee2..3a13243f0 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -186,11 +186,7 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      try {\n-        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n-      } catch (RuntimeException e2) {\n-        throw e;\n-      }\n+      return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMjk3MA==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494622970", "bodyText": "Wait - these are strings? If so, I don't think the comparison below is going to work as expected. Probably need a date / instant parsing step in here.", "author": "calbach", "createdAt": "2020-09-24T21:32:55Z", "path": "api/src/main/java/org/pmiops/workbench/api/RuntimeController.java", "diffHunk": "@@ -173,10 +176,69 @@ private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundEx\n         workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n     workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    return ResponseEntity.ok(\n-        leonardoMapper.toApiRuntime(\n-            leonardoNotebooksClient.getRuntime(\n-                workspaceNamespace, userProvider.get().getRuntimeName())));\n+    try {\n+      return ResponseEntity.ok(\n+          leonardoMapper.toApiRuntime(\n+              leonardoNotebooksClient.getRuntime(\n+                  workspaceNamespace, userProvider.get().getRuntimeName())));\n+    } catch (NotFoundException e) {\n+      if (!workbenchConfigProvider.get().featureFlags.enableCustomRuntimes) {\n+        throw e;\n+      }\n+\n+      try {\n+        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n+      } catch (RuntimeException e2) {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  private Runtime getOverrideFromListRuntimes(String workspaceNamespace) {\n+    Optional<LeonardoListRuntimeResponse> mostRecentRuntimeMaybe =\n+        leonardoNotebooksClient.listRuntimesByProject(workspaceNamespace, true).stream()\n+            .sorted(\n+                (a, b) -> {\n+                  String a_createdDate, b_createdDate;\n+                  if (a.getAuditInfo() == null || a.getAuditInfo().getCreatedDate() == null) {\n+                    a_createdDate = \"\";\n+                  } else {\n+                    a_createdDate = a.getAuditInfo().getCreatedDate();\n+                  }\n+\n+                  if (b.getAuditInfo() == null || b.getAuditInfo().getCreatedDate() == null) {\n+                    b_createdDate = \"\";", "originalCommit": "89facb2814c95dfa5edaac135e3b51274cfb3039", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4ODgzMQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r494988831", "bodyText": "I think it works as long as we receive the timestamps in a consistent timezone.\n\"easily comparable and sortable with a trivial string comparison\"\nhttps://fits.gsfc.nasa.gov/iso-time.html", "author": "ericsong", "createdAt": "2020-09-25T13:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMjk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzMTA3Mw==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r495031073", "bodyText": "going to merge since I have approval and tests are passing but I can add something later if this is still a concern", "author": "ericsong", "createdAt": "2020-09-25T14:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMjk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NTA0NQ==", "url": "https://github.com/all-of-us/workbench/pull/4044#discussion_r495165045", "bodyText": "Oh wow, wasn't aware of that property. That's quite useful, thanks.", "author": "calbach", "createdAt": "2020-09-25T18:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMjk3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e47266b4518e6973d57d67dfaf215051d2085da0", "chunk": "diff --git a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\nindex 34f33aee2..3a13243f0 100644\n--- a/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n+++ b/api/src/main/java/org/pmiops/workbench/api/RuntimeController.java\n\n@@ -186,11 +186,7 @@ public class RuntimeController implements RuntimeApiDelegate {\n         throw e;\n       }\n \n-      try {\n-        return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n-      } catch (RuntimeException e2) {\n-        throw e;\n-      }\n+      return ResponseEntity.ok(getOverrideFromListRuntimes(workspaceNamespace));\n     }\n   }\n \n"}}, {"oid": "e47266b4518e6973d57d67dfaf215051d2085da0", "url": "https://github.com/all-of-us/workbench/commit/e47266b4518e6973d57d67dfaf215051d2085da0", "message": "code review - tightening try/catch scope, some test modifications", "committedDate": "2020-09-25T13:58:18Z", "type": "commit"}]}