{"pr_number": 3833, "pr_title": "Pkriens/importclassname", "pr_createdAt": "2020-03-13T17:28:57Z", "pr_url": "https://github.com/bndtools/bnd/pull/3833", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MzY0MQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392373641", "bodyText": "Please include a package-info.java for each new package.", "author": "bjhargrave", "createdAt": "2020-03-13T17:34:10Z", "path": "aQute.libg/src/aQute/lib/hierarchy/FolderNode.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package aQute.lib.hierarchy;", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/aQute.libg/src/aQute/lib/hierarchy/FolderNode.java b/aQute.libg/src/aQute/lib/hierarchy/FolderNode.java\ndeleted file mode 100644\nindex 4a360ff6f..000000000\n--- a/aQute.libg/src/aQute/lib/hierarchy/FolderNode.java\n+++ /dev/null\n\n@@ -1,20 +0,0 @@\n-package aQute.lib.hierarchy;\n-\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-public interface FolderNode extends NamedNode, Iterable<NamedNode> {\n-\tNamedNode[] children();\n-\n-\tdefault Stream<String> names() {\n-\t\treturn stream().map(NamedNode::name);\n-\t}\n-\n-\tdefault Stream<NamedNode> stream() {\n-\t\treturn Stream.of(children());\n-\t}\n-\tint size();\n-\n-\tOptional<NamedNode> get(String name);\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MzgxMA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392373810", "bodyText": "Please include a package-info.java for each new package.", "author": "bjhargrave", "createdAt": "2020-03-13T17:34:33Z", "path": "aQute.libg/src/aQute/lib/lazy/Lazy.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package aQute.lib.lazy;", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/aQute.libg/src/aQute/lib/lazy/Lazy.java b/aQute.libg/src/aQute/lib/lazy/Lazy.java\ndeleted file mode 100644\nindex a47a6d0f2..000000000\n--- a/aQute.libg/src/aQute/lib/lazy/Lazy.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-package aQute.lib.lazy;\n-\n-import java.io.Closeable;\n-import java.util.function.Supplier;\n-\n-import aQute.lib.exceptions.ConsumerWithException;\n-import aQute.lib.exceptions.Exceptions;\n-import aQute.lib.exceptions.FunctionWithException;\n-import aQute.lib.exceptions.SupplierWithException;\n-\n-/**\n- * A constructor like function. The Lazy will initialize at first use. It also\n- * provides 'safe' functions to use the lazy object and postponing the close\n- * until at end. If this object is closed, it can be reopened. Closing will also\n- * close the target if it implements AutoCloseable.\n- *\n- * @param <T> the type\n- */\n-public class Lazy<T> implements AutoCloseable, Supplier<T> {\n-\tfinal SupplierWithException<T>\tsupplier;\n-\tvolatile T\t\t\t\t\t\ttarget;\n-\n-\t/**\n-\t * Factory function\n-\t *\n-\t * @param supplier factory\n-\t */\n-\tpublic Lazy(SupplierWithException<T> supplier) {\n-\t\tassert supplier != null;\n-\t\tthis.supplier = supplier;\n-\t}\n-\n-\t/**\n-\t * Close this object, this will reset the target. It will be reopened when\n-\t * get is called again.\n-\t */\n-\t@Override\n-\tpublic synchronized void close() {\n-\t\ttarget = null;\n-\t\tif (target instanceof AutoCloseable)\n-\t\t\ttry {\n-\t\t\t\t((Closeable) target).close();\n-\t\t\t} catch (Exception e) {\n-\t\t\t\t// ignore\n-\t\t\t}\n-\t}\n-\n-\t/**\n-\t * Double locking does work on the Java 5+ memory model, see at end\n-\t * http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\n-\t * <p>\n-\t * It allows the majority of cases to only cross a read barrier\n-\t */\n-\t@Override\n-\tpublic T get() {\n-\t\tif (target != null)\n-\t\t\treturn target;\n-\n-\t\tsynchronized (this) {\n-\t\t\tif (target != null)\n-\t\t\t\treturn target;\n-\t\t\ttry {\n-\t\t\t\treturn target = supplier.get();\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow Exceptions.duck(e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Run a consumer with the target, delaying close until finished. I.e. this\n-\t * function shouldn't stay away forever.\n-\t *\n-\t * @param c the consumer\n-\t */\n-\tpublic synchronized void run(ConsumerWithException<T> c) {\n-\t\ttry {\n-\t\t\tc.accept(get());\n-\t\t} catch (Exception e) {\n-\t\t\tthrow Exceptions.duck(e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Run a function with the target, delaying close until finished. I.e. this\n-\t * function shouldn't stay away forever.\n-\t *\n-\t * @param c the function\n-\t */\n-\tpublic synchronized <R> R map(FunctionWithException<T, R> c) {\n-\t\ttry {\n-\t\t\treturn c.apply(get());\n-\t\t} catch (Exception e) {\n-\t\t\tthrow Exceptions.duck(e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Check if initialized. Clearly this is a snapshot\n-\t *\n-\t * @return true if initialized\n-\t */\n-\tpublic boolean isInitialized() {\n-\t\treturn target != null;\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NTI5Nw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392375297", "bodyText": "It returns true in all cases.", "author": "bjhargrave", "createdAt": "2020-03-13T17:37:22Z", "path": "aQute.libg/src/aQute/lib/zip/ZipUtil.java", "diffHunk": "@@ -75,4 +76,12 @@ public static String cleanPath(String path) {\n \t\treturn clean.toString();\n \t}\n \n+\tpublic static boolean isCompromised(String path) {\n+\t\ttry {\n+\t\t\tcleanPath(path);\n+\t\t\treturn true;", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEyMDY0MA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r393120640", "bodyText": "Isn't this back-the-front? If cleanPath throws an exception, the path is compromised, no? So the method should return true not false.", "author": "bjhargrave", "createdAt": "2020-03-16T15:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NTI5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e89388d35e043d7c50a921e81dc182221fbcd78b", "chunk": "diff --git a/aQute.libg/src/aQute/lib/zip/ZipUtil.java b/aQute.libg/src/aQute/lib/zip/ZipUtil.java\nindex bd4110b2f..e9e2e187f 100644\n--- a/aQute.libg/src/aQute/lib/zip/ZipUtil.java\n+++ b/aQute.libg/src/aQute/lib/zip/ZipUtil.java\n\n@@ -26,54 +24,126 @@ public class ZipUtil {\n \t\tentry.setTime(utc);\n \t}\n \n+\tenum State {\n+\t\tbegin,\n+\t\tone,\n+\t\ttwo,\n+\t\tsegment\n+\t}\n+\n \t/**\n \t * Clean the input path to avoid ZipSlip issues.\n \t * <p>\n-\t * All '.' and '..' path entries are resolved and removed.\n+\t * All double '/', '.' and '..' path entries are resolved and removed. The\n+\t * returned path will have a '/' at the end when the path has a '/' at the\n+\t * end. A '/' is stripped. An empty string is\n \t *\n \t * @param path ZipEntry path\n \t * @return Cleansed ZipEntry path.\n \t * @throws UncheckedIOException If the entry used '..' relative paths to\n \t *             back up past the start of the path.\n \t */\n+\n \tpublic static String cleanPath(String path) {\n-\t\tif (path.indexOf('.') < 0) {\n-\t\t\treturn \"\";\n-\t\t}\n-\t\tStringRover rover = new StringRover(path);\n-\t\tStringBuilder clean = new StringBuilder();\n-\t\twhile (!rover.isEmpty()) {\n-\t\t\tint n = rover.indexOf('/');\n-\t\t\tif (n < 0) {\n-\t\t\t\tn = rover.length();\n-\t\t\t}\n-\t\t\tif ((n == 0) || ((n == 1) && (rover.charAt(0) == '.'))) {\n-\t\t\t\t// case \"\" or \".\"\n-\t\t\t} else if ((n == 2) && (rover.charAt(0) == '.') && (rover.charAt(1) == '.')) {\n-\t\t\t\t// case \"..\"\n-\t\t\t\tint lastSlash = clean.lastIndexOf(\"/\");\n-\t\t\t\tif (lastSlash == -1) {\n-\t\t\t\t\tif (clean.length() == 0) {\n-\t\t\t\t\t\t// bad design, this is a common outcome\n-\t\t\t\t\t\tthrow new UncheckedIOException(new IOException(\"Entry path is outside of zip file: \" + path));\n+\t\tStringBuilder out = new StringBuilder();\n+\n+\t\tint l = path.length();\n+\t\tState state = State.begin;\n+\t\tint level = 0;\n+\n+\t\tfor (int i = path.length() - 1; i >= 0; i--) {\n+\t\t\tchar c = path.charAt(i);\n+\t\t\tswitch (state) {\n+\t\t\t\tcase begin :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tif (i == l - 1)\n+\t\t\t\t\t\t\t\tout.append('/');\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tcase '.' :\n+\t\t\t\t\t\t\tstate = State.one;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tif (level >= 0)\n+\t\t\t\t\t\t\t\tout.append(c);\n+\n+\t\t\t\t\t\t\tstate = State.segment;\n+\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\t\t\tclean.setLength(0);\n-\t\t\t\t} else {\n-\t\t\t\t\tclean.setLength(lastSlash - 1);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (clean.length() > 0) {\n-\t\t\t\t\tclean.append('/');\n-\t\t\t\t}\n-\t\t\t\tclean.append(rover, 0, n);\n-\t\t\t}\n-\t\t\trover.increment(n);\n-\t\t\tif ((rover.length() == 1) && (clean.length() > 0)) {\n-\t\t\t\tclean.append('/'); // trailing slash\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase one :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tstate = State.begin;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tcase '.' :\n+\t\t\t\t\t\t\tstate = State.two;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tstate = State.segment;\n+\t\t\t\t\t\t\tif (level >= 0) {\n+\t\t\t\t\t\t\t\tout.append('.');\n+\t\t\t\t\t\t\t\tout.append(c);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase two :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tstate = State.begin;\n+\t\t\t\t\t\t\tlevel--;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tstate = State.segment;\n+\t\t\t\t\t\t\tif (level >= 0) {\n+\t\t\t\t\t\t\t\tout.append('.');\n+\t\t\t\t\t\t\t\tout.append('.');\n+\t\t\t\t\t\t\t\tout.append(c);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase segment :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tstate = State.begin;\n+\t\t\t\t\t\t\tif (level < 0) {\n+\t\t\t\t\t\t\t\tlevel++;\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t// FALL THROUGH\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tif (level >= 0)\n+\t\t\t\t\t\t\t\tout.append(c);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n \t\t\t}\n-\t\t\trover.increment();\n \t\t}\n-\t\treturn clean.toString();\n+\n+\t\tint last = out.length() - 1;\n+\n+\t\tif (last > 0 && out.charAt(last) == '/')\n+\t\t\tout.setLength(last--);\n+\n+\t\tif (out.length() == path.length())\n+\t\t\treturn path;\n+\n+\t\tif ((state == State.one && level == -1) || state == State.two || level < -1)\n+\t\t\tthrow new UncheckedIOException(new IOException(\"Entry path is outside of zip file: \" + path));\n+\n+\n+\t\tout.reverse();\n+\n+\t\treturn out.toString();\n \t}\n \n \tpublic static boolean isCompromised(String path) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NTUyMA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392375520", "bodyText": "Helpful comment. I am not sure how it is a common case. Can you provide an example of such a common case?", "author": "bjhargrave", "createdAt": "2020-03-13T17:37:48Z", "path": "aQute.libg/src/aQute/lib/zip/ZipUtil.java", "diffHunk": "@@ -54,6 +54,7 @@ public static String cleanPath(String path) {\n \t\t\t\tint lastSlash = clean.lastIndexOf(\"/\");\n \t\t\t\tif (lastSlash == -1) {\n \t\t\t\t\tif (clean.length() == 0) {\n+\t\t\t\t\t\t// bad design, this is a common outcome", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE3MDM1NA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394170354", "bodyText": "We should not throw exceptions for input validation. Wrong input is part of the contract of this method. Exceptions, at least in bnd, are a failure of the code because the inputs are outside the contract.", "author": "pkriens", "createdAt": "2020-03-18T08:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NTUyMA=="}], "type": "inlineReview", "revised_code": {"commit": "e89388d35e043d7c50a921e81dc182221fbcd78b", "chunk": "diff --git a/aQute.libg/src/aQute/lib/zip/ZipUtil.java b/aQute.libg/src/aQute/lib/zip/ZipUtil.java\nindex bd4110b2f..e9e2e187f 100644\n--- a/aQute.libg/src/aQute/lib/zip/ZipUtil.java\n+++ b/aQute.libg/src/aQute/lib/zip/ZipUtil.java\n\n@@ -26,54 +24,126 @@ public class ZipUtil {\n \t\tentry.setTime(utc);\n \t}\n \n+\tenum State {\n+\t\tbegin,\n+\t\tone,\n+\t\ttwo,\n+\t\tsegment\n+\t}\n+\n \t/**\n \t * Clean the input path to avoid ZipSlip issues.\n \t * <p>\n-\t * All '.' and '..' path entries are resolved and removed.\n+\t * All double '/', '.' and '..' path entries are resolved and removed. The\n+\t * returned path will have a '/' at the end when the path has a '/' at the\n+\t * end. A '/' is stripped. An empty string is\n \t *\n \t * @param path ZipEntry path\n \t * @return Cleansed ZipEntry path.\n \t * @throws UncheckedIOException If the entry used '..' relative paths to\n \t *             back up past the start of the path.\n \t */\n+\n \tpublic static String cleanPath(String path) {\n-\t\tif (path.indexOf('.') < 0) {\n-\t\t\treturn \"\";\n-\t\t}\n-\t\tStringRover rover = new StringRover(path);\n-\t\tStringBuilder clean = new StringBuilder();\n-\t\twhile (!rover.isEmpty()) {\n-\t\t\tint n = rover.indexOf('/');\n-\t\t\tif (n < 0) {\n-\t\t\t\tn = rover.length();\n-\t\t\t}\n-\t\t\tif ((n == 0) || ((n == 1) && (rover.charAt(0) == '.'))) {\n-\t\t\t\t// case \"\" or \".\"\n-\t\t\t} else if ((n == 2) && (rover.charAt(0) == '.') && (rover.charAt(1) == '.')) {\n-\t\t\t\t// case \"..\"\n-\t\t\t\tint lastSlash = clean.lastIndexOf(\"/\");\n-\t\t\t\tif (lastSlash == -1) {\n-\t\t\t\t\tif (clean.length() == 0) {\n-\t\t\t\t\t\t// bad design, this is a common outcome\n-\t\t\t\t\t\tthrow new UncheckedIOException(new IOException(\"Entry path is outside of zip file: \" + path));\n+\t\tStringBuilder out = new StringBuilder();\n+\n+\t\tint l = path.length();\n+\t\tState state = State.begin;\n+\t\tint level = 0;\n+\n+\t\tfor (int i = path.length() - 1; i >= 0; i--) {\n+\t\t\tchar c = path.charAt(i);\n+\t\t\tswitch (state) {\n+\t\t\t\tcase begin :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tif (i == l - 1)\n+\t\t\t\t\t\t\t\tout.append('/');\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tcase '.' :\n+\t\t\t\t\t\t\tstate = State.one;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tif (level >= 0)\n+\t\t\t\t\t\t\t\tout.append(c);\n+\n+\t\t\t\t\t\t\tstate = State.segment;\n+\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\t\t\tclean.setLength(0);\n-\t\t\t\t} else {\n-\t\t\t\t\tclean.setLength(lastSlash - 1);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (clean.length() > 0) {\n-\t\t\t\t\tclean.append('/');\n-\t\t\t\t}\n-\t\t\t\tclean.append(rover, 0, n);\n-\t\t\t}\n-\t\t\trover.increment(n);\n-\t\t\tif ((rover.length() == 1) && (clean.length() > 0)) {\n-\t\t\t\tclean.append('/'); // trailing slash\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase one :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tstate = State.begin;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tcase '.' :\n+\t\t\t\t\t\t\tstate = State.two;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tstate = State.segment;\n+\t\t\t\t\t\t\tif (level >= 0) {\n+\t\t\t\t\t\t\t\tout.append('.');\n+\t\t\t\t\t\t\t\tout.append(c);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase two :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tstate = State.begin;\n+\t\t\t\t\t\t\tlevel--;\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tstate = State.segment;\n+\t\t\t\t\t\t\tif (level >= 0) {\n+\t\t\t\t\t\t\t\tout.append('.');\n+\t\t\t\t\t\t\t\tout.append('.');\n+\t\t\t\t\t\t\t\tout.append(c);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase segment :\n+\t\t\t\t\tswitch (c) {\n+\t\t\t\t\t\tcase '/' :\n+\t\t\t\t\t\t\tstate = State.begin;\n+\t\t\t\t\t\t\tif (level < 0) {\n+\t\t\t\t\t\t\t\tlevel++;\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t// FALL THROUGH\n+\t\t\t\t\t\tdefault :\n+\t\t\t\t\t\t\tif (level >= 0)\n+\t\t\t\t\t\t\t\tout.append(c);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n \t\t\t}\n-\t\t\trover.increment();\n \t\t}\n-\t\treturn clean.toString();\n+\n+\t\tint last = out.length() - 1;\n+\n+\t\tif (last > 0 && out.charAt(last) == '/')\n+\t\t\tout.setLength(last--);\n+\n+\t\tif (out.length() == path.length())\n+\t\t\treturn path;\n+\n+\t\tif ((state == State.one && level == -1) || state == State.two || level < -1)\n+\t\t\tthrow new UncheckedIOException(new IOException(\"Entry path is outside of zip file: \" + path));\n+\n+\n+\t\tout.reverse();\n+\n+\t\treturn out.toString();\n \t}\n \n \tpublic static boolean isCompromised(String path) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NjIxOA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392376218", "bodyText": "Please include a package-info.java for each new package.", "author": "bjhargrave", "createdAt": "2020-03-13T17:39:00Z", "path": "aQute.libg/src/aQute/libg/ints/IntCounter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package aQute.libg.ints;", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/aQute.libg/src/aQute/libg/ints/IntCounter.java b/aQute.libg/src/aQute/libg/ints/IntCounter.java\ndeleted file mode 100644\nindex f94b3c90c..000000000\n--- a/aQute.libg/src/aQute/libg/ints/IntCounter.java\n+++ /dev/null\n\n@@ -1,44 +0,0 @@\n-package aQute.libg.ints;\n-\n-public class IntCounter {\n-\tint count;\n-\n-\n-\tpublic IntCounter() {\n-\t\tthis(0);\n-\t}\n-\n-\tpublic IntCounter(int n) {\n-\t\tthis.count = n;\n-\t}\n-\n-\tpublic int inc() {\n-\t\tint old = count;\n-\t\tif (count == Integer.MAX_VALUE)\n-\t\t\tthrow new IllegalArgumentException(\"Overflow +\");\n-\t\tcount++;\n-\t\treturn old;\n-\t}\n-\n-\tpublic int dec() {\n-\t\tint old = count;\n-\t\tif (count == Integer.MIN_VALUE)\n-\t\t\tthrow new IllegalArgumentException(\"Overflow -\");\n-\t\tcount--;\n-\t\treturn old;\n-\t}\n-\n-\tpublic int reset(int n) {\n-\t\tint old = count;\n-\t\tcount = n;\n-\t\treturn old;\n-\t}\n-\n-\tpublic int reset() {\n-\t\treturn reset(0);\n-\t}\n-\n-\tpublic int get() {\n-\t\treturn count;\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3OTE3MQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392379171", "bodyText": "Shouldn't you add to the list before calling the super method?", "author": "bjhargrave", "createdAt": "2020-03-13T17:44:50Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/Analyzer.java", "diffHunk": "@@ -159,6 +160,11 @@ public Analyzer(Processor parent) {\n \n \tpublic Analyzer() {}\n \n+\t@Override\n+\tprotected void setTypeSpecificPlugins(Set<Object> list) {\n+\t\tsuper.setTypeSpecificPlugins(list);\n+\t\tlist.add(new ClassIndexerAnalyzer());", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/Analyzer.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/Analyzer.java\nindex 51b25a7df..d79efb6f6 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/Analyzer.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/Analyzer.java\n\n@@ -160,11 +159,6 @@ public class Analyzer extends Processor {\n \n \tpublic Analyzer() {}\n \n-\t@Override\n-\tprotected void setTypeSpecificPlugins(Set<Object> list) {\n-\t\tsuper.setTypeSpecificPlugins(list);\n-\t\tlist.add(new ClassIndexerAnalyzer());\n-\t}\n \t/**\n \t * Specifically for Maven\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MDk3MQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392380971", "bodyText": "Isn't this really a resource name to a fqn name? So resourceNameToFQN might be a more descriptive name?", "author": "bjhargrave", "createdAt": "2020-03-13T17:48:21Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java", "diffHunk": "@@ -606,10 +619,18 @@ public static String binaryToFQN(String binary) {\n \t\treturn binary.replace('/', '.');\n \t}\n \n+\tpublic static String binaryClassToFQN(String path) {", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\nindex 174ae08e1..8db3453e5 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n\n@@ -619,18 +606,10 @@ public class Descriptors {\n \t\treturn binary.replace('/', '.');\n \t}\n \n-\tpublic static String binaryClassToFQN(String path) {\n-\t\treturn binaryToFQN(path.substring(0, path.length() - 6));\n-\t}\n-\n \tpublic static String fqnToBinary(String binary) {\n \t\treturn binary.replace('.', '/');\n \t}\n \n-\tpublic static String fqnClassToBinary(String binary) {\n-\t\treturn binary.replace('.', '/') + \".class\";\n-\t}\n-\n \tpublic static String getPackage(String binaryNameOrFqn) {\n \t\tint n = binaryNameOrFqn.lastIndexOf('/');\n \t\tif (n >= 0)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MTIzNg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392381236", "bodyText": "Isn't this really a fqn name to a resource name? So fqnToResourceName might be a more descriptive name?", "author": "bjhargrave", "createdAt": "2020-03-13T17:48:52Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java", "diffHunk": "@@ -606,10 +619,18 @@ public static String binaryToFQN(String binary) {\n \t\treturn binary.replace('/', '.');\n \t}\n \n+\tpublic static String binaryClassToFQN(String path) {\n+\t\treturn binaryToFQN(path.substring(0, path.length() - 6));\n+\t}\n+\n \tpublic static String fqnToBinary(String binary) {\n \t\treturn binary.replace('.', '/');\n \t}\n \n+\tpublic static String fqnClassToBinary(String binary) {", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\nindex 174ae08e1..8db3453e5 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n\n@@ -619,18 +606,10 @@ public class Descriptors {\n \t\treturn binary.replace('/', '.');\n \t}\n \n-\tpublic static String binaryClassToFQN(String path) {\n-\t\treturn binaryToFQN(path.substring(0, path.length() - 6));\n-\t}\n-\n \tpublic static String fqnToBinary(String binary) {\n \t\treturn binary.replace('.', '/');\n \t}\n \n-\tpublic static String fqnClassToBinary(String binary) {\n-\t\treturn binary.replace('.', '/') + \".class\";\n-\t}\n-\n \tpublic static String getPackage(String binaryNameOrFqn) {\n \t\tint n = binaryNameOrFqn.lastIndexOf('/');\n \t\tif (n >= 0)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MTc5Nw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392381797", "bodyText": "Comment trails off...", "author": "bjhargrave", "createdAt": "2020-03-13T17:49:55Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java", "diffHunk": "@@ -654,4 +675,112 @@ public TypeRef getTypeRefFromPath(String path) {\n \t\treturn getTypeRef(path.substring(0, path.length() - 6));\n \t}\n \n+\tpublic static String pathToFqn(String path) {\n+\t\tassert path.endsWith(\".class\");\n+\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tint j = path.length() - 6;\n+\t\tfor (int i = 0; i < j; i++) {\n+\t\t\tchar c = path.charAt(i);\n+\t\t\tif (c == '/')\n+\t\t\t\tsb.append('.');\n+\t\t\telse\n+\t\t\t\tsb.append(c);\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n+\n+\tpublic static boolean isBinaryClass(String resource) {\n+\t\treturn resource.endsWith(\".class\");\n+\t}\n+\n+\t/**\n+\t * Java really screwed up in using different names for the binary path and\n+\t * the fqns. This calculates the simple name of a potentially nested class.\n+\t *\n+\t * @param resource ( segment '/')+ (name '$')* name '.class'\n+\t * @return the last name\n+\t */\n+\tpublic static String binaryToSimple(String resource) {\n+\t\tif (resource == null)\n+\t\t\treturn null;\n+\n+\t\tassert isBinaryClass(resource);\n+\n+\t\tint end = resource.length() - 6;\n+\t\tint rover = end;\n+\t\twhile (rover >= 0) {\n+\t\t\tchar ch = resource.charAt(rover--);\n+\t\t\tif (ch == '$' || ch == '/')\n+\t\t\t\tbreak;\n+\t\t}\n+\t\treturn resource.substring(rover + 1, end);\n+\t}\n+\n+\t/**\n+\t * Heuristic for a class name. We assume a segment with", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\nindex 174ae08e1..8db3453e5 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n\n@@ -675,112 +654,4 @@ public class Descriptors {\n \t\treturn getTypeRef(path.substring(0, path.length() - 6));\n \t}\n \n-\tpublic static String pathToFqn(String path) {\n-\t\tassert path.endsWith(\".class\");\n-\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tint j = path.length() - 6;\n-\t\tfor (int i = 0; i < j; i++) {\n-\t\t\tchar c = path.charAt(i);\n-\t\t\tif (c == '/')\n-\t\t\t\tsb.append('.');\n-\t\t\telse\n-\t\t\t\tsb.append(c);\n-\t\t}\n-\t\treturn sb.toString();\n-\t}\n-\n-\tpublic static boolean isBinaryClass(String resource) {\n-\t\treturn resource.endsWith(\".class\");\n-\t}\n-\n-\t/**\n-\t * Java really screwed up in using different names for the binary path and\n-\t * the fqns. This calculates the simple name of a potentially nested class.\n-\t *\n-\t * @param resource ( segment '/')+ (name '$')* name '.class'\n-\t * @return the last name\n-\t */\n-\tpublic static String binaryToSimple(String resource) {\n-\t\tif (resource == null)\n-\t\t\treturn null;\n-\n-\t\tassert isBinaryClass(resource);\n-\n-\t\tint end = resource.length() - 6;\n-\t\tint rover = end;\n-\t\twhile (rover >= 0) {\n-\t\t\tchar ch = resource.charAt(rover--);\n-\t\t\tif (ch == '$' || ch == '/')\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn resource.substring(rover + 1, end);\n-\t}\n-\n-\t/**\n-\t * Heuristic for a class name. We assume a segment with\n-\t *\n-\t * @param fqn can be a class name, nested class, or simple name\n-\t * @return true if the last segment starts with an upper case\n-\t */\n-\tpublic static boolean isClassName(String fqn) {\n-\t\tif (fqn.isEmpty())\n-\t\t\treturn false;\n-\n-\t\tint n = fqn.lastIndexOf('.') + 1;\n-\t\tif (n >= fqn.length())\n-\t\t\treturn false;\n-\n-\t\tchar ch = fqn.charAt(n);\n-\n-\t\treturn Character.isUpperCase(ch);\n-\t}\n-\n-\t/**\n-\t * Return a 2 element array based on the fqn. The first element is the\n-\t * package name, the second is the class name. Each can be absent, but not\n-\t * both. The class name can be a nested class (will contain a '.' then)\n-\t *\n-\t * @param fqn a Java identifier name, either a simple class name, a\n-\t *            qualified class name, or a package name\n-\t * @return a Result with 2 element array with [package, class]\n-\t */\n-\tpublic static Result<String[], String> determine(String fqn) {\n-\t\tif (fqn == null || fqn.isEmpty())\n-\t\t\treturn Result.err(\"No qualified name given (either null or empty) %s\", fqn);\n-\n-\t\tint cstart = -1;\n-\t\tboolean start = true;\n-\t\tfor (int i = 0; i < fqn.length(); i++) {\n-\t\t\tchar ch = fqn.charAt(i);\n-\t\t\tif (start) {\n-\t\t\t\tif (!Character.isJavaIdentifierStart(ch)) {\n-\t\t\t\t\treturn Result.err(\"Could not match %s to a qualified Java Identifier :: package? classname\", fqn);\n-\t\t\t\t}\n-\t\t\t\tif (Character.isUpperCase(ch)) {\n-\t\t\t\t\tcstart = i;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tstart = false;\n-\t\t\t} else {\n-\t\t\t\tif (ch == '.') {\n-\t\t\t\t\tstart = true;\n-\t\t\t\t} else if (!Character.isJavaIdentifierPart(ch)) {\n-\t\t\t\t\treturn Result.err(\n-\t\t\t\t\t\t\"Could not match %s to a qualified Java Identifier :: package? classname, char %s\", fqn, i);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tString[] result = new String[2];\n-\t\tif (cstart == 0) {\n-\t\t\tresult[1] = fqn;\n-\t\t} else if (cstart > 0) {\n-\t\t\tresult[0] = fqn.substring(0, cstart - 1);\n-\t\t\tresult[1] = fqn.substring(cstart);\n-\t\t} else {\n-\t\t\tresult[0] = fqn;\n-\t\t}\n-\t\treturn Result.ok(result);\n-\t}\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4Mjc0OQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392382749", "bodyText": "Shouldn't this be an error case (NPE) instead of a silent return?", "author": "bjhargrave", "createdAt": "2020-03-13T17:51:48Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/Processor.java", "diffHunk": "@@ -1304,6 +1304,8 @@ public void propertiesChanged() {}\n \t * @param propertiesFile\n \t */\n \tpublic void setProperties(File propertiesFile) {\n+\t\tif (propertiesFile == null)", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/Processor.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/Processor.java\nindex bffa05cfa..e9d8999eb 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/Processor.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/Processor.java\n\n@@ -1304,8 +1304,6 @@ public class Processor extends Domain implements Reporter, Registry, Constants,\n \t * @param propertiesFile\n \t */\n \tpublic void setProperties(File propertiesFile) {\n-\t\tif (propertiesFile == null)\n-\t\t\treturn;\n \t\tpropertiesFile = propertiesFile.getAbsoluteFile();\n \t\tsetProperties(propertiesFile, propertiesFile.getParentFile());\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4Mzc2OA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392383768", "bodyText": "What is the point of the local var since it is immediately out of scope?", "author": "bjhargrave", "createdAt": "2020-03-13T17:53:55Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java", "diffHunk": "@@ -79,13 +87,9 @@ public ResourceBuilder addCapability(CapReqBuilder builder) {\n \t\treturn this;\n \t}\n \n-\tprivate Capability addCapability0(CapReqBuilder builder) {\n-\t\tCapability cap = buildCapability(builder);\n-\t\tCapability previous = capabilities.putIfAbsent(cap, cap);\n-\t\tif (previous != null) {\n-\t\t\treturn previous;\n-\t\t}\n-\t\treturn cap;\n+\tprivate void addCapability0(CapReqBuilder builder) {\n+\t\tbuilder.setResource(resource);\n+\t\tCapReqBuilder previous = capabilities.putIfAbsent(builder, builder);", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e89388d35e043d7c50a921e81dc182221fbcd78b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\nindex 8f4188b54..d4d4d7c33 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\n\n@@ -89,7 +89,7 @@ public class ResourceBuilder {\n \n \tprivate void addCapability0(CapReqBuilder builder) {\n \t\tbuilder.setResource(resource);\n-\t\tCapReqBuilder previous = capabilities.putIfAbsent(builder, builder);\n+\t\tcapabilities.putIfAbsent(builder, builder);\n \t}\n \n \tprotected Capability buildCapability(CapReqBuilder builder) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NDIyMA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392384220", "bodyText": "This seems like a breaking API change without previous warning.", "author": "bjhargrave", "createdAt": "2020-03-13T17:54:52Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java", "diffHunk": "@@ -134,13 +138,17 @@ public Resource build() {\n \t\t\tthrow new IllegalStateException(\"Resource already built\");\n \t\tbuilt = true;\n \n-\t\tresource.setCapabilities(capabilities.values());\n+\t\tresource.setCapabilities(capabilities.values()\n+\t\t\t.stream()\n+\t\t\t.map(cr -> cr.buildCapability())\n+\t\t\t.collect(Collectors.toSet()));\n \t\tresource.setRequirements(requirements.values());\n \t\treturn resource;\n \t}\n \n+\t@Deprecated\n \tpublic List<Capability> getCapabilities() {\n-\t\treturn new ArrayList<>(capabilities.values());\n+\t\tthrow new UnsupportedOperationException(\"Must first be build\");", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2ODY3OQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392568679", "bodyText": "There is only one place where we use it. I'll take a look", "author": "pkriens", "createdAt": "2020-03-14T08:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NDIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "e89388d35e043d7c50a921e81dc182221fbcd78b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\nindex 8f4188b54..d4d4d7c33 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\n\n@@ -146,9 +146,16 @@ public class ResourceBuilder {\n \t\treturn resource;\n \t}\n \n+\t/**\n+\t * This method makes the cap builders a cap. This is expensive and should\n+\t * not be used. Wait until the resource is build and then get the\n+\t * capabilities.\n+\t *\n+\t * @return a list of capabilities\n+\t */\n \t@Deprecated\n \tpublic List<Capability> getCapabilities() {\n-\t\tthrow new UnsupportedOperationException(\"Must first be build\");\n+\t\treturn Collections.unmodifiableList((List<? extends Capability>) capabilities.values());\n \t}\n \n \tpublic List<Requirement> getRequirements() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NDYxNw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392384617", "bodyText": "This change is not source compatible.", "author": "bjhargrave", "createdAt": "2020-03-13T17:55:42Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java", "diffHunk": "@@ -638,15 +646,15 @@ public void addRequirements(List<Requirement> requires) {\n \t\treturn capabilities;\n \t}\n \n-\tpublic Map<Capability, Capability> from(Resource bundle) {\n-\t\tMap<Capability, Capability> mapping = new HashMap<>();\n+\tpublic Map<Capability, CapReqBuilder> from(Resource bundle) {", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NjIwMQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392556201", "bodyText": "Actually, upon further thinking, this change is, from a practical point of view, a binary incompatible change. Any call site getting a value from a map entry will have a compiler generated cast to Capability. So existing binaries doing something like:\nCapability cap = from(bundle).get(someCap);\nwill result in a ClassCastException at runtime since the compiler expects the value to be of type Capability and generates a cast to verify this.\nSo this sort of change is, in effect, binary incompatible.", "author": "bjhargrave", "createdAt": "2020-03-14T04:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NDYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\nindex 8f4188b54..cf4937391 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/ResourceBuilder.java\n\n@@ -646,15 +638,15 @@ public class ResourceBuilder {\n \t\treturn capabilities;\n \t}\n \n-\tpublic Map<Capability, CapReqBuilder> from(Resource bundle) {\n-\t\tMap<Capability, CapReqBuilder> mapping = new HashMap<>();\n+\tpublic Map<Capability, Capability> from(Resource bundle) {\n+\t\tMap<Capability, Capability> mapping = new HashMap<>();\n \n \t\taddRequirements(bundle.getRequirements(null));\n \n \t\tfor (Capability c : bundle.getCapabilities(null)) {\n \t\t\tCapReqBuilder clone = CapReqBuilder.clone(c);\n-\t\t\taddCapability0(clone);\n-\t\t\tmapping.put(c, clone);\n+\t\t\tCapability addedCapability = addCapability0(clone);\n+\t\t\tmapping.put(c, addedCapability);\n \t\t}\n \t\treturn mapping;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4ODM5Mg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r392388392", "bodyText": "Would the return type be better as Result<Map.Entry<String,String>,String> or Result<Pair<String,String>,String>? Using String[] is pretty open and provides no clear evidence that the array contains exactly 2 strings.", "author": "bjhargrave", "createdAt": "2020-03-13T18:03:14Z", "path": "biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java", "diffHunk": "@@ -654,4 +675,112 @@ public TypeRef getTypeRefFromPath(String path) {\n \t\treturn getTypeRef(path.substring(0, path.length() - 6));\n \t}\n \n+\tpublic static String pathToFqn(String path) {\n+\t\tassert path.endsWith(\".class\");\n+\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tint j = path.length() - 6;\n+\t\tfor (int i = 0; i < j; i++) {\n+\t\t\tchar c = path.charAt(i);\n+\t\t\tif (c == '/')\n+\t\t\t\tsb.append('.');\n+\t\t\telse\n+\t\t\t\tsb.append(c);\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n+\n+\tpublic static boolean isBinaryClass(String resource) {\n+\t\treturn resource.endsWith(\".class\");\n+\t}\n+\n+\t/**\n+\t * Java really screwed up in using different names for the binary path and\n+\t * the fqns. This calculates the simple name of a potentially nested class.\n+\t *\n+\t * @param resource ( segment '/')+ (name '$')* name '.class'\n+\t * @return the last name\n+\t */\n+\tpublic static String binaryToSimple(String resource) {\n+\t\tif (resource == null)\n+\t\t\treturn null;\n+\n+\t\tassert isBinaryClass(resource);\n+\n+\t\tint end = resource.length() - 6;\n+\t\tint rover = end;\n+\t\twhile (rover >= 0) {\n+\t\t\tchar ch = resource.charAt(rover--);\n+\t\t\tif (ch == '$' || ch == '/')\n+\t\t\t\tbreak;\n+\t\t}\n+\t\treturn resource.substring(rover + 1, end);\n+\t}\n+\n+\t/**\n+\t * Heuristic for a class name. We assume a segment with\n+\t *\n+\t * @param fqn can be a class name, nested class, or simple name\n+\t * @return true if the last segment starts with an upper case\n+\t */\n+\tpublic static boolean isClassName(String fqn) {\n+\t\tif (fqn.isEmpty())\n+\t\t\treturn false;\n+\n+\t\tint n = fqn.lastIndexOf('.') + 1;\n+\t\tif (n >= fqn.length())\n+\t\t\treturn false;\n+\n+\t\tchar ch = fqn.charAt(n);\n+\n+\t\treturn Character.isUpperCase(ch);\n+\t}\n+\n+\t/**\n+\t * Return a 2 element array based on the fqn. The first element is the\n+\t * package name, the second is the class name. Each can be absent, but not\n+\t * both. The class name can be a nested class (will contain a '.' then)\n+\t *\n+\t * @param fqn a Java identifier name, either a simple class name, a\n+\t *            qualified class name, or a package name\n+\t * @return a Result with 2 element array with [package, class]\n+\t */\n+\tpublic static Result<String[], String> determine(String fqn) {", "originalCommit": "3a0a47f40c7dd74a836678a3a834ee163f64a8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "chunk": "diff --git a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\nindex 174ae08e1..8db3453e5 100644\n--- a/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n+++ b/biz.aQute.bndlib/src/aQute/bnd/osgi/Descriptors.java\n\n@@ -675,112 +654,4 @@ public class Descriptors {\n \t\treturn getTypeRef(path.substring(0, path.length() - 6));\n \t}\n \n-\tpublic static String pathToFqn(String path) {\n-\t\tassert path.endsWith(\".class\");\n-\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tint j = path.length() - 6;\n-\t\tfor (int i = 0; i < j; i++) {\n-\t\t\tchar c = path.charAt(i);\n-\t\t\tif (c == '/')\n-\t\t\t\tsb.append('.');\n-\t\t\telse\n-\t\t\t\tsb.append(c);\n-\t\t}\n-\t\treturn sb.toString();\n-\t}\n-\n-\tpublic static boolean isBinaryClass(String resource) {\n-\t\treturn resource.endsWith(\".class\");\n-\t}\n-\n-\t/**\n-\t * Java really screwed up in using different names for the binary path and\n-\t * the fqns. This calculates the simple name of a potentially nested class.\n-\t *\n-\t * @param resource ( segment '/')+ (name '$')* name '.class'\n-\t * @return the last name\n-\t */\n-\tpublic static String binaryToSimple(String resource) {\n-\t\tif (resource == null)\n-\t\t\treturn null;\n-\n-\t\tassert isBinaryClass(resource);\n-\n-\t\tint end = resource.length() - 6;\n-\t\tint rover = end;\n-\t\twhile (rover >= 0) {\n-\t\t\tchar ch = resource.charAt(rover--);\n-\t\t\tif (ch == '$' || ch == '/')\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn resource.substring(rover + 1, end);\n-\t}\n-\n-\t/**\n-\t * Heuristic for a class name. We assume a segment with\n-\t *\n-\t * @param fqn can be a class name, nested class, or simple name\n-\t * @return true if the last segment starts with an upper case\n-\t */\n-\tpublic static boolean isClassName(String fqn) {\n-\t\tif (fqn.isEmpty())\n-\t\t\treturn false;\n-\n-\t\tint n = fqn.lastIndexOf('.') + 1;\n-\t\tif (n >= fqn.length())\n-\t\t\treturn false;\n-\n-\t\tchar ch = fqn.charAt(n);\n-\n-\t\treturn Character.isUpperCase(ch);\n-\t}\n-\n-\t/**\n-\t * Return a 2 element array based on the fqn. The first element is the\n-\t * package name, the second is the class name. Each can be absent, but not\n-\t * both. The class name can be a nested class (will contain a '.' then)\n-\t *\n-\t * @param fqn a Java identifier name, either a simple class name, a\n-\t *            qualified class name, or a package name\n-\t * @return a Result with 2 element array with [package, class]\n-\t */\n-\tpublic static Result<String[], String> determine(String fqn) {\n-\t\tif (fqn == null || fqn.isEmpty())\n-\t\t\treturn Result.err(\"No qualified name given (either null or empty) %s\", fqn);\n-\n-\t\tint cstart = -1;\n-\t\tboolean start = true;\n-\t\tfor (int i = 0; i < fqn.length(); i++) {\n-\t\t\tchar ch = fqn.charAt(i);\n-\t\t\tif (start) {\n-\t\t\t\tif (!Character.isJavaIdentifierStart(ch)) {\n-\t\t\t\t\treturn Result.err(\"Could not match %s to a qualified Java Identifier :: package? classname\", fqn);\n-\t\t\t\t}\n-\t\t\t\tif (Character.isUpperCase(ch)) {\n-\t\t\t\t\tcstart = i;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tstart = false;\n-\t\t\t} else {\n-\t\t\t\tif (ch == '.') {\n-\t\t\t\t\tstart = true;\n-\t\t\t\t} else if (!Character.isJavaIdentifierPart(ch)) {\n-\t\t\t\t\treturn Result.err(\n-\t\t\t\t\t\t\"Could not match %s to a qualified Java Identifier :: package? classname, char %s\", fqn, i);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tString[] result = new String[2];\n-\t\tif (cstart == 0) {\n-\t\t\tresult[1] = fqn;\n-\t\t} else if (cstart > 0) {\n-\t\t\tresult[0] = fqn.substring(0, cstart - 1);\n-\t\t\tresult[1] = fqn.substring(cstart);\n-\t\t} else {\n-\t\t\tresult[0] = fqn;\n-\t\t}\n-\t\treturn Result.ok(result);\n-\t}\n-\n }\n"}}, {"oid": "e89388d35e043d7c50a921e81dc182221fbcd78b", "url": "https://github.com/bndtools/bnd/commit/e89388d35e043d7c50a921e81dc182221fbcd78b", "message": "[resourcebuilder] Kept backward compatibility\n\nThere is a call from(Resource) that returned a\nmap from the given resource caps to the caps\nin the resource builder. However, I needed\nthe caps to be mutable. \n\nThis fix lets the CapReqBuilder implement \nCapability. Since cap equals and cap hashCode\nis defined on value this should work fine.\n\n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-16T16:35:13Z", "type": "forcePushed"}, {"oid": "d85d6930ce3194e1fc1a3379b7014d16fb6a0934", "url": "https://github.com/bndtools/bnd/commit/d85d6930ce3194e1fc1a3379b7014d16fb6a0934", "message": "[lgtm] Make LGTM happy\n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T10:55:03Z", "type": "forcePushed"}, {"oid": "17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "url": "https://github.com/bndtools/bnd/commit/17dd38ce5f01b59b0aef3a0ea800ba75c2b5628b", "message": " [hex] Added support for numbers to hex\n    \n- byte, short, char, int, long\n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:51:43Z", "type": "commit"}, {"oid": "d23cd57ff7afabce1ff093c746a509ed7ca6ce83", "url": "https://github.com/bndtools/bnd/commit/d23cd57ff7afabce1ff093c746a509ed7ca6ce83", "message": "[lgtm] LGTM whines about zip slip\n    \n    It turned out that PersistenceMap did not escape\n    file names. However, LGTM warned far away from\n    this, basically when you put a unslipped entry\n    name in any Map.\n    \n    While workin on this I saw that the ZipUtil.cleanPath\n    did not properly handle '..'. I've added test cases\n    and replace it because it looked slow and I couldn't\n    see how it worked. It now uses a state machine.\n    \n    The fix to PersistentMap required escaping\n    and unescaping so I added this to Strings.\n    \n    All with tests ...\n    \n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:52:55Z", "type": "commit"}, {"oid": "3b0eae77b52d845d3523eaad41d73d0efb78d832", "url": "https://github.com/bndtools/bnd/commit/3b0eae77b52d845d3523eaad41d73d0efb78d832", "message": "[libg] Lazy init support & IntCounter\n    \n    Tiny utilities.\n    \n    Lazy Init -> makes it easy to create an object on demand.\n    \n    IntCounter, simple counter not concurrent. Handy for recursive\n    calls and when values need to be final with lambdas.\n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:53:31Z", "type": "commit"}, {"oid": "fc7a1224cf6e3b4354b6e07d5f9b26ac592f9b36", "url": "https://github.com/bndtools/bnd/commit/fc7a1224cf6e3b4354b6e07d5f9b26ac592f9b36", "message": "[hierarchy] Utility for fast hierarchy handling\n    \n    The current Jar class is extremely handy to process\n    file trees or zip files. However, the internal representation\n    of the hierarchy is _extremely_ expensive. It uses a Tree per\n    directory :-( Accessing this hierarchy is also clumsy since\n    you either use long paths or the directory.\n    \n    This code implements a fast hierarchy with convenience functions\n    plus indexers for Zip streams, Zip files, and folder structure.\n    \n    Could be used in the Jar Editor, maybe in the Jar class.\n    \n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:53:59Z", "type": "commit"}, {"oid": "7cfb07fdd2edb9c37f1bf572faa694e4ee3270cf", "url": "https://github.com/bndtools/bnd/commit/7cfb07fdd2edb9c37f1bf572faa694e4ee3270cf", "message": "[bndlib] Small changes\n    \n    - Handy functions for testing strings and the mess Java made of names\n    - Bundle Id improved and used in VersionedClause & Container\n    - Allow null for Processor propertiesFile\n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:54:37Z", "type": "commit"}, {"oid": "fd6121f8447ce18f30f3438a28660de02792d027", "url": "https://github.com/bndtools/bnd/commit/fd6121f8447ce18f30f3438a28660de02792d027", "message": "[classindex] Supports hashes on class names\n    \n    Adds a search method to Workspace for a class name,\n    either qualified with a package or without.\n    \n    To support searching in the absence of a package,\n    the Analyzer (through an Analyzer Plugin) is\n    extended to add hashes of a packages class name\n    to a package capability.\n    \n    Since clearly not a lot of bundles will have this data,\n    I also extended the Resource Builder to add these\n    hashes. This works well for the Maven Bnd Repository\n    and some others because they always parse the files.\n    \n    The workspace search forwards the query to the\n    ClassIndex class. This will analyze the request\n    and pick an optimal search strategy.\n    \n    We need to discuss if we can make adding these\n    hashes standard (OSGi?) or have to make it optional.\n    \n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:55:47Z", "type": "commit"}, {"oid": "9367a4eeda9f618ab1338bcb280db0793bce14de", "url": "https://github.com/bndtools/bnd/commit/9367a4eeda9f618ab1338bcb280db0793bce14de", "message": " [import quickfix] Replaced previous Quickfix\n    \n    I am greatly thankful for the previous version of\n    the quick fix because I'd never figured the eclipse\n    part out.\n    \n    I've taken this part and moved any part that did\n    stuff that  should be in bnd to bnd. This way,\n    others can leverage this code. Support was\n    added in Workspace and the BndEditModel to\n    do this kind of stuff easier.\n    \n    Therefore, the deletion of the old classes is\n    no criticism. Very happy I had that. That said,\n    Fr. Krieg needs to take a good look I got all the\n    functionality. I could not find good Eclipse\n    documentation what one could expect for each of the\n    error codes.\n    \n    In the bug, it is indicated that there was also\n    a completion list. This did not work for me, and\n    I could also not really see why I never got triggered.\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:56:08Z", "type": "commit"}, {"oid": "9367a4eeda9f618ab1338bcb280db0793bce14de", "url": "https://github.com/bndtools/bnd/commit/9367a4eeda9f618ab1338bcb280db0793bce14de", "message": " [import quickfix] Replaced previous Quickfix\n    \n    I am greatly thankful for the previous version of\n    the quick fix because I'd never figured the eclipse\n    part out.\n    \n    I've taken this part and moved any part that did\n    stuff that  should be in bnd to bnd. This way,\n    others can leverage this code. Support was\n    added in Workspace and the BndEditModel to\n    do this kind of stuff easier.\n    \n    Therefore, the deletion of the old classes is\n    no criticism. Very happy I had that. That said,\n    Fr. Krieg needs to take a good look I got all the\n    functionality. I could not find good Eclipse\n    documentation what one could expect for each of the\n    error codes.\n    \n    In the bug, it is indicated that there was also\n    a completion list. This did not work for me, and\n    I could also not really see why I never got triggered.\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-17T16:56:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDczMjk1Mg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394732952", "bodyText": "It was probably a good idea to get rid of this as AddBundleCompletionProposal is an implementation detail. Ideally, we should only be testing through the public API (which is BuildpathQuickfixProcessor.getCorrections()), so we should try and make sure that we get effective coverage of AddBundleCompletionProposal through BuildpathQuickfixProcessorTest.", "author": "kriegfrj", "createdAt": "2020-03-19T01:08:13Z", "path": "bndtools.core/test/org/bndtools/core/editors/ImportPackageQuickFixProcessorAddBundleCompletionProposalTest.java", "diffHunk": "@@ -1,57 +0,0 @@\n-package org.bndtools.core.editors;", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NDc4Mw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394894783", "bodyText": "I like tests but I agree I've got an aversion against Eclipse GUI testing. I find I spend way more time testing my own mocks & scaffolding than actual error cases.\nHowever, if you think, as we discuss later, that you can set up error cases for all the use cases (error codes/source code) then that would be fantastic.", "author": "pkriens", "createdAt": "2020-03-19T09:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDczMjk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA2NjAwNQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395066005", "bodyText": "I agree - Eclipse testing is tricky. I think writing the tests for the original quick fix processor was a bit of a turning point for me when I started to realise the limitations of mocks - yes, you spend as much time debugging the mocks as you do the actual code. Since then I've had a strong preference for testing against actual code rather than against mocks (where it makes sense to do so), effectively skipping unit testing and going straight for integration tests.\nI think the good news is that I've learned a lot more about OSGi and Bnd since those days, and I think I can come up with an OSGi-type test that uses more of actual Eclipse and less mocking. This could become a model for other GUI tests.", "author": "kriegfrj", "createdAt": "2020-03-19T14:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDczMjk1Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0MTQyMw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394741423", "bodyText": "Note that Eclipse won't (or shouldn't!) call getCorrections() unless at least one of the problems in locations is of a type that we have told Eclipse we can support (via hasCorrections()). So if we've gotten this far, it's likely that we should be doing further investigation.\nThe if/return here will prematurely terminate the loop if the first location is of a problem type that we can't correct, without checking the rest of them. Because (as noted above) it is likely that one of the subsequent reported problems is a problem type that we might be able to correct, it would be better if this was a continue rather than return null.", "author": "kriegfrj", "createdAt": "2020-03-19T01:38:04Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.compiler.IProblem;\n+import org.eclipse.jdt.core.dom.ASTNode;\n+import org.eclipse.jdt.core.dom.ImportDeclaration;\n+import org.eclipse.jdt.core.dom.Name;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jdt.ui.text.java.IProblemLocation;\n+import org.eclipse.jdt.ui.text.java.IQuickFixProcessor;\n+\n+import aQute.bnd.build.Container;\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.Workspace;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.lib.exceptions.Exceptions;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+public class BuildpathQuickfixProcessor implements IQuickFixProcessor {\n+\n+\t@Override\n+\tpublic boolean hasCorrections(ICompilationUnit unit, int problemId) {\n+\t\tswitch (problemId) {\n+\t\t\tcase IProblem.IsClassPathCorrect :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.ImportNotFound :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.UndefinedType :\n+\t\t\t\treturn true;\n+\t\t\tdefault :\n+\t\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic IJavaCompletionProposal[] getCorrections(IInvocationContext context, IProblemLocation[] locations)\n+\t\tthrows CoreException {\n+\t\ttry {\n+\t\t\tList<IJavaCompletionProposal> proposals = new ArrayList<>();\n+\n+\t\t\tICompilationUnit compUnit = context.getCompilationUnit();\n+\t\t\tIJavaProject java = compUnit.getJavaProject();\n+\t\t\tif (java == null)\n+\t\t\t\treturn null;\n+\n+\t\t\tProject project = Central.getProject(java.getProject());\n+\t\t\tif (project == null)\n+\t\t\t\treturn null;\n+\n+\t\t\tboolean test = isInDir(project.getTestSrc(), compUnit.getResource());\n+\t\t\tWorkspace workspace = project.getWorkspace();\n+\n+\t\t\tfor (IProblemLocation location : locations) {\n+\n+\t\t\t\tif (!hasCorrections(context.getCompilationUnit(), location.getProblemId()))\n+\t\t\t\t\treturn null;", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NTE4OQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394895189", "bodyText": "I actually got called ... I'll make it a continue. good catch.", "author": "pkriens", "createdAt": "2020-03-19T09:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0MTQyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTEyMw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395079123", "bodyText": "Happens to the best of us \ud83d\ude09", "author": "kriegfrj", "createdAt": "2020-03-19T14:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0MTQyMw=="}], "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\nindex 6a65e556b..169e3bad5 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n\n@@ -31,6 +31,7 @@ import aQute.bnd.build.Container;\n import aQute.bnd.build.Project;\n import aQute.bnd.build.Workspace;\n import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Descriptors;\n import aQute.lib.exceptions.Exceptions;\n import bndtools.Plugin;\n import bndtools.central.Central;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0MjI2NQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394742265", "bodyText": "These were originally collapsed into one return statement, thus:\ncase IProblem.IsClassPathCorrect :\ncase IProblem.ImportNotFound :\ncase IProblem.UndefinedType :\n    return true;\nAny particular reason for exploding these out into individual return statements?\nAlso, we may need to add other entries to the switch in order to tell Eclipse that we can now handle other problem types due to the enhanced class name searching, and to take advantage of this functionality. However, as you point out the documentation on this is not good. I arrived at the above set by experimentation - set up a workspace in Eclipse with a situation that I know we should be able to correct, add a print problemId to stderr, and then hover over it in the Eclipse instance to see what problemId we get.", "author": "kriegfrj", "createdAt": "2020-03-19T01:39:51Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.compiler.IProblem;\n+import org.eclipse.jdt.core.dom.ASTNode;\n+import org.eclipse.jdt.core.dom.ImportDeclaration;\n+import org.eclipse.jdt.core.dom.Name;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jdt.ui.text.java.IProblemLocation;\n+import org.eclipse.jdt.ui.text.java.IQuickFixProcessor;\n+\n+import aQute.bnd.build.Container;\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.Workspace;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.lib.exceptions.Exceptions;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+public class BuildpathQuickfixProcessor implements IQuickFixProcessor {\n+\n+\t@Override\n+\tpublic boolean hasCorrections(ICompilationUnit unit, int problemId) {\n+\t\tswitch (problemId) {\n+\t\t\tcase IProblem.IsClassPathCorrect :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.ImportNotFound :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.UndefinedType :\n+\t\t\t\treturn true;", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5MjAyMg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394892022", "bodyText": "I had a really hard time generating the other error ids. Just could not figure it out.\nI kept them separate to visually indicate that we should try to figure out if they all need to be supported and how. I am assuming they have some semantics.", "author": "pkriens", "createdAt": "2020-03-19T09:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0MjI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3MzEyMg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395073122", "bodyText": "Yes, they all have some semantics and (from memory) they are a little different.\nI remember that one of the more esoteric error types I tried to handle was when there is a missing transitive dependency. Error message something like \"Cannot find  - it is indirectly referenced by classes on the classpath.\"", "author": "kriegfrj", "createdAt": "2020-03-19T14:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0MjI2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\nindex 6a65e556b..169e3bad5 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n\n@@ -31,6 +31,7 @@ import aQute.bnd.build.Container;\n import aQute.bnd.build.Project;\n import aQute.bnd.build.Workspace;\n import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Descriptors;\n import aQute.lib.exceptions.Exceptions;\n import bndtools.Plugin;\n import bndtools.central.Central;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0NjIxMw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394746213", "bodyText": "This part of the code is obviously new to support quick fixes of incomplete class definitions.\nThe original quick fix processor primarily supported the case where the import statement already existed, but could not be resolved because the bundle was not on -buildpath. In such cases, you don't want to create the import statement again, nor do you want to add a \".*\" import if you've already explicitly imported the class that you want. I think we need to be selective about if/when we call createImport(), depending on what problem we are trying to fix.", "author": "kriegfrj", "createdAt": "2020-03-19T01:48:59Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import org.bndtools.core.ui.icons.Icons;\n+import org.eclipse.core.resources.WorkspaceJob;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jface.text.contentassist.IContextInformation;\n+import org.eclipse.swt.graphics.Image;\n+import org.eclipse.swt.graphics.Point;\n+\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.model.BndEditModel;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Constants;\n+import aQute.bnd.osgi.Descriptors;\n+import aQute.lib.strings.Strings;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletionProposal {\n+\n+\tfinal BundleId\t\t\t\tbundle;\n+\tfinal String\t\t\t\tdisplayString;\n+\tfinal int\t\t\t\t\trelevance;\n+\tfinal IInvocationContext\tcontext;\n+\tfinal Project\t\t\t\tproject;\n+\tfinal String\t\t\t\tpathtype;\n+\tfinal String\t\t\t\tfqn;\n+\n+\tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n+\t\tProject project, String pathtype) {\n+\t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n+\t\tthis.fqn = fqn;\n+\t\tthis.bundle = bundle;\n+\t\tthis.relevance = relevance;\n+\t\tthis.context = context;\n+\t\tthis.project = project;\n+\t\tthis.pathtype = pathtype;\n+\t\tthis.displayString = Strings.format(\"Add %s %s to %s (found %s)\", bundle.getBsn(), bundle.getShortVersion(),\n+\t\t\tpathtype, fqn);\n+\t}\n+\n+\t@Override\n+\tpublic void apply(org.eclipse.jface.text.IDocument document) {\n+\t\tschedule();\n+\t}\n+\n+\t/**\n+\t * @see org.eclipse.jface.text.contentassist.ICompletionProposal#getSelection(org.eclipse.jface.text.IDocument)\n+\t */\n+\t@Override\n+\tpublic Point getSelection(org.eclipse.jface.text.IDocument document) {\n+\t\treturn new Point(context.getSelectionOffset(), context.getSelectionLength());\n+\t}\n+\n+\t@Override\n+\tpublic String getAdditionalProposalInfo() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic String getDisplayString() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic Image getImage() {\n+\t\treturn Icons.image(\"bundle\");\n+\t}\n+\n+\t@Override\n+\tpublic IContextInformation getContextInformation() {\n+\t\treturn new IContextInformation() {\n+\n+\t\t\t@Override\n+\t\t\tpublic String getContextDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path\";\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Image getImage() {\n+\t\t\t\treturn Icons.image(\"bundle\");\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String getInformationDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path - info\";\n+\t\t\t}\n+\n+\t\t};\n+\t}\n+\n+\t@Override\n+\tpublic int getRelevance() {\n+\t\treturn relevance;\n+\t}\n+\n+\t@Override\n+\tpublic IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n+\t\ttry {\n+\t\t\tIStatus status = Central.bndCall(() -> {\n+\t\t\t\tBndEditModel model = new BndEditModel(project);\n+\t\t\t\tmodel.load();\n+\n+\t\t\t\tswitch (pathtype) {\n+\t\t\t\t\tcase Constants.TESTPATH :\n+\t\t\t\t\t\tmodel.addPath(bundle, Constants.TESTPATH);\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tcase Constants.BUILDPATH :\n+\t\t\t\t\tdefault :\n+\t\t\t\t\t\tmodel.addPath(bundle, Constants.BUILDPATH);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tmodel.saveChanges();\n+\t\t\t\tCentral.refreshFile(project.getPropertiesFile());\n+\t\t\t\treturn Status.OK_STATUS;\n+\t\t\t});\n+\n+\t\t\tString[] determine = Descriptors.determine(fqn)\n+\t\t\t\t.unwrap();\n+\n+\t\t\tassert determine[0] != null : \"We must have found a package\";\n+\n+\t\t\tif (determine[1] == null) {\n+\t\t\t\tcontext.getCompilationUnit()\n+\t\t\t\t\t.createImport(fqn + \".*\", null, monitor);\n+\t\t\t} else {\n+\t\t\t\tcontext.getCompilationUnit()\n+\t\t\t\t\t.createImport(fqn, null, monitor);\n+\t\t\t}\n+\t\t\treturn status;", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5MTE0NA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394891144", "bodyText": "I think duplicates are automatically skipped, at least I read something in the comments\nI just cannot find a definition of the error codes.\n\nI tested this in the UI and it seems to work fine so far. Shall we wait until we have actually test cases. I could not find a good definition of the error codes, what arguments they supplied, and what cases they were reported. I basically could only find import errors.\nHaving test code would allow us to see each case we want to support. I reasoned this was the safe way and the Eclipse quick fixes support cleaning up if necessary.\nI am a big fan of less is more. I'd like to start very simple that covers 80%, and then add the missing cases explicitly.", "author": "pkriens", "createdAt": "2020-03-19T09:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0NjIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\nindex 3e83ea6ad..65160fb25 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n\n@@ -30,9 +30,10 @@ class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletio\n \tfinal Project\t\t\t\tproject;\n \tfinal String\t\t\t\tpathtype;\n \tfinal String\t\t\t\tfqn;\n+\tfinal boolean\t\t\t\tdoImport;\n \n \tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n-\t\tProject project, String pathtype) {\n+\t\tProject project, String pathtype, boolean doImport) {\n \t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n \t\tthis.fqn = fqn;\n \t\tthis.bundle = bundle;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0NjI1OA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394746258", "bodyText": "For the quick fix processor, I could never figure out when this was used. It is possible they are not used for quick fixes, but for completion proposals (which are different to quick fixes).\nHowever they are used, the strings should probably use displayString (eg, with these new changes, sometimes we're adding to the test path and not the build path).", "author": "kriegfrj", "createdAt": "2020-03-19T01:49:13Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import org.bndtools.core.ui.icons.Icons;\n+import org.eclipse.core.resources.WorkspaceJob;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jface.text.contentassist.IContextInformation;\n+import org.eclipse.swt.graphics.Image;\n+import org.eclipse.swt.graphics.Point;\n+\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.model.BndEditModel;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Constants;\n+import aQute.bnd.osgi.Descriptors;\n+import aQute.lib.strings.Strings;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletionProposal {\n+\n+\tfinal BundleId\t\t\t\tbundle;\n+\tfinal String\t\t\t\tdisplayString;\n+\tfinal int\t\t\t\t\trelevance;\n+\tfinal IInvocationContext\tcontext;\n+\tfinal Project\t\t\t\tproject;\n+\tfinal String\t\t\t\tpathtype;\n+\tfinal String\t\t\t\tfqn;\n+\n+\tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n+\t\tProject project, String pathtype) {\n+\t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n+\t\tthis.fqn = fqn;\n+\t\tthis.bundle = bundle;\n+\t\tthis.relevance = relevance;\n+\t\tthis.context = context;\n+\t\tthis.project = project;\n+\t\tthis.pathtype = pathtype;\n+\t\tthis.displayString = Strings.format(\"Add %s %s to %s (found %s)\", bundle.getBsn(), bundle.getShortVersion(),\n+\t\t\tpathtype, fqn);\n+\t}\n+\n+\t@Override\n+\tpublic void apply(org.eclipse.jface.text.IDocument document) {\n+\t\tschedule();\n+\t}\n+\n+\t/**\n+\t * @see org.eclipse.jface.text.contentassist.ICompletionProposal#getSelection(org.eclipse.jface.text.IDocument)\n+\t */\n+\t@Override\n+\tpublic Point getSelection(org.eclipse.jface.text.IDocument document) {\n+\t\treturn new Point(context.getSelectionOffset(), context.getSelectionLength());\n+\t}\n+\n+\t@Override\n+\tpublic String getAdditionalProposalInfo() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic String getDisplayString() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic Image getImage() {\n+\t\treturn Icons.image(\"bundle\");\n+\t}\n+\n+\t@Override\n+\tpublic IContextInformation getContextInformation() {\n+\t\treturn new IContextInformation() {\n+\n+\t\t\t@Override\n+\t\t\tpublic String getContextDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path\";\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Image getImage() {\n+\t\t\t\treturn Icons.image(\"bundle\");\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String getInformationDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path - info\";\n+\t\t\t}\n+\n+\t\t};\n+\t}", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\nindex 3e83ea6ad..65160fb25 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n\n@@ -30,9 +30,10 @@ class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletio\n \tfinal Project\t\t\t\tproject;\n \tfinal String\t\t\t\tpathtype;\n \tfinal String\t\t\t\tfqn;\n+\tfinal boolean\t\t\t\tdoImport;\n \n \tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n-\t\tProject project, String pathtype) {\n+\t\tProject project, String pathtype, boolean doImport) {\n \t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n \t\tthis.fqn = fqn;\n \t\tthis.bundle = bundle;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0NjM2NQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394746365", "bodyText": "Error message needs to reflect whether the attempt was made to update the -buildpath or -testpath.", "author": "kriegfrj", "createdAt": "2020-03-19T01:49:46Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import org.bndtools.core.ui.icons.Icons;\n+import org.eclipse.core.resources.WorkspaceJob;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jface.text.contentassist.IContextInformation;\n+import org.eclipse.swt.graphics.Image;\n+import org.eclipse.swt.graphics.Point;\n+\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.model.BndEditModel;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Constants;\n+import aQute.bnd.osgi.Descriptors;\n+import aQute.lib.strings.Strings;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletionProposal {\n+\n+\tfinal BundleId\t\t\t\tbundle;\n+\tfinal String\t\t\t\tdisplayString;\n+\tfinal int\t\t\t\t\trelevance;\n+\tfinal IInvocationContext\tcontext;\n+\tfinal Project\t\t\t\tproject;\n+\tfinal String\t\t\t\tpathtype;\n+\tfinal String\t\t\t\tfqn;\n+\n+\tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n+\t\tProject project, String pathtype) {\n+\t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n+\t\tthis.fqn = fqn;\n+\t\tthis.bundle = bundle;\n+\t\tthis.relevance = relevance;\n+\t\tthis.context = context;\n+\t\tthis.project = project;\n+\t\tthis.pathtype = pathtype;\n+\t\tthis.displayString = Strings.format(\"Add %s %s to %s (found %s)\", bundle.getBsn(), bundle.getShortVersion(),\n+\t\t\tpathtype, fqn);\n+\t}\n+\n+\t@Override\n+\tpublic void apply(org.eclipse.jface.text.IDocument document) {\n+\t\tschedule();\n+\t}\n+\n+\t/**\n+\t * @see org.eclipse.jface.text.contentassist.ICompletionProposal#getSelection(org.eclipse.jface.text.IDocument)\n+\t */\n+\t@Override\n+\tpublic Point getSelection(org.eclipse.jface.text.IDocument document) {\n+\t\treturn new Point(context.getSelectionOffset(), context.getSelectionLength());\n+\t}\n+\n+\t@Override\n+\tpublic String getAdditionalProposalInfo() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic String getDisplayString() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic Image getImage() {\n+\t\treturn Icons.image(\"bundle\");\n+\t}\n+\n+\t@Override\n+\tpublic IContextInformation getContextInformation() {\n+\t\treturn new IContextInformation() {\n+\n+\t\t\t@Override\n+\t\t\tpublic String getContextDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path\";\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Image getImage() {\n+\t\t\t\treturn Icons.image(\"bundle\");\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String getInformationDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path - info\";\n+\t\t\t}\n+\n+\t\t};\n+\t}\n+\n+\t@Override\n+\tpublic int getRelevance() {\n+\t\treturn relevance;\n+\t}\n+\n+\t@Override\n+\tpublic IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n+\t\ttry {\n+\t\t\tIStatus status = Central.bndCall(() -> {\n+\t\t\t\tBndEditModel model = new BndEditModel(project);\n+\t\t\t\tmodel.load();\n+\n+\t\t\t\tswitch (pathtype) {\n+\t\t\t\t\tcase Constants.TESTPATH :\n+\t\t\t\t\t\tmodel.addPath(bundle, Constants.TESTPATH);\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tcase Constants.BUILDPATH :\n+\t\t\t\t\tdefault :\n+\t\t\t\t\t\tmodel.addPath(bundle, Constants.BUILDPATH);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tmodel.saveChanges();\n+\t\t\t\tCentral.refreshFile(project.getPropertiesFile());\n+\t\t\t\treturn Status.OK_STATUS;\n+\t\t\t});\n+\n+\t\t\tString[] determine = Descriptors.determine(fqn)\n+\t\t\t\t.unwrap();\n+\n+\t\t\tassert determine[0] != null : \"We must have found a package\";\n+\n+\t\t\tif (determine[1] == null) {\n+\t\t\t\tcontext.getCompilationUnit()\n+\t\t\t\t\t.createImport(fqn + \".*\", null, monitor);\n+\t\t\t} else {\n+\t\t\t\tcontext.getCompilationUnit()\n+\t\t\t\t\t.createImport(fqn, null, monitor);\n+\t\t\t}\n+\t\t\treturn status;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new CoreException(\n+\t\t\t\tnew Status(IStatus.ERROR, Plugin.PLUGIN_ID, \"Failed to add bundle to -buildpath\", e));", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4Nzg4OQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394887889", "bodyText": "fixed", "author": "pkriens", "createdAt": "2020-03-19T09:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0NjM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\nindex 3e83ea6ad..65160fb25 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n\n@@ -30,9 +30,10 @@ class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletio\n \tfinal Project\t\t\t\tproject;\n \tfinal String\t\t\t\tpathtype;\n \tfinal String\t\t\t\tfqn;\n+\tfinal boolean\t\t\t\tdoImport;\n \n \tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n-\t\tProject project, String pathtype) {\n+\t\tProject project, String pathtype, boolean doImport) {\n \t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n \t\tthis.fqn = fqn;\n \t\tthis.bundle = bundle;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0NzIwMw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394747203", "bodyText": "The old quick fix processor made use of the monitor when saving. Admittedly, this is likely to be a fast operation. However, more generally, perhaps we should be considering a more standard way of interfacing IProgressMonitor with Central.bndCall(). This could have other usability benefits in other parts of Bndtools (I'm thinking of resolving, for example, which can sometimes take a while without much visual feedback on progress).", "author": "kriegfrj", "createdAt": "2020-03-19T01:53:31Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import org.bndtools.core.ui.icons.Icons;\n+import org.eclipse.core.resources.WorkspaceJob;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jface.text.contentassist.IContextInformation;\n+import org.eclipse.swt.graphics.Image;\n+import org.eclipse.swt.graphics.Point;\n+\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.model.BndEditModel;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Constants;\n+import aQute.bnd.osgi.Descriptors;\n+import aQute.lib.strings.Strings;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletionProposal {\n+\n+\tfinal BundleId\t\t\t\tbundle;\n+\tfinal String\t\t\t\tdisplayString;\n+\tfinal int\t\t\t\t\trelevance;\n+\tfinal IInvocationContext\tcontext;\n+\tfinal Project\t\t\t\tproject;\n+\tfinal String\t\t\t\tpathtype;\n+\tfinal String\t\t\t\tfqn;\n+\n+\tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n+\t\tProject project, String pathtype) {\n+\t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n+\t\tthis.fqn = fqn;\n+\t\tthis.bundle = bundle;\n+\t\tthis.relevance = relevance;\n+\t\tthis.context = context;\n+\t\tthis.project = project;\n+\t\tthis.pathtype = pathtype;\n+\t\tthis.displayString = Strings.format(\"Add %s %s to %s (found %s)\", bundle.getBsn(), bundle.getShortVersion(),\n+\t\t\tpathtype, fqn);\n+\t}\n+\n+\t@Override\n+\tpublic void apply(org.eclipse.jface.text.IDocument document) {\n+\t\tschedule();\n+\t}\n+\n+\t/**\n+\t * @see org.eclipse.jface.text.contentassist.ICompletionProposal#getSelection(org.eclipse.jface.text.IDocument)\n+\t */\n+\t@Override\n+\tpublic Point getSelection(org.eclipse.jface.text.IDocument document) {\n+\t\treturn new Point(context.getSelectionOffset(), context.getSelectionLength());\n+\t}\n+\n+\t@Override\n+\tpublic String getAdditionalProposalInfo() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic String getDisplayString() {\n+\t\treturn displayString;\n+\t}\n+\n+\t@Override\n+\tpublic Image getImage() {\n+\t\treturn Icons.image(\"bundle\");\n+\t}\n+\n+\t@Override\n+\tpublic IContextInformation getContextInformation() {\n+\t\treturn new IContextInformation() {\n+\n+\t\t\t@Override\n+\t\t\tpublic String getContextDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path\";\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Image getImage() {\n+\t\t\t\treturn Icons.image(\"bundle\");\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String getInformationDisplayString() {\n+\t\t\t\treturn \"Added \" + bundle + \" to build path - info\";\n+\t\t\t}\n+\n+\t\t};\n+\t}\n+\n+\t@Override\n+\tpublic int getRelevance() {\n+\t\treturn relevance;\n+\t}\n+\n+\t@Override\n+\tpublic IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n+\t\ttry {\n+\t\t\tIStatus status = Central.bndCall(() -> {\n+\t\t\t\tBndEditModel model = new BndEditModel(project);\n+\t\t\t\tmodel.load();", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4NTkyOA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394885928", "bodyText": "Yes, it is been on my mind for some time to bring the monitor as concept in bnd. I'll add something, but not in this branch.", "author": "pkriens", "createdAt": "2020-03-19T09:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc0NzIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\nindex 3e83ea6ad..65160fb25 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/AddBundleCompletionProposal.java\n\n@@ -30,9 +30,10 @@ class AddBundleCompletionProposal extends WorkspaceJob implements IJavaCompletio\n \tfinal Project\t\t\t\tproject;\n \tfinal String\t\t\t\tpathtype;\n \tfinal String\t\t\t\tfqn;\n+\tfinal boolean\t\t\t\tdoImport;\n \n \tpublic AddBundleCompletionProposal(String fqn, BundleId bundle, int relevance, IInvocationContext context,\n-\t\tProject project, String pathtype) {\n+\t\tProject project, String pathtype, boolean doImport) {\n \t\tsuper(\"Adding '\" + bundle + \"' to \" + project + \" \" + pathtype);\n \t\tthis.fqn = fqn;\n \t\tthis.bundle = bundle;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MTk4MQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394751981", "bodyText": "For the common case where we haven't found any proposals, perhaps we should return null rather than an empty array. Saves the overhead of the extra object allocations. Relatively small optimisation though.", "author": "kriegfrj", "createdAt": "2020-03-19T02:12:01Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.compiler.IProblem;\n+import org.eclipse.jdt.core.dom.ASTNode;\n+import org.eclipse.jdt.core.dom.ImportDeclaration;\n+import org.eclipse.jdt.core.dom.Name;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jdt.ui.text.java.IProblemLocation;\n+import org.eclipse.jdt.ui.text.java.IQuickFixProcessor;\n+\n+import aQute.bnd.build.Container;\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.Workspace;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.lib.exceptions.Exceptions;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+public class BuildpathQuickfixProcessor implements IQuickFixProcessor {\n+\n+\t@Override\n+\tpublic boolean hasCorrections(ICompilationUnit unit, int problemId) {\n+\t\tswitch (problemId) {\n+\t\t\tcase IProblem.IsClassPathCorrect :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.ImportNotFound :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.UndefinedType :\n+\t\t\t\treturn true;\n+\t\t\tdefault :\n+\t\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic IJavaCompletionProposal[] getCorrections(IInvocationContext context, IProblemLocation[] locations)\n+\t\tthrows CoreException {\n+\t\ttry {\n+\t\t\tList<IJavaCompletionProposal> proposals = new ArrayList<>();\n+\n+\t\t\tICompilationUnit compUnit = context.getCompilationUnit();\n+\t\t\tIJavaProject java = compUnit.getJavaProject();\n+\t\t\tif (java == null)\n+\t\t\t\treturn null;\n+\n+\t\t\tProject project = Central.getProject(java.getProject());\n+\t\t\tif (project == null)\n+\t\t\t\treturn null;\n+\n+\t\t\tboolean test = isInDir(project.getTestSrc(), compUnit.getResource());\n+\t\t\tWorkspace workspace = project.getWorkspace();\n+\n+\t\t\tfor (IProblemLocation location : locations) {\n+\n+\t\t\t\tif (!hasCorrections(context.getCompilationUnit(), location.getProblemId()))\n+\t\t\t\t\treturn null;\n+\n+\t\t\t\tString partialClassName = getPartialClassName(location.getCoveringNode(context.getASTRoot()));\n+\t\t\t\tif (partialClassName == null && location.getProblemArguments().length > 0)\n+\t\t\t\t\tpartialClassName = location.getProblemArguments()[0];\n+\n+\t\t\t\tif (partialClassName == null)\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tMap<String, List<BundleId>> result = workspace.search(partialClassName)\n+\t\t\t\t\t.orElseThrow(s -> new CoreException(new Status(IStatus.ERROR, Plugin.PLUGIN_ID, s)));\n+\n+\t\t\t\tSet<BundleId> buildpath = getBundleIds(project.getBuildpath());\n+\t\t\t\tSet<BundleId> testpath = test ? getBundleIds(project.getTestpath()) : Collections.emptySet();\n+\n+\t\t\t\tresult.entrySet()\n+\t\t\t\t\t.forEach(e -> {\n+\t\t\t\t\t\tfor (BundleId id : e.getValue()) {\n+\n+\t\t\t\t\t\t\tif (test && !testpath.contains(id) && !buildpath.contains(id))\n+\t\t\t\t\t\t\t\tproposals.add(propose(e.getKey(), id, context, location, project, \"-testpath\"));\n+\n+\t\t\t\t\t\t\tif (!buildpath.contains(id))\n+\t\t\t\t\t\t\t\tproposals.add(propose(e.getKey(), id, context, location, project, \"-buildpath\"));\n+\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\t}\n+\t\t\treturn proposals.toArray(new IJavaCompletionProposal[0]);", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg3MTUzNQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394871535", "bodyText": "less is more ...", "author": "pkriens", "createdAt": "2020-03-19T08:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MTk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2ODgwMQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395368801", "bodyText": "Having re-read the spec for getCorrections() (per the javadoc), just to let you know that this is technically non-compliant - the javadoc calls for null to be returned if you don't have any proposals. It will probably work, but we might one day run into an issue if Eclipse ever relies on the assumption that it should be null.", "author": "kriegfrj", "createdAt": "2020-03-19T23:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MTk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4MjM0Mg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395482342", "bodyText": "I disagree but it is not worth to fight about this. Fixed.", "author": "pkriens", "createdAt": "2020-03-20T08:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MTk4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\nindex 6a65e556b..169e3bad5 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n\n@@ -31,6 +31,7 @@ import aQute.bnd.build.Container;\n import aQute.bnd.build.Project;\n import aQute.bnd.build.Workspace;\n import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Descriptors;\n import aQute.lib.exceptions.Exceptions;\n import bndtools.Plugin;\n import bndtools.central.Central;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MjAwNw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394752007", "bodyText": "Because this is the entry point from Eclipse into the quick fix processor, maybe it would be better to wrap this in a CoreException rather than allowing it to propagate up? I'm not 100% sure on Eclipse best practice here, but that seems to be what we've done elsewhere in Bndtools.", "author": "kriegfrj", "createdAt": "2020-03-19T02:12:06Z", "path": "bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.bndtools.core.editors.quickfix;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Status;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.compiler.IProblem;\n+import org.eclipse.jdt.core.dom.ASTNode;\n+import org.eclipse.jdt.core.dom.ImportDeclaration;\n+import org.eclipse.jdt.core.dom.Name;\n+import org.eclipse.jdt.ui.text.java.IInvocationContext;\n+import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;\n+import org.eclipse.jdt.ui.text.java.IProblemLocation;\n+import org.eclipse.jdt.ui.text.java.IQuickFixProcessor;\n+\n+import aQute.bnd.build.Container;\n+import aQute.bnd.build.Project;\n+import aQute.bnd.build.Workspace;\n+import aQute.bnd.osgi.BundleId;\n+import aQute.lib.exceptions.Exceptions;\n+import bndtools.Plugin;\n+import bndtools.central.Central;\n+\n+public class BuildpathQuickfixProcessor implements IQuickFixProcessor {\n+\n+\t@Override\n+\tpublic boolean hasCorrections(ICompilationUnit unit, int problemId) {\n+\t\tswitch (problemId) {\n+\t\t\tcase IProblem.IsClassPathCorrect :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.ImportNotFound :\n+\t\t\t\treturn true;\n+\t\t\tcase IProblem.UndefinedType :\n+\t\t\t\treturn true;\n+\t\t\tdefault :\n+\t\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic IJavaCompletionProposal[] getCorrections(IInvocationContext context, IProblemLocation[] locations)\n+\t\tthrows CoreException {\n+\t\ttry {\n+\t\t\tList<IJavaCompletionProposal> proposals = new ArrayList<>();\n+\n+\t\t\tICompilationUnit compUnit = context.getCompilationUnit();\n+\t\t\tIJavaProject java = compUnit.getJavaProject();\n+\t\t\tif (java == null)\n+\t\t\t\treturn null;\n+\n+\t\t\tProject project = Central.getProject(java.getProject());\n+\t\t\tif (project == null)\n+\t\t\t\treturn null;\n+\n+\t\t\tboolean test = isInDir(project.getTestSrc(), compUnit.getResource());\n+\t\t\tWorkspace workspace = project.getWorkspace();\n+\n+\t\t\tfor (IProblemLocation location : locations) {\n+\n+\t\t\t\tif (!hasCorrections(context.getCompilationUnit(), location.getProblemId()))\n+\t\t\t\t\treturn null;\n+\n+\t\t\t\tString partialClassName = getPartialClassName(location.getCoveringNode(context.getASTRoot()));\n+\t\t\t\tif (partialClassName == null && location.getProblemArguments().length > 0)\n+\t\t\t\t\tpartialClassName = location.getProblemArguments()[0];\n+\n+\t\t\t\tif (partialClassName == null)\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tMap<String, List<BundleId>> result = workspace.search(partialClassName)\n+\t\t\t\t\t.orElseThrow(s -> new CoreException(new Status(IStatus.ERROR, Plugin.PLUGIN_ID, s)));\n+\n+\t\t\t\tSet<BundleId> buildpath = getBundleIds(project.getBuildpath());\n+\t\t\t\tSet<BundleId> testpath = test ? getBundleIds(project.getTestpath()) : Collections.emptySet();\n+\n+\t\t\t\tresult.entrySet()\n+\t\t\t\t\t.forEach(e -> {\n+\t\t\t\t\t\tfor (BundleId id : e.getValue()) {\n+\n+\t\t\t\t\t\t\tif (test && !testpath.contains(id) && !buildpath.contains(id))\n+\t\t\t\t\t\t\t\tproposals.add(propose(e.getKey(), id, context, location, project, \"-testpath\"));\n+\n+\t\t\t\t\t\t\tif (!buildpath.contains(id))\n+\t\t\t\t\t\t\t\tproposals.add(propose(e.getKey(), id, context, location, project, \"-buildpath\"));\n+\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\t}\n+\t\t\treturn proposals.toArray(new IJavaCompletionProposal[0]);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow Exceptions.duck(e);\n+\t\t}", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4NTMyMw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394885323", "bodyText": "If you look at the code you see that CoreException is thrown when we have something useful to tell, see line 85. All other exceptions are basically out of contract. No way to do anything useful there. If there are common exceptions that we want to handle we should change the API to use Result.\nIn bnd, exceptions are treated as a boolean, they should just signal an out of contract failure. The new Result is really helpful here. Since not everybody follows that model, sometimes you need to catch an exception that contains information you cannot get in any other way. That is then necessary but we should try to treat exceptions as booleans, indicating you're in lala land, no way to known where you are anymore.", "author": "pkriens", "createdAt": "2020-03-19T09:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA4OTkzMQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395089931", "bodyText": "Hmm, I'm not sure I follow here. If this was a Bnd internal function, changing the API to use Result would be a sensible option. But this is part of the Eclipse API - we don't have control over it, we have to try and comply with it.\nThe documentation for IQuickFixProcessor.getCorrections() states that we may throw CoreException if something goes wrong. It doesn't say that we're allowed to throw any other kind of exception, and if we do Eclipse's behaviour will be undefined (especially a checked exception masked as an unchecked exception). It might prevent other quick fix processors from running. Less likely, but more seriously it might crash our editor, or our entire Eclipse instance. Surely it is better to be a good citizen and do our best to make sure that our own internal errors (even unanticipated errors caused by bugs) don't do damage to any of our \"neighbours\"?", "author": "kriegfrj", "createdAt": "2020-03-19T14:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEwNDkxNQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395104915", "bodyText": "The issue is that in 'normal' code the exception would always be a runtime exception. I decided from the beginning that an Checked Exceptions are evil and should be treated as runtime exceptions. I.e. if this exception is thrown, the code is wrong. The Exceptions class was added to treat the checked exceptions as RuntimeExceptions.\nYou're right about the consequences but an exception there means the code is fundamentally broken. I.e. like a NPE. It just should not happen and therefore should not have a decent  handling. It is Game Over.", "author": "pkriens", "createdAt": "2020-03-19T15:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2Nzg2Mg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395367862", "bodyText": "I get that an exception there means the code is fundamentally broken, that it should not happen. But if it is fundamentally broken/it does happen? What if we do cause an NPE, for example? Wouldn't it be better if we didn't bring down Eclipse or stop other quick fix processors from running?\nIf your answer to this is simply \"no\", I guess I will shrug my shoulders and note my disagreement for the record. I would sandbox it to prevent our contagion from spreading.", "author": "kriegfrj", "createdAt": "2020-03-19T23:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4MDI2Mw==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395480263", "bodyText": "But Eclipse is sandboxing it already ... Any runtime exception must be caught or Eclipse would not survive very long. It should also be logged in the error log, which Core Exceptions aren't I think. It happens to be visible here because I decided early on in bnd (1999 probably) that checked exceptions are evil and all methods are throwing Exception, basically treating all exceptions as runtime exceptions. The primary reason is to pass the original cause upwards instead of the long chains that too often miss the root cause. This strategy makes runtime exceptions visible in cases like this, cases that normal code can ignore. If this exception happens, it is like a core dump in C code or panic() in Rust. I want this to be really bad because it is a code error and must be fixed asap, not hidden in any way. The goal is to show the place where the thing failed and we should therefore not wrap it in any way. And I want it in the Eclipse log.\nSo far it worked fine for me. However, lambdas threw a bit of a wrench in this strategy and that makes us struggle a bit with it. I wish Java had an option to ignore checked exceptions, like every other language on earth. It is probably the worst idea since language design began. So due to lambdas, I'd probably not throw Exception on every method again. But that would increase the use of duck() because I refuse to play the game of checked exceptions unless forced by bad API design.", "author": "pkriens", "createdAt": "2020-03-20T07:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4Njc4Ng==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r396186786", "bodyText": "If Eclipse is properly sandboxing it already, then scratch what I said - I agree that yours is the best implementation in that circumstance. Unnecessary wrapping of the exception makes it harder to find the root cause in the logs.", "author": "kriegfrj", "createdAt": "2020-03-23T02:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1MjAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "53707f3d69c72a2070770c59821d56637e93339a", "chunk": "diff --git a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\nindex 6a65e556b..169e3bad5 100644\n--- a/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n+++ b/bndtools.core/src/org/bndtools/core/editors/quickfix/BuildpathQuickfixProcessor.java\n\n@@ -31,6 +31,7 @@ import aQute.bnd.build.Container;\n import aQute.bnd.build.Project;\n import aQute.bnd.build.Workspace;\n import aQute.bnd.osgi.BundleId;\n+import aQute.bnd.osgi.Descriptors;\n import aQute.lib.exceptions.Exceptions;\n import bndtools.Plugin;\n import bndtools.central.Central;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NDY5Mg==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394754692", "bodyText": "I don't think it's accurate to say that \"the majority of the code is tested in bnd\". I'm sure that all of the searching code is tested in Bnd - but searching is only half of the quick fix processor's responsibility. The other thing that the quick fix processor has to do (equally important) is understand Eclipse's error message formats so that it knows what to search for and can translate that into a form that Bnd understands, and then conversely take Bnd's response and translate that into a form that Eclipse can use. The first part in particular is a non-trivial operation and accounted for a significant chunk of the original quick-fix code.\nThe original ImportPackageQuickFixProcessorTest was close to a full end-to-end test - it used actual source code with errors which could be quick-fixed, then it used Eclipse's compiler to compile these into an actual AST, and finally it created actual IProblemLocation objects (which were built based on observed values determined by experimentation on a live Eclipse instance). It passed these in to getCompletions() to ensure that the correct set of ICompletionProposals was created.\nIn order to ensure that we haven't had any regressions, we should do something similar. The old test should form the basis, as I know it had pretty good coverage of lots of weird corner cases. Your code is admittedly a lot simpler, but I'm not sure if this simplification has come at the expense of us not handling some of these weird corner cases.\nThe more I think about this as I type, the more I am of the opinion that the best way forward for me to review your changes will be to port ImportPackageQuickFixProcessor to BuildpathQuickFixProcessorTest. For starters, I can't remember all of the weird corner cases, and even if I could testing them all manually would be onerous. If I instead go to the effort of porting the test, then we have the added benefit of a solid regression test moving forward so that others can make changes without fear of breaking existing functionality (that is, after all, why I went to the effort of writing the original regression test in the first place!)", "author": "kriegfrj", "createdAt": "2020-03-19T02:22:28Z", "path": "bndtools.core/test/org/bndtools/core/editors/BuildpathQuickFixProcessorTest.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.bndtools.core.editors;\n+\n+import org.junit.Test;\n+\n+public class BuildpathQuickFixProcessorTest {\n+\n+\t@Test\n+\tpublic void testBasic() {\n+\t\t// not sure how to test this\n+\t\t// the majority of the code is tested in bnd\n+\t}", "originalCommit": "9367a4eeda9f618ab1338bcb280db0793bce14de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg3MDg3MA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394870870", "bodyText": "That was what I was secretly hoping for :-)\nIt is always very nice if you have a different person doing the test.", "author": "pkriens", "createdAt": "2020-03-19T08:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NjEzMA==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r394896130", "bodyText": "If you just could have a standalone test where I can give a Java source with a problem and get the quick fixes, that would be great. We could use this in other cases as well since this stuff is highly undertested.", "author": "pkriens", "createdAt": "2020-03-19T09:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3MzUxMQ==", "url": "https://github.com/bndtools/bnd/pull/3833#discussion_r395073511", "bodyText": "As noted above, I'll have a look when I get a chance.", "author": "kriegfrj", "createdAt": "2020-03-19T14:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NDY5Mg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "53707f3d69c72a2070770c59821d56637e93339a", "url": "https://github.com/bndtools/bnd/commit/53707f3d69c72a2070770c59821d56637e93339a", "message": "[review] After Fr. Krieg review\n\n- More careful with imports\n- Use bndCall with monitor\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-19T14:06:14Z", "type": "commit"}, {"oid": "acac272b9e6f00aff9a5c6803d106a053ef5e268", "url": "https://github.com/bndtools/bnd/commit/acac272b9e6f00aff9a5c6803d106a053ef5e268", "message": "rename \n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-19T16:47:50Z", "type": "commit"}, {"oid": "acac272b9e6f00aff9a5c6803d106a053ef5e268", "url": "https://github.com/bndtools/bnd/commit/acac272b9e6f00aff9a5c6803d106a053ef5e268", "message": "rename \n\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-19T16:47:50Z", "type": "forcePushed"}, {"oid": "a6c212ea591540b554505352f823b85a17b181a3", "url": "https://github.com/bndtools/bnd/commit/a6c212ea591540b554505352f823b85a17b181a3", "message": "Rename is harder than I thought\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-20T08:04:46Z", "type": "commit"}, {"oid": "a3607060ecc74b18dfbb803272472ae4caa987c9", "url": "https://github.com/bndtools/bnd/commit/a3607060ecc74b18dfbb803272472ae4caa987c9", "message": "Return null on no proposals.\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-20T08:05:27Z", "type": "commit"}, {"oid": "2555a5f0b0f1552e38d1760260332f61883c48e9", "url": "https://github.com/bndtools/bnd/commit/2555a5f0b0f1552e38d1760260332f61883c48e9", "message": "[libg] Doc\n\n- Added some more odd to the new Lazy & IntCounter\n- A few more utility methods in IntCounter\n- Cleaned ip the overflow handling\n\nSigned-off-by: Peter Kriens <Peter.Kriens@aqute.biz>", "committedDate": "2020-03-20T08:51:00Z", "type": "commit"}]}