{"pr_number": 12886, "pr_title": "Capability framework with changes for enabling capability", "pr_createdAt": "2020-12-07T18:23:19Z", "pr_url": "https://github.com/cdapio/cdap/pull/12886", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NjkyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537746923", "bodyText": "Remove CAPABILITY_ prefix since the inner class name already has it.", "author": "chtyim", "createdAt": "2020-12-07T18:53:28Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -1495,4 +1495,22 @@\n      */\n     public static final String UPDATE_ALLOWED = PREFIX + \"update.allowed\";\n   }\n+\n+  /**\n+   * Constants for capability management\n+   */\n+  public static final class Capability {\n+    /**\n+     * External config directory path key\n+     */\n+    public static final String CAPABILITY_CONFIG_EXTERNAL_DIR = \"capability.config.external.dir\";", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java b/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java\nindex 5b53e92622b..31bd60dffa2 100644\n--- a/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java\n+++ b/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java\n\n@@ -1503,14 +1508,14 @@ public final class Constants {\n     /**\n      * External config directory path key\n      */\n-    public static final String CAPABILITY_CONFIG_EXTERNAL_DIR = \"capability.config.external.dir\";\n+    public static final String CONFIG_DIR = \"capability.config.dir\";\n     /**\n      * Internal config directory path key\n      */\n-    public static final String CAPABILITY_CONFIG_DIR = \"capability.config.dir\";\n+    public static final String DATA_DIR = \"capability.data.dir\";\n     /**\n      * Interval for scanning config directory\n      */\n-    public static final String CAPABILITY_SCAN_INTERVAL = \"capability.scan.interval.mins\";\n+    public static final String SCAN_INTERVAL = \"capability.scan.interval.mins\";\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NzM3Mw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537747373", "bodyText": "Remove comment", "author": "chtyim", "createdAt": "2020-12-07T18:54:10Z", "path": "cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityManagementServiceTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.AllProgramsApp;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+\n+/**\n+ * Test for {@link CapabilityManagementService}\n+ */\n+public class CapabilityManagementServiceTest extends CapabilityBaseTest {\n+\n+  private static final String VERSION = \"1.0.0\";\n+  private static final String APP_NAME = AllProgramsApp.NAME;\n+  private static final String NAMESPACE = \"default\";\n+  private static final String PROGRAM_NAME = AllProgramsApp.NoOpService.NAME;\n+  private static final Class<AllProgramsApp> APP_CLASS = AllProgramsApp.class;\n+  private static LocationFactory locationFactory;\n+  private static CapabilityManagementService capabilityManagementService;\n+  private static CapabilityManager capabilityManager;\n+  private static CConfiguration cConfiguration;\n+  //private static String externalConfigPath;", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityManagementServiceTest.java b/cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityManagementServiceTest.java\ndeleted file mode 100644\nindex 35f5621206b..00000000000\n--- a/cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityManagementServiceTest.java\n+++ /dev/null\n\n@@ -1,82 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import io.cdap.cdap.AllProgramsApp;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.proto.ProgramRunStatus;\n-import io.cdap.cdap.proto.ProgramType;\n-import io.cdap.cdap.proto.id.ApplicationId;\n-import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.filesystem.LocationFactory;\n-import org.junit.Assert;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n-\n-import java.io.File;\n-import java.nio.file.Files;\n-\n-/**\n- * Test for {@link CapabilityManagementService}\n- */\n-public class CapabilityManagementServiceTest extends CapabilityBaseTest {\n-\n-  private static final String VERSION = \"1.0.0\";\n-  private static final String APP_NAME = AllProgramsApp.NAME;\n-  private static final String NAMESPACE = \"default\";\n-  private static final String PROGRAM_NAME = AllProgramsApp.NoOpService.NAME;\n-  private static final Class<AllProgramsApp> APP_CLASS = AllProgramsApp.class;\n-  private static LocationFactory locationFactory;\n-  private static CapabilityManagementService capabilityManagementService;\n-  private static CapabilityManager capabilityManager;\n-  private static CConfiguration cConfiguration;\n-  //private static String externalConfigPath;\n-\n-  @BeforeClass\n-  public static void setup() throws Exception {\n-    capabilityManagementService = getInjector().getInstance(CapabilityManagementService.class);\n-    capabilityManagementService.stop();\n-    capabilityManager = getInjector().getInstance(CapabilityManager.class);\n-    cConfiguration = getInjector().getInstance(CConfiguration.class);\n-    String externalConfigPath = tmpFolder.newFolder(\"capability-config-external\").getAbsolutePath();\n-    cConfiguration.set(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR,\n-                       externalConfigPath);\n-    cConfiguration.set(Constants.Capability.CAPABILITY_CONFIG_DIR,\n-                       tmpFolder.newFolder(\"capability-config\").getAbsolutePath());\n-    String fileName = \"cap1.json\";\n-    File testJson = new File(\n-      CapabilityManagementServiceTest.class.getResource(String.format(\"/%s\", fileName)).getPath());\n-    Files.copy(testJson.toPath(), new File(String.format(\"%s/%s\", externalConfigPath, fileName)).toPath());\n-  }\n-\n-  @Test\n-  public void testRunOneIteration() throws Exception {\n-    deployTestArtifact();\n-    //Make sure capability is not present\n-    Assert.assertFalse(capabilityManager.isCapabilityPresent(\"cap1\"));\n-    //call runOneIteration\n-    capabilityManagementService.runOneIteration();\n-    //app should be deployed and program should be run\n-    ApplicationId applicationId = new ApplicationId(NAMESPACE, APP_NAME, VERSION);\n-    ProgramId programId = new ProgramId(applicationId, ProgramType.SERVICE, PROGRAM_NAME);\n-    assertProgramRuns(programId, ProgramRunStatus.RUNNING, 1);\n-    //capability is present and enabled\n-    Assert.assertTrue(capabilityManager.isCapabilityPresent(\"cap1\"));\n-    Assert.assertEquals(CapabilityStatus.ENABLED, capabilityManager.getStatus(\"cap1\"));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0ODcxNQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537748715", "bodyText": "Why extends from AppFabricTestBase. Generally a simpler unit-test that directly test against the class is more preferrable.", "author": "chtyim", "createdAt": "2020-12-07T18:56:13Z", "path": "cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityBaseTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.io.Files;\n+import io.cdap.cdap.AllProgramsApp;\n+import io.cdap.cdap.common.id.Id;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.test.AppJarHelper;\n+import io.cdap.cdap.internal.app.services.http.AppFabricTestBase;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.junit.BeforeClass;\n+\n+import java.io.File;\n+\n+/**\n+ * Base class with common setup and methods for testing capability feature\n+ */\n+public class CapabilityBaseTest extends AppFabricTestBase {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityBaseTest.java b/cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityBaseTest.java\ndeleted file mode 100644\nindex 7ae62aa6bf5..00000000000\n--- a/cdap-app-fabric/src/test/java/io/cdap/cdap/internal/capability/CapabilityBaseTest.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.io.Files;\n-import io.cdap.cdap.AllProgramsApp;\n-import io.cdap.cdap.common.id.Id;\n-import io.cdap.cdap.common.io.Locations;\n-import io.cdap.cdap.common.test.AppJarHelper;\n-import io.cdap.cdap.internal.app.services.http.AppFabricTestBase;\n-import org.apache.twill.filesystem.Location;\n-import org.apache.twill.filesystem.LocationFactory;\n-import org.junit.BeforeClass;\n-\n-import java.io.File;\n-\n-/**\n- * Base class with common setup and methods for testing capability feature\n- */\n-public class CapabilityBaseTest extends AppFabricTestBase {\n-\n-  static final String VERSION = \"1.0.0\";\n-  static final String APP_NAME = AllProgramsApp.NAME;\n-  static final String NAMESPACE = \"default\";\n-  static final String PROGRAM_NAME = AllProgramsApp.NoOpService.NAME;\n-  static final Class<AllProgramsApp> APP_CLASS = AllProgramsApp.class;\n-\n-  private static LocationFactory locationFactory;\n-\n-  @BeforeClass\n-  public static void commonSetup() {\n-    locationFactory = getInjector().getInstance(LocationFactory.class);\n-  }\n-\n-  void deployTestArtifact() throws Exception {\n-    Id.Artifact artifactId = Id.Artifact\n-      .from(Id.Namespace.DEFAULT, APP_NAME, VERSION);\n-    Location appJar = AppJarHelper.createDeploymentJar(locationFactory, APP_CLASS);\n-    File appJarFile = new File(tmpFolder.newFolder(),\n-                               String.format(\"%s-%s.jar\", artifactId.getName(), artifactId.getVersion().getVersion()));\n-    Files.copy(Locations.newInputSupplier(appJar), appJarFile);\n-    appJar.delete();\n-    addAppArtifact(artifactId, APP_CLASS);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MTcyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537751723", "bodyText": "We already have a Program class. It is better not to have the same class name even it in different package.", "author": "chtyim", "createdAt": "2020-12-07T18:59:15Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/Program.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with fields for requesting Programs that should be started for a capability\n+ */\n+public class Program {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NDI5NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540474294", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-10T20:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MTcyMw=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/Program.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/SystemProgram.java\nsimilarity index 81%\nrename from cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/Program.java\nrename to cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/SystemProgram.java\nindex 69cd1dffa2f..659e064b9c2 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/Program.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/SystemProgram.java\n\n@@ -23,16 +23,17 @@ import javax.annotation.Nullable;\n /**\n  * Class with fields for requesting Programs that should be started for a capability\n  */\n-public class Program {\n-  private String namespace;\n-  private String application;\n-  private String type;\n-  private String name;\n-  private String version;\n-  private Map<String, String> args;\n+public class SystemProgram {\n \n-  public Program(String namespace, String application, String type, String name, @Nullable String version,\n-                 @Nullable Map<String, String> args) {\n+  private final String namespace;\n+  private final String application;\n+  private final String type;\n+  private final String name;\n+  private final String version;\n+  private final Map<String, String> args;\n+\n+  public SystemProgram(String namespace, String application, String type, String name, @Nullable String version,\n+                       @Nullable Map<String, String> args) {\n     this.namespace = namespace;\n     this.application = application;\n     this.type = type;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Mjk1Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537752952", "bodyText": "Why need this class? Seems unnecessary.", "author": "chtyim", "createdAt": "2020-12-07T19:01:09Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\nindex b3a336907e0..a69a12ad40f 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\n\n@@ -16,23 +16,110 @@\n \n package io.cdap.cdap.internal.capability;\n \n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n \n /**\n  * Class with helpful methods for managing capabilities\n  */\n-public class CapabilityManager {\n+public class CapabilityManager extends AbstractIdleService {\n \n   private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n \n-  private ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n \n-  CapabilityManager() {\n-    capabilityStatusMap = new ConcurrentHashMap<>();\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MzUyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537753523", "bodyText": "final fields.", "author": "chtyim", "createdAt": "2020-12-07T19:02:03Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MzY5Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537753696", "bodyText": "static fields before non-static fields.", "author": "chtyim", "createdAt": "2020-12-07T19:02:17Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MzgwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537753808", "bodyText": "Remove public for injected constructor.", "author": "chtyim", "createdAt": "2020-12-07T19:02:27Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NDA0Mw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537754043", "bodyText": "this.scheduleInterval to be consistent.", "author": "chtyim", "createdAt": "2020-12-07T19:02:47Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NTAwNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537755007", "bodyText": "Is this accurate? You are not rethrowing, right?", "author": "chtyim", "createdAt": "2020-12-07T19:04:27Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NjEyMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537756123", "bodyText": "should be try (Reader reader = ...) { } to have the file reader closed", "author": "chtyim", "createdAt": "2020-12-07T19:06:11Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.\n+      LOG.error(\"Error while scanning capability config directory \", exception);\n+    }\n+  }\n+\n+  private void scanConfigDirectory() throws FileNotFoundException {\n+    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n+    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n+    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n+    //TODO should each config run in its own thread ?\n+    for (File configFile : DirUtils.listFiles(destDir)) {\n+      CapabilityConfig capabilityConfig = parseConfig(configFile);\n+      if (toDelete.contains(configFile)) {\n+        handleDelete(capabilityConfig, configFile);\n+        continue;\n+      }\n+      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n+    }\n+  }\n+\n+  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n+    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityManager.isCapabilityPresent(capability)) {\n+      return;\n+    }\n+    //capability deleted. Remove the file\n+    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n+    configFile.delete();\n+  }\n+\n+  private Set<File> diffAndCopy(File srcDir, File destDir) {\n+    List<File> srcFiles = DirUtils.listFiles(srcDir);\n+    //copy the new files and replace\n+    srcFiles.stream().\n+      forEach(file -> {\n+        try {\n+          Files\n+            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n+                  StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException exception) {\n+          throw new RuntimeException(exception);\n+        }\n+      });\n+    //find the files to remove\n+    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n+      .filter(file -> matchName(file, srcFiles))\n+      .collect(Collectors.toSet());\n+    return destFilesToRemove;\n+  }\n+\n+  private boolean matchName(File file, List<File> files) {\n+    return files.stream()\n+      .map(File::getName)\n+      .noneMatch(fileName -> fileName.equals(file.getName()));\n+  }\n+\n+  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n+    Reader reader = new FileReader(configFile);", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1NzQ0MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537757441", "bodyText": "Use a simple for-loop is better in this case. Wrapping all IOException as RuntimeException is bad.", "author": "chtyim", "createdAt": "2020-12-07T19:08:14Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.\n+      LOG.error(\"Error while scanning capability config directory \", exception);\n+    }\n+  }\n+\n+  private void scanConfigDirectory() throws FileNotFoundException {\n+    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n+    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n+    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n+    //TODO should each config run in its own thread ?\n+    for (File configFile : DirUtils.listFiles(destDir)) {\n+      CapabilityConfig capabilityConfig = parseConfig(configFile);\n+      if (toDelete.contains(configFile)) {\n+        handleDelete(capabilityConfig, configFile);\n+        continue;\n+      }\n+      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n+    }\n+  }\n+\n+  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n+    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityManager.isCapabilityPresent(capability)) {\n+      return;\n+    }\n+    //capability deleted. Remove the file\n+    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n+    configFile.delete();\n+  }\n+\n+  private Set<File> diffAndCopy(File srcDir, File destDir) {\n+    List<File> srcFiles = DirUtils.listFiles(srcDir);\n+    //copy the new files and replace\n+    srcFiles.stream().", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Nzc4NQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537757785", "bodyText": "Don't use string format to create new file path. Use new File(destDir, file.getName) instead.", "author": "chtyim", "createdAt": "2020-12-07T19:08:48Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n+ */\n+public class CapabilityManagementService extends AbstractScheduledService {\n+\n+  private CConfiguration cConf;\n+  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n+  private final long scheduleInterval;\n+  private CapabilityManager capabilityManager;\n+  private static final Gson GSON = new Gson();\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+\n+  @Inject\n+  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n+                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n+    this.cConf = cConf;\n+    this.capabilityExecutorMap = capabilityExecutorMap;\n+    this.capabilityManager = capabilityManager;\n+    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    //Subsequent executions will not run concurrently (scheduler guarantee),\n+    // so need not worry about scan already in progress.\n+    LOG.debug(\"Scanning capability config directory\");\n+    try {\n+      scanConfigDirectory();\n+    } catch (Exception exception) {\n+      //If exception is thrown, no more executions will happen.\n+      LOG.error(\"Error while scanning capability config directory \", exception);\n+    }\n+  }\n+\n+  private void scanConfigDirectory() throws FileNotFoundException {\n+    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n+    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n+    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n+    //TODO should each config run in its own thread ?\n+    for (File configFile : DirUtils.listFiles(destDir)) {\n+      CapabilityConfig capabilityConfig = parseConfig(configFile);\n+      if (toDelete.contains(configFile)) {\n+        handleDelete(capabilityConfig, configFile);\n+        continue;\n+      }\n+      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n+    }\n+  }\n+\n+  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n+    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityManager.isCapabilityPresent(capability)) {\n+      return;\n+    }\n+    //capability deleted. Remove the file\n+    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n+    configFile.delete();\n+  }\n+\n+  private Set<File> diffAndCopy(File srcDir, File destDir) {\n+    List<File> srcFiles = DirUtils.listFiles(srcDir);\n+    //copy the new files and replace\n+    srcFiles.stream().\n+      forEach(file -> {\n+        try {\n+          Files\n+            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\ndeleted file mode 100644\nindex 29ecf532fff..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ /dev/null\n\n@@ -1,136 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractScheduledService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-/**\n- * Service for managing capabilities. Responsible for periodically reading capability configurations and applying them.\n- */\n-public class CapabilityManagementService extends AbstractScheduledService {\n-\n-  private CConfiguration cConf;\n-  private Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap;\n-  private final long scheduleInterval;\n-  private CapabilityManager capabilityManager;\n-  private static final Gson GSON = new Gson();\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n-\n-  @Inject\n-  public CapabilityManagementService(CConfiguration cConf, CapabilityManager capabilityManager,\n-                                     Map<CapabilityActionType, CapabilityActionExecutor> capabilityExecutorMap) {\n-    this.cConf = cConf;\n-    this.capabilityExecutorMap = capabilityExecutorMap;\n-    this.capabilityManager = capabilityManager;\n-    scheduleInterval = cConf.getLong(Constants.Capability.CAPABILITY_SCAN_INTERVAL, 1L);\n-  }\n-\n-  @Override\n-  protected void runOneIteration() throws Exception {\n-    //Subsequent executions will not run concurrently (scheduler guarantee),\n-    // so need not worry about scan already in progress.\n-    LOG.debug(\"Scanning capability config directory\");\n-    try {\n-      scanConfigDirectory();\n-    } catch (Exception exception) {\n-      //If exception is thrown, no more executions will happen.\n-      LOG.error(\"Error while scanning capability config directory \", exception);\n-    }\n-  }\n-\n-  private void scanConfigDirectory() throws FileNotFoundException {\n-    File srcDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_EXTERNAL_DIR));\n-    File destDir = new File(cConf.get(Constants.Capability.CAPABILITY_CONFIG_DIR));\n-    Set<File> toDelete = diffAndCopy(srcDir, destDir);\n-    //TODO should each config run in its own thread ?\n-    for (File configFile : DirUtils.listFiles(destDir)) {\n-      CapabilityConfig capabilityConfig = parseConfig(configFile);\n-      if (toDelete.contains(configFile)) {\n-        handleDelete(capabilityConfig, configFile);\n-        continue;\n-      }\n-      capabilityExecutorMap.get(capabilityConfig.getType()).execute(capabilityConfig);\n-    }\n-  }\n-\n-  private void handleDelete(CapabilityConfig capabilityConfig, File configFile) {\n-    capabilityExecutorMap.get(CapabilityActionType.DELETE).execute(capabilityConfig);\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityManager.isCapabilityPresent(capability)) {\n-      return;\n-    }\n-    //capability deleted. Remove the file\n-    LOG.debug(\"Cleaning up the config file {} after removing capability {}\", configFile, capability);\n-    configFile.delete();\n-  }\n-\n-  private Set<File> diffAndCopy(File srcDir, File destDir) {\n-    List<File> srcFiles = DirUtils.listFiles(srcDir);\n-    //copy the new files and replace\n-    srcFiles.stream().\n-      forEach(file -> {\n-        try {\n-          Files\n-            .copy(file.toPath(), new File(String.format(\"%s/%s\", destDir.getAbsolutePath(), file.getName())).toPath(),\n-                  StandardCopyOption.REPLACE_EXISTING);\n-        } catch (IOException exception) {\n-          throw new RuntimeException(exception);\n-        }\n-      });\n-    //find the files to remove\n-    Set<File> destFilesToRemove = DirUtils.listFiles(destDir).stream()\n-      .filter(file -> matchName(file, srcFiles))\n-      .collect(Collectors.toSet());\n-    return destFilesToRemove;\n-  }\n-\n-  private boolean matchName(File file, List<File> files) {\n-    return files.stream()\n-      .map(File::getName)\n-      .noneMatch(fileName -> fileName.equals(file.getName()));\n-  }\n-\n-  private CapabilityConfig parseConfig(File configFile) throws FileNotFoundException {\n-    Reader reader = new FileReader(configFile);\n-    return GSON.fromJson(reader, CapabilityConfig.class);\n-  }\n-\n-  @Override\n-  protected Scheduler scheduler() {\n-    return Scheduler.newFixedRateSchedule(1L, scheduleInterval, TimeUnit.MINUTES);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTg5Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537761897", "bodyText": "Use isEmpty", "author": "chtyim", "createdAt": "2020-12-07T19:15:26Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityEnableExecutor.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.deploy.pipeline.ApplicationWithPrograms;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.proto.ApplicationDetail;\n+import io.cdap.cdap.proto.ProgramStatus;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Executor for enabling a capability\n+ */\n+public class CapabilityEnableExecutor implements CapabilityActionExecutor {\n+\n+  private CapabilityManager capabilityManager;\n+  private final ApplicationLifecycleService appLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private static final Gson GSON = new Gson();\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private static final Set<Class<? extends Exception>> nonRetryableExceptions =\n+    new HashSet<>(\n+      Arrays.asList(UnauthorizedException.class, InvalidArtifactException.class\n+      ));\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityEnableExecutor.class);\n+\n+  @Inject\n+  CapabilityEnableExecutor(CapabilityManager capabilityManager, ApplicationLifecycleService appLifecycleService,\n+                           ProgramLifecycleService programLifecycleService) {\n+    this.capabilityManager = capabilityManager;\n+    this.appLifecycleService = appLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  @Override\n+  public void execute(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    LOG.debug(\"Enabling capability {}\", capability);\n+    try {\n+      deployAllApps(capability, capabilityConfig.getApplications());\n+      startAllPrograms(capability, capabilityConfig.getPrograms());\n+      capabilityManager.updateStatus(capability, CapabilityStatus.ENABLED);\n+    } catch (Exception exception) {\n+      capabilityManager.updateStatus(capability, CapabilityStatus.UNKNOWN);\n+      LOG.error(\"Enabling capability {} failed.\", capability, exception);\n+    }\n+  }\n+\n+  private void deployAllApps(String capability, List<Application> applications) throws Exception {\n+    if (applications == null || applications.size() == 0) {", "originalCommit": "dc80e1502fd26ccd7ba1d1c6b973be9045c437f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MjE5Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r537762197", "bodyText": "Is applications nullable?", "author": "chtyim", "createdAt": "2020-12-07T19:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTg5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityEnableExecutor.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityEnableExecutor.java\ndeleted file mode 100644\nindex 223f089fd54..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityEnableExecutor.java\n+++ /dev/null\n\n@@ -1,170 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.api.retry.RetryableException;\n-import io.cdap.cdap.common.ApplicationNotFoundException;\n-import io.cdap.cdap.common.InvalidArtifactException;\n-import io.cdap.cdap.common.service.Retries;\n-import io.cdap.cdap.common.service.RetryStrategies;\n-import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n-import io.cdap.cdap.internal.app.deploy.pipeline.ApplicationWithPrograms;\n-import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n-import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n-import io.cdap.cdap.proto.ApplicationDetail;\n-import io.cdap.cdap.proto.ProgramStatus;\n-import io.cdap.cdap.proto.ProgramType;\n-import io.cdap.cdap.proto.id.ApplicationId;\n-import io.cdap.cdap.proto.id.ProgramId;\n-import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Executor for enabling a capability\n- */\n-public class CapabilityEnableExecutor implements CapabilityActionExecutor {\n-\n-  private CapabilityManager capabilityManager;\n-  private final ApplicationLifecycleService appLifecycleService;\n-  private final ProgramLifecycleService programLifecycleService;\n-  private static final Gson GSON = new Gson();\n-  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n-    // no-op\n-  };\n-  private static final Set<Class<? extends Exception>> nonRetryableExceptions =\n-    new HashSet<>(\n-      Arrays.asList(UnauthorizedException.class, InvalidArtifactException.class\n-      ));\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityEnableExecutor.class);\n-\n-  @Inject\n-  CapabilityEnableExecutor(CapabilityManager capabilityManager, ApplicationLifecycleService appLifecycleService,\n-                           ProgramLifecycleService programLifecycleService) {\n-    this.capabilityManager = capabilityManager;\n-    this.appLifecycleService = appLifecycleService;\n-    this.programLifecycleService = programLifecycleService;\n-  }\n-\n-  @Override\n-  public void execute(CapabilityConfig capabilityConfig) {\n-    String capability = capabilityConfig.getCapability();\n-    LOG.debug(\"Enabling capability {}\", capability);\n-    try {\n-      deployAllApps(capability, capabilityConfig.getApplications());\n-      startAllPrograms(capability, capabilityConfig.getPrograms());\n-      capabilityManager.updateStatus(capability, CapabilityStatus.ENABLED);\n-    } catch (Exception exception) {\n-      capabilityManager.updateStatus(capability, CapabilityStatus.UNKNOWN);\n-      LOG.error(\"Enabling capability {} failed.\", capability, exception);\n-    }\n-  }\n-\n-  private void deployAllApps(String capability, List<Application> applications) throws Exception {\n-    if (applications == null || applications.size() == 0) {\n-      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n-      return;\n-    }\n-    for (Application application : applications) {\n-      String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n-      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n-      LOG.debug(\"Deploying app {}\", applicationId);\n-      deployApp(applicationId, application);\n-    }\n-  }\n-\n-  private void deployApp(ApplicationId applicationId, Application application) throws Exception {\n-    if (isAppDeployed(applicationId)) {\n-      //Already deployed.\n-      LOG.debug(\"Application {} is already deployed\", applicationId);\n-      return;\n-    }\n-    LOG.debug(\"Attempting to deploy application {} with retries.\", applicationId);\n-    //TODO Is a retry really required here?\n-    ApplicationWithPrograms appWithPrograms = Retries.callWithRetries(() -> {\n-      return deploySystemApp(applicationId, application);\n-    }, RetryStrategies.limit(5, RetryStrategies.fixDelay(6, TimeUnit.SECONDS)));\n-    if (appWithPrograms == null) {\n-      LOG.info(\"Expected deployed application , got null\");\n-      return;\n-    }\n-  }\n-\n-  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n-    ApplicationDetail applicationDetail = getApplicationDetail(applicationId);\n-    if (applicationDetail == null) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  private ApplicationDetail getApplicationDetail(ApplicationId appId) throws Exception {\n-    try {\n-      return appLifecycleService.getAppDetail(appId);\n-    } catch (ApplicationNotFoundException exception) {\n-      return null;\n-    }\n-  }\n-\n-  private ApplicationWithPrograms deploySystemApp(ApplicationId appId,\n-                                                  Application application) throws Exception {\n-    String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n-    try {\n-      return appLifecycleService.deployApp(appId.getParent(), appId.getApplication(), appId.getVersion(),\n-                                           application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR,\n-                                           null, null);\n-    } catch (Exception exception) {\n-      if (nonRetryableExceptions.contains(exception) || nonRetryableExceptions.contains(exception.getCause())) {\n-        throw exception;\n-      }\n-      throw new RetryableException(exception);\n-    }\n-  }\n-\n-  private void startAllPrograms(String capability, List<Program> programs) throws Exception {\n-    if (programs == null || programs.size() == 0) {\n-      LOG.debug(\"Capability {} do not have programs associated with it\", capability);\n-      return;\n-    }\n-    for (Program program : programs) {\n-      String version = program.getVersion() == null ? ApplicationId.DEFAULT_VERSION : program.getVersion();\n-      ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(), version);\n-      ProgramId programId = new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()),\n-                                          program.getName());\n-      LOG.debug(\"Starting program {}\", programId);\n-      startProgram(programId, program.getArgs());\n-    }\n-  }\n-\n-  private void startProgram(ProgramId programId, Map<String, String> args) throws Exception {\n-    ProgramStatus currentStatus = programLifecycleService.getProgramStatus(programId);\n-    if (currentStatus == ProgramStatus.RUNNING) {\n-      LOG.debug(\"Program {} already running\", programId);\n-      return;\n-    }\n-    programLifecycleService.run(programId, args, false);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MTgyOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538791828", "bodyText": "final", "author": "chtyim", "createdAt": "2020-12-08T20:43:04Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MjQ2MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538792461", "bodyText": "Use an AtomicReference<Map...> to do atomic replacement of map in the set method.", "author": "chtyim", "createdAt": "2020-12-08T20:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzQ3NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917474", "bodyText": "done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MTgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\nindex bf81f331f40..17f8f260c7a 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n\n@@ -16,16 +16,18 @@\n \n package io.cdap.cdap.internal.app.services;\n \n-import com.google.common.util.concurrent.AbstractScheduledService;\n import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n import io.cdap.cdap.common.conf.CConfiguration;\n import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n import io.cdap.cdap.proto.ProgramType;\n import io.cdap.cdap.proto.id.NamespaceId;\n import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.api.RunId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MjgzMA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538792830", "bodyText": "Call it setProgramsEnabled. This means renaming the field too.", "author": "chtyim", "createdAt": "2020-12-08T20:44:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzQ0MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917440", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5MjgzMA=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\nindex bf81f331f40..17f8f260c7a 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n\n@@ -16,16 +16,18 @@\n \n package io.cdap.cdap.internal.app.services;\n \n-import com.google.common.util.concurrent.AbstractScheduledService;\n import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n import io.cdap.cdap.common.conf.CConfiguration;\n import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n import io.cdap.cdap.proto.ProgramType;\n import io.cdap.cdap.proto.id.NamespaceId;\n import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.api.RunId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Mzc1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538793758", "bodyText": "Put the default value into cdap-default.xml instead.", "author": "chtyim", "createdAt": "2020-12-08T20:46:29Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzM4Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917387", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Mzc1OA=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\nindex bf81f331f40..17f8f260c7a 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n\n@@ -16,16 +16,18 @@\n \n package io.cdap.cdap.internal.app.services;\n \n-import com.google.common.util.concurrent.AbstractScheduledService;\n import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n import io.cdap.cdap.common.conf.CConfiguration;\n import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n import io.cdap.cdap.proto.ProgramType;\n import io.cdap.cdap.proto.id.NamespaceId;\n import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.api.RunId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5NDA5MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538794091", "bodyText": "debug", "author": "chtyim", "createdAt": "2020-12-08T20:46:57Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\nindex bf81f331f40..17f8f260c7a 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n\n@@ -16,16 +16,18 @@\n \n package io.cdap.cdap.internal.app.services;\n \n-import com.google.common.util.concurrent.AbstractScheduledService;\n import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n import io.cdap.cdap.common.conf.CConfiguration;\n import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n import io.cdap.cdap.proto.ProgramType;\n import io.cdap.cdap.proto.id.NamespaceId;\n import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.api.RunId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538797994", "bodyText": "It is better to loop by the ProgramId and call ProgramRuntimeService.list(ProgramId) on each of them", "author": "chtyim", "createdAt": "2020-12-08T20:53:16Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception exception) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", exception);\n+    }\n+  }\n+\n+  private void reconcileServices() {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.enabledServices);\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2OTMwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538869308", "bodyText": "Listing with program id will return only the enabled services runs. We also need to identify the services to stop, so using listAll for service here.", "author": "greeshmaswaminathan", "createdAt": "2020-12-08T22:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MjE4Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538872187", "bodyText": "Since you are listing all runs, you can collect the list of extra runs to stop in here. Also, always collect the ProgramRunId to pin point to which runs to run.", "author": "chtyim", "createdAt": "2020-12-08T22:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzI5OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917299", "bodyText": "Done. Changes in #12886", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5Nzk5NA=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\nindex bf81f331f40..17f8f260c7a 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n\n@@ -16,16 +16,18 @@\n \n package io.cdap.cdap.internal.app.services;\n \n-import com.google.common.util.concurrent.AbstractScheduledService;\n import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n import io.cdap.cdap.common.conf.CConfiguration;\n import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n import io.cdap.cdap.proto.ProgramType;\n import io.cdap.cdap.proto.id.NamespaceId;\n import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.api.RunId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMDE3Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538800177", "bodyText": "I think this doesn't handle the case where there are two runs of the same programId, in which we want to stop the extra ones.", "author": "chtyim", "createdAt": "2020-12-08T20:55:30Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception exception) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", exception);\n+    }\n+  }\n+\n+  private void reconcileServices() {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.enabledServices);\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);\n+    Set<ProgramId> servicesToStop = new HashSet<>();\n+    Set<ProgramId> servicesRunning = new HashSet<>();\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2OTc2Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538869762", "bodyText": "Stopping additional runs are handled separately.", "author": "greeshmaswaminathan", "createdAt": "2020-12-08T22:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMDE3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\nindex bf81f331f40..17f8f260c7a 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n\n@@ -16,16 +16,18 @@\n \n package io.cdap.cdap.internal.app.services;\n \n-import com.google.common.util.concurrent.AbstractScheduledService;\n import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n import io.cdap.cdap.common.conf.CConfiguration;\n import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n import io.cdap.cdap.proto.ProgramType;\n import io.cdap.cdap.proto.id.NamespaceId;\n import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.api.RunId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMjc4Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538802782", "bodyText": "Usually we just use ex as the variable name for exception.", "author": "chtyim", "createdAt": "2020-12-08T20:58:31Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import org.apache.twill.api.RunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private Map<ProgramId, Map<String, String>> enabledServices;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL, 10L);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param enabledServices\n+   */\n+  public void setEnabledServices(Map<ProgramId, Map<String, String>> enabledServices) {\n+    this.enabledServices = new HashMap<>(enabledServices);\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (enabledServices == null) {\n+      LOG.info(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception exception) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", exception);\n+    }\n+  }\n+\n+  private void reconcileServices() {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.enabledServices);\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);\n+    Set<ProgramId> servicesToStop = new HashSet<>();\n+    Set<ProgramId> servicesRunning = new HashSet<>();\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {\n+      ProgramId programId = runtimeInfo.getProgramId();\n+      if (!programId.getNamespaceId().equals(NamespaceId.SYSTEM)) {\n+        //We care only about system services\n+        continue;\n+      }\n+      if (!enabledServices.contains(programId)) {\n+        servicesToStop.add(programId);\n+      } else {\n+        servicesRunning.add(programId);\n+      }\n+    }\n+    Set<ProgramId> servicesToStart = enabledServices.stream()\n+      .filter(programId -> !servicesRunning.contains(programId))\n+      .collect(Collectors.toSet());\n+    startServices(servicesToStart, enabledServicesMap);\n+    stopServices(servicesToStop);\n+    //prune additional runs if any\n+    pruneAdditionalRuns(enabledServices);\n+  }\n+\n+  private void startServices(Set<ProgramId> servicesToStart, Map<ProgramId, Map<String, String>> enabledServicesMap) {\n+    for (ProgramId programId : servicesToStart) {\n+      Map<String, String> overrides = enabledServicesMap.get(programId);\n+      LOG.debug(\"Starting program {} with args {}\", programId, overrides);\n+      try {\n+        programLifecycleService.start(programId, overrides, false);\n+      } catch (Exception exception) {", "originalCommit": "ffc8b56cbb64257fbf1b85b527aefd333e074acb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzE0Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r538917147", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T00:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwMjc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5818e0d644b15fb787210d97e1eb0fb675d66228", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\nindex bf81f331f40..17f8f260c7a 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java\n\n@@ -16,16 +16,18 @@\n \n package io.cdap.cdap.internal.app.services;\n \n-import com.google.common.util.concurrent.AbstractScheduledService;\n import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n import io.cdap.cdap.common.conf.CConfiguration;\n import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n import io.cdap.cdap.proto.ProgramType;\n import io.cdap.cdap.proto.id.NamespaceId;\n import io.cdap.cdap.proto.id.ProgramId;\n-import org.apache.twill.api.RunId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"oid": "5818e0d644b15fb787210d97e1eb0fb675d66228", "url": "https://github.com/cdapio/cdap/commit/5818e0d644b15fb787210d97e1eb0fb675d66228", "message": "Capability framework wih changes for enabling capability", "committedDate": "2020-12-10T20:26:07Z", "type": "forcePushed"}, {"oid": "292338c543bbd45ae87b1a19e6c9cfa9f4447e3d", "url": "https://github.com/cdapio/cdap/commit/292338c543bbd45ae87b1a19e6c9cfa9f4447e3d", "message": "Capability framework wih changes for enabling capability", "committedDate": "2020-12-10T20:43:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYyNTM0Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540625347", "bodyText": "No need to have binding. Just new it in the CapabilityManager", "author": "chtyim", "createdAt": "2020-12-11T01:35:56Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +303,9 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n+      bind(CapabilityManager.class).in(Scopes.SINGLETON);\n       bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n+      bind(MetadataSearchClient.class).in(Scopes.SINGLETON);", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTY3Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481676", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYyNTM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\nindex 40fda1c0889..688f9c6fc00 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n\n@@ -303,9 +304,6 @@ public final class AppFabricServiceRuntimeModule extends RuntimeModule {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      bind(CapabilityManager.class).in(Scopes.SINGLETON);\n-      bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n-      bind(MetadataSearchClient.class).in(Scopes.SINGLETON);\n       bind(OwnerAdmin.class).to(DefaultOwnerAdmin.class);\n       bind(CoreSchedulerService.class).in(Scopes.SINGLETON);\n       bind(Scheduler.class).to(CoreSchedulerService.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MjMyNA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540842324", "bodyText": "Shouldn't call pipeline. CDAP platform itself has no concept of pipeline. Call it stopAllPrograms", "author": "chtyim", "createdAt": "2020-12-11T10:22:06Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+    refreshCapabilities();\n+  }\n+\n+  /**\n+   * Apply capabilities based on the configuration files on disk\n+   */\n+  private void refreshCapabilities() {\n+    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n+    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n+    try {\n+      readLock.lock();\n+      for (File configFile : DirUtils.listFiles(dataDir)) {\n+        try (Reader reader = new FileReader(configFile)) {\n+          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n+        } catch (IOException ex) {\n+          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n+        }\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+    refreshCapabilities(allCapabilityConfigs);\n+  }\n+\n+  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n+    //collect all programs to be enabled\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    Set<String> enabledCapabilities = new HashSet<>();\n+    for (CapabilityConfig config : capabilityConfigs) {\n+      String capability = config.getCapability();\n+      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n+      switch (config.getType()) {\n+        case ENABLE:\n+          deployAllApps(capability, config.getApplications());\n+          config.getPrograms().forEach(systemProgram -> enabledPrograms\n+            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+          enabledCapabilities.add(capability);\n+          break;\n+        case DISABLE:\n+          disableCapability(capability);\n+          break;\n+        case DELETE:\n+          deleteCapability(config);\n+          break;\n+        default:\n+          LOG.error(\"Unknown capability action {} \", config.getType());\n+          break;\n+      }\n+    }\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    enabledCapabilities.forEach(this::enableCapability);\n+  }\n+\n+  /**\n+   * Returns the list of applications that are having metadata tagged with the capability\n+   *\n+   * @param namespace  Namespace for which applications should be listed\n+   * @param capability Capability by which to filter\n+   * @param cursor     Optional cursor from a previous response\n+   * @param offset     Offset from where to start\n+   * @param limit      Limit of records to fetch\n+   * @return\n+   * @throws IOException - Exception from meta data search if any\n+   */\n+  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n+                                                     int offset, int limit) throws IOException {\n+    String capabilityTag = String.format(CAPABILITY, capability);\n+    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n+      .addNamespace(namespace.getNamespace())\n+      .addType(APPLICATION)\n+      .setScope(MetadataScope.SYSTEM)\n+      .setCursor(cursor)\n+      .setOffset(offset)\n+      .setLimit(limit)\n+      .build();\n+    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n+    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n+      .map(MetadataSearchResultRecord::getMetadataEntity)\n+      .map(this::getApplicationId)\n+      .collect(Collectors.toSet());\n+    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n+                              searchResponse.getOffset(), searchResponse.getLimit(),\n+                              searchResponse.getTotal());\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n+  }\n+\n+  @Nullable\n+  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n+    List<String> cursors = searchResponse.getCursors();\n+    if (cursors == null || cursors.isEmpty()) {\n+      return null;\n+    }\n+    return cursors.get(0);\n+  }\n+\n+  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n+    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n+                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n+                             metadataEntity.getValue(MetadataEntity.VERSION));\n+  }\n+\n+  private void enableCapability(String capability) {\n+    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n+    LOG.debug(\"Capability {} enabled.\", capability);\n+  }\n+\n+  private void disableCapability(String capability) {\n+    //mark as disabled to prevent further runs\n+    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n+    //stop pipelines\n+    try {\n+      stopPipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //programs(services) will be stopped by SystemProgramManagementService\n+    LOG.debug(\"Capability {} disabled.\", capability);\n+  }\n+\n+  private void deleteCapability(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n+      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n+      return;\n+    }\n+    //delete pipelines\n+    try {\n+      deletePipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //delete applications\n+    for (SystemApplication application : capabilityConfig.getApplications()) {\n+      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n+                                                      application.getVersion());\n+      try {\n+        applicationLifecycleService.removeApplication(applicationId);\n+      } catch (Exception exception) {\n+        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n+      }\n+    }\n+    capabilityStatusMap.remove(capability);\n+    LOG.debug(\"Capability {} deleted.\", capability);\n+  }\n+\n+  private void deletePipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopPipelines(String capability) throws Exception {", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTY5OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481698", "bodyText": "Renamed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MjMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\ndeleted file mode 100644\nindex fc0ef841a07..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\n+++ /dev/null\n\n@@ -1,422 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractIdleService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.api.metadata.MetadataEntity;\n-import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n-import io.cdap.cdap.app.runtime.Arguments;\n-import io.cdap.cdap.common.ApplicationNotFoundException;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.namespace.NamespaceAdmin;\n-import io.cdap.cdap.common.service.Retries;\n-import io.cdap.cdap.common.service.RetryStrategies;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n-import io.cdap.cdap.internal.app.runtime.BasicArguments;\n-import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n-import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n-import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n-import io.cdap.cdap.internal.entity.EntityResult;\n-import io.cdap.cdap.proto.NamespaceMeta;\n-import io.cdap.cdap.proto.ProgramRecord;\n-import io.cdap.cdap.proto.ProgramType;\n-import io.cdap.cdap.proto.id.ApplicationId;\n-import io.cdap.cdap.proto.id.NamespaceId;\n-import io.cdap.cdap.proto.id.ProgramId;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n-import io.cdap.cdap.spi.metadata.SearchRequest;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-\n-/**\n- * Class with helpful methods for managing capabilities\n- */\n-public class CapabilityManager extends AbstractIdleService {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n-  private static final Gson GSON = new Gson();\n-  private static final int RETRY_LIMIT = 5;\n-  private static final int RETRY_DELAY = 5;\n-  private static final String CAPABILITY = \"capability:%s\";\n-  private static final String APPLICATION = \"application\";\n-  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n-    // no-op\n-  };\n-  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n-  private final SystemProgramManagementService systemProgramManagementService;\n-  private final ApplicationLifecycleService applicationLifecycleService;\n-  private final ProgramLifecycleService programLifecycleService;\n-  private final NamespaceAdmin namespaceAdmin;\n-  private final MetadataSearchClient metadataSearchClient;\n-  private final CConfiguration cConf;\n-  private final Lock readLock;\n-  private final Lock writeLock;\n-\n-  @Inject\n-  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n-                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n-                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n-    this.capabilityStatusMap = new ConcurrentHashMap<>();\n-    this.systemProgramManagementService = systemProgramManagementService;\n-    this.applicationLifecycleService = applicationLifecycleService;\n-    this.programLifecycleService = programLifecycleService;\n-    this.metadataSearchClient = metadataSearchClient;\n-    this.namespaceAdmin = namespaceAdmin;\n-    this.cConf = cConf;\n-    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n-    readLock = rwLock.readLock();\n-    writeLock = rwLock.writeLock();\n-  }\n-\n-  @Override\n-  protected void startUp() {\n-    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n-    //refresh the status of all capabilities\n-    systemProgramManagementService.start();\n-    refreshCapabilities();\n-  }\n-\n-  @Override\n-  protected void shutDown() {\n-    systemProgramManagementService.stopAndWait();\n-    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n-  }\n-\n-  /**\n-   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n-   *\n-   * @param capability\n-   * @return {@link CapabilityStatus}\n-   */\n-  public CapabilityStatus getStatus(String capability) {\n-    if (!capabilityStatusMap.containsKey(capability)) {\n-      throw new IllegalArgumentException(\"Capability not found\");\n-    }\n-    return capabilityStatusMap.get(capability);\n-  }\n-\n-  /**\n-   * Returns boolean indicating whether the capability is present in the system\n-   *\n-   * @param capability\n-   * @return boolean indicating presence of capability\n-   */\n-  public boolean isCapabilityPresent(String capability) {\n-    return capabilityStatusMap.containsKey(capability);\n-  }\n-\n-  /**\n-   * Applies the given capability configurations\n-   *\n-   * @param\n-   */\n-  public void apply(List<CapabilityConfig> capabilityConfigs) {\n-    try {\n-      writeLock.lock();\n-      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n-        String capability = capabilityConfig.getCapability();\n-        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n-        try (FileWriter writer = new FileWriter(file)) {\n-          GSON.toJson(capabilityConfig, writer);\n-        } catch (IOException ex) {\n-          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n-        }\n-      }\n-    } finally {\n-      writeLock.unlock();\n-    }\n-    refreshCapabilities();\n-  }\n-\n-  /**\n-   * Apply capabilities based on the configuration files on disk\n-   */\n-  private void refreshCapabilities() {\n-    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n-    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n-    try {\n-      readLock.lock();\n-      for (File configFile : DirUtils.listFiles(dataDir)) {\n-        try (Reader reader = new FileReader(configFile)) {\n-          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n-        } catch (IOException ex) {\n-          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n-        }\n-      }\n-    } finally {\n-      readLock.unlock();\n-    }\n-    refreshCapabilities(allCapabilityConfigs);\n-  }\n-\n-  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n-    //collect all programs to be enabled\n-    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n-    Set<String> enabledCapabilities = new HashSet<>();\n-    for (CapabilityConfig config : capabilityConfigs) {\n-      String capability = config.getCapability();\n-      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n-      switch (config.getType()) {\n-        case ENABLE:\n-          deployAllApps(capability, config.getApplications());\n-          config.getPrograms().forEach(systemProgram -> enabledPrograms\n-            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n-          enabledCapabilities.add(capability);\n-          break;\n-        case DISABLE:\n-          disableCapability(capability);\n-          break;\n-        case DELETE:\n-          deleteCapability(config);\n-          break;\n-        default:\n-          LOG.error(\"Unknown capability action {} \", config.getType());\n-          break;\n-      }\n-    }\n-    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n-    enabledCapabilities.forEach(this::enableCapability);\n-  }\n-\n-  /**\n-   * Returns the list of applications that are having metadata tagged with the capability\n-   *\n-   * @param namespace  Namespace for which applications should be listed\n-   * @param capability Capability by which to filter\n-   * @param cursor     Optional cursor from a previous response\n-   * @param offset     Offset from where to start\n-   * @param limit      Limit of records to fetch\n-   * @return\n-   * @throws IOException - Exception from meta data search if any\n-   */\n-  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n-                                                     int offset, int limit) throws IOException {\n-    String capabilityTag = String.format(CAPABILITY, capability);\n-    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n-      .addNamespace(namespace.getNamespace())\n-      .addType(APPLICATION)\n-      .setScope(MetadataScope.SYSTEM)\n-      .setCursor(cursor)\n-      .setOffset(offset)\n-      .setLimit(limit)\n-      .build();\n-    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n-    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n-      .map(MetadataSearchResultRecord::getMetadataEntity)\n-      .map(this::getApplicationId)\n-      .collect(Collectors.toSet());\n-    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n-                              searchResponse.getOffset(), searchResponse.getLimit(),\n-                              searchResponse.getTotal());\n-  }\n-\n-  private ProgramId getProgramId(SystemProgram program) {\n-    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n-                                                    program.getVersion());\n-    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n-  }\n-\n-  @Nullable\n-  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n-    List<String> cursors = searchResponse.getCursors();\n-    if (cursors == null || cursors.isEmpty()) {\n-      return null;\n-    }\n-    return cursors.get(0);\n-  }\n-\n-  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n-    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n-                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n-                             metadataEntity.getValue(MetadataEntity.VERSION));\n-  }\n-\n-  private void enableCapability(String capability) {\n-    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n-    LOG.debug(\"Capability {} enabled.\", capability);\n-  }\n-\n-  private void disableCapability(String capability) {\n-    //mark as disabled to prevent further runs\n-    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n-    //stop pipelines\n-    try {\n-      stopPipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //programs(services) will be stopped by SystemProgramManagementService\n-    LOG.debug(\"Capability {} disabled.\", capability);\n-  }\n-\n-  private void deleteCapability(CapabilityConfig capabilityConfig) {\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n-      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n-      return;\n-    }\n-    //delete pipelines\n-    try {\n-      deletePipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //delete applications\n-    for (SystemApplication application : capabilityConfig.getApplications()) {\n-      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n-                                                      application.getVersion());\n-      try {\n-        applicationLifecycleService.removeApplication(applicationId);\n-      } catch (Exception exception) {\n-        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n-      }\n-    }\n-    capabilityStatusMap.remove(capability);\n-    LOG.debug(\"Capability {} deleted.\", capability);\n-  }\n-\n-  private void deletePipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::deleteAppWithRetry);\n-  }\n-\n-  private void stopPipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::stopPrograms);\n-  }\n-\n-  private void deployAllApps(String capability, List<SystemApplication> applications) {\n-    if (applications.isEmpty()) {\n-      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n-      return;\n-    }\n-    for (SystemApplication application : applications) {\n-      doWithRetry(application, this::deployApp);\n-    }\n-  }\n-\n-  private void deployApp(SystemApplication application) {\n-    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n-    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n-    LOG.debug(\"Deploying app {}\", applicationId);\n-    try {\n-      if (isAppDeployed(applicationId)) {\n-        //Already deployed.\n-        LOG.debug(\"Application {} is already deployed\", applicationId);\n-        return;\n-      }\n-      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n-      applicationLifecycleService\n-        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n-                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n-    try {\n-      applicationLifecycleService.getAppDetail(applicationId);\n-      return true;\n-    } catch (ApplicationNotFoundException exception) {\n-      return false;\n-    }\n-  }\n-\n-  //Find all applications for capability and call consumer for each\n-  private void doForAllApps(String capability, Consumer<ApplicationId> consumer) throws Exception {\n-    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n-      int offset = 0;\n-      int limit = 100;\n-      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n-      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n-                                                            offset, limit);\n-      while (results.getEntities().size() > 0) {\n-        //call consumer for each entity\n-        results.getEntities().forEach(consumer);\n-        if (results.getEntities().size() < limit) {\n-          break;\n-        }\n-        offset += limit;\n-        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n-      }\n-    }\n-  }\n-\n-  private void stopPrograms(ApplicationId applicationId) {\n-    try {\n-      List<ProgramRecord> programs = applicationLifecycleService.getAppDetail(applicationId).getPrograms();\n-      for (ProgramRecord programRecord : programs) {\n-        ProgramId programId = new ProgramId(applicationId, programRecord.getType(), programRecord.getName());\n-        doWithRetry(programId, this::stopProgram);\n-      }\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping programs for application {} failed with {}\", applicationId, ex);\n-    }\n-  }\n-\n-  private void stopProgram(ProgramId programId) {\n-    try {\n-      programLifecycleService.stop(programId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private void deleteAppWithRetry(ApplicationId applicationId) {\n-    doWithRetry(applicationId, this::deleteApp);\n-  }\n-\n-  private void deleteApp(ApplicationId applicationId) {\n-    try {\n-      applicationLifecycleService.removeApplication(applicationId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private <T> void doWithRetry(T argument, Consumer<T> consumer) {\n-    Retries.callWithRetries(() -> {\n-      consumer.accept(argument);\n-      return null;\n-    }, RetryStrategies.limit(RETRY_LIMIT, RetryStrategies.fixDelay(RETRY_DELAY, TimeUnit.SECONDS)));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDkwMw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540844903", "bodyText": "Is everything exception retryable?", "author": "chtyim", "createdAt": "2020-12-11T10:26:28Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+    refreshCapabilities();\n+  }\n+\n+  /**\n+   * Apply capabilities based on the configuration files on disk\n+   */\n+  private void refreshCapabilities() {\n+    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n+    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n+    try {\n+      readLock.lock();\n+      for (File configFile : DirUtils.listFiles(dataDir)) {\n+        try (Reader reader = new FileReader(configFile)) {\n+          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n+        } catch (IOException ex) {\n+          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n+        }\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+    refreshCapabilities(allCapabilityConfigs);\n+  }\n+\n+  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n+    //collect all programs to be enabled\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    Set<String> enabledCapabilities = new HashSet<>();\n+    for (CapabilityConfig config : capabilityConfigs) {\n+      String capability = config.getCapability();\n+      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n+      switch (config.getType()) {\n+        case ENABLE:\n+          deployAllApps(capability, config.getApplications());\n+          config.getPrograms().forEach(systemProgram -> enabledPrograms\n+            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+          enabledCapabilities.add(capability);\n+          break;\n+        case DISABLE:\n+          disableCapability(capability);\n+          break;\n+        case DELETE:\n+          deleteCapability(config);\n+          break;\n+        default:\n+          LOG.error(\"Unknown capability action {} \", config.getType());\n+          break;\n+      }\n+    }\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    enabledCapabilities.forEach(this::enableCapability);\n+  }\n+\n+  /**\n+   * Returns the list of applications that are having metadata tagged with the capability\n+   *\n+   * @param namespace  Namespace for which applications should be listed\n+   * @param capability Capability by which to filter\n+   * @param cursor     Optional cursor from a previous response\n+   * @param offset     Offset from where to start\n+   * @param limit      Limit of records to fetch\n+   * @return\n+   * @throws IOException - Exception from meta data search if any\n+   */\n+  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n+                                                     int offset, int limit) throws IOException {\n+    String capabilityTag = String.format(CAPABILITY, capability);\n+    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n+      .addNamespace(namespace.getNamespace())\n+      .addType(APPLICATION)\n+      .setScope(MetadataScope.SYSTEM)\n+      .setCursor(cursor)\n+      .setOffset(offset)\n+      .setLimit(limit)\n+      .build();\n+    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n+    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n+      .map(MetadataSearchResultRecord::getMetadataEntity)\n+      .map(this::getApplicationId)\n+      .collect(Collectors.toSet());\n+    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n+                              searchResponse.getOffset(), searchResponse.getLimit(),\n+                              searchResponse.getTotal());\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n+  }\n+\n+  @Nullable\n+  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n+    List<String> cursors = searchResponse.getCursors();\n+    if (cursors == null || cursors.isEmpty()) {\n+      return null;\n+    }\n+    return cursors.get(0);\n+  }\n+\n+  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n+    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n+                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n+                             metadataEntity.getValue(MetadataEntity.VERSION));\n+  }\n+\n+  private void enableCapability(String capability) {\n+    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n+    LOG.debug(\"Capability {} enabled.\", capability);\n+  }\n+\n+  private void disableCapability(String capability) {\n+    //mark as disabled to prevent further runs\n+    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n+    //stop pipelines\n+    try {\n+      stopPipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //programs(services) will be stopped by SystemProgramManagementService\n+    LOG.debug(\"Capability {} disabled.\", capability);\n+  }\n+\n+  private void deleteCapability(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n+      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n+      return;\n+    }\n+    //delete pipelines\n+    try {\n+      deletePipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //delete applications\n+    for (SystemApplication application : capabilityConfig.getApplications()) {\n+      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n+                                                      application.getVersion());\n+      try {\n+        applicationLifecycleService.removeApplication(applicationId);\n+      } catch (Exception exception) {\n+        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n+      }\n+    }\n+    capabilityStatusMap.remove(capability);\n+    LOG.debug(\"Capability {} deleted.\", capability);\n+  }\n+\n+  private void deletePipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopPipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::stopPrograms);\n+  }\n+\n+  private void deployAllApps(String capability, List<SystemApplication> applications) {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::deployApp);\n+    }\n+  }\n+\n+  private void deployApp(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    try {\n+      if (isAppDeployed(applicationId)) {\n+        //Already deployed.\n+        LOG.debug(\"Application {} is already deployed\", applicationId);\n+        return;\n+      }\n+      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+      applicationLifecycleService\n+        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+    } catch (Exception ex) {\n+      throw new RetryableException(ex);", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0ODgwMQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541148801", "bodyText": "We could restrict it to not retry for UnauthorizedException, InvalidArtifactException . Only retrying for ArtifactNotFoundException may not be sufficient I think. Not sure what the exception is in case system is not fully ready.", "author": "greeshmaswaminathan", "createdAt": "2020-12-11T18:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTc1Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481757", "bodyText": "Added some checks for exceptions.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDkwMw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\ndeleted file mode 100644\nindex fc0ef841a07..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\n+++ /dev/null\n\n@@ -1,422 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractIdleService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.api.metadata.MetadataEntity;\n-import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n-import io.cdap.cdap.app.runtime.Arguments;\n-import io.cdap.cdap.common.ApplicationNotFoundException;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.namespace.NamespaceAdmin;\n-import io.cdap.cdap.common.service.Retries;\n-import io.cdap.cdap.common.service.RetryStrategies;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n-import io.cdap.cdap.internal.app.runtime.BasicArguments;\n-import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n-import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n-import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n-import io.cdap.cdap.internal.entity.EntityResult;\n-import io.cdap.cdap.proto.NamespaceMeta;\n-import io.cdap.cdap.proto.ProgramRecord;\n-import io.cdap.cdap.proto.ProgramType;\n-import io.cdap.cdap.proto.id.ApplicationId;\n-import io.cdap.cdap.proto.id.NamespaceId;\n-import io.cdap.cdap.proto.id.ProgramId;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n-import io.cdap.cdap.spi.metadata.SearchRequest;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-\n-/**\n- * Class with helpful methods for managing capabilities\n- */\n-public class CapabilityManager extends AbstractIdleService {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n-  private static final Gson GSON = new Gson();\n-  private static final int RETRY_LIMIT = 5;\n-  private static final int RETRY_DELAY = 5;\n-  private static final String CAPABILITY = \"capability:%s\";\n-  private static final String APPLICATION = \"application\";\n-  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n-    // no-op\n-  };\n-  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n-  private final SystemProgramManagementService systemProgramManagementService;\n-  private final ApplicationLifecycleService applicationLifecycleService;\n-  private final ProgramLifecycleService programLifecycleService;\n-  private final NamespaceAdmin namespaceAdmin;\n-  private final MetadataSearchClient metadataSearchClient;\n-  private final CConfiguration cConf;\n-  private final Lock readLock;\n-  private final Lock writeLock;\n-\n-  @Inject\n-  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n-                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n-                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n-    this.capabilityStatusMap = new ConcurrentHashMap<>();\n-    this.systemProgramManagementService = systemProgramManagementService;\n-    this.applicationLifecycleService = applicationLifecycleService;\n-    this.programLifecycleService = programLifecycleService;\n-    this.metadataSearchClient = metadataSearchClient;\n-    this.namespaceAdmin = namespaceAdmin;\n-    this.cConf = cConf;\n-    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n-    readLock = rwLock.readLock();\n-    writeLock = rwLock.writeLock();\n-  }\n-\n-  @Override\n-  protected void startUp() {\n-    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n-    //refresh the status of all capabilities\n-    systemProgramManagementService.start();\n-    refreshCapabilities();\n-  }\n-\n-  @Override\n-  protected void shutDown() {\n-    systemProgramManagementService.stopAndWait();\n-    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n-  }\n-\n-  /**\n-   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n-   *\n-   * @param capability\n-   * @return {@link CapabilityStatus}\n-   */\n-  public CapabilityStatus getStatus(String capability) {\n-    if (!capabilityStatusMap.containsKey(capability)) {\n-      throw new IllegalArgumentException(\"Capability not found\");\n-    }\n-    return capabilityStatusMap.get(capability);\n-  }\n-\n-  /**\n-   * Returns boolean indicating whether the capability is present in the system\n-   *\n-   * @param capability\n-   * @return boolean indicating presence of capability\n-   */\n-  public boolean isCapabilityPresent(String capability) {\n-    return capabilityStatusMap.containsKey(capability);\n-  }\n-\n-  /**\n-   * Applies the given capability configurations\n-   *\n-   * @param\n-   */\n-  public void apply(List<CapabilityConfig> capabilityConfigs) {\n-    try {\n-      writeLock.lock();\n-      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n-        String capability = capabilityConfig.getCapability();\n-        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n-        try (FileWriter writer = new FileWriter(file)) {\n-          GSON.toJson(capabilityConfig, writer);\n-        } catch (IOException ex) {\n-          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n-        }\n-      }\n-    } finally {\n-      writeLock.unlock();\n-    }\n-    refreshCapabilities();\n-  }\n-\n-  /**\n-   * Apply capabilities based on the configuration files on disk\n-   */\n-  private void refreshCapabilities() {\n-    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n-    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n-    try {\n-      readLock.lock();\n-      for (File configFile : DirUtils.listFiles(dataDir)) {\n-        try (Reader reader = new FileReader(configFile)) {\n-          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n-        } catch (IOException ex) {\n-          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n-        }\n-      }\n-    } finally {\n-      readLock.unlock();\n-    }\n-    refreshCapabilities(allCapabilityConfigs);\n-  }\n-\n-  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n-    //collect all programs to be enabled\n-    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n-    Set<String> enabledCapabilities = new HashSet<>();\n-    for (CapabilityConfig config : capabilityConfigs) {\n-      String capability = config.getCapability();\n-      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n-      switch (config.getType()) {\n-        case ENABLE:\n-          deployAllApps(capability, config.getApplications());\n-          config.getPrograms().forEach(systemProgram -> enabledPrograms\n-            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n-          enabledCapabilities.add(capability);\n-          break;\n-        case DISABLE:\n-          disableCapability(capability);\n-          break;\n-        case DELETE:\n-          deleteCapability(config);\n-          break;\n-        default:\n-          LOG.error(\"Unknown capability action {} \", config.getType());\n-          break;\n-      }\n-    }\n-    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n-    enabledCapabilities.forEach(this::enableCapability);\n-  }\n-\n-  /**\n-   * Returns the list of applications that are having metadata tagged with the capability\n-   *\n-   * @param namespace  Namespace for which applications should be listed\n-   * @param capability Capability by which to filter\n-   * @param cursor     Optional cursor from a previous response\n-   * @param offset     Offset from where to start\n-   * @param limit      Limit of records to fetch\n-   * @return\n-   * @throws IOException - Exception from meta data search if any\n-   */\n-  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n-                                                     int offset, int limit) throws IOException {\n-    String capabilityTag = String.format(CAPABILITY, capability);\n-    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n-      .addNamespace(namespace.getNamespace())\n-      .addType(APPLICATION)\n-      .setScope(MetadataScope.SYSTEM)\n-      .setCursor(cursor)\n-      .setOffset(offset)\n-      .setLimit(limit)\n-      .build();\n-    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n-    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n-      .map(MetadataSearchResultRecord::getMetadataEntity)\n-      .map(this::getApplicationId)\n-      .collect(Collectors.toSet());\n-    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n-                              searchResponse.getOffset(), searchResponse.getLimit(),\n-                              searchResponse.getTotal());\n-  }\n-\n-  private ProgramId getProgramId(SystemProgram program) {\n-    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n-                                                    program.getVersion());\n-    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n-  }\n-\n-  @Nullable\n-  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n-    List<String> cursors = searchResponse.getCursors();\n-    if (cursors == null || cursors.isEmpty()) {\n-      return null;\n-    }\n-    return cursors.get(0);\n-  }\n-\n-  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n-    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n-                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n-                             metadataEntity.getValue(MetadataEntity.VERSION));\n-  }\n-\n-  private void enableCapability(String capability) {\n-    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n-    LOG.debug(\"Capability {} enabled.\", capability);\n-  }\n-\n-  private void disableCapability(String capability) {\n-    //mark as disabled to prevent further runs\n-    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n-    //stop pipelines\n-    try {\n-      stopPipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //programs(services) will be stopped by SystemProgramManagementService\n-    LOG.debug(\"Capability {} disabled.\", capability);\n-  }\n-\n-  private void deleteCapability(CapabilityConfig capabilityConfig) {\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n-      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n-      return;\n-    }\n-    //delete pipelines\n-    try {\n-      deletePipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //delete applications\n-    for (SystemApplication application : capabilityConfig.getApplications()) {\n-      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n-                                                      application.getVersion());\n-      try {\n-        applicationLifecycleService.removeApplication(applicationId);\n-      } catch (Exception exception) {\n-        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n-      }\n-    }\n-    capabilityStatusMap.remove(capability);\n-    LOG.debug(\"Capability {} deleted.\", capability);\n-  }\n-\n-  private void deletePipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::deleteAppWithRetry);\n-  }\n-\n-  private void stopPipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::stopPrograms);\n-  }\n-\n-  private void deployAllApps(String capability, List<SystemApplication> applications) {\n-    if (applications.isEmpty()) {\n-      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n-      return;\n-    }\n-    for (SystemApplication application : applications) {\n-      doWithRetry(application, this::deployApp);\n-    }\n-  }\n-\n-  private void deployApp(SystemApplication application) {\n-    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n-    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n-    LOG.debug(\"Deploying app {}\", applicationId);\n-    try {\n-      if (isAppDeployed(applicationId)) {\n-        //Already deployed.\n-        LOG.debug(\"Application {} is already deployed\", applicationId);\n-        return;\n-      }\n-      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n-      applicationLifecycleService\n-        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n-                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n-    try {\n-      applicationLifecycleService.getAppDetail(applicationId);\n-      return true;\n-    } catch (ApplicationNotFoundException exception) {\n-      return false;\n-    }\n-  }\n-\n-  //Find all applications for capability and call consumer for each\n-  private void doForAllApps(String capability, Consumer<ApplicationId> consumer) throws Exception {\n-    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n-      int offset = 0;\n-      int limit = 100;\n-      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n-      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n-                                                            offset, limit);\n-      while (results.getEntities().size() > 0) {\n-        //call consumer for each entity\n-        results.getEntities().forEach(consumer);\n-        if (results.getEntities().size() < limit) {\n-          break;\n-        }\n-        offset += limit;\n-        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n-      }\n-    }\n-  }\n-\n-  private void stopPrograms(ApplicationId applicationId) {\n-    try {\n-      List<ProgramRecord> programs = applicationLifecycleService.getAppDetail(applicationId).getPrograms();\n-      for (ProgramRecord programRecord : programs) {\n-        ProgramId programId = new ProgramId(applicationId, programRecord.getType(), programRecord.getName());\n-        doWithRetry(programId, this::stopProgram);\n-      }\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping programs for application {} failed with {}\", applicationId, ex);\n-    }\n-  }\n-\n-  private void stopProgram(ProgramId programId) {\n-    try {\n-      programLifecycleService.stop(programId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private void deleteAppWithRetry(ApplicationId applicationId) {\n-    doWithRetry(applicationId, this::deleteApp);\n-  }\n-\n-  private void deleteApp(ApplicationId applicationId) {\n-    try {\n-      applicationLifecycleService.removeApplication(applicationId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private <T> void doWithRetry(T argument, Consumer<T> consumer) {\n-    Retries.callWithRetries(() -> {\n-      consumer.accept(argument);\n-      return null;\n-    }, RetryStrategies.limit(RETRY_LIMIT, RetryStrategies.fixDelay(RETRY_DELAY, TimeUnit.SECONDS)));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzA4OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r540847088", "bodyText": "This check seems unnecessary. Why not just let the getApplications get called again and have it return empty set if there is no more apps?", "author": "chtyim", "createdAt": "2020-12-11T10:29:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+    refreshCapabilities();\n+  }\n+\n+  /**\n+   * Apply capabilities based on the configuration files on disk\n+   */\n+  private void refreshCapabilities() {\n+    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n+    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n+    try {\n+      readLock.lock();\n+      for (File configFile : DirUtils.listFiles(dataDir)) {\n+        try (Reader reader = new FileReader(configFile)) {\n+          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n+        } catch (IOException ex) {\n+          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n+        }\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+    refreshCapabilities(allCapabilityConfigs);\n+  }\n+\n+  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n+    //collect all programs to be enabled\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    Set<String> enabledCapabilities = new HashSet<>();\n+    for (CapabilityConfig config : capabilityConfigs) {\n+      String capability = config.getCapability();\n+      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n+      switch (config.getType()) {\n+        case ENABLE:\n+          deployAllApps(capability, config.getApplications());\n+          config.getPrograms().forEach(systemProgram -> enabledPrograms\n+            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+          enabledCapabilities.add(capability);\n+          break;\n+        case DISABLE:\n+          disableCapability(capability);\n+          break;\n+        case DELETE:\n+          deleteCapability(config);\n+          break;\n+        default:\n+          LOG.error(\"Unknown capability action {} \", config.getType());\n+          break;\n+      }\n+    }\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    enabledCapabilities.forEach(this::enableCapability);\n+  }\n+\n+  /**\n+   * Returns the list of applications that are having metadata tagged with the capability\n+   *\n+   * @param namespace  Namespace for which applications should be listed\n+   * @param capability Capability by which to filter\n+   * @param cursor     Optional cursor from a previous response\n+   * @param offset     Offset from where to start\n+   * @param limit      Limit of records to fetch\n+   * @return\n+   * @throws IOException - Exception from meta data search if any\n+   */\n+  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n+                                                     int offset, int limit) throws IOException {\n+    String capabilityTag = String.format(CAPABILITY, capability);\n+    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n+      .addNamespace(namespace.getNamespace())\n+      .addType(APPLICATION)\n+      .setScope(MetadataScope.SYSTEM)\n+      .setCursor(cursor)\n+      .setOffset(offset)\n+      .setLimit(limit)\n+      .build();\n+    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n+    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n+      .map(MetadataSearchResultRecord::getMetadataEntity)\n+      .map(this::getApplicationId)\n+      .collect(Collectors.toSet());\n+    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n+                              searchResponse.getOffset(), searchResponse.getLimit(),\n+                              searchResponse.getTotal());\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n+  }\n+\n+  @Nullable\n+  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n+    List<String> cursors = searchResponse.getCursors();\n+    if (cursors == null || cursors.isEmpty()) {\n+      return null;\n+    }\n+    return cursors.get(0);\n+  }\n+\n+  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n+    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n+                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n+                             metadataEntity.getValue(MetadataEntity.VERSION));\n+  }\n+\n+  private void enableCapability(String capability) {\n+    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n+    LOG.debug(\"Capability {} enabled.\", capability);\n+  }\n+\n+  private void disableCapability(String capability) {\n+    //mark as disabled to prevent further runs\n+    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n+    //stop pipelines\n+    try {\n+      stopPipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //programs(services) will be stopped by SystemProgramManagementService\n+    LOG.debug(\"Capability {} disabled.\", capability);\n+  }\n+\n+  private void deleteCapability(CapabilityConfig capabilityConfig) {\n+    String capability = capabilityConfig.getCapability();\n+    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n+      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n+      return;\n+    }\n+    //delete pipelines\n+    try {\n+      deletePipelines(capability);\n+    } catch (Exception ex) {\n+      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n+    }\n+    //delete applications\n+    for (SystemApplication application : capabilityConfig.getApplications()) {\n+      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n+                                                      application.getVersion());\n+      try {\n+        applicationLifecycleService.removeApplication(applicationId);\n+      } catch (Exception exception) {\n+        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n+      }\n+    }\n+    capabilityStatusMap.remove(capability);\n+    LOG.debug(\"Capability {} deleted.\", capability);\n+  }\n+\n+  private void deletePipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopPipelines(String capability) throws Exception {\n+    doForAllApps(capability, this::stopPrograms);\n+  }\n+\n+  private void deployAllApps(String capability, List<SystemApplication> applications) {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::deployApp);\n+    }\n+  }\n+\n+  private void deployApp(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    try {\n+      if (isAppDeployed(applicationId)) {\n+        //Already deployed.\n+        LOG.debug(\"Application {} is already deployed\", applicationId);\n+        return;\n+      }\n+      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+      applicationLifecycleService\n+        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+    } catch (Exception ex) {\n+      throw new RetryableException(ex);\n+    }\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllApps(String capability, Consumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (results.getEntities().size() > 0) {\n+        //call consumer for each entity\n+        results.getEntities().forEach(consumer);\n+        if (results.getEntities().size() < limit) {", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTc4Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481786", "bodyText": "Removed", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzA4OA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\ndeleted file mode 100644\nindex fc0ef841a07..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\n+++ /dev/null\n\n@@ -1,422 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractIdleService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.api.metadata.MetadataEntity;\n-import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n-import io.cdap.cdap.app.runtime.Arguments;\n-import io.cdap.cdap.common.ApplicationNotFoundException;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.namespace.NamespaceAdmin;\n-import io.cdap.cdap.common.service.Retries;\n-import io.cdap.cdap.common.service.RetryStrategies;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n-import io.cdap.cdap.internal.app.runtime.BasicArguments;\n-import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n-import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n-import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n-import io.cdap.cdap.internal.entity.EntityResult;\n-import io.cdap.cdap.proto.NamespaceMeta;\n-import io.cdap.cdap.proto.ProgramRecord;\n-import io.cdap.cdap.proto.ProgramType;\n-import io.cdap.cdap.proto.id.ApplicationId;\n-import io.cdap.cdap.proto.id.NamespaceId;\n-import io.cdap.cdap.proto.id.ProgramId;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n-import io.cdap.cdap.spi.metadata.SearchRequest;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-\n-/**\n- * Class with helpful methods for managing capabilities\n- */\n-public class CapabilityManager extends AbstractIdleService {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n-  private static final Gson GSON = new Gson();\n-  private static final int RETRY_LIMIT = 5;\n-  private static final int RETRY_DELAY = 5;\n-  private static final String CAPABILITY = \"capability:%s\";\n-  private static final String APPLICATION = \"application\";\n-  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n-    // no-op\n-  };\n-  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n-  private final SystemProgramManagementService systemProgramManagementService;\n-  private final ApplicationLifecycleService applicationLifecycleService;\n-  private final ProgramLifecycleService programLifecycleService;\n-  private final NamespaceAdmin namespaceAdmin;\n-  private final MetadataSearchClient metadataSearchClient;\n-  private final CConfiguration cConf;\n-  private final Lock readLock;\n-  private final Lock writeLock;\n-\n-  @Inject\n-  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n-                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n-                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n-    this.capabilityStatusMap = new ConcurrentHashMap<>();\n-    this.systemProgramManagementService = systemProgramManagementService;\n-    this.applicationLifecycleService = applicationLifecycleService;\n-    this.programLifecycleService = programLifecycleService;\n-    this.metadataSearchClient = metadataSearchClient;\n-    this.namespaceAdmin = namespaceAdmin;\n-    this.cConf = cConf;\n-    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n-    readLock = rwLock.readLock();\n-    writeLock = rwLock.writeLock();\n-  }\n-\n-  @Override\n-  protected void startUp() {\n-    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n-    //refresh the status of all capabilities\n-    systemProgramManagementService.start();\n-    refreshCapabilities();\n-  }\n-\n-  @Override\n-  protected void shutDown() {\n-    systemProgramManagementService.stopAndWait();\n-    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n-  }\n-\n-  /**\n-   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n-   *\n-   * @param capability\n-   * @return {@link CapabilityStatus}\n-   */\n-  public CapabilityStatus getStatus(String capability) {\n-    if (!capabilityStatusMap.containsKey(capability)) {\n-      throw new IllegalArgumentException(\"Capability not found\");\n-    }\n-    return capabilityStatusMap.get(capability);\n-  }\n-\n-  /**\n-   * Returns boolean indicating whether the capability is present in the system\n-   *\n-   * @param capability\n-   * @return boolean indicating presence of capability\n-   */\n-  public boolean isCapabilityPresent(String capability) {\n-    return capabilityStatusMap.containsKey(capability);\n-  }\n-\n-  /**\n-   * Applies the given capability configurations\n-   *\n-   * @param\n-   */\n-  public void apply(List<CapabilityConfig> capabilityConfigs) {\n-    try {\n-      writeLock.lock();\n-      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n-        String capability = capabilityConfig.getCapability();\n-        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n-        try (FileWriter writer = new FileWriter(file)) {\n-          GSON.toJson(capabilityConfig, writer);\n-        } catch (IOException ex) {\n-          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n-        }\n-      }\n-    } finally {\n-      writeLock.unlock();\n-    }\n-    refreshCapabilities();\n-  }\n-\n-  /**\n-   * Apply capabilities based on the configuration files on disk\n-   */\n-  private void refreshCapabilities() {\n-    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n-    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n-    try {\n-      readLock.lock();\n-      for (File configFile : DirUtils.listFiles(dataDir)) {\n-        try (Reader reader = new FileReader(configFile)) {\n-          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n-        } catch (IOException ex) {\n-          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n-        }\n-      }\n-    } finally {\n-      readLock.unlock();\n-    }\n-    refreshCapabilities(allCapabilityConfigs);\n-  }\n-\n-  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n-    //collect all programs to be enabled\n-    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n-    Set<String> enabledCapabilities = new HashSet<>();\n-    for (CapabilityConfig config : capabilityConfigs) {\n-      String capability = config.getCapability();\n-      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n-      switch (config.getType()) {\n-        case ENABLE:\n-          deployAllApps(capability, config.getApplications());\n-          config.getPrograms().forEach(systemProgram -> enabledPrograms\n-            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n-          enabledCapabilities.add(capability);\n-          break;\n-        case DISABLE:\n-          disableCapability(capability);\n-          break;\n-        case DELETE:\n-          deleteCapability(config);\n-          break;\n-        default:\n-          LOG.error(\"Unknown capability action {} \", config.getType());\n-          break;\n-      }\n-    }\n-    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n-    enabledCapabilities.forEach(this::enableCapability);\n-  }\n-\n-  /**\n-   * Returns the list of applications that are having metadata tagged with the capability\n-   *\n-   * @param namespace  Namespace for which applications should be listed\n-   * @param capability Capability by which to filter\n-   * @param cursor     Optional cursor from a previous response\n-   * @param offset     Offset from where to start\n-   * @param limit      Limit of records to fetch\n-   * @return\n-   * @throws IOException - Exception from meta data search if any\n-   */\n-  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n-                                                     int offset, int limit) throws IOException {\n-    String capabilityTag = String.format(CAPABILITY, capability);\n-    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n-      .addNamespace(namespace.getNamespace())\n-      .addType(APPLICATION)\n-      .setScope(MetadataScope.SYSTEM)\n-      .setCursor(cursor)\n-      .setOffset(offset)\n-      .setLimit(limit)\n-      .build();\n-    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n-    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n-      .map(MetadataSearchResultRecord::getMetadataEntity)\n-      .map(this::getApplicationId)\n-      .collect(Collectors.toSet());\n-    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n-                              searchResponse.getOffset(), searchResponse.getLimit(),\n-                              searchResponse.getTotal());\n-  }\n-\n-  private ProgramId getProgramId(SystemProgram program) {\n-    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n-                                                    program.getVersion());\n-    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n-  }\n-\n-  @Nullable\n-  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n-    List<String> cursors = searchResponse.getCursors();\n-    if (cursors == null || cursors.isEmpty()) {\n-      return null;\n-    }\n-    return cursors.get(0);\n-  }\n-\n-  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n-    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n-                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n-                             metadataEntity.getValue(MetadataEntity.VERSION));\n-  }\n-\n-  private void enableCapability(String capability) {\n-    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n-    LOG.debug(\"Capability {} enabled.\", capability);\n-  }\n-\n-  private void disableCapability(String capability) {\n-    //mark as disabled to prevent further runs\n-    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n-    //stop pipelines\n-    try {\n-      stopPipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //programs(services) will be stopped by SystemProgramManagementService\n-    LOG.debug(\"Capability {} disabled.\", capability);\n-  }\n-\n-  private void deleteCapability(CapabilityConfig capabilityConfig) {\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n-      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n-      return;\n-    }\n-    //delete pipelines\n-    try {\n-      deletePipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //delete applications\n-    for (SystemApplication application : capabilityConfig.getApplications()) {\n-      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n-                                                      application.getVersion());\n-      try {\n-        applicationLifecycleService.removeApplication(applicationId);\n-      } catch (Exception exception) {\n-        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n-      }\n-    }\n-    capabilityStatusMap.remove(capability);\n-    LOG.debug(\"Capability {} deleted.\", capability);\n-  }\n-\n-  private void deletePipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::deleteAppWithRetry);\n-  }\n-\n-  private void stopPipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::stopPrograms);\n-  }\n-\n-  private void deployAllApps(String capability, List<SystemApplication> applications) {\n-    if (applications.isEmpty()) {\n-      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n-      return;\n-    }\n-    for (SystemApplication application : applications) {\n-      doWithRetry(application, this::deployApp);\n-    }\n-  }\n-\n-  private void deployApp(SystemApplication application) {\n-    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n-    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n-    LOG.debug(\"Deploying app {}\", applicationId);\n-    try {\n-      if (isAppDeployed(applicationId)) {\n-        //Already deployed.\n-        LOG.debug(\"Application {} is already deployed\", applicationId);\n-        return;\n-      }\n-      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n-      applicationLifecycleService\n-        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n-                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n-    try {\n-      applicationLifecycleService.getAppDetail(applicationId);\n-      return true;\n-    } catch (ApplicationNotFoundException exception) {\n-      return false;\n-    }\n-  }\n-\n-  //Find all applications for capability and call consumer for each\n-  private void doForAllApps(String capability, Consumer<ApplicationId> consumer) throws Exception {\n-    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n-      int offset = 0;\n-      int limit = 100;\n-      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n-      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n-                                                            offset, limit);\n-      while (results.getEntities().size() > 0) {\n-        //call consumer for each entity\n-        results.getEntities().forEach(consumer);\n-        if (results.getEntities().size() < limit) {\n-          break;\n-        }\n-        offset += limit;\n-        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n-      }\n-    }\n-  }\n-\n-  private void stopPrograms(ApplicationId applicationId) {\n-    try {\n-      List<ProgramRecord> programs = applicationLifecycleService.getAppDetail(applicationId).getPrograms();\n-      for (ProgramRecord programRecord : programs) {\n-        ProgramId programId = new ProgramId(applicationId, programRecord.getType(), programRecord.getName());\n-        doWithRetry(programId, this::stopProgram);\n-      }\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping programs for application {} failed with {}\", applicationId, ex);\n-    }\n-  }\n-\n-  private void stopProgram(ProgramId programId) {\n-    try {\n-      programLifecycleService.stop(programId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private void deleteAppWithRetry(ApplicationId applicationId) {\n-    doWithRetry(applicationId, this::deleteApp);\n-  }\n-\n-  private void deleteApp(ApplicationId applicationId) {\n-    try {\n-      applicationLifecycleService.removeApplication(applicationId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private <T> void doWithRetry(T argument, Consumer<T> consumer) {\n-    Retries.callWithRetries(() -> {\n-      consumer.accept(argument);\n-      return null;\n-    }, RetryStrategies.limit(RETRY_LIMIT, RetryStrategies.fixDelay(RETRY_DELAY, TimeUnit.SECONDS)));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTA4OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541109089", "bodyText": "Seems like this class doesn't need to be a service. I am imagining there is a higher level service for watching/scanning for file changes, in which we can have it to manage the lifecycle of the systemProgramManagementService.", "author": "chtyim", "createdAt": "2020-12-11T17:29:10Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTkwNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481906", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTA4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\ndeleted file mode 100644\nindex fc0ef841a07..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\n+++ /dev/null\n\n@@ -1,422 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractIdleService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.api.metadata.MetadataEntity;\n-import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n-import io.cdap.cdap.app.runtime.Arguments;\n-import io.cdap.cdap.common.ApplicationNotFoundException;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.namespace.NamespaceAdmin;\n-import io.cdap.cdap.common.service.Retries;\n-import io.cdap.cdap.common.service.RetryStrategies;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n-import io.cdap.cdap.internal.app.runtime.BasicArguments;\n-import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n-import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n-import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n-import io.cdap.cdap.internal.entity.EntityResult;\n-import io.cdap.cdap.proto.NamespaceMeta;\n-import io.cdap.cdap.proto.ProgramRecord;\n-import io.cdap.cdap.proto.ProgramType;\n-import io.cdap.cdap.proto.id.ApplicationId;\n-import io.cdap.cdap.proto.id.NamespaceId;\n-import io.cdap.cdap.proto.id.ProgramId;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n-import io.cdap.cdap.spi.metadata.SearchRequest;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-\n-/**\n- * Class with helpful methods for managing capabilities\n- */\n-public class CapabilityManager extends AbstractIdleService {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n-  private static final Gson GSON = new Gson();\n-  private static final int RETRY_LIMIT = 5;\n-  private static final int RETRY_DELAY = 5;\n-  private static final String CAPABILITY = \"capability:%s\";\n-  private static final String APPLICATION = \"application\";\n-  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n-    // no-op\n-  };\n-  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n-  private final SystemProgramManagementService systemProgramManagementService;\n-  private final ApplicationLifecycleService applicationLifecycleService;\n-  private final ProgramLifecycleService programLifecycleService;\n-  private final NamespaceAdmin namespaceAdmin;\n-  private final MetadataSearchClient metadataSearchClient;\n-  private final CConfiguration cConf;\n-  private final Lock readLock;\n-  private final Lock writeLock;\n-\n-  @Inject\n-  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n-                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n-                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n-    this.capabilityStatusMap = new ConcurrentHashMap<>();\n-    this.systemProgramManagementService = systemProgramManagementService;\n-    this.applicationLifecycleService = applicationLifecycleService;\n-    this.programLifecycleService = programLifecycleService;\n-    this.metadataSearchClient = metadataSearchClient;\n-    this.namespaceAdmin = namespaceAdmin;\n-    this.cConf = cConf;\n-    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n-    readLock = rwLock.readLock();\n-    writeLock = rwLock.writeLock();\n-  }\n-\n-  @Override\n-  protected void startUp() {\n-    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n-    //refresh the status of all capabilities\n-    systemProgramManagementService.start();\n-    refreshCapabilities();\n-  }\n-\n-  @Override\n-  protected void shutDown() {\n-    systemProgramManagementService.stopAndWait();\n-    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n-  }\n-\n-  /**\n-   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n-   *\n-   * @param capability\n-   * @return {@link CapabilityStatus}\n-   */\n-  public CapabilityStatus getStatus(String capability) {\n-    if (!capabilityStatusMap.containsKey(capability)) {\n-      throw new IllegalArgumentException(\"Capability not found\");\n-    }\n-    return capabilityStatusMap.get(capability);\n-  }\n-\n-  /**\n-   * Returns boolean indicating whether the capability is present in the system\n-   *\n-   * @param capability\n-   * @return boolean indicating presence of capability\n-   */\n-  public boolean isCapabilityPresent(String capability) {\n-    return capabilityStatusMap.containsKey(capability);\n-  }\n-\n-  /**\n-   * Applies the given capability configurations\n-   *\n-   * @param\n-   */\n-  public void apply(List<CapabilityConfig> capabilityConfigs) {\n-    try {\n-      writeLock.lock();\n-      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n-        String capability = capabilityConfig.getCapability();\n-        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n-        try (FileWriter writer = new FileWriter(file)) {\n-          GSON.toJson(capabilityConfig, writer);\n-        } catch (IOException ex) {\n-          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n-        }\n-      }\n-    } finally {\n-      writeLock.unlock();\n-    }\n-    refreshCapabilities();\n-  }\n-\n-  /**\n-   * Apply capabilities based on the configuration files on disk\n-   */\n-  private void refreshCapabilities() {\n-    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n-    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n-    try {\n-      readLock.lock();\n-      for (File configFile : DirUtils.listFiles(dataDir)) {\n-        try (Reader reader = new FileReader(configFile)) {\n-          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n-        } catch (IOException ex) {\n-          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n-        }\n-      }\n-    } finally {\n-      readLock.unlock();\n-    }\n-    refreshCapabilities(allCapabilityConfigs);\n-  }\n-\n-  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n-    //collect all programs to be enabled\n-    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n-    Set<String> enabledCapabilities = new HashSet<>();\n-    for (CapabilityConfig config : capabilityConfigs) {\n-      String capability = config.getCapability();\n-      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n-      switch (config.getType()) {\n-        case ENABLE:\n-          deployAllApps(capability, config.getApplications());\n-          config.getPrograms().forEach(systemProgram -> enabledPrograms\n-            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n-          enabledCapabilities.add(capability);\n-          break;\n-        case DISABLE:\n-          disableCapability(capability);\n-          break;\n-        case DELETE:\n-          deleteCapability(config);\n-          break;\n-        default:\n-          LOG.error(\"Unknown capability action {} \", config.getType());\n-          break;\n-      }\n-    }\n-    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n-    enabledCapabilities.forEach(this::enableCapability);\n-  }\n-\n-  /**\n-   * Returns the list of applications that are having metadata tagged with the capability\n-   *\n-   * @param namespace  Namespace for which applications should be listed\n-   * @param capability Capability by which to filter\n-   * @param cursor     Optional cursor from a previous response\n-   * @param offset     Offset from where to start\n-   * @param limit      Limit of records to fetch\n-   * @return\n-   * @throws IOException - Exception from meta data search if any\n-   */\n-  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n-                                                     int offset, int limit) throws IOException {\n-    String capabilityTag = String.format(CAPABILITY, capability);\n-    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n-      .addNamespace(namespace.getNamespace())\n-      .addType(APPLICATION)\n-      .setScope(MetadataScope.SYSTEM)\n-      .setCursor(cursor)\n-      .setOffset(offset)\n-      .setLimit(limit)\n-      .build();\n-    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n-    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n-      .map(MetadataSearchResultRecord::getMetadataEntity)\n-      .map(this::getApplicationId)\n-      .collect(Collectors.toSet());\n-    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n-                              searchResponse.getOffset(), searchResponse.getLimit(),\n-                              searchResponse.getTotal());\n-  }\n-\n-  private ProgramId getProgramId(SystemProgram program) {\n-    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n-                                                    program.getVersion());\n-    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n-  }\n-\n-  @Nullable\n-  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n-    List<String> cursors = searchResponse.getCursors();\n-    if (cursors == null || cursors.isEmpty()) {\n-      return null;\n-    }\n-    return cursors.get(0);\n-  }\n-\n-  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n-    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n-                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n-                             metadataEntity.getValue(MetadataEntity.VERSION));\n-  }\n-\n-  private void enableCapability(String capability) {\n-    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n-    LOG.debug(\"Capability {} enabled.\", capability);\n-  }\n-\n-  private void disableCapability(String capability) {\n-    //mark as disabled to prevent further runs\n-    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n-    //stop pipelines\n-    try {\n-      stopPipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //programs(services) will be stopped by SystemProgramManagementService\n-    LOG.debug(\"Capability {} disabled.\", capability);\n-  }\n-\n-  private void deleteCapability(CapabilityConfig capabilityConfig) {\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n-      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n-      return;\n-    }\n-    //delete pipelines\n-    try {\n-      deletePipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //delete applications\n-    for (SystemApplication application : capabilityConfig.getApplications()) {\n-      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n-                                                      application.getVersion());\n-      try {\n-        applicationLifecycleService.removeApplication(applicationId);\n-      } catch (Exception exception) {\n-        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n-      }\n-    }\n-    capabilityStatusMap.remove(capability);\n-    LOG.debug(\"Capability {} deleted.\", capability);\n-  }\n-\n-  private void deletePipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::deleteAppWithRetry);\n-  }\n-\n-  private void stopPipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::stopPrograms);\n-  }\n-\n-  private void deployAllApps(String capability, List<SystemApplication> applications) {\n-    if (applications.isEmpty()) {\n-      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n-      return;\n-    }\n-    for (SystemApplication application : applications) {\n-      doWithRetry(application, this::deployApp);\n-    }\n-  }\n-\n-  private void deployApp(SystemApplication application) {\n-    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n-    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n-    LOG.debug(\"Deploying app {}\", applicationId);\n-    try {\n-      if (isAppDeployed(applicationId)) {\n-        //Already deployed.\n-        LOG.debug(\"Application {} is already deployed\", applicationId);\n-        return;\n-      }\n-      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n-      applicationLifecycleService\n-        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n-                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n-    try {\n-      applicationLifecycleService.getAppDetail(applicationId);\n-      return true;\n-    } catch (ApplicationNotFoundException exception) {\n-      return false;\n-    }\n-  }\n-\n-  //Find all applications for capability and call consumer for each\n-  private void doForAllApps(String capability, Consumer<ApplicationId> consumer) throws Exception {\n-    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n-      int offset = 0;\n-      int limit = 100;\n-      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n-      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n-                                                            offset, limit);\n-      while (results.getEntities().size() > 0) {\n-        //call consumer for each entity\n-        results.getEntities().forEach(consumer);\n-        if (results.getEntities().size() < limit) {\n-          break;\n-        }\n-        offset += limit;\n-        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n-      }\n-    }\n-  }\n-\n-  private void stopPrograms(ApplicationId applicationId) {\n-    try {\n-      List<ProgramRecord> programs = applicationLifecycleService.getAppDetail(applicationId).getPrograms();\n-      for (ProgramRecord programRecord : programs) {\n-        ProgramId programId = new ProgramId(applicationId, programRecord.getType(), programRecord.getName());\n-        doWithRetry(programId, this::stopProgram);\n-      }\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping programs for application {} failed with {}\", applicationId, ex);\n-    }\n-  }\n-\n-  private void stopProgram(ProgramId programId) {\n-    try {\n-      programLifecycleService.stop(programId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private void deleteAppWithRetry(ApplicationId applicationId) {\n-    doWithRetry(applicationId, this::deleteApp);\n-  }\n-\n-  private void deleteApp(ApplicationId applicationId) {\n-    try {\n-      applicationLifecycleService.removeApplication(applicationId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private <T> void doWithRetry(T argument, Consumer<T> consumer) {\n-    Retries.callWithRetries(() -> {\n-      consumer.accept(argument);\n-      return null;\n-    }, RetryStrategies.limit(RETRY_LIMIT, RetryStrategies.fixDelay(RETRY_DELAY, TimeUnit.SECONDS)));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExOTA0OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541119049", "bodyText": "I think the exception should be surfaced to the caller, right? Otherwise it's possible changes was detected but never be applied and no one is retrying it.", "author": "chtyim", "createdAt": "2020-12-11T17:45:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.util.concurrent.AbstractIdleService;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramRecord;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class with helpful methods for managing capabilities\n+ */\n+public class CapabilityManager extends AbstractIdleService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final MetadataSearchClient metadataSearchClient;\n+  private final CConfiguration cConf;\n+  private final Lock readLock;\n+  private final Lock writeLock;\n+\n+  @Inject\n+  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n+                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n+    this.capabilityStatusMap = new ConcurrentHashMap<>();\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.metadataSearchClient = metadataSearchClient;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.cConf = cConf;\n+    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    readLock = rwLock.readLock();\n+    writeLock = rwLock.writeLock();\n+  }\n+\n+  @Override\n+  protected void startUp() {\n+    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n+    //refresh the status of all capabilities\n+    systemProgramManagementService.start();\n+    refreshCapabilities();\n+  }\n+\n+  @Override\n+  protected void shutDown() {\n+    systemProgramManagementService.stopAndWait();\n+    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) {\n+    if (!capabilityStatusMap.containsKey(capability)) {\n+      throw new IllegalArgumentException(\"Capability not found\");\n+    }\n+    return capabilityStatusMap.get(capability);\n+  }\n+\n+  /**\n+   * Returns boolean indicating whether the capability is present in the system\n+   *\n+   * @param capability\n+   * @return boolean indicating presence of capability\n+   */\n+  public boolean isCapabilityPresent(String capability) {\n+    return capabilityStatusMap.containsKey(capability);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) {\n+    try {\n+      writeLock.lock();\n+      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n+        String capability = capabilityConfig.getCapability();\n+        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n+        try (FileWriter writer = new FileWriter(file)) {\n+          GSON.toJson(capabilityConfig, writer);\n+        } catch (IOException ex) {\n+          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);", "originalCommit": "b898e34e34b9bee3dee35ee27f012640d25b4be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ4MTk0OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r541481948", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-12T02:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExOTA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\ndeleted file mode 100644\nindex fc0ef841a07..00000000000\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManager.java\n+++ /dev/null\n\n@@ -1,422 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Cask Data, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package io.cdap.cdap.internal.capability;\n-\n-import com.google.common.util.concurrent.AbstractIdleService;\n-import com.google.gson.Gson;\n-import com.google.inject.Inject;\n-import io.cdap.cdap.api.metadata.MetadataEntity;\n-import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n-import io.cdap.cdap.app.runtime.Arguments;\n-import io.cdap.cdap.common.ApplicationNotFoundException;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n-import io.cdap.cdap.common.namespace.NamespaceAdmin;\n-import io.cdap.cdap.common.service.Retries;\n-import io.cdap.cdap.common.service.RetryStrategies;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n-import io.cdap.cdap.internal.app.runtime.BasicArguments;\n-import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n-import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n-import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n-import io.cdap.cdap.internal.entity.EntityResult;\n-import io.cdap.cdap.proto.NamespaceMeta;\n-import io.cdap.cdap.proto.ProgramRecord;\n-import io.cdap.cdap.proto.ProgramType;\n-import io.cdap.cdap.proto.id.ApplicationId;\n-import io.cdap.cdap.proto.id.NamespaceId;\n-import io.cdap.cdap.proto.id.ProgramId;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n-import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n-import io.cdap.cdap.spi.metadata.SearchRequest;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import javax.annotation.Nullable;\n-\n-/**\n- * Class with helpful methods for managing capabilities\n- */\n-public class CapabilityManager extends AbstractIdleService {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManager.class);\n-  private static final Gson GSON = new Gson();\n-  private static final int RETRY_LIMIT = 5;\n-  private static final int RETRY_DELAY = 5;\n-  private static final String CAPABILITY = \"capability:%s\";\n-  private static final String APPLICATION = \"application\";\n-  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n-    // no-op\n-  };\n-  private final ConcurrentMap<String, CapabilityStatus> capabilityStatusMap;\n-  private final SystemProgramManagementService systemProgramManagementService;\n-  private final ApplicationLifecycleService applicationLifecycleService;\n-  private final ProgramLifecycleService programLifecycleService;\n-  private final NamespaceAdmin namespaceAdmin;\n-  private final MetadataSearchClient metadataSearchClient;\n-  private final CConfiguration cConf;\n-  private final Lock readLock;\n-  private final Lock writeLock;\n-\n-  @Inject\n-  CapabilityManager(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n-                    ApplicationLifecycleService applicationLifecycleService, MetadataSearchClient metadataSearchClient,\n-                    NamespaceAdmin namespaceAdmin, ProgramLifecycleService programLifecycleService) {\n-    this.capabilityStatusMap = new ConcurrentHashMap<>();\n-    this.systemProgramManagementService = systemProgramManagementService;\n-    this.applicationLifecycleService = applicationLifecycleService;\n-    this.programLifecycleService = programLifecycleService;\n-    this.metadataSearchClient = metadataSearchClient;\n-    this.namespaceAdmin = namespaceAdmin;\n-    this.cConf = cConf;\n-    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n-    readLock = rwLock.readLock();\n-    writeLock = rwLock.writeLock();\n-  }\n-\n-  @Override\n-  protected void startUp() {\n-    LOG.info(\"Starting {}\", this.getClass().getSimpleName());\n-    //refresh the status of all capabilities\n-    systemProgramManagementService.start();\n-    refreshCapabilities();\n-  }\n-\n-  @Override\n-  protected void shutDown() {\n-    systemProgramManagementService.stopAndWait();\n-    LOG.info(\"Stopping {}\", this.getClass().getSimpleName());\n-  }\n-\n-  /**\n-   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n-   *\n-   * @param capability\n-   * @return {@link CapabilityStatus}\n-   */\n-  public CapabilityStatus getStatus(String capability) {\n-    if (!capabilityStatusMap.containsKey(capability)) {\n-      throw new IllegalArgumentException(\"Capability not found\");\n-    }\n-    return capabilityStatusMap.get(capability);\n-  }\n-\n-  /**\n-   * Returns boolean indicating whether the capability is present in the system\n-   *\n-   * @param capability\n-   * @return boolean indicating presence of capability\n-   */\n-  public boolean isCapabilityPresent(String capability) {\n-    return capabilityStatusMap.containsKey(capability);\n-  }\n-\n-  /**\n-   * Applies the given capability configurations\n-   *\n-   * @param\n-   */\n-  public void apply(List<CapabilityConfig> capabilityConfigs) {\n-    try {\n-      writeLock.lock();\n-      for (CapabilityConfig capabilityConfig : capabilityConfigs) {\n-        String capability = capabilityConfig.getCapability();\n-        File file = new File(cConf.get(Constants.Capability.DATA_DIR), capability + \".json\");\n-        try (FileWriter writer = new FileWriter(file)) {\n-          GSON.toJson(capabilityConfig, writer);\n-        } catch (IOException ex) {\n-          LOG.error(\"Saving capability {} config to file {} failed with {} \", capability, file, ex);\n-        }\n-      }\n-    } finally {\n-      writeLock.unlock();\n-    }\n-    refreshCapabilities();\n-  }\n-\n-  /**\n-   * Apply capabilities based on the configuration files on disk\n-   */\n-  private void refreshCapabilities() {\n-    List<CapabilityConfig> allCapabilityConfigs = new ArrayList<>();\n-    File dataDir = new File(cConf.get(Constants.Capability.DATA_DIR));\n-    try {\n-      readLock.lock();\n-      for (File configFile : DirUtils.listFiles(dataDir)) {\n-        try (Reader reader = new FileReader(configFile)) {\n-          allCapabilityConfigs.add(GSON.fromJson(reader, CapabilityConfig.class));\n-        } catch (IOException ex) {\n-          LOG.error(\"Reading capability config file {} failed with {}\", configFile, ex);\n-        }\n-      }\n-    } finally {\n-      readLock.unlock();\n-    }\n-    refreshCapabilities(allCapabilityConfigs);\n-  }\n-\n-  private void refreshCapabilities(List<CapabilityConfig> capabilityConfigs) {\n-    //collect all programs to be enabled\n-    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n-    Set<String> enabledCapabilities = new HashSet<>();\n-    for (CapabilityConfig config : capabilityConfigs) {\n-      String capability = config.getCapability();\n-      LOG.debug(\"Applying {} action for capability {}\", config.getType(), capability);\n-      switch (config.getType()) {\n-        case ENABLE:\n-          deployAllApps(capability, config.getApplications());\n-          config.getPrograms().forEach(systemProgram -> enabledPrograms\n-            .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n-          enabledCapabilities.add(capability);\n-          break;\n-        case DISABLE:\n-          disableCapability(capability);\n-          break;\n-        case DELETE:\n-          deleteCapability(config);\n-          break;\n-        default:\n-          LOG.error(\"Unknown capability action {} \", config.getType());\n-          break;\n-      }\n-    }\n-    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n-    enabledCapabilities.forEach(this::enableCapability);\n-  }\n-\n-  /**\n-   * Returns the list of applications that are having metadata tagged with the capability\n-   *\n-   * @param namespace  Namespace for which applications should be listed\n-   * @param capability Capability by which to filter\n-   * @param cursor     Optional cursor from a previous response\n-   * @param offset     Offset from where to start\n-   * @param limit      Limit of records to fetch\n-   * @return\n-   * @throws IOException - Exception from meta data search if any\n-   */\n-  public EntityResult<ApplicationId> getApplications(NamespaceId namespace, String capability, @Nullable String cursor,\n-                                                     int offset, int limit) throws IOException {\n-    String capabilityTag = String.format(CAPABILITY, capability);\n-    SearchRequest searchRequest = SearchRequest.of(capabilityTag)\n-      .addNamespace(namespace.getNamespace())\n-      .addType(APPLICATION)\n-      .setScope(MetadataScope.SYSTEM)\n-      .setCursor(cursor)\n-      .setOffset(offset)\n-      .setLimit(limit)\n-      .build();\n-    MetadataSearchResponse searchResponse = metadataSearchClient.search(searchRequest);\n-    Set<ApplicationId> applicationIds = searchResponse.getResults().stream()\n-      .map(MetadataSearchResultRecord::getMetadataEntity)\n-      .map(this::getApplicationId)\n-      .collect(Collectors.toSet());\n-    return new EntityResult<>(applicationIds, getCursorResponse(searchResponse),\n-                              searchResponse.getOffset(), searchResponse.getLimit(),\n-                              searchResponse.getTotal());\n-  }\n-\n-  private ProgramId getProgramId(SystemProgram program) {\n-    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n-                                                    program.getVersion());\n-    return new ProgramId(applicationId, ProgramType.valueOf(program.getType()), program.getName());\n-  }\n-\n-  @Nullable\n-  private String getCursorResponse(MetadataSearchResponse searchResponse) {\n-    List<String> cursors = searchResponse.getCursors();\n-    if (cursors == null || cursors.isEmpty()) {\n-      return null;\n-    }\n-    return cursors.get(0);\n-  }\n-\n-  private ApplicationId getApplicationId(MetadataEntity metadataEntity) {\n-    return new ApplicationId(metadataEntity.getValue(MetadataEntity.NAMESPACE),\n-                             metadataEntity.getValue(MetadataEntity.APPLICATION),\n-                             metadataEntity.getValue(MetadataEntity.VERSION));\n-  }\n-\n-  private void enableCapability(String capability) {\n-    capabilityStatusMap.put(capability, CapabilityStatus.ENABLED);\n-    LOG.debug(\"Capability {} enabled.\", capability);\n-  }\n-\n-  private void disableCapability(String capability) {\n-    //mark as disabled to prevent further runs\n-    capabilityStatusMap.put(capability, CapabilityStatus.DISABLED);\n-    //stop pipelines\n-    try {\n-      stopPipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //programs(services) will be stopped by SystemProgramManagementService\n-    LOG.debug(\"Capability {} disabled.\", capability);\n-  }\n-\n-  private void deleteCapability(CapabilityConfig capabilityConfig) {\n-    String capability = capabilityConfig.getCapability();\n-    if (capabilityStatusMap.get(capability) == CapabilityStatus.ENABLED) {\n-      LOG.error(\"Deleting capability {} failed. Capability should be disabled before deleting.\", capability);\n-      return;\n-    }\n-    //delete pipelines\n-    try {\n-      deletePipelines(capability);\n-    } catch (Exception ex) {\n-      LOG.error(\"Deleting pipelines failed for capability {} with exception {}\", capability, ex);\n-    }\n-    //delete applications\n-    for (SystemApplication application : capabilityConfig.getApplications()) {\n-      ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(),\n-                                                      application.getVersion());\n-      try {\n-        applicationLifecycleService.removeApplication(applicationId);\n-      } catch (Exception exception) {\n-        LOG.error(\"Deleting application {} failed with exception {}\", applicationId, exception);\n-      }\n-    }\n-    capabilityStatusMap.remove(capability);\n-    LOG.debug(\"Capability {} deleted.\", capability);\n-  }\n-\n-  private void deletePipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::deleteAppWithRetry);\n-  }\n-\n-  private void stopPipelines(String capability) throws Exception {\n-    doForAllApps(capability, this::stopPrograms);\n-  }\n-\n-  private void deployAllApps(String capability, List<SystemApplication> applications) {\n-    if (applications.isEmpty()) {\n-      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n-      return;\n-    }\n-    for (SystemApplication application : applications) {\n-      doWithRetry(application, this::deployApp);\n-    }\n-  }\n-\n-  private void deployApp(SystemApplication application) {\n-    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n-    ApplicationId applicationId = new ApplicationId(application.getNamespace(), application.getName(), version);\n-    LOG.debug(\"Deploying app {}\", applicationId);\n-    try {\n-      if (isAppDeployed(applicationId)) {\n-        //Already deployed.\n-        LOG.debug(\"Application {} is already deployed\", applicationId);\n-        return;\n-      }\n-      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n-      applicationLifecycleService\n-        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n-                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n-    try {\n-      applicationLifecycleService.getAppDetail(applicationId);\n-      return true;\n-    } catch (ApplicationNotFoundException exception) {\n-      return false;\n-    }\n-  }\n-\n-  //Find all applications for capability and call consumer for each\n-  private void doForAllApps(String capability, Consumer<ApplicationId> consumer) throws Exception {\n-    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n-      int offset = 0;\n-      int limit = 100;\n-      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n-      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n-                                                            offset, limit);\n-      while (results.getEntities().size() > 0) {\n-        //call consumer for each entity\n-        results.getEntities().forEach(consumer);\n-        if (results.getEntities().size() < limit) {\n-          break;\n-        }\n-        offset += limit;\n-        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n-      }\n-    }\n-  }\n-\n-  private void stopPrograms(ApplicationId applicationId) {\n-    try {\n-      List<ProgramRecord> programs = applicationLifecycleService.getAppDetail(applicationId).getPrograms();\n-      for (ProgramRecord programRecord : programs) {\n-        ProgramId programId = new ProgramId(applicationId, programRecord.getType(), programRecord.getName());\n-        doWithRetry(programId, this::stopProgram);\n-      }\n-    } catch (Exception ex) {\n-      LOG.error(\"Stopping programs for application {} failed with {}\", applicationId, ex);\n-    }\n-  }\n-\n-  private void stopProgram(ProgramId programId) {\n-    try {\n-      programLifecycleService.stop(programId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private void deleteAppWithRetry(ApplicationId applicationId) {\n-    doWithRetry(applicationId, this::deleteApp);\n-  }\n-\n-  private void deleteApp(ApplicationId applicationId) {\n-    try {\n-      applicationLifecycleService.removeApplication(applicationId);\n-    } catch (Exception ex) {\n-      throw new RetryableException(ex);\n-    }\n-  }\n-\n-  private <T> void doWithRetry(T argument, Consumer<T> consumer) {\n-    Retries.callWithRetries(() -> {\n-      consumer.accept(argument);\n-      return null;\n-    }, RetryStrategies.limit(RETRY_LIMIT, RetryStrategies.fixDelay(RETRY_DELAY, TimeUnit.SECONDS)));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMTczMQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542721731", "bodyText": "Do we need all these to be public bindings? It is better to have capability related bindings in its own private module and add to appropriate injector creation.", "author": "chtyim", "createdAt": "2020-12-14T20:05:04Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +306,12 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n+      bind(CapabilityApplier.class).in(Scopes.SINGLETON);", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MzU0Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544853542", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMTczMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\nindex 20e018e2e24..688f9c6fc00 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n\n@@ -306,12 +304,6 @@ public final class AppFabricServiceRuntimeModule extends RuntimeModule {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      bind(CapabilityApplier.class).in(Scopes.SINGLETON);\n-      bind(CapabilityStatusStore.class).in(Scopes.SINGLETON);\n-      bind(CapabilityReader.class).to(CapabilityStatusStore.class);\n-      bind(CapabilityWriter.class).to(CapabilityStatusStore.class);\n-      bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n-      bind(CapabilityManagementService.class).in(Scopes.SINGLETON);\n       bind(OwnerAdmin.class).to(DefaultOwnerAdmin.class);\n       bind(CoreSchedulerService.class).in(Scopes.SINGLETON);\n       bind(Scheduler.class).to(CoreSchedulerService.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMzE5MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542723190", "bodyText": "Do we allow all capability to be used in preview?", "author": "chtyim", "createdAt": "2020-12-14T20:06:32Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewRunnerModule.java", "diffHunk": "@@ -194,6 +196,8 @@ protected void configure() {\n \n     bind(PreferencesFetcher.class).toProvider(preferencesFetcherProvider);\n     expose(PreferencesFetcher.class);\n+\n+    bind(CapabilityReader.class).to(NoopCapabilityReader.class);", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2MDQzMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544760432", "bodyText": "We didn't consider preview till now. Should we block for preview ?", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T02:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MzM4OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544853389", "bodyText": "Modified to use same the full reader implementation.", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMzE5MA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewRunnerModule.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewRunnerModule.java\nindex 23528c64a57..66bc7414b01 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewRunnerModule.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewRunnerModule.java\n\n@@ -197,7 +197,7 @@ public class PreviewRunnerModule extends PrivateModule {\n     bind(PreferencesFetcher.class).toProvider(preferencesFetcherProvider);\n     expose(PreferencesFetcher.class);\n \n-    bind(CapabilityReader.class).to(NoopCapabilityReader.class);\n+    bind(CapabilityReader.class).to(CapabilityStatusStore.class);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczNjMxMA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542736310", "bodyText": "This seems like an internal class to capability? If that's the case, make it package private", "author": "chtyim", "createdAt": "2020-12-14T20:18:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MzExNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544853116", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczNjMxMA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex e1cf9b04fc8..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -16,9 +16,11 @@\n \n package io.cdap.cdap.internal.capability;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.gson.Gson;\n import com.google.inject.Inject;\n-import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.common.ApplicationNotFoundException;\n import io.cdap.cdap.common.ArtifactNotFoundException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczOTIxOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r542739218", "bodyText": "Takes Collection<? extends CapabilityConfig> instead.", "author": "chtyim", "createdAt": "2020-12-14T20:21:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityChecker,\n+                    CapabilityWriter capabilityWriter) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityChecker;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) throws Exception {", "originalCommit": "7a8b944366e6d578837fba88dc58dd6d272b7539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1Mjc3Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544852777", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczOTIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex e1cf9b04fc8..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -16,9 +16,11 @@\n \n package io.cdap.cdap.internal.capability;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.gson.Gson;\n import com.google.inject.Inject;\n-import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.common.ApplicationNotFoundException;\n import io.cdap.cdap.common.ArtifactNotFoundException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMjg3OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544732879", "bodyText": "Have this class also implements the HttpErrorStatusProvider interface to respond with appropriate HTTP status when a capability is not available during app deploy / program start time.", "author": "chtyim", "createdAt": "2020-12-17T01:00:00Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityNotAvailableException.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+/**\n+ * CapabilityNotAvailableException indicating that the capability is disabled\n+ */\n+public class CapabilityNotAvailableException extends Exception {", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MjcxNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544852717", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMjg3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityNotAvailableException.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityNotAvailableException.java\nindex dc5b7fe9e51..5e983639901 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityNotAvailableException.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityNotAvailableException.java\n\n@@ -16,13 +16,21 @@\n \n package io.cdap.cdap.internal.capability;\n \n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+\n+import java.net.HttpURLConnection;\n+\n /**\n  * CapabilityNotAvailableException indicating that the capability is disabled\n  */\n-public class CapabilityNotAvailableException extends Exception {\n+public class CapabilityNotAvailableException extends Exception implements HttpErrorStatusProvider {\n \n   public CapabilityNotAvailableException(String capability) {\n     super(String.format(\"Capability %s is not enabled.\", capability));\n   }\n-  \n+\n+  @Override\n+  public int getStatusCode() {\n+    return HttpURLConnection.HTTP_FORBIDDEN;\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMzg5OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544733899", "bodyText": "Are we always hiding apps when capability is disable?", "author": "chtyim", "createdAt": "2020-12-17T01:02:43Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -224,6 +229,12 @@ protected void shutDown() throws Exception {\n     List<ApplicationDetail> result = new ArrayList<>();\n     for (Map.Entry<ApplicationId, ApplicationSpecification> entry : appSpecs.entrySet()) {\n       ApplicationDetail applicationDetail = ApplicationDetail.fromSpec(entry.getValue(), owners.get(entry.getKey()));\n+      try {\n+        capabilityReader.ensureApplicationEnabled(namespace.getNamespace(), applicationDetail.getName());", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczOTI5MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544739290", "bodyText": "Also, if the appClass.getRequirements().getCapabilities() already tells what capability an app needs, then why we need the ensureApplicationEnabled method?", "author": "chtyim", "createdAt": "2020-12-17T01:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMzg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MjY0MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544852641", "bodyText": "Changed to use capabilities from  appspec", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczMzg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\nindex d95067c39b2..a5d17dcd4b9 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\n\n@@ -230,7 +229,7 @@ public class ApplicationLifecycleService extends AbstractIdleService {\n     for (Map.Entry<ApplicationId, ApplicationSpecification> entry : appSpecs.entrySet()) {\n       ApplicationDetail applicationDetail = ApplicationDetail.fromSpec(entry.getValue(), owners.get(entry.getKey()));\n       try {\n-        capabilityReader.ensureApplicationEnabled(namespace.getNamespace(), applicationDetail.getName());\n+        capabilityReader.checkAllEnabled(entry.getValue());\n       } catch (CapabilityNotAvailableException ex) {\n         LOG.debug(\"Application {} is ignored due to exception.\", applicationDetail.getName(), ex);\n         continue;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNDk0OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544734949", "bodyText": "You can simplify it to\nboolean allEnabled = appClass.getRequirements().getCapabilities().stream().allMatch(capabilityReader::isEnabled);\nif (!allEnabled) {\n  throw ...\n}", "author": "chtyim", "createdAt": "2020-12-17T01:05:25Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -896,7 +907,12 @@ private ApplicationWithPrograms deployApp(NamespaceId namespaceId, @Nullable Str\n       throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n                                                        artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n     }\n-\n+    Set<String> capabilities = appClass.getRequirements().getCapabilities();\n+    for (String capability : capabilities) {\n+      if (!capabilityReader.isEnabled(capability)) {", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3MDI0OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544770249", "bodyText": "didnt use stream API because of needing to wrap IOException as a RuntimeException", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T02:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNDk0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\nindex d95067c39b2..a5d17dcd4b9 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\n\n@@ -907,12 +906,7 @@ public class ApplicationLifecycleService extends AbstractIdleService {\n       throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n                                                        artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n     }\n-    Set<String> capabilities = appClass.getRequirements().getCapabilities();\n-    for (String capability : capabilities) {\n-      if (!capabilityReader.isEnabled(capability)) {\n-        throw new CapabilityNotAvailableException(capability);\n-      }\n-    }\n+    capabilityReader.checkAllEnabled(appClass.getRequirements().getCapabilities());\n     // deploy application with newly added artifact\n     AppDeploymentInfo deploymentInfo = new AppDeploymentInfo(artifactDetail.getDescriptor(), namespaceId,\n                                                              appClass, appName, appVersion,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNjg4NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544736884", "bodyText": "Unused?", "author": "chtyim", "createdAt": "2020-12-17T01:10:57Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ProgramLifecycleService.java", "diffHunk": "@@ -478,6 +481,19 @@ public RunId run(ProgramId programId, Map<String, String> overrides, boolean deb\n     return runs;\n   }\n \n+  /**\n+   * Stop all active programs for the given application\n+   * @param applicationId\n+   * @throws Exception\n+   */\n+  public void stopAll(ApplicationId applicationId) throws Exception {\n+    Set<RunId> runs = new HashSet<>();", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTk2OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851968", "bodyText": "Removed", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDczNjg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ProgramLifecycleService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ProgramLifecycleService.java\nindex e686344da69..ac1d1eea3f3 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ProgramLifecycleService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ProgramLifecycleService.java\n\n@@ -487,7 +489,6 @@ public class ProgramLifecycleService {\n    * @throws Exception\n    */\n   public void stopAll(ApplicationId applicationId) throws Exception {\n-    Set<RunId> runs = new HashSet<>();\n     Map<ProgramRunId, RunRecordDetail> runMap = store.getActiveRuns(applicationId);\n     for (ProgramRunId programRunId : runMap.keySet()) {\n       stop(programRunId.getParent(), programRunId.getRun());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0MTkzOQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544741939", "bodyText": "for identity function, use Function.identity() instead", "author": "chtyim", "createdAt": "2020-12-17T01:24:43Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityChecker,\n+                    CapabilityWriter capabilityWriter) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityChecker;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(List<CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, capabilityStatusRecord -> capabilityStatusRecord));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability,\n+                                capabilityOperationRecord -> capabilityOperationRecord));", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTkxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851912", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0MTkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex bb59d8899c9..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -16,9 +16,11 @@\n \n package io.cdap.cdap.internal.capability;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.gson.Gson;\n import com.google.inject.Inject;\n-import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.common.ApplicationNotFoundException;\n import io.cdap.cdap.common.ArtifactNotFoundException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDE2MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544744160", "bodyText": "Why take the status as string in the constructor? It's better to take the enum directly.", "author": "chtyim", "createdAt": "2020-12-17T01:30:49Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Configuration for applying an action for a capability\n+ */\n+public class CapabilityConfig {\n+\n+  private final String label;\n+  private final CapabilityStatus status;\n+  private final String capability;\n+  private final List<SystemApplication> applications;\n+  private final List<SystemProgram> programs;\n+\n+  public CapabilityConfig(String label, String status, String capability,\n+                          @Nullable List<SystemApplication> applications, @Nullable List<SystemProgram> programs) {\n+    this.label = label;\n+    this.status = CapabilityStatus.valueOf(status);", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTg2NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851864", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDE2MA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\nindex e392d8f0c1b..3a474f19d1b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\n\n@@ -16,10 +16,10 @@\n \n package io.cdap.cdap.internal.capability;\n \n-import java.util.Collections;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Objects;\n-import javax.annotation.Nullable;\n \n /**\n  * Configuration for applying an action for a capability\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDQ0Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544744442", "bodyText": "Should requires empty list instead of null.", "author": "chtyim", "createdAt": "2020-12-17T01:31:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Configuration for applying an action for a capability\n+ */\n+public class CapabilityConfig {\n+\n+  private final String label;\n+  private final CapabilityStatus status;\n+  private final String capability;\n+  private final List<SystemApplication> applications;\n+  private final List<SystemProgram> programs;\n+\n+  public CapabilityConfig(String label, String status, String capability,\n+                          @Nullable List<SystemApplication> applications, @Nullable List<SystemProgram> programs) {", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NTMxNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544745316", "bodyText": "Also, take a Collection<? extends SystemApplication> is better.", "author": "chtyim", "createdAt": "2020-12-17T01:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTgwNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851806", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NDQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\nindex e392d8f0c1b..3a474f19d1b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\n\n@@ -16,10 +16,10 @@\n \n package io.cdap.cdap.internal.capability;\n \n-import java.util.Collections;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Objects;\n-import javax.annotation.Nullable;\n \n /**\n  * Configuration for applying an action for a capability\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NTM4OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544745388", "bodyText": "Do a defensive copy of the incoming collection.", "author": "chtyim", "createdAt": "2020-12-17T01:34:22Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Configuration for applying an action for a capability\n+ */\n+public class CapabilityConfig {\n+\n+  private final String label;\n+  private final CapabilityStatus status;\n+  private final String capability;\n+  private final List<SystemApplication> applications;\n+  private final List<SystemProgram> programs;\n+\n+  public CapabilityConfig(String label, String status, String capability,\n+                          @Nullable List<SystemApplication> applications, @Nullable List<SystemProgram> programs) {\n+    this.label = label;\n+    this.status = CapabilityStatus.valueOf(status);\n+    this.capability = capability;\n+    this.applications = (applications == null) ? Collections.emptyList() : applications;", "originalCommit": "61add550c326a000dadb2a1936bb95fcc0804076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MTc2Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r544851766", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-17T06:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0NTM4OA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\nindex e392d8f0c1b..3a474f19d1b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityConfig.java\n\n@@ -16,10 +16,10 @@\n \n package io.cdap.cdap.internal.capability;\n \n-import java.util.Collections;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Objects;\n-import javax.annotation.Nullable;\n \n /**\n  * Configuration for applying an action for a capability\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1OTkzNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545459937", "bodyText": "Can you create a class instead of using inner class?", "author": "chtyim", "createdAt": "2020-12-17T23:01:01Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +306,20 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n+      install(new PrivateModule() {", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDQwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545554408", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1OTkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\nindex c47db81deae..688f9c6fc00 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n\n@@ -306,20 +304,6 @@ public final class AppFabricServiceRuntimeModule extends RuntimeModule {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      install(new PrivateModule() {\n-        @Override\n-        protected void configure() {\n-          bind(CapabilityApplier.class).in(Scopes.SINGLETON);\n-          bind(CapabilityStatusStore.class).in(Scopes.SINGLETON);\n-          bind(CapabilityReader.class).to(CapabilityStatusStore.class);\n-          bind(CapabilityWriter.class).to(CapabilityStatusStore.class);\n-          bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n-          bind(CapabilityManagementService.class).in(Scopes.SINGLETON);\n-          expose(CapabilityManagementService.class);\n-          expose(CapabilityReader.class);\n-          expose(CapabilityWriter.class);\n-        }\n-      });\n       bind(OwnerAdmin.class).to(DefaultOwnerAdmin.class);\n       bind(CoreSchedulerService.class).in(Scopes.SINGLETON);\n       bind(Scheduler.class).to(CoreSchedulerService.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ2NDY0Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545464646", "bodyText": "Seeing this loop couple times. Seems likes you can refactor it into the CapabilityReader instead. E.g. CapabilityReader.isAllEnabled(Collection<String> capabilities).", "author": "chtyim", "createdAt": "2020-12-17T23:09:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/deploy/pipeline/LocalArtifactLoaderStage.java", "diffHunk": "@@ -124,6 +132,14 @@ public void process(AppDeploymentInfo deploymentInfo) throws Exception {\n       applicationId = deploymentInfo.getNamespaceId().app(specification.getName(), appVersion);\n     }\n     authorizationEnforcer.enforce(applicationId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    for (Map.Entry<String, Plugin> pluginEntry : specification.getPlugins().entrySet()) {\n+      Set<String> capabilities = pluginEntry.getValue().getPluginClass().getRequirements().getCapabilities();\n+      for (String capability : capabilities) {", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDM2OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545554369", "bodyText": "Added a method that checks all and throws exception if not enabled. This is to ensure we can capture/propagate the disabled capability.", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ2NDY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/deploy/pipeline/LocalArtifactLoaderStage.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/deploy/pipeline/LocalArtifactLoaderStage.java\nindex f88c91fb0b0..83a7ca79078 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/deploy/pipeline/LocalArtifactLoaderStage.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/deploy/pipeline/LocalArtifactLoaderStage.java\n\n@@ -132,14 +128,7 @@ public class LocalArtifactLoaderStage extends AbstractStage<AppDeploymentInfo> {\n       applicationId = deploymentInfo.getNamespaceId().app(specification.getName(), appVersion);\n     }\n     authorizationEnforcer.enforce(applicationId, authenticationContext.getPrincipal(), Action.ADMIN);\n-    for (Map.Entry<String, Plugin> pluginEntry : specification.getPlugins().entrySet()) {\n-      Set<String> capabilities = pluginEntry.getValue().getPluginClass().getRequirements().getCapabilities();\n-      for (String capability : capabilities) {\n-        if (!capabilityReader.isEnabled(capability)) {\n-          throw new CapabilityNotAvailableException(capability);\n-        }\n-      }\n-    }\n+    capabilityReader.checkAllEnabled(specification);\n     emit(new ApplicationDeployable(deploymentInfo.getArtifactId(), deploymentInfo.getArtifactLocation(),\n                                    applicationId, specification, store.getApplication(applicationId),\n                                    ApplicationDeployScope.USER, deploymentInfo.getApplicationClass(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTQ1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545489458", "bodyText": "I think this class should take the CapabilityStatusStore instead of separate reader and writer.", "author": "chtyim", "createdAt": "2020-12-18T00:14:37Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDAxNQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545554015", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex c6ebcc2ae63..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -21,7 +21,6 @@ import com.google.gson.Gson;\n import com.google.inject.Inject;\n import io.cdap.cdap.api.metadata.MetadataEntity;\n import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.common.ApplicationNotFoundException;\n import io.cdap.cdap.common.ArtifactNotFoundException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTk3Mw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545489973", "bodyText": "The getCapabilityOperations should be only in the store class/interface. Generally think of the store as the internal class, while reader and writer are public. Since operation is internal to capability implementation, there is no need to expose it to either reader/writer interface", "author": "chtyim", "createdAt": "2020-12-18T00:15:51Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,\n+                    CapabilityWriter capabilityWriter, DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityReader;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1Mzk2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545553967", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4OTk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex c6ebcc2ae63..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -21,7 +21,6 @@ import com.google.gson.Gson;\n import com.google.inject.Inject;\n import io.cdap.cdap.api.metadata.MetadataEntity;\n import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.common.ApplicationNotFoundException;\n import io.cdap.cdap.common.ArtifactNotFoundException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MTY2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545491667", "bodyText": "You don't need try catch to determine if it can be retried or not. The Retrie.callWithRetries method can take a Predicate<Exception> to determine if the exception is retryable or not.", "author": "chtyim", "createdAt": "2020-12-18T00:20:53Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,\n+                    CapabilityWriter capabilityWriter, DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityReader;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityWriter\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityWriter\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithMetadata(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithMetadata(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithMetadata(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityWriter.deleteCapability(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithMetadata(String capability) throws Exception {\n+    doForAllAppsWithMetadata(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopAllProgramsWithMetadata(String capability) throws Exception {\n+    doForAllAppsWithMetadata(capability, this::stopAllRunningProgramsForApp);\n+  }\n+\n+  private void deployAllSystemApps(String capability, List<SystemApplication> applications) throws Exception {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::retryableDeployApp);\n+    }\n+  }\n+\n+  private void retryableDeployApp(SystemApplication application) throws Exception {\n+    ApplicationId applicationId = getApplicationId(application);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    try {\n+      if (isAppDeployed(applicationId)) {\n+        //Already deployed.\n+        LOG.debug(\"Application {} is already deployed\", applicationId);\n+        return;\n+      }\n+      String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+      applicationLifecycleService\n+        .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                   application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+    } catch (Exception ex) {\n+      checkForRetry(ex);\n+      throw new RetryableException(ex);\n+    }\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllAppsWithMetadata(String capability, CheckedConsumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (!results.getEntities().isEmpty()) {\n+        //call consumer for each entity\n+        for (ApplicationId entity : results.getEntities()) {\n+          consumer.accept(entity);\n+        }\n+        offset += limit;\n+        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n+      }\n+    }\n+  }\n+\n+  private void stopAllRunningProgramsForApp(ApplicationId applicationId) {\n+    try {\n+      doWithRetry(applicationId, this::retryableStopRunningPrograms);\n+    } catch (Exception ex) {\n+      LOG.error(\"Stopping programs for application {} failed with {}\", applicationId, ex);\n+    }\n+  }\n+\n+  private void retryableStopRunningPrograms(ApplicationId applicationId) throws Exception {\n+    try {\n+      programLifecycleService.stopAll(applicationId);\n+    } catch (Exception ex) {\n+      checkForRetry(ex);\n+      throw new RetryableException(ex);\n+    }\n+  }\n+\n+  private void deleteAppWithRetry(ApplicationId applicationId) throws Exception {\n+    doWithRetry(applicationId, this::retryableDeleteApp);\n+  }\n+\n+  private void retryableDeleteApp(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.removeApplication(applicationId);\n+    } catch (Exception ex) {\n+      checkForRetry(ex);", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MzYyOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545553628", "bodyText": "Thanks, could remove lot of unnecessary methods.", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MTY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex c6ebcc2ae63..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -21,7 +21,6 @@ import com.google.gson.Gson;\n import com.google.inject.Inject;\n import io.cdap.cdap.api.metadata.MetadataEntity;\n import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.common.ApplicationNotFoundException;\n import io.cdap.cdap.common.ArtifactNotFoundException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MjE0Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545492147", "bodyText": "The method signature has nothing to do with metadata. Metadata is the implementation detail. You better call this deleteAllAppsWithCapability.", "author": "chtyim", "createdAt": "2020-12-18T00:22:18Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.api.retry.RetryableException;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+public class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityReader capabilityReader;\n+  private final CapabilityWriter capabilityWriter;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityReader capabilityReader,\n+                    CapabilityWriter capabilityWriter, DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityReader = capabilityReader;\n+    this.capabilityWriter = capabilityWriter;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityReader.getAllCapabilities().stream().collect(\n+      Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityReader.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityWriter\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityWriter\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithMetadata(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityReader.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityWriter.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityWriter.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithMetadata(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithMetadata(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityWriter.deleteCapability(capability);\n+      capabilityWriter.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithMetadata(String capability) throws Exception {", "originalCommit": "ce3c2aa2a04612da26366cf4af22b5650cce2c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MzQyNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r545553427", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-18T03:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MjE0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex c6ebcc2ae63..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -21,7 +21,6 @@ import com.google.gson.Gson;\n import com.google.inject.Inject;\n import io.cdap.cdap.api.metadata.MetadataEntity;\n import io.cdap.cdap.api.metadata.MetadataScope;\n-import io.cdap.cdap.api.retry.RetryableException;\n import io.cdap.cdap.app.runtime.Arguments;\n import io.cdap.cdap.common.ApplicationNotFoundException;\n import io.cdap.cdap.common.ArtifactNotFoundException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMDQ4MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546110481", "bodyText": "please try to avoid installing module like this. Put it in AppFabricServiceMain, MasterServiceMain, and StandaloneMain", "author": "chtyim", "createdAt": "2020-12-18T21:58:55Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java", "diffHunk": "@@ -302,7 +301,7 @@ protected void configure() {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      bind(SystemProgramManagementService.class).in(Scopes.SINGLETON);\n+      install(new CapabilityModule());", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzU1MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207550", "bodyText": "Moved to individual getModules() for AppFabricServiceRuntimeModule since several classes in Appfabric has dependency on CapabilityReader.", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMDQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\nindex d35ef8a75ad..688f9c6fc00 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/app/guice/AppFabricServiceRuntimeModule.java\n\n@@ -301,7 +304,6 @@ public final class AppFabricServiceRuntimeModule extends RuntimeModule {\n       bind(ProfileService.class).in(Scopes.SINGLETON);\n       bind(ProgramLifecycleService.class).in(Scopes.SINGLETON);\n       bind(SystemAppManagementService.class).in(Scopes.SINGLETON);\n-      install(new CapabilityModule());\n       bind(OwnerAdmin.class).to(DefaultOwnerAdmin.class);\n       bind(CoreSchedulerService.class).in(Scopes.SINGLETON);\n       bind(Scheduler.class).to(CoreSchedulerService.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMTU4OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546111588", "bodyText": "this is not an efficient implementation. You should be able to make one query to the storage, instead of querying them one by one.", "author": "chtyim", "createdAt": "2020-12-18T22:02:09Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) throws IOException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> keyField = Collections\n+        .singleton(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      Collection<String> returnField = Collections.singleton(StoreDefinition.CapabilitiesStore.STATUS_FIELD);\n+      Optional<StructuredRow> result = capabilityTable.read(keyField, returnField);\n+      return result.map(structuredRow -> CapabilityStatus\n+        .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase())).orElse(null);\n+    }, IOException.class);\n+  }\n+\n+  @Override\n+  public boolean isEnabled(String capability) throws IOException {\n+    return getStatus(capability) == CapabilityStatus.ENABLED;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    for (String capability : capabilities) {\n+      if (!isEnabled(capability)) {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzQwNA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207404", "bodyText": "changed to single query.", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMTU4OA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\nindex 1b37f0274fc..f7c91951c2b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n\n@@ -32,8 +32,10 @@ import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n-import java.util.Optional;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n \n /**\n  * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMzQ1Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546113452", "bodyText": "Repeated logic as in the LocalArtifactLoaderStage class? Consider moving it into CapabilityReader.checkAllEnabled(ApplicationSpecification spec).", "author": "chtyim", "createdAt": "2020-12-18T22:06:47Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -224,13 +228,27 @@ protected void shutDown() throws Exception {\n     List<ApplicationDetail> result = new ArrayList<>();\n     for (Map.Entry<ApplicationId, ApplicationSpecification> entry : appSpecs.entrySet()) {\n       ApplicationDetail applicationDetail = ApplicationDetail.fromSpec(entry.getValue(), owners.get(entry.getKey()));\n+      try {\n+        ensureApplicationEnabled(entry.getValue());\n+      } catch (CapabilityNotAvailableException ex) {\n+        LOG.debug(\"Application {} is ignored due to exception.\", applicationDetail.getName(), ex);\n+        continue;\n+      }\n       if (predicate.test(applicationDetail)) {\n         result.add(filterApplicationDetail(entry.getKey(), applicationDetail));\n       }\n     }\n     return result;\n   }\n \n+  private void ensureApplicationEnabled(ApplicationSpecification appSpec) throws IOException,\n+    CapabilityNotAvailableException {\n+    for (Map.Entry<String, Plugin> pluginEntry : appSpec.getPlugins().entrySet()) {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzM2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207367", "bodyText": "Moved", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMzQ1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\nindex 1fc32e36b0a..a5d17dcd4b9 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java\n\n@@ -229,7 +229,7 @@ public class ApplicationLifecycleService extends AbstractIdleService {\n     for (Map.Entry<ApplicationId, ApplicationSpecification> entry : appSpecs.entrySet()) {\n       ApplicationDetail applicationDetail = ApplicationDetail.fromSpec(entry.getValue(), owners.get(entry.getKey()));\n       try {\n-        ensureApplicationEnabled(entry.getValue());\n+        capabilityReader.checkAllEnabled(entry.getValue());\n       } catch (CapabilityNotAvailableException ex) {\n         LOG.debug(\"Application {} is ignored due to exception.\", applicationDetail.getName(), ex);\n         continue;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTM3OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546115378", "bodyText": "So this call and the previous call are in different transaction, is it ok? E.g. if the status changed to ENABLED, but the operation was not deleted.", "author": "chtyim", "createdAt": "2020-12-18T22:12:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODc1MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546178751", "bodyText": "Should not be a problem. Next attempt, this will be noticed as ongoing operation , but since the config is same , action will not be applied and the operation entry will get deleted.", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T02:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTM3OA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex 2daf006fa05..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -57,7 +57,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjM2OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546116368", "bodyText": "Seems unnecessary to have this one line method.", "author": "chtyim", "createdAt": "2020-12-18T22:15:25Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithCapability(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithCapability(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithCapability(String capability) throws Exception {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex 2daf006fa05..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -57,7 +57,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjQxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546116412", "bodyText": "Same as above.", "author": "chtyim", "createdAt": "2020-12-18T22:15:35Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithCapability(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithCapability(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithCapability(String capability) throws Exception {\n+    doForAllAppsWithCapability(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopAllProgramsWithCapability(String capability) throws Exception {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzM1MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207350", "bodyText": "Removed", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex 2daf006fa05..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -57,7 +57,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjY3MA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546116670", "bodyText": "Just call it stopAllPrograms(ApplicationId appId). It is clear enough what is it doing.", "author": "chtyim", "createdAt": "2020-12-18T22:16:15Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      stopAllProgramsWithCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        stopAllProgramsWithCapability(capability);\n+      }\n+      //remove all applications having capability metadata.\n+      deleteAllAppsWithCapability(capability);\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        deleteAppWithRetry(applicationId);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deleteAllAppsWithCapability(String capability) throws Exception {\n+    doForAllAppsWithCapability(capability, this::deleteAppWithRetry);\n+  }\n+\n+  private void stopAllProgramsWithCapability(String capability) throws Exception {\n+    doForAllAppsWithCapability(capability, this::stopAllRunningProgramsForApp);\n+  }\n+\n+  private void deployAllSystemApps(String capability, List<SystemApplication> applications) throws Exception {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::retryableDeployApp);\n+    }\n+  }\n+\n+  private void retryableDeployApp(SystemApplication application) throws Exception {\n+    ApplicationId applicationId = getApplicationId(application);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    if (isAppDeployed(applicationId)) {\n+      //Already deployed.\n+      LOG.debug(\"Application {} is already deployed\", applicationId);\n+      return;\n+    }\n+    String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+    applicationLifecycleService\n+      .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                 application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllAppsWithCapability(String capability, CheckedConsumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (!results.getEntities().isEmpty()) {\n+        //call consumer for each entity\n+        for (ApplicationId entity : results.getEntities()) {\n+          consumer.accept(entity);\n+        }\n+        offset += limit;\n+        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n+      }\n+    }\n+  }\n+\n+  private void stopAllRunningProgramsForApp(ApplicationId applicationId) {", "originalCommit": "2f523b0449cd420c2363f871850db649e71f1526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwNzMyNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546207326", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-19T07:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex 2daf006fa05..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -57,7 +57,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1MjA4NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546552084", "bodyText": "Instead of exposing the status and the operations separated, they should be returned by one call (and via one query to DB). It should return something like Map<String, CapabilityRecord>, with CapabilityRecord contains the status and list of operations.", "author": "chtyim", "createdAt": "2020-12-21T07:39:28Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0Njc1NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946754", "bodyText": "Fixed to make it single method. Will be part of single txn.", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1MjA4NA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex d186729c2a2..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -57,7 +57,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1NzgxNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546557817", "bodyText": "Shouldn't check. Just force stopping regardless. In fact, deleteCapabilities should be calling disableCapabilities, followed by deleting app since all operations should be idempotent.", "author": "chtyim", "createdAt": "2020-12-21T07:55:52Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      doForAllAppsWithCapability(capability,\n+                                 applicationId -> doWithRetry(applicationId, programLifecycleService::stopAll));\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NjgxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946812", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1NzgxNw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex d186729c2a2..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -57,7 +57,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1OTY3MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546559671", "bodyText": "Does it need to be public?", "author": "chtyim", "createdAt": "2020-12-21T08:00:47Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.metadata.MetadataEntity;\n+import io.cdap.cdap.api.metadata.MetadataScope;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.common.ApplicationNotFoundException;\n+import io.cdap.cdap.common.ArtifactNotFoundException;\n+import io.cdap.cdap.common.InvalidArtifactException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.namespace.NamespaceAdmin;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.internal.app.deploy.ProgramTerminator;\n+import io.cdap.cdap.internal.app.runtime.BasicArguments;\n+import io.cdap.cdap.internal.app.services.ApplicationLifecycleService;\n+import io.cdap.cdap.internal.app.services.ProgramLifecycleService;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import io.cdap.cdap.internal.entity.EntityResult;\n+import io.cdap.cdap.proto.NamespaceMeta;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResponse;\n+import io.cdap.cdap.proto.metadata.MetadataSearchResultRecord;\n+import io.cdap.cdap.security.spi.authorization.UnauthorizedException;\n+import io.cdap.cdap.spi.metadata.SearchRequest;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class that applies capabilities\n+ */\n+class CapabilityApplier {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityApplier.class);\n+  private static final Gson GSON = new Gson();\n+  private static final int RETRY_LIMIT = 5;\n+  private static final int RETRY_DELAY = 5;\n+  private static final String CAPABILITY = \"capability:%s\";\n+  private static final String APPLICATION = \"application\";\n+  private static final ProgramTerminator NOOP_PROGRAM_TERMINATOR = programId -> {\n+    // no-op\n+  };\n+  private final SystemProgramManagementService systemProgramManagementService;\n+  private final ApplicationLifecycleService applicationLifecycleService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final NamespaceAdmin namespaceAdmin;\n+  private final CapabilityStatusStore capabilityStatusStore;\n+  private final MetadataSearchClient metadataSearchClient;\n+\n+  @Inject\n+  CapabilityApplier(CConfiguration cConf, SystemProgramManagementService systemProgramManagementService,\n+                    ApplicationLifecycleService applicationLifecycleService, NamespaceAdmin namespaceAdmin,\n+                    ProgramLifecycleService programLifecycleService, CapabilityStatusStore capabilityStatusStore,\n+                    DiscoveryServiceClient discoveryClient) {\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.applicationLifecycleService = applicationLifecycleService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.capabilityStatusStore = capabilityStatusStore;\n+    this.namespaceAdmin = namespaceAdmin;\n+    this.metadataSearchClient = new MetadataSearchClient(discoveryClient);\n+  }\n+\n+  /**\n+   * Applies the given capability configurations\n+   *\n+   * @param capabilityConfigs\n+   */\n+  public void apply(Collection<? extends CapabilityConfig> capabilityConfigs) throws Exception {\n+    List<CapabilityConfig> newConfigs = new ArrayList<>(capabilityConfigs);\n+    Set<CapabilityConfig> enableSet = new HashSet<>();\n+    Set<CapabilityConfig> disableSet = new HashSet<>();\n+    Set<CapabilityConfig> deleteSet = new HashSet<>();\n+    Map<String, CapabilityStatusRecord> currentCapabilities = capabilityStatusStore.getAllCapabilities().stream()\n+      .collect(Collectors.toMap(CapabilityStatusRecord::getCapability, Function.identity()));\n+    Map<String, CapabilityOperationRecord> currentOperations = capabilityStatusStore.getCapabilityOperations().stream()\n+      .collect(Collectors.toMap(CapabilityOperationRecord::getCapability, Function.identity()));\n+    for (CapabilityConfig newConfig : newConfigs) {\n+      String capability = newConfig.getCapability();\n+      if (currentOperations.containsKey(capability)) {\n+        LOG.debug(\"Capability {} config for status {} skipped because there is already an operation {} in progress.\",\n+                  capability, newConfig.getStatus(), currentOperations.get(capability).getActionType());\n+        continue;\n+      }\n+      switch (newConfig.getStatus()) {\n+        case ENABLED:\n+          enableSet.add(newConfig);\n+          break;\n+        case DISABLED:\n+          disableSet.add(newConfig);\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(capability);\n+    }\n+    //add all unfinished operations to retry\n+    for (CapabilityOperationRecord operationRecord : currentOperations.values()) {\n+      switch (operationRecord.getActionType()) {\n+        case ENABLE:\n+          enableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DISABLE:\n+          disableSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        case DELETE:\n+          deleteSet.add(operationRecord.getCapabilityConfig());\n+          break;\n+        default:\n+          break;\n+      }\n+      currentCapabilities.remove(operationRecord.getCapability());\n+    }\n+    // find the ones that are not being applied or retried - these should be removed\n+    deleteSet.addAll(currentCapabilities.values().stream()\n+                       .map(CapabilityStatusRecord::getCapabilityConfig).collect(Collectors.toSet()));\n+    enableCapabilities(enableSet);\n+    disableCapabilities(disableSet);\n+    deleteCapabilities(deleteSet);\n+  }\n+\n+  private void enableCapabilities(Set<CapabilityConfig> enableSet) throws Exception {\n+    Map<ProgramId, Arguments> enabledPrograms = new HashMap<>();\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      //collect the enabled programs\n+      capabilityConfig.getPrograms().forEach(systemProgram -> enabledPrograms\n+        .put(getProgramId(systemProgram), new BasicArguments(systemProgram.getArgs())));\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.ENABLE, capabilityConfig);\n+      LOG.debug(\"Enabling capability {}\", capability);\n+      //If already deployed, will be ignored\n+      deployAllSystemApps(capability, capabilityConfig.getApplications());\n+    }\n+    //start all programs\n+    systemProgramManagementService.setProgramsEnabled(enabledPrograms);\n+    //mark all as enabled\n+    for (CapabilityConfig capabilityConfig : enableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capability, CapabilityStatus.ENABLED, capabilityConfig);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Enabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void disableCapabilities(Set<CapabilityConfig> disableSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : disableSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      if (capabilityConfig.equals(existingConfig)) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DISABLE, capabilityConfig);\n+      LOG.debug(\"Disabling capability {}\", capability);\n+      capabilityStatusStore\n+        .addOrUpdateCapability(capabilityConfig.getCapability(), CapabilityStatus.DISABLED, capabilityConfig);\n+      //stop all the programs having capability metadata. Services will be stopped by SystemProgramManagementService\n+      doForAllAppsWithCapability(capability,\n+                                 applicationId -> doWithRetry(applicationId, programLifecycleService::stopAll));\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Disabled capability {}\", capability);\n+    }\n+  }\n+\n+  private void deleteCapabilities(Set<CapabilityConfig> deleteSet) throws Exception {\n+    for (CapabilityConfig capabilityConfig : deleteSet) {\n+      String capability = capabilityConfig.getCapability();\n+      CapabilityConfig existingConfig = capabilityStatusStore.getConfig(capability);\n+      //already deleted\n+      if (existingConfig == null) {\n+        capabilityStatusStore.deleteCapabilityOperation(capability);\n+        continue;\n+      }\n+      capabilityStatusStore.addOrUpdateCapabilityOperation(capability, CapabilityAction.DELETE, capabilityConfig);\n+      LOG.debug(\"Deleting capability {}\", capability);\n+      if (existingConfig.getStatus() == CapabilityStatus.ENABLED) {\n+        //stop all the programs having capability metadata.\n+        doForAllAppsWithCapability(capability,\n+                                   applicationId -> doWithRetry(applicationId, programLifecycleService::stopAll));\n+      }\n+      //remove all applications having capability metadata.\n+      doForAllAppsWithCapability(capability,\n+                                 applicationId -> doWithRetry(applicationId,\n+                                                              applicationLifecycleService::removeApplication));\n+      //remove deployments of system applications\n+      for (SystemApplication application : capabilityConfig.getApplications()) {\n+        ApplicationId applicationId = getApplicationId(application);\n+        doWithRetry(applicationId, applicationLifecycleService::removeApplication);\n+      }\n+      capabilityStatusStore.deleteCapability(capability);\n+      capabilityStatusStore.deleteCapabilityOperation(capability);\n+      LOG.debug(\"Deleted capability {}\", capability);\n+    }\n+  }\n+\n+  private ApplicationId getApplicationId(SystemApplication application) {\n+    String version = application.getVersion() == null ? ApplicationId.DEFAULT_VERSION : application.getVersion();\n+    return new ApplicationId(application.getNamespace(), application.getName(), version);\n+  }\n+\n+  private ProgramId getProgramId(SystemProgram program) {\n+    ApplicationId applicationId = new ApplicationId(program.getNamespace(), program.getApplication(),\n+                                                    program.getVersion());\n+    return new ProgramId(applicationId, ProgramType.valueOf(program.getType().toUpperCase()), program.getName());\n+  }\n+\n+  private void deployAllSystemApps(String capability, List<SystemApplication> applications) throws Exception {\n+    if (applications.isEmpty()) {\n+      LOG.debug(\"Capability {} do not have apps associated with it\", capability);\n+      return;\n+    }\n+    for (SystemApplication application : applications) {\n+      doWithRetry(application, this::deployApp);\n+    }\n+  }\n+\n+  private void deployApp(SystemApplication application) throws Exception {\n+    ApplicationId applicationId = getApplicationId(application);\n+    LOG.debug(\"Deploying app {}\", applicationId);\n+    if (isAppDeployed(applicationId)) {\n+      //Already deployed.\n+      LOG.debug(\"Application {} is already deployed\", applicationId);\n+      return;\n+    }\n+    String configString = application.getConfig() == null ? null : GSON.toJson(application.getConfig());\n+    applicationLifecycleService\n+      .deployApp(applicationId.getParent(), applicationId.getApplication(), applicationId.getVersion(),\n+                 application.getArtifact(), configString, NOOP_PROGRAM_TERMINATOR, null, null);\n+  }\n+\n+  private boolean isAppDeployed(ApplicationId applicationId) throws Exception {\n+    try {\n+      applicationLifecycleService.getAppDetail(applicationId);\n+      return true;\n+    } catch (ApplicationNotFoundException exception) {\n+      return false;\n+    }\n+  }\n+\n+  //Find all applications for capability and call consumer for each\n+  private void doForAllAppsWithCapability(String capability, CheckedConsumer<ApplicationId> consumer) throws Exception {\n+    for (NamespaceMeta namespaceMeta : namespaceAdmin.list()) {\n+      int offset = 0;\n+      int limit = 100;\n+      NamespaceId namespaceId = namespaceMeta.getNamespaceId();\n+      EntityResult<ApplicationId> results = getApplications(namespaceId, capability, null,\n+                                                            offset, limit);\n+      while (!results.getEntities().isEmpty()) {\n+        //call consumer for each entity\n+        for (ApplicationId entity : results.getEntities()) {\n+          consumer.accept(entity);\n+        }\n+        offset += limit;\n+        results = getApplications(namespaceId, capability, results.getCursor(), offset, limit);\n+      }\n+    }\n+  }\n+\n+  private <T> void doWithRetry(T argument, CheckedConsumer<T> consumer) throws Exception {\n+    Retries.callWithRetries(() -> {\n+      consumer.accept(argument);\n+      return null;\n+    }, RetryStrategies.limit(RETRY_LIMIT, RetryStrategies.fixDelay(RETRY_DELAY, TimeUnit.SECONDS)), this::shouldRetry);\n+  }\n+\n+  private boolean shouldRetry(Throwable throwable) {\n+    return !(throwable instanceof UnauthorizedException ||\n+      throwable instanceof InvalidArtifactException ||\n+      throwable instanceof ArtifactNotFoundException);\n+  }\n+\n+  /**\n+   * Consumer functional interface that can throw exception\n+   *\n+   * @param <T>\n+   */\n+  @FunctionalInterface\n+  public interface CheckedConsumer<T> {", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0Njg2Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946862", "bodyText": "Made private", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1OTY3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\nindex d186729c2a2..3e0b116d1cd 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityApplier.java\n\n@@ -57,7 +57,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ3MQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546560471", "bodyText": "No need to call super method.", "author": "chtyim", "createdAt": "2020-12-21T08:02:45Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Scan service for capability configurations\n+ */\n+public class CapabilityManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+  private static final Gson GSON = new Gson();\n+  private final long scheduleIntervalInMillis;\n+  private final CConfiguration cConf;\n+  private final CapabilityApplier capabilityApplier;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+\n+  @Inject\n+  CapabilityManagementService(CConfiguration cConf, CapabilityApplier capabilityApplier,\n+                              SystemProgramManagementService systemProgramManagementService) {\n+    super(RetryStrategies\n+            .fixDelay(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES), TimeUnit.MINUTES));\n+    this.cConf = cConf;\n+    this.capabilityApplier = capabilityApplier;\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.scheduleIntervalInMillis = TimeUnit.MINUTES\n+      .toMillis(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES));\n+  }\n+\n+  @Override\n+  protected void doStartUp() throws Exception {\n+    super.doStartUp();", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NjkyNA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946924", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\nindex f59c93e9853..94c2a7a1649 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n\n@@ -60,35 +60,35 @@ public class CapabilityManagementService extends AbstractRetryableScheduledServi\n   }\n \n   @Override\n-  protected void doStartUp() throws Exception {\n-    super.doStartUp();\n+  protected void doStartUp() {\n+    LOG.debug(\"Starting scheduled service {}\", getServiceName());\n     systemProgramManagementService.start();\n   }\n \n   @Override\n-  protected void doShutdown() throws Exception {\n-    super.doShutdown();\n+  protected void doShutdown() {\n+    LOG.debug(\"Stopping scheduled service {}\", getServiceName());\n     systemProgramManagementService.stopAndWait();\n   }\n \n   @Override\n   protected long runTask() throws Exception {\n     LOG.debug(\"Scanning capability config directory.\");\n-    List<CapabilityConfig> capabilityConfigList = scanConfigDirectory();\n+    List<CapabilityConfig> capabilityConfigs = scanConfigDirectory();\n     //apply all the config\n-    capabilityApplier.apply(capabilityConfigList);\n+    capabilityApplier.apply(capabilityConfigs);\n     return scheduleIntervalInMillis;\n   }\n \n   private List<CapabilityConfig> scanConfigDirectory() throws IOException {\n     File configDir = new File(cConf.get(Constants.Capability.CONFIG_DIR));\n-    List<CapabilityConfig> allConfigs = new ArrayList<>();\n+    List<CapabilityConfig> capabilityConfigs = new ArrayList<>();\n     for (File configFile : DirUtils.listFiles(configDir)) {\n       try (Reader reader = new FileReader(configFile)) {\n         CapabilityConfig capabilityConfig = GSON.fromJson(reader, CapabilityConfig.class);\n-        allConfigs.add(capabilityConfig);\n+        capabilityConfigs.add(capabilityConfig);\n       }\n     }\n-    return allConfigs;\n+    return capabilityConfigs;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ5Ng==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546560496", "bodyText": "No need to call super method.", "author": "chtyim", "createdAt": "2020-12-21T08:02:50Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Scan service for capability configurations\n+ */\n+public class CapabilityManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+  private static final Gson GSON = new Gson();\n+  private final long scheduleIntervalInMillis;\n+  private final CConfiguration cConf;\n+  private final CapabilityApplier capabilityApplier;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+\n+  @Inject\n+  CapabilityManagementService(CConfiguration cConf, CapabilityApplier capabilityApplier,\n+                              SystemProgramManagementService systemProgramManagementService) {\n+    super(RetryStrategies\n+            .fixDelay(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES), TimeUnit.MINUTES));\n+    this.cConf = cConf;\n+    this.capabilityApplier = capabilityApplier;\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.scheduleIntervalInMillis = TimeUnit.MINUTES\n+      .toMillis(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES));\n+  }\n+\n+  @Override\n+  protected void doStartUp() throws Exception {\n+    super.doStartUp();\n+    systemProgramManagementService.start();\n+  }\n+\n+  @Override\n+  protected void doShutdown() throws Exception {\n+    super.doShutdown();", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0Njk2NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546946964", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MDQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\nindex f59c93e9853..94c2a7a1649 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n\n@@ -60,35 +60,35 @@ public class CapabilityManagementService extends AbstractRetryableScheduledServi\n   }\n \n   @Override\n-  protected void doStartUp() throws Exception {\n-    super.doStartUp();\n+  protected void doStartUp() {\n+    LOG.debug(\"Starting scheduled service {}\", getServiceName());\n     systemProgramManagementService.start();\n   }\n \n   @Override\n-  protected void doShutdown() throws Exception {\n-    super.doShutdown();\n+  protected void doShutdown() {\n+    LOG.debug(\"Stopping scheduled service {}\", getServiceName());\n     systemProgramManagementService.stopAndWait();\n   }\n \n   @Override\n   protected long runTask() throws Exception {\n     LOG.debug(\"Scanning capability config directory.\");\n-    List<CapabilityConfig> capabilityConfigList = scanConfigDirectory();\n+    List<CapabilityConfig> capabilityConfigs = scanConfigDirectory();\n     //apply all the config\n-    capabilityApplier.apply(capabilityConfigList);\n+    capabilityApplier.apply(capabilityConfigs);\n     return scheduleIntervalInMillis;\n   }\n \n   private List<CapabilityConfig> scanConfigDirectory() throws IOException {\n     File configDir = new File(cConf.get(Constants.Capability.CONFIG_DIR));\n-    List<CapabilityConfig> allConfigs = new ArrayList<>();\n+    List<CapabilityConfig> capabilityConfigs = new ArrayList<>();\n     for (File configFile : DirUtils.listFiles(configDir)) {\n       try (Reader reader = new FileReader(configFile)) {\n         CapabilityConfig capabilityConfig = GSON.fromJson(reader, CapabilityConfig.class);\n-        allConfigs.add(capabilityConfig);\n+        capabilityConfigs.add(capabilityConfig);\n       }\n     }\n-    return allConfigs;\n+    return capabilityConfigs;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTIzNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546561237", "bodyText": "It is a better habit to keep naming consistent in the same class. E.g. it is called allConfigs here, while it is called capabilityConfigList from the method above. It is better to consistently calling it capabilityConfigs (plural of the collection type)", "author": "chtyim", "createdAt": "2020-12-21T08:04:44Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.services.SystemProgramManagementService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Scan service for capability configurations\n+ */\n+public class CapabilityManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CapabilityManagementService.class);\n+  private static final Gson GSON = new Gson();\n+  private final long scheduleIntervalInMillis;\n+  private final CConfiguration cConf;\n+  private final CapabilityApplier capabilityApplier;\n+  private final SystemProgramManagementService systemProgramManagementService;\n+\n+  @Inject\n+  CapabilityManagementService(CConfiguration cConf, CapabilityApplier capabilityApplier,\n+                              SystemProgramManagementService systemProgramManagementService) {\n+    super(RetryStrategies\n+            .fixDelay(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES), TimeUnit.MINUTES));\n+    this.cConf = cConf;\n+    this.capabilityApplier = capabilityApplier;\n+    this.systemProgramManagementService = systemProgramManagementService;\n+    this.scheduleIntervalInMillis = TimeUnit.MINUTES\n+      .toMillis(cConf.getLong(Constants.Capability.DIR_SCAN_INTERVAL_MINUTES));\n+  }\n+\n+  @Override\n+  protected void doStartUp() throws Exception {\n+    super.doStartUp();\n+    systemProgramManagementService.start();\n+  }\n+\n+  @Override\n+  protected void doShutdown() throws Exception {\n+    super.doShutdown();\n+    systemProgramManagementService.stopAndWait();\n+  }\n+\n+  @Override\n+  protected long runTask() throws Exception {\n+    LOG.debug(\"Scanning capability config directory.\");\n+    List<CapabilityConfig> capabilityConfigList = scanConfigDirectory();\n+    //apply all the config\n+    capabilityApplier.apply(capabilityConfigList);\n+    return scheduleIntervalInMillis;\n+  }\n+\n+  private List<CapabilityConfig> scanConfigDirectory() throws IOException {\n+    File configDir = new File(cConf.get(Constants.Capability.CONFIG_DIR));\n+    List<CapabilityConfig> allConfigs = new ArrayList<>();", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzAwOA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947008", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTIzNw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\nindex f59c93e9853..94c2a7a1649 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityManagementService.java\n\n@@ -60,35 +60,35 @@ public class CapabilityManagementService extends AbstractRetryableScheduledServi\n   }\n \n   @Override\n-  protected void doStartUp() throws Exception {\n-    super.doStartUp();\n+  protected void doStartUp() {\n+    LOG.debug(\"Starting scheduled service {}\", getServiceName());\n     systemProgramManagementService.start();\n   }\n \n   @Override\n-  protected void doShutdown() throws Exception {\n-    super.doShutdown();\n+  protected void doShutdown() {\n+    LOG.debug(\"Stopping scheduled service {}\", getServiceName());\n     systemProgramManagementService.stopAndWait();\n   }\n \n   @Override\n   protected long runTask() throws Exception {\n     LOG.debug(\"Scanning capability config directory.\");\n-    List<CapabilityConfig> capabilityConfigList = scanConfigDirectory();\n+    List<CapabilityConfig> capabilityConfigs = scanConfigDirectory();\n     //apply all the config\n-    capabilityApplier.apply(capabilityConfigList);\n+    capabilityApplier.apply(capabilityConfigs);\n     return scheduleIntervalInMillis;\n   }\n \n   private List<CapabilityConfig> scanConfigDirectory() throws IOException {\n     File configDir = new File(cConf.get(Constants.Capability.CONFIG_DIR));\n-    List<CapabilityConfig> allConfigs = new ArrayList<>();\n+    List<CapabilityConfig> capabilityConfigs = new ArrayList<>();\n     for (File configFile : DirUtils.listFiles(configDir)) {\n       try (Reader reader = new FileReader(configFile)) {\n         CapabilityConfig capabilityConfig = GSON.fromJson(reader, CapabilityConfig.class);\n-        allConfigs.add(capabilityConfig);\n+        capabilityConfigs.add(capabilityConfig);\n       }\n     }\n-    return allConfigs;\n+    return capabilityConfigs;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTkzMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546561932", "bodyText": "You can move this to the CapabilityReader interface as the default implementation.", "author": "chtyim", "createdAt": "2020-12-21T08:06:29Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) throws IOException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> keyField = Collections\n+        .singleton(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      Collection<String> returnField = Collections.singleton(StoreDefinition.CapabilitiesStore.STATUS_FIELD);\n+      Optional<StructuredRow> result = capabilityTable.read(keyField, returnField);\n+      return result.map(structuredRow -> CapabilityStatus\n+        .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase())).orElse(null);\n+    }, IOException.class);\n+  }\n+\n+  @Override\n+  public boolean isEnabled(String capability) throws IOException {\n+    return getStatus(capability) == CapabilityStatus.ENABLED;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      List<List<Field<?>>> multiKeys = new ArrayList<>();\n+      capabilities.forEach(capability -> {\n+        multiKeys\n+          .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability)));\n+      });\n+      Map<String, String> capabilityMap = capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+      for (String capability : capabilities) {\n+        if (!capabilityMap.containsKey(capability) || CapabilityStatus\n+          .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n+          throw new CapabilityNotAvailableException(capability);\n+        }\n+      }\n+    }, IOException.class, CapabilityNotAvailableException.class);\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(ApplicationSpecification appSpec) throws IOException, CapabilityNotAvailableException {\n+    Set<String> capabilities = appSpec.getPlugins().entrySet().stream()", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzEwMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947102", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTkzMg=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\nindex 78f6a830c5d..f7c91951c2b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n\n@@ -18,7 +18,6 @@ package io.cdap.cdap.internal.capability;\n \n import com.google.gson.Gson;\n import com.google.inject.Inject;\n-import io.cdap.cdap.api.app.ApplicationSpecification;\n import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n import io.cdap.cdap.spi.data.StructuredRow;\n import io.cdap.cdap.spi.data.StructuredTable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MzQ1Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546563452", "bodyText": "This method seems like no longer used. Please remove it.", "author": "chtyim", "createdAt": "2020-12-21T08:10:17Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * CapabilityReader interface with methods based on current capability status\n+ */\n+public interface CapabilityReader {\n+\n+  /**\n+   * Returns the status of capability.\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  CapabilityStatus getStatus(String capability) throws IOException;\n+\n+  /**\n+   * Return boolean indicating whether the capability is enabled\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  boolean isEnabled(String capability) throws IOException;", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzA1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947058", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MzQ1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\nindex c6163059017..d679be72b84 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\n\n@@ -20,34 +20,18 @@ import io.cdap.cdap.api.app.ApplicationSpecification;\n \n import java.io.IOException;\n import java.util.Collection;\n-import java.util.List;\n-import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * CapabilityReader interface with methods based on current capability status\n  */\n public interface CapabilityReader {\n \n-  /**\n-   * Returns the status of capability.\n-   *\n-   * @param capability\n-   * @return\n-   * @throws IOException\n-   */\n-  CapabilityStatus getStatus(String capability) throws IOException;\n-\n-  /**\n-   * Return boolean indicating whether the capability is enabled\n-   *\n-   * @param capability\n-   * @return\n-   * @throws IOException\n-   */\n-  boolean isEnabled(String capability) throws IOException;\n-\n   /**\n    * Throws {@link CapabilityNotAvailableException} if all capabilities are not enabled\n+   *\n    * @param capabilities\n    * @return\n    * @throws IOException\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTQxMg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546565412", "bodyText": "Move this loop outside of the transaction as it has nothing to do with it. You can use the one that takes TxCallable to return the capabilityMap from the transaction.", "author": "chtyim", "createdAt": "2020-12-21T08:15:16Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * Return the current status for a capability. If capability is not present, throws {@link IllegalArgumentException}\n+   *\n+   * @param capability\n+   * @return {@link CapabilityStatus}\n+   */\n+  public CapabilityStatus getStatus(String capability) throws IOException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> keyField = Collections\n+        .singleton(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      Collection<String> returnField = Collections.singleton(StoreDefinition.CapabilitiesStore.STATUS_FIELD);\n+      Optional<StructuredRow> result = capabilityTable.read(keyField, returnField);\n+      return result.map(structuredRow -> CapabilityStatus\n+        .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase())).orElse(null);\n+    }, IOException.class);\n+  }\n+\n+  @Override\n+  public boolean isEnabled(String capability) throws IOException {\n+    return getStatus(capability) == CapabilityStatus.ENABLED;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      List<List<Field<?>>> multiKeys = new ArrayList<>();\n+      capabilities.forEach(capability -> {\n+        multiKeys\n+          .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability)));\n+      });\n+      Map<String, String> capabilityMap = capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+      for (String capability : capabilities) {", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzE2Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947167", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\nindex 78f6a830c5d..f7c91951c2b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n\n@@ -18,7 +18,6 @@ package io.cdap.cdap.internal.capability;\n \n import com.google.gson.Gson;\n import com.google.inject.Inject;\n-import io.cdap.cdap.api.app.ApplicationSpecification;\n import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n import io.cdap.cdap.spi.data.StructuredRow;\n import io.cdap.cdap.spi.data.StructuredTable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTU5OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546565599", "bodyText": "This method seems like not used. Please remove it.", "author": "chtyim", "createdAt": "2020-12-21T08:15:48Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * CapabilityReader interface with methods based on current capability status\n+ */\n+public interface CapabilityReader {\n+\n+  /**\n+   * Returns the status of capability.\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  CapabilityStatus getStatus(String capability) throws IOException;", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzIxNg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947216", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NTU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\nindex c6163059017..d679be72b84 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\n\n@@ -20,34 +20,18 @@ import io.cdap.cdap.api.app.ApplicationSpecification;\n \n import java.io.IOException;\n import java.util.Collection;\n-import java.util.List;\n-import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * CapabilityReader interface with methods based on current capability status\n  */\n public interface CapabilityReader {\n \n-  /**\n-   * Returns the status of capability.\n-   *\n-   * @param capability\n-   * @return\n-   * @throws IOException\n-   */\n-  CapabilityStatus getStatus(String capability) throws IOException;\n-\n-  /**\n-   * Return boolean indicating whether the capability is enabled\n-   *\n-   * @param capability\n-   * @return\n-   * @throws IOException\n-   */\n-  boolean isEnabled(String capability) throws IOException;\n-\n   /**\n    * Throws {@link CapabilityNotAvailableException} if all capabilities are not enabled\n+   *\n    * @param capabilities\n    * @return\n    * @throws IOException\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NzM1NQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546567355", "bodyText": "Avoid expose method that backed by DB and have the caller looping and calling it in a tight loop. It's better to take a collection and returns a map/collection.", "author": "chtyim", "createdAt": "2020-12-21T08:20:02Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import io.cdap.cdap.api.app.ApplicationSpecification;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * CapabilityReader interface with methods based on current capability status\n+ */\n+public interface CapabilityReader {\n+\n+  /**\n+   * Returns the status of capability.\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  CapabilityStatus getStatus(String capability) throws IOException;\n+\n+  /**\n+   * Return boolean indicating whether the capability is enabled\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  boolean isEnabled(String capability) throws IOException;\n+\n+  /**\n+   * Throws {@link CapabilityNotAvailableException} if all capabilities are not enabled\n+   * @param capabilities\n+   * @return\n+   * @throws IOException\n+   */\n+  void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException;\n+\n+  /**\n+   * Throws {@link CapabilityNotAvailableException} if all capabilities are not enabled\n+   * @param appSpec\n+   * @return\n+   * @throws IOException\n+   */\n+  void checkAllEnabled(ApplicationSpecification appSpec) throws IOException, CapabilityNotAvailableException;\n+\n+  /**\n+   * Get the configuration for this capability if present\n+   *\n+   * @param capability\n+   * @return\n+   * @throws IOException\n+   */\n+  @Nullable\n+  CapabilityConfig getConfig(String capability) throws IOException;", "originalCommit": "12e21f9870377bb2130603961cd8b923a7a8198d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzI2Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r546947262", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-21T21:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2NzM1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\nindex c6163059017..d679be72b84 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityReader.java\n\n@@ -20,34 +20,18 @@ import io.cdap.cdap.api.app.ApplicationSpecification;\n \n import java.io.IOException;\n import java.util.Collection;\n-import java.util.List;\n-import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * CapabilityReader interface with methods based on current capability status\n  */\n public interface CapabilityReader {\n \n-  /**\n-   * Returns the status of capability.\n-   *\n-   * @param capability\n-   * @return\n-   * @throws IOException\n-   */\n-  CapabilityStatus getStatus(String capability) throws IOException;\n-\n-  /**\n-   * Return boolean indicating whether the capability is enabled\n-   *\n-   * @param capability\n-   * @return\n-   * @throws IOException\n-   */\n-  boolean isEnabled(String capability) throws IOException;\n-\n   /**\n    * Throws {@link CapabilityNotAvailableException} if all capabilities are not enabled\n+   *\n    * @param capabilities\n    * @return\n    * @throws IOException\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDI3NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547000274", "bodyText": "I don't think it will throw the CapabilityNotAvailableException from the transaction, right?", "author": "chtyim", "createdAt": "2020-12-22T00:30:02Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    Map<String, String> capabilityMap = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+\n+    }, IOException.class, CapabilityNotAvailableException.class);", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzc3Mg==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013772", "bodyText": "It doesn't, removed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDI3NA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\nindex 5b57c93369d..f7c91951c2b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n\n@@ -63,7 +63,7 @@ public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter\n           structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n         ));\n \n-    }, IOException.class, CapabilityNotAvailableException.class);\n+    }, IOException.class);\n     for (String capability : capabilities) {\n       if (!capabilityMap.containsKey(capability) || CapabilityStatus\n         .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDYzMA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547000630", "bodyText": "You can just use Collections.singleton(Fields.stirngField(....)) instead of creating an array list.", "author": "chtyim", "createdAt": "2020-12-22T00:31:30Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    Map<String, String> capabilityMap = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+\n+    }, IOException.class, CapabilityNotAvailableException.class);\n+    for (String capability : capabilities) {\n+      if (!capabilityMap.containsKey(capability) || CapabilityStatus\n+        .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n+        throw new CapabilityNotAvailableException(capability);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, CapabilityConfig> getConfigs(Collection<String> capabilities) throws IOException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class))\n+        );\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Returns list of all capability records\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  public Map<String, CapabilityRecord> getCapabilityRecords() throws IOException {\n+    Map<String, CapabilityRecord> capabilityRecordMap = new HashMap<>();\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      //query all operations\n+      Map<String, CapabilityOperationRecord> capabilityOperationMap = new HashMap<>();\n+      StructuredTable capabilityOperationTable = context\n+        .getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      CloseableIterator<StructuredRow> operationsResultIterator = capabilityOperationTable\n+        .scan(Range.all(), Integer.MAX_VALUE);\n+      operationsResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityOperationRecord capabilityOperationRecord = new CapabilityOperationRecord(\n+          capability, CapabilityAction\n+          .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.ACTION_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        capabilityOperationMap.put(capability, capabilityOperationRecord);\n+      });\n+      //query all capabilities\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      CloseableIterator<StructuredRow> capabilityResultIterator = capabilityTable.scan(Range.all(), Integer.MAX_VALUE);\n+      capabilityResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityStatusRecord capabilityStatusRecord = new CapabilityStatusRecord(\n+          capability,\n+          CapabilityStatus\n+            .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        //add to result and remove from operations map\n+        capabilityRecordMap\n+          .put(capability,\n+               new CapabilityRecord(capabilityStatusRecord, capabilityOperationMap.remove(capability)));\n+      });\n+      //add the remaining operations to result\n+      capabilityOperationMap.keySet().forEach(capability -> capabilityRecordMap\n+        .put(capability, new CapabilityRecord(null, capabilityOperationMap.get(capability))));\n+      return capabilityRecordMap;\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Add or update capability\n+   *\n+   * @param capability\n+   * @param status\n+   * @throws IOException\n+   */\n+  @Override\n+  public void addOrUpdateCapability(String capability, CapabilityStatus status,\n+                                    CapabilityConfig config) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.STATUS_FIELD, status.name().toLowerCase()));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.CONFIG_FIELD, GSON.toJson(config)));\n+      fields.add(Fields.longField(StoreDefinition.CapabilitiesStore.UPDATED_TIME_FIELD, System.currentTimeMillis()));\n+      capabilityTable.upsert(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Delete capability\n+   *\n+   * @param capability\n+   * @throws IOException\n+   */\n+  @Override\n+  public void deleteCapability(String capability) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzcyNw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013727", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDYzMA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\nindex 5b57c93369d..f7c91951c2b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n\n@@ -63,7 +63,7 @@ public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter\n           structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n         ));\n \n-    }, IOException.class, CapabilityNotAvailableException.class);\n+    }, IOException.class);\n     for (String capability : capabilities) {\n       if (!capabilityMap.containsKey(capability) || CapabilityStatus\n         .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDY5Nw==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547000697", "bodyText": "Same here. You can use Collections.singleton", "author": "chtyim", "createdAt": "2020-12-22T00:31:48Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.capability;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.cdap.cdap.store.StoreDefinition;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CapabilityStatusStore which takes care of reading , writing capability status and provides additional helpful methods\n+ */\n+public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter {\n+\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  @Inject\n+  CapabilityStatusStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  @Override\n+  public void checkAllEnabled(Collection<String> capabilities) throws IOException, CapabilityNotAvailableException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    Map<String, String> capabilityMap = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n+        ));\n+\n+    }, IOException.class, CapabilityNotAvailableException.class);\n+    for (String capability : capabilities) {\n+      if (!capabilityMap.containsKey(capability) || CapabilityStatus\n+        .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n+        throw new CapabilityNotAvailableException(capability);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, CapabilityConfig> getConfigs(Collection<String> capabilities) throws IOException {\n+    List<List<Field<?>>> multiKeys = new ArrayList<>();\n+    capabilities.forEach(capability -> multiKeys\n+      .add(Collections.singletonList(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability))));\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      return capabilityTable.multiRead(multiKeys).stream().\n+        collect(Collectors.toMap(\n+          structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD),\n+          structuredRow -> GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class))\n+        );\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Returns list of all capability records\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  public Map<String, CapabilityRecord> getCapabilityRecords() throws IOException {\n+    Map<String, CapabilityRecord> capabilityRecordMap = new HashMap<>();\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      //query all operations\n+      Map<String, CapabilityOperationRecord> capabilityOperationMap = new HashMap<>();\n+      StructuredTable capabilityOperationTable = context\n+        .getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      CloseableIterator<StructuredRow> operationsResultIterator = capabilityOperationTable\n+        .scan(Range.all(), Integer.MAX_VALUE);\n+      operationsResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityOperationRecord capabilityOperationRecord = new CapabilityOperationRecord(\n+          capability, CapabilityAction\n+          .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.ACTION_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        capabilityOperationMap.put(capability, capabilityOperationRecord);\n+      });\n+      //query all capabilities\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      CloseableIterator<StructuredRow> capabilityResultIterator = capabilityTable.scan(Range.all(), Integer.MAX_VALUE);\n+      capabilityResultIterator.forEachRemaining(structuredRow -> {\n+        String capability = structuredRow.getString(StoreDefinition.CapabilitiesStore.NAME_FIELD);\n+        CapabilityStatusRecord capabilityStatusRecord = new CapabilityStatusRecord(\n+          capability,\n+          CapabilityStatus\n+            .valueOf(structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD).toUpperCase()),\n+          GSON\n+            .fromJson(structuredRow.getString(StoreDefinition.CapabilitiesStore.CONFIG_FIELD), CapabilityConfig.class));\n+        //add to result and remove from operations map\n+        capabilityRecordMap\n+          .put(capability,\n+               new CapabilityRecord(capabilityStatusRecord, capabilityOperationMap.remove(capability)));\n+      });\n+      //add the remaining operations to result\n+      capabilityOperationMap.keySet().forEach(capability -> capabilityRecordMap\n+        .put(capability, new CapabilityRecord(null, capabilityOperationMap.get(capability))));\n+      return capabilityRecordMap;\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Add or update capability\n+   *\n+   * @param capability\n+   * @param status\n+   * @throws IOException\n+   */\n+  @Override\n+  public void addOrUpdateCapability(String capability, CapabilityStatus status,\n+                                    CapabilityConfig config) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.STATUS_FIELD, status.name().toLowerCase()));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.CONFIG_FIELD, GSON.toJson(config)));\n+      fields.add(Fields.longField(StoreDefinition.CapabilitiesStore.UPDATED_TIME_FIELD, System.currentTimeMillis()));\n+      capabilityTable.upsert(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Delete capability\n+   *\n+   * @param capability\n+   * @throws IOException\n+   */\n+  @Override\n+  public void deleteCapability(String capability) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITIES);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      capabilityTable.delete(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Adds or update capability operations\n+   *\n+   * @param capability\n+   * @param actionType\n+   * @param config\n+   * @throws IOException\n+   */\n+  public void addOrUpdateCapabilityOperation(String capability, CapabilityAction actionType,\n+                                             CapabilityConfig config) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.ACTION_FIELD, actionType.name().toLowerCase()));\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.CONFIG_FIELD, GSON.toJson(config)));\n+      capabilityTable.upsert(fields);\n+    }, IOException.class);\n+  }\n+\n+  /**\n+   * Deletes capability operations\n+   *\n+   * @param capability\n+   * @throws IOException\n+   */\n+  public void deleteCapabilityOperation(String capability) throws IOException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable capabilityTable = context.getTable(StoreDefinition.CapabilitiesStore.CAPABILITY_OPERATIONS);\n+      Collection<Field<?>> fields = new ArrayList<>();\n+      fields.add(Fields.stringField(StoreDefinition.CapabilitiesStore.NAME_FIELD, capability));", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzY5NA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013694", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMDY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\nindex 5b57c93369d..f7c91951c2b 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/capability/CapabilityStatusStore.java\n\n@@ -63,7 +63,7 @@ public class CapabilityStatusStore implements CapabilityReader, CapabilityWriter\n           structuredRow -> structuredRow.getString(StoreDefinition.CapabilitiesStore.STATUS_FIELD)\n         ));\n \n-    }, IOException.class, CapabilityNotAvailableException.class);\n+    }, IOException.class);\n     for (String capability : capabilities) {\n       if (!capabilityMap.containsKey(capability) || CapabilityStatus\n         .valueOf(capabilityMap.get(capability).toUpperCase()) != CapabilityStatus.ENABLED) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMTQ1OA==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547001458", "bodyText": "I don't see this being used? If not, please remove it and also from the cdap-default.xml", "author": "chtyim", "createdAt": "2020-12-22T00:34:41Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -1500,4 +1500,22 @@\n      */\n     public static final String UPDATE_ALLOWED = PREFIX + \"update.allowed\";\n   }\n+\n+  /**\n+   * Constants for capability management\n+   */\n+  public static final class Capability {\n+    /**\n+     * Interval for scanning config\n+     */\n+    public static final String DIR_SCAN_INTERVAL_MINUTES = \"capability.dir.scan.interval.minutes\";\n+    /**\n+     * Capability config directory path key\n+     */\n+    public static final String CONFIG_DIR = \"capability.config.dir\";\n+    /**\n+     * Timeout for re-applying capabilities\n+     */\n+    public static final String APPLY_TIMEOUT_MINUTES = \"capability.apply.timeout.minutes\";", "originalCommit": "7a2d2e0cfa507542170aa75ae30f00fac3fc83a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxMzY2OQ==", "url": "https://github.com/cdapio/cdap/pull/12886#discussion_r547013669", "bodyText": "Removed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-22T01:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwMTQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "chunk": "diff --git a/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java b/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java\nindex 25d223961b4..2ffa9df207b 100644\n--- a/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java\n+++ b/cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java\n\n@@ -1513,9 +1513,5 @@ public final class Constants {\n      * Capability config directory path key\n      */\n     public static final String CONFIG_DIR = \"capability.config.dir\";\n-    /**\n-     * Timeout for re-applying capabilities\n-     */\n-    public static final String APPLY_TIMEOUT_MINUTES = \"capability.apply.timeout.minutes\";\n   }\n }\n"}}, {"oid": "e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "url": "https://github.com/cdapio/cdap/commit/e8039396e3a376f932132c0bc0b2d8b1f0f3097c", "message": "Capability framework with changes for enabling, disabling and deleting capability\n\nDatabase is used for storing capability status and capability operation\n\nApp deployment, program start/run , schedule execution validates for enabled capability\n\nListing apps and plugins are filtered for enabled capability", "committedDate": "2020-12-22T00:52:11Z", "type": "forcePushed"}, {"oid": "5c7fcecab74b589114d8a56af85d65918abdb6af", "url": "https://github.com/cdapio/cdap/commit/5c7fcecab74b589114d8a56af85d65918abdb6af", "message": "Capability framework with changes for enabling, disabling and deleting capability\n\nDatabase is used for storing capability status and capability operation\n\nApp deployment, program start/run , schedule execution validates for enabled capability\n\nListing apps and plugins are filtered for enabled capability", "committedDate": "2020-12-22T01:06:52Z", "type": "commit"}, {"oid": "5c7fcecab74b589114d8a56af85d65918abdb6af", "url": "https://github.com/cdapio/cdap/commit/5c7fcecab74b589114d8a56af85d65918abdb6af", "message": "Capability framework with changes for enabling, disabling and deleting capability\n\nDatabase is used for storing capability status and capability operation\n\nApp deployment, program start/run , schedule execution validates for enabled capability\n\nListing apps and plugins are filtered for enabled capability", "committedDate": "2020-12-22T01:06:52Z", "type": "forcePushed"}]}