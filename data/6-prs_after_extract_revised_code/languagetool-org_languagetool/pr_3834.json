{"pr_number": 3834, "pr_title": "decrease the number of line/column calculations", "pr_createdAt": "2020-11-10T18:37:16Z", "pr_url": "https://github.com/languagetool-org/languagetool/pull/3834", "timeline": [{"oid": "54bafb357a62f3876d86657f67521e5c19251d91", "url": "https://github.com/languagetool-org/languagetool/commit/54bafb357a62f3876d86657f67521e5c19251d91", "message": "decrease the number of line/column calculations\n\nprecompute them just once for all sentences, not for each rule afresh\nuse this data to speedup text-level match anchoring", "committedDate": "2020-11-10T14:57:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTk3Mg==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520845972", "bodyText": "This operator is not very common, could you add a comment?", "author": "danielnaber", "createdAt": "2020-11-10T20:13:10Z", "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1772,56 +1806,37 @@ public static void removeTemporaryFiles() {\n                     \", text length: \" + annotatedText.getPlainText().length());\n             //        \", text length: \" + annotatedText.getPlainText().length() + \", common word count: \" + commonWords.getKnownWordsPerLanguage(annotatedText.getPlainText()));\n           }\n-          charCount += sentence.length();\n-          lineCount += countLineBreaks(sentence);\n-\n-          // calculate matching column:\n-          int lineBreakPos = sentence.lastIndexOf('\\n');\n-          if (lineBreakPos == -1) {\n-            columnCount += sentence.length();\n-          } else {\n-            if (lineBreakPos == 0) {\n-              columnCount = sentence.length();\n-              if (!language.getSentenceTokenizer().singleLineBreaksMarksPara()) {\n-                columnCount--;\n-              }\n-            } else {\n-              columnCount = sentence.length() - lineBreakPos;\n-            }\n-          }\n         } catch (ErrorRateTooHighException e) {\n           throw e;\n         } catch (Exception e) {\n           throw new RuntimeException(\"Could not check sentence (language: \" + language + \"): <sentcontent>\"\n-                  + StringUtils.abbreviate(analyzedSentence.toTextString(), 500) + \"</sentcontent>\", e);\n+                  + StringUtils.abbreviate(sentence.analyzed.toTextString(), 500) + \"</sentcontent>\", e);\n         }\n       }\n       return ruleMatches;\n     }\n \n-    private LineColumnRange getLineColumnRange(RuleMatch match) {\n-      LineColumnPosition fromPos = new LineColumnPosition(-1, -1);\n-      LineColumnPosition toPos = new LineColumnPosition(-1, -1);\n-      LineColumnPosition pos = new LineColumnPosition(0, 0);\n-      int charCount = 0;\n-      for (AnalyzedSentence analyzedSentence : analyzedSentences) {\n-        for (AnalyzedTokenReadings readings : analyzedSentence.getTokens()) {\n-          String token = readings.getToken();\n-          if (\"\\n\".equals(token)) {\n-            pos.line++;\n-            pos.column = 0;\n-          }\n-          pos.column += token.length();\n-          charCount += token.length();\n-          if (charCount == match.getFromPos()) {\n-            fromPos = new LineColumnPosition(pos.line, pos.column);\n-          }\n-          if (charCount == match.getToPos()) {\n-            toPos = new LineColumnPosition(pos.line, pos.column);\n-          }\n-        }\n+    private LineColumnPosition findLineColumn(int offset) {\n+      if (sentences.isEmpty()) return new LineColumnPosition(0, 0);\n+\n+      SentenceData sentence = findSentenceContaining(offset);\n+      String prefix = sentence.text.substring(0, offset - sentence.startOffset);\n+      return new LineColumnPosition(\n+        sentence.startLine + countLineBreaks(prefix),\n+        processColumnChange(sentence.startColumn, prefix));\n+    }\n+\n+    private SentenceData findSentenceContaining(int offset) {\n+      int low = 0;\n+      int high = sentences.size() - 1;\n+      while (low <= high) {\n+        int mid = (low + high) >>> 1;", "originalCommit": "54bafb357a62f3876d86657f67521e5c19251d91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2MzY3Mw==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520863673", "bodyText": "It's inspired by JDK code, but indeed, this could be simplified. Will do!", "author": "donnerpeter", "createdAt": "2020-11-10T20:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "70c4de687bdcd56b1c4c281745dc43426419ac5a", "chunk": "diff --git a/languagetool-core/src/main/java/org/languagetool/JLanguageTool.java b/languagetool-core/src/main/java/org/languagetool/JLanguageTool.java\nindex a4ecffac48..81de2ed80e 100644\n--- a/languagetool-core/src/main/java/org/languagetool/JLanguageTool.java\n+++ b/languagetool-core/src/main/java/org/languagetool/JLanguageTool.java\n\n@@ -1830,7 +1830,7 @@ public class JLanguageTool {\n       int low = 0;\n       int high = sentences.size() - 1;\n       while (low <= high) {\n-        int mid = (low + high) >>> 1;\n+        int mid = (low + high) / 2;\n         SentenceData sentence = sentences.get(mid);\n         if (sentence.startOffset < offset) low = mid + 1;\n         else if (sentence.startOffset > offset) high = mid - 1;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520862972", "bodyText": "Here's an inconsistency. Some clients expect column to be 0-based (as in javadoc) and some \u2014 1-based. From the history I've seen that the similar condition in the previous version of code was a hack to make some tests happy (since they're using deprecated API anyway), so I've decided to create an equivalent.", "author": "donnerpeter", "createdAt": "2020-11-10T20:45:47Z", "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "originalCommit": "54bafb357a62f3876d86657f67521e5c19251d91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDgzNQ==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520870835", "bodyText": "Line/column information is deprecated in LT, we don't show it anymore in the JSON response (our main use case), we just keep it running for the command-line LT.", "author": "danielnaber", "createdAt": "2020-11-10T21:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3Mjc0OA==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520872748", "bodyText": "Any plans to remove it?", "author": "donnerpeter", "createdAt": "2020-11-10T21:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NTk5NQ==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520875995", "bodyText": "I'd prefer to have it removed, but I see the line number is useful when running LT on the command-line, so it would need to be calculated somewhere else (maybe not in JLanguageTool). But I have no plans to work on this.", "author": "danielnaber", "createdAt": "2020-11-10T21:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg4ODIyMQ==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520888221", "bodyText": "Do you mean only org.languagetool.commandline.Main or anything else? If the former, I think this calculation could be moved there relatively easily, and JLanguageTool could become free of this logic, and maybe even faster.", "author": "donnerpeter", "createdAt": "2020-11-10T21:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg5NDU0Mg==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520894542", "bodyText": "I haven't checked closely, but yes, org.languagetool.commandline.Main sounds like the logical place for this code.", "author": "danielnaber", "createdAt": "2020-11-10T21:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEzODQ2MQ==", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r521138461", "bodyText": "I can also see some column usages in XML serialization, Wikipedia and UI HTML. I don't know of their importance nowadays. But maybe I'll take a look at this some day :)", "author": "donnerpeter", "createdAt": "2020-11-11T06:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "70c4de687bdcd56b1c4c281745dc43426419ac5a", "url": "https://github.com/languagetool-org/languagetool/commit/70c4de687bdcd56b1c4c281745dc43426419ac5a", "message": "binary search: make division by 2 more obvious", "committedDate": "2020-11-10T20:48:24Z", "type": "commit"}]}